test_method,detected_smells
"@Test
    public void testCompareRunningContainerInUserNetworkWithDefaultPropertiesAndMatchedContainerStateShouldPass() {
        String networkName = ""test-network"";
        String ipv4 = ""172.100.0.100"";

        predefinedState.networks.put(networkName,
                createServiceNetwork(networkName, ipv4));
        addNetworkToInspectMap(predefinedInspectMap, networkName, ipv4);

        ContainerState mappedState = new ContainerState();
        ContainerStateMapper.propertiesToContainerState(mappedState, predefinedInspectMap);
        assertTrue(""predefined and mapped state should be equal"",
                areEqualContainerStates(predefinedState, mappedState));
    }",No Smells
"@Test
    public void testCreatedContainerShouldBeInspectedOnNetworkOperationFailure() throws Throwable {
        // delete provisioned containers
        removeContainer();
        // create a new state that has never been data collected
        createContainerState();

        // update the container state with a network that does not exist
        ServiceNetwork network = new ServiceNetwork();
        network.name = ""network"";
        ContainerState patch = new ContainerState();
        patch.networks = new HashMap<>();
        patch.networks.put(network.name, network);
        patchContainerState(patch);

        sendGetContainerStateRequest();
        assertNull(""Container ID should have been null before creation on host"", containerState.id);

        // This should fail on the attempt to connect the container to the network
        createContainer(true /* expect error */);

        // The createContainer method will verify that the id has been collected
    }",No Smells
"@Test
    public void testDeleteWithRetry() throws Throwable {
        // verify container is running
        verifyContainerIsRunning(true);
        assertEquals(""Unexpected PowerState in ContainerState"",
                PowerState.RUNNING, containerState.powerState);

        // simulate Docker host down
        tearDownMockDockerHost();

        sendDeleteContainerRequest();

        // wait for provisioning task stage to change to failed
        waitForPropertyValue(provisioningTaskLink, MockTaskState.class, ""taskInfo.stage"",
                TaskState.TaskStage.FAILED);

        // verify the operation was retried
        MockTaskState task = getDocument(MockTaskState.class, provisioningTaskLink);
        assertNotNull(task);
        assertNotNull(task.customProperties);
        assertEquals(Boolean.TRUE.toString(), task.customProperties.get(RETRIED_AFTER_FAILURE));
    }",No Smells
"@Test
    public void testInspectContainer() throws Throwable {
        sendInspectContainerRequest();

        // wait for request task stage to change to finish
        waitForPropertyValue(provisioningTaskLink, MockTaskState.class, ""taskInfo.stage"",
                TaskState.TaskStage.FINISHED);
    }",No Smells
"@Test
    public void testInspectContainerWithRetry() throws Throwable {
        // verify container is running
        verifyContainerIsRunning(true);
        assertEquals(""Unexpected PowerState in ContainerState"",
                PowerState.RUNNING, containerState.powerState);

        // simulate Docker host down
        tearDownMockDockerHost();

        sendInspectContainerRequest();

        // wait for provisioning task stage to change to failed
        waitForPropertyValue(provisioningTaskLink, MockTaskState.class, ""taskInfo.stage"",
                TaskState.TaskStage.FAILED);

        // verify the operation was retried
        MockTaskState task = getDocument(MockTaskState.class, provisioningTaskLink);
        assertNotNull(task);
        assertNotNull(task.customProperties);
        assertEquals(Boolean.TRUE.toString(), task.customProperties.get(RETRIED_AFTER_FAILURE));
    }",No Smells
"@Test
    public void testStatsDisabledWhenContainerStopped() throws Throwable {
        sendFetchContainerStatsRequest();

        // wait for request task stage to change to finish
        waitForPropertyValue(provisioningTaskLink, MockTaskState.class, ""taskInfo.stage"",
                TaskState.TaskStage.FINISHED);

        // stop the container
        sendStopContainerRequest();

        // wait for request task stage to change to finish
        waitForPropertyValue(provisioningTaskLink, MockTaskState.class, ""taskInfo.stage"",
                TaskState.TaskStage.FINISHED);

        // try to fetch the stats again and expect failure
        try {
            sendFetchContainerStatsRequest();
            fail(""Fetch stats is expected to fail"");
        }",No Smells
"@Test
    public void testHostPermanentlyNotAvailable() throws Throwable {
        ComputeState state = new ComputeState();
        state.powerState = PowerState.SUSPEND;
        Map<String, String> properties = new HashMap<>();
        properties.put(ContainerHostService.RETRIES_COUNT_PROP_NAME, ""2"");
        state.customProperties = properties;
        doOperation(state,
                UriUtils.buildUri(host, dockerHostState.documentSelfLink), false,
                Action.PATCH);
        waitFor(() -> {
            dockerHostState = retrieveDockerHostState();
            return PowerState.SUSPEND == dockerHostState.powerState;
        }",Eager Test
"@Test
    public void testHostPingWithResourceReference() throws Throwable {
        dockerHostState = requestDockerHostOperation(MockDockerPathConstants._PING,
                ContainerHostOperationType.PING);
    }",No Smells
"@Test
    public void testListContainersWithCallBack() throws Throwable {
        // Tests the following behaviour:
        // 1. There are 0 containers initially
        // 2. Create one and get the results again. There should be 1.
        host.log(Level.INFO, ""Started listing containers with callback."");
        assertListedEntitiesCount(0, ContainerHostOperationType.LIST_CONTAINERS, new ContainerItem());
        createEntity(MockDockerCreateContainerService.SELF_LINK, () -> {
            try {
                assertListedEntitiesCount(1, ContainerHostOperationType.LIST_CONTAINERS, new ContainerItem());
            }",No Smells
"@Test
    public void testListVolumesWithCallBack() throws Throwable {
        // Tests the following behaviour:
        // 1. There are 0 volumes initially
        // 2. Create one and get the results again. There should be 1.
        host.log(Level.INFO, ""Started listing volumes with callback."");
        assertListedEntitiesCount(0, ContainerHostOperationType.LIST_VOLUMES, new VolumeItem());
        createEntity(MockDockerCreateVolumeService.SELF_LINK, () -> {
            try {
                assertListedEntitiesCount(1, ContainerHostOperationType.LIST_VOLUMES, new VolumeItem());
            }",No Smells
"@Test
    public void testNetworkInspect() throws Throwable {
        // Network creation is not direct operation, this means it will take some time.
        while ((MockDockerNetworkService.networksMap == null
                || MockDockerNetworkService.networksMap.isEmpty())
                && NETWORK_LIST_RETRY_COUNT > 0) {
            Thread.sleep(TIME_BETWEEN_RETRIES_IN_MILSEC);
            NETWORK_LIST_RETRY_COUNT--;
        }",Eager Test
"@Test
    public void testGetFromUserResources() throws Throwable {
        Path testXenonImagesPath = Files.createTempDirectory(""test-xenon-images"");

        HostInitCommonServiceConfig.startServices(host);
        waitForServiceAvailability(ConfigurationFactoryService.SELF_LINK);
        waitForServiceAvailability(UriUtils.buildUriPath(UriUtils.buildUriPath(
                ConfigurationFactoryService.SELF_LINK, FileUtil.USER_RESOURCES_PATH_VARIABLE)));

        // Set expected configuration
        ConfigurationState config = new ConfigurationState();
        config.documentSelfLink = UriUtils.buildUriPath(ConfigurationFactoryService.SELF_LINK,
                FileUtil.USER_RESOURCES_PATH_VARIABLE);
        config.key = FileUtil.USER_RESOURCES_PATH_VARIABLE;
        config.value = testXenonImagesPath.toAbsolutePath().toString();

        doPut(config);

        File imageDir = new File(UriUtils.buildUriPath(testXenonImagesPath.toString(),
                SystemImageRetrievalManager.SYSTEM_IMAGES_PATH));
        imageDir.mkdir();

        byte[] content = IOUtils.toByteArray(Thread.currentThread().getContextClassLoader()
                .getResourceAsStream(TEST_IMAGE));
        // Basically, rename it so it must be loaded from user resources for sure
        File tmpFile = new File(
                UriUtils.buildUriPath(imageDir.getAbsolutePath(), TEST_IMAGE_RES));
        tmpFile.createNewFile();
        try (OutputStream os = new FileOutputStream(tmpFile)) {
            os.write(content);
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testFilterVolumeBindings() {
        List<String> bindings = DockerAdapterUtils.filterVolumeBindings(null);
        assertEquals(Collections.emptyList(), bindings);

        String[] volumes = new String[] {}",No Smells
"@Test
    public void testConversions() {
        DockerDevice device = DockerDevice.fromString(fullDeviceString);

        // fromString
        verifyDevice(""fromString: "" + description, device);

        // toMap
        Map<String, String> map = device.toMap();
        verifyMap(""toMap: "" + description, map);

        // fromMap
        device = DockerDevice.fromMap(map);
        verifyDevice(""fromMap: "" + description, device);

        // toString
        assertEquals(""toString: "" + description, fullDeviceString, device.toString());
    }",No Smells
"@Test
    public void testDockerPortStringParsing() {
        DockerPortMapping portMapping = DockerPortMapping.fromString(fullPortString);
        assertEquals(description + "": hostIp"", expectedHostIp, portMapping.getHostIp());
        assertEquals(description + "": hostPort"", expectedHostPort, portMapping.getHostPort());
        assertEquals(description + "": containerPort"", expectedContainerPort,
                portMapping.getContainerPort());

        assertEquals(description + "": protocol"", expectedProtocol, portMapping.getProtocol());
    }",No Smells
"@Test
    public void testBuildApiServerProxyUrl() {
        String apiVersionPrefix = ""/api/v1"";
        String namespace = ""test-namespace"";
        String selfLink = ""/services/test"";
        String proxiedPath = ""/test-path"";

        String expected = context.host.address
                + ""/api/v1/namespaces/test-namespace/services/test/proxy/test-path"";
        assertEquals(expected, ApiUtil.buildApiServerProxyUri(context, apiVersionPrefix, namespace,
                selfLink, proxiedPath));
    }",No Smells
"@Test
    public void testDelete() throws Throwable {
        PodState podState = new PodState();
        podState.pod = new Pod();
        podState.pod.spec = new PodSpec();
        podState.pod.spec.containers = new ArrayList<>();
        Container container1 = new Container();
        container1.name = ""container1"";
        container1.image = ""test-image"";
        podState.pod.spec.containers.add(container1);
        podState.pod.metadata = new ObjectMeta();
        podState.pod.metadata.selfLink = ""/api/v1/namespaces/default/pods/test-pod"";
        podState.pod.metadata.name = ""test-pod"";
        podState.parentLink = kubernetesHostState.documentSelfLink;
        podState.kubernetesSelfLink = podState.pod.metadata.selfLink;
        podState = doPost(podState, PodFactoryService.SELF_LINK);

        service.deployedElementsMap.put(""test-pod"", podState.pod);
        assertTrue(service.deployedElementsMap.size() == 1);

        provisioningTaskLink = createProvisioningTask();

        AdapterRequest request = new AdapterRequest();
        request.resourceReference = UriUtils.buildUri(host, podState.documentSelfLink);
        request.serviceTaskCallback = ServiceTaskCallback.create(provisioningTaskLink);
        request.operationTypeId = KubernetesOperationType.DELETE.id;

        doOperation(KubernetesAdapterService.SELF_LINK, request);

        waitForPropertyValue(provisioningTaskLink, MockTaskState.class, ""taskInfo.stage"",
                TaskState.TaskStage.FINISHED);

        final String selfLink = podState.documentSelfLink;
        final long timeoutInMillis = 5000; // 5sec
        long startTime = System.currentTimeMillis();

        waitFor(() -> {
            if (System.currentTimeMillis() - startTime > timeoutInMillis) {
                fail(String.format(""Entity [%s] not deletes within %s ms"", selfLink, timeoutInMillis));
            }",No Smells
"@Test
    public void testFetchLogs() throws Throwable {
        service.containerNamesToLogs.put(""container1"", ""test-log-1"");
        service.containerNamesToLogs.put(""container2"", ""test-log-2"");
        service.containerNamesToLogs.put(""container3"", ""test-log-3"");

        PodState podState = new PodState();
        podState.pod = new Pod();
        podState.pod.spec = new PodSpec();
        podState.pod.spec.containers = new ArrayList<>();
        Container container1 = new Container();
        container1.name = ""container1"";
        Container container2 = new Container();
        container2.name = ""container2"";
        Container container3 = new Container();
        container3.name = ""container3"";
        podState.pod.spec.containers.add(container1);
        podState.pod.spec.containers.add(container2);
        podState.pod.spec.containers.add(container3);
        podState.pod.metadata = new ObjectMeta();
        podState.pod.metadata.selfLink = ""/api/v1/namespaces/default/pods/test-pod"";
        podState.parentLink = kubernetesHostState.documentSelfLink;

        podState = doPost(podState, PodFactoryService.SELF_LINK);

        provisioningTaskLink = createProvisioningTask();

        AdapterRequest request = new AdapterRequest();
        request.resourceReference = UriUtils.buildUri(host, podState.documentSelfLink);
        request.serviceTaskCallback = ServiceTaskCallback.create(provisioningTaskLink);
        request.operationTypeId = KubernetesOperationType.FETCH_LOGS.id;

        doOperation(KubernetesAdapterService.SELF_LINK, request);

        waitForPropertyValue(provisioningTaskLink, MockTaskState.class, ""taskInfo.stage"",
                TaskState.TaskStage.FINISHED);

        for (Container container : podState.pod.spec.containers) {
            LogServiceState logState = getDocument(LogServiceState.class, LogService
                    .FACTORY_LINK + ""/"" + UriUtils.getLastPathSegment(podState.documentSelfLink)
                    + ""-""
                    + container.name);
            assertEquals(service.containerNamesToLogs.get(container.name), new String(logState
                    .logs, ""UTF-8""));
        }",No Smells
"@Test
    public void testInspect() throws Throwable {
        PodState podState = new PodState();
        podState.pod = new Pod();
        podState.pod.spec = new PodSpec();
        podState.pod.spec.containers = new ArrayList<>();
        Container container1 = new Container();
        container1.name = ""container1"";
        container1.image = ""test-image"";
        podState.pod.spec.containers.add(container1);
        podState.pod.metadata = new ObjectMeta();
        podState.pod.metadata.selfLink = ""/api/v1/namespaces/default/pods/test-pod"";
        podState.pod.metadata.name = ""test-pod"";
        podState.parentLink = kubernetesHostState.documentSelfLink;
        podState.kubernetesSelfLink = podState.pod.metadata.selfLink;
        podState = doPost(podState, PodFactoryService.SELF_LINK);

        Pod updatedPod = new Pod();
        updatedPod.metadata = new ObjectMeta();
        updatedPod.metadata.name = ""test-pod"";
        updatedPod.metadata.selfLink = ""/api/v1/namespaces/default/pods/test-pod"";
        updatedPod.spec = new PodSpec();
        updatedPod.spec.containers = new ArrayList<>();
        Container updatedContainer = new Container();
        updatedContainer.name = ""new-container1"";
        updatedContainer.image = ""new-test-image"";
        updatedPod.spec.containers.add(updatedContainer);

        service.inspectMap.put(podState.pod, updatedPod);

        provisioningTaskLink = createProvisioningTask();

        AdapterRequest request = new AdapterRequest();
        request.resourceReference = UriUtils.buildUri(host, podState.documentSelfLink);
        request.serviceTaskCallback = ServiceTaskCallback.create(provisioningTaskLink);
        request.operationTypeId = KubernetesOperationType.INSPECT.id;
        doOperation(KubernetesAdapterService.SELF_LINK, request);

        waitForPropertyValue(provisioningTaskLink, MockTaskState.class, ""taskInfo.stage"",
                TaskState.TaskStage.FINISHED);

        PodState patchedPod = getDocument(PodState.class, podState.documentSelfLink);

        assertEquals(podState.descriptionLink, patchedPod.descriptionLink);
        assertEquals(podState.compositeComponentLink, patchedPod.compositeComponentLink);
        assertEquals(podState.parentLink, patchedPod.parentLink);

        assertEquals(updatedContainer.name, patchedPod.pod.spec.containers.get(0).name);
        assertEquals(updatedContainer.image, patchedPod.pod.spec.containers.get(0).image);
    }",No Smells
"@Test
    public void testValidateServicesAreDeployedFirst() throws Throwable {
        String wordpressTemplate = CommonTestStateFactory
                .getFileContent(""WordPress_with_MySQL_kubernetes.yaml"");

        String compositeDescriptionLink = importTemplate(wordpressTemplate);

        CompositeDescription compositeDescription = getCompositeDescription(
                compositeDescriptionLink);

        CompositeComponent compositeComponent = new CompositeComponent();
        compositeComponent.name = compositeDescription.name + ""-mcm-102"";
        compositeComponent.compositeDescriptionLink = compositeDescription.documentSelfLink;
        compositeComponent.customProperties = new HashMap<>();
        compositeComponent.customProperties.put(CUSTOM_PROPERTY_HOST_LINK,
                kubernetesHostState.documentSelfLink);
        compositeComponent = doPost(compositeComponent, CompositeComponentFactoryService.SELF_LINK);

        addPodsAndReplicaSetsForWordpressApp(extractId(compositeComponent.documentSelfLink));

        provisioningTaskLink = createProvisioningTask();

        ApplicationRequest appRequest = createApplicationRequest(
                compositeComponent.documentSelfLink);

        doOperation(ManagementUriParts.ADAPTER_KUBERNETES_APPLICATION, appRequest);

        // wait for provisioning task stage to change to finish
        waitForPropertyValue(provisioningTaskLink, MockTaskState.class, ""taskInfo.stage"",
                TaskState.TaskStage.FINISHED);

        assertEquals(10, service.deployedElements.size());

        List<BaseKubernetesObject> kubernetesElements = new ArrayList<>();
        service.deployedElements.forEach(e -> kubernetesElements.add(e));

        // Assert that services are deployed first.
        assertEquals(KubernetesUtil.SERVICE_TYPE, kubernetesElements.get(4).kind);
        assertEquals(KubernetesUtil.SERVICE_TYPE, kubernetesElements.get(5).kind);

        // Assert that states are created and they have correct compositeComponentLink.
        CompositeComponent finalCompositeComponent = compositeComponent;

        List<String> resourceLinks = getDocumentLinksOfType(ServiceState.class);
        assertEquals(2, resourceLinks.size());
        resourceLinks.forEach(link -> doOperation(Operation.createGet(host, link)
                .setCompletion((o, ex) -> {
                    if (ex != null) {
                        host.failIteration(ex);
                    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void TestCorrectDateParse() {
        KubernetesContainerStateMapper.parseDate(""2017-01-09T10:43:32Z"");
    }",No Smells
"@Test
    public void TestCorrectEnvMap() {
        EnvVar e = new EnvVar();
        e.name = ""name"";
        e.value = ""val"";
        String env = KubernetesContainerStateMapper.makeEnv(e);
        Assert.assertEquals(e.name + ""="" + e.value, env);
    }",No Smells
"@Test
    public void TestCorrectParseMemM() {
        long r = KubernetesContainerStateMapper.parseMem(""4M"");
        Assert.assertEquals(4_000_000L, r);
    }",No Smells
"@Test
    public void TestCorrectParseMemT() {
        long r = KubernetesContainerStateMapper.parseMem(""4T"");
        Assert.assertEquals(4_000_000_000_000L, r);
    }",No Smells
"@Test
    public void TestGetIdWithoutPrefix() {
        String inID = ""some-random-id"";
        String id = KubernetesContainerStateMapper.getId(inID);
        Assert.assertEquals(inID, id);
    }",No Smells
"@Test
    public void TestGetPowerStateStopped() {
        ContainerStatus status = new ContainerStatus();
        status.state = new com.vmware.admiral.compute.kubernetes.entities.pods.ContainerState();
        status.state.terminated = new ContainerStateTerminated();
        PowerState state = KubernetesContainerStateMapper.getPowerState(status);
        Assert.assertEquals(PowerState.STOPPED, state);
    }",No Smells
"@Test
    public void TestInvalidParseCPU() {
        float r = KubernetesContainerStateMapper.parseCPU(""m933m"");
        Assert.assertEquals(0F, r, 1e-6F);
    }",No Smells
"@Test
    public void TestMapContainerWithNullInputContainer() {
        ContainerState outState = new ContainerState();
        ContainerStatus status = new ContainerStatus();
        status.containerID = ""docker://test-id"";
        // status.state = new ContainerState();
        KubernetesContainerStateMapper.mapContainer(outState, null, status);
        Assert.assertNull(outState.id);
        Assert.assertNull(outState.powerState);
    }",No Smells
"@Test
    public void TestParseMemWithEmptyString() {
        long r = KubernetesContainerStateMapper.parseMem("""");
        Assert.assertEquals(0L, r);
    }",No Smells
"@Test
    public void testCreateUser() throws Throwable {
        PKSRemoteClientService client = new PKSRemoteClientService(null, host);
        assertNotNull(client);

        PKSContext ctx = new PKSContext();
        ctx.pksAPIUri = URI.create(""http://some.host"");

        ServiceClient mockClient = mockClient(client);
        ArgumentCaptor<Operation> valueCapture = ArgumentCaptor.forClass(Operation.class);
        doNothing().when(mockClient).send(valueCapture.capture());

        // test casual exception
        DeferredResult<KubeConfig> result = client.createUser(null, null);
        try {
            result.toCompletionStage().toCompletableFuture().get();
            fail(""should not reach here"");
        }",Eager Test
"@Test
    public void testGetClusters() throws Throwable {
        PKSRemoteClientService client = new PKSRemoteClientService(null, host);
        assertNotNull(client);

        PKSContext ctx = new PKSContext();
        ctx.pksAPIUri = URI.create(""http://some.host"");

        ServiceClient mockClient = mockClient(client);
        ArgumentCaptor<Operation> valueCapture = ArgumentCaptor.forClass(Operation.class);
        doNothing().when(mockClient).send(valueCapture.capture());

        // test casual exception
        DeferredResult<List<PKSCluster>> result = client.getClusters(null);
        try {
            result.toCompletionStage().toCompletableFuture().get();
            fail(""should not reach here"");
        }",Eager Test
"@Test
    public void testGetPlans() throws Throwable {
        PKSRemoteClientService client = new PKSRemoteClientService(null, host);
        assertNotNull(client);

        PKSContext ctx = new PKSContext();
        ctx.pksAPIUri = URI.create(""http://some.host"");

        ServiceClient mockClient = mockClient(client);
        ArgumentCaptor<Operation> valueCapture = ArgumentCaptor.forClass(Operation.class);
        doNothing().when(mockClient).send(valueCapture.capture());

        // test casual exception
        DeferredResult<List<PKSPlan>> result = client.getPlans(null);
        try {
            result.toCompletionStage().toCompletableFuture().get();
            fail(""should not reach here"");
        }",Eager Test
"@Test
    public void testGetKubeConfigWithBearerToken() throws Throwable {
        String authCredentialsLink = createCredentials(AuthCredentialsType.Bearer, true)
                .documentSelfLink;
        String hostLink = createCompute(authCredentialsLink, true, true).documentSelfLink;

        URI serviceUri = UriUtils.buildUri(host, KubeConfigContentService.SELF_LINK,
                UriUtils.buildUriQuery(""hostLink"", hostLink));

        verifyOperation(Operation.createGet(serviceUri), o -> {
            assertEquals(""attachment; filename=\""kubeconfig\"""",
                    o.getResponseHeader(""Content-Disposition""));
            assertEquals(KUBE_CONFIG_YAML, o.getBody(String.class));
        }",No Smells
"@Test
    public void testGetKubeConfigWithCertificateAndKey() throws Throwable {
        assertTrue(UUID.randomUUID().toString().matches(""[-a-z0-9]+""));
        String authCredentialsLink = createCredentials(AuthCredentialsType.PublicKey, false)
                .documentSelfLink;
        String hostLink = createCompute(authCredentialsLink, true, false).documentSelfLink;

        URI serviceUri = UriUtils.buildUri(host, KubeConfigContentService.SELF_LINK,
                UriUtils.buildUriQuery(""hostLink"", hostLink));

        verifyOperation(Operation.createGet(serviceUri), o -> {
            assertEquals(""attachment; filename=\""kubeconfig\"""",
                    o.getResponseHeader(""Content-Disposition""));
        }",No Smells
"@Test
    public void testShouldFailWhenHostLinkParamIsMissing() throws Throwable {
        URI serviceUri = UriUtils.buildUri(host, KubeConfigContentService.SELF_LINK);
        try {
            doOperation(null, serviceUri, true, Action.GET);
            fail(""Operation should have failed: hostLink query param not set"");
        }",No Smells
"@Test
    public void testAddPKSClusterFail() {
        String endpointLink = createEndpoint().documentSelfLink;

        AddClusterRequest request = new AddClusterRequest();
        request.endpointLink = endpointLink;

        Operation o = Operation
                .createPost(host, PKSClusterConfigService.SELF_LINK)
                .setBodyNoCloning(request);
        FailureResponse failureResponse = sender.sendAndWaitFailure(o);

        assertNotNull(failureResponse);
        assertNotNull(failureResponse.failure);
    }",No Smells
"@Test
    public void testGetPKSCluster() {
        String endpoint = createEndpoint().documentSelfLink;
        List<PKSCluster> clusters = sendListRequest(endpoint,
                MockPKSAdapterService.CLUSTER_NAME_CREATE_SUCCESS, false);

        assertNotNull(clusters);
        assertEquals(1, clusters.size());

        clusters = sendListRequest(endpoint, ""non-existing-cluster"", true);
        assertNull(clusters);
    }",No Smells
"@Test
    public void testDuplicateRegistryInsideProjectShouldFail() throws Throwable {
        RegistryState registryState = new RegistryState();
        registryState.address = ""http://0.0.0.0"";
        registryState.name = ""TestRegistry"";
        registryState.tenantLinks = new ArrayList<>();
        registryState.tenantLinks.add(""test-project"");

        doPost(registryState, RegistryFactoryService.SELF_LINK);

        try {
            doPost(registryState, RegistryFactoryService.SELF_LINK);
            fail(""Should not be possible to add the same registry twice in the same scope"");
        }",No Smells
"@Test
    public void testSameRegistryTwoDifferentProjectsNotRemoveOldTenantLinkShouldFail() throws
            Throwable {
        RegistryState registryState = new RegistryState();
        registryState.address = ""http://0.0.0.0"";
        registryState.name = ""TestRegistry"";
        registryState.tenantLinks = new ArrayList<>();

        registryState.tenantLinks.add(""test-project1"");
        doPost(registryState, RegistryFactoryService.SELF_LINK);

        registryState.tenantLinks.add(""test-project2"");
        try {
            doPost(registryState, RegistryFactoryService.SELF_LINK);
            fail(""Should not be possible to add the same registry in two different projects"");
        }",No Smells
"@Test
    public void testSameRegistryTwoDifferentProjectsRemoveOldTenantLink() throws Throwable {
        RegistryState registryState = new RegistryState();
        registryState.address = ""http://0.0.0.0"";
        registryState.name = ""TestRegistry"";
        registryState.tenantLinks = new ArrayList<>();

        registryState.tenantLinks.add(""test-project1"");
        doPost(registryState, RegistryFactoryService.SELF_LINK);

        registryState.tenantLinks.remove(""test-project1"");
        registryState.tenantLinks.add(""test-project2"");

        doPost(registryState, RegistryFactoryService.SELF_LINK);
    }",No Smells
"@Test
    public void testV2ListImageTags() throws Throwable {
        URI v2RegistryStateUri = UriUtils.buildUri(host, v2RegistryStateLink);

        sendRegistryListTagsRequest(v2RegistryStateUri, ""v2registry.test/vmware/admiral"", (Operation op) -> {
            String[] tags = op.getBody(String[].class);
            assertNotNull(""result is null"", tags);
            assertArrayEquals(new String[] { ""7.1"", ""7.2"", ""7.3"", ""7.4"" }",No Smells
"@Test
    public void testDefaultProjectCreatedOnStartUp() throws Throwable {
        waitForServiceAvailability(ProjectService.DEFAULT_PROJECT_LINK);

        ProjectState project = getDocument(ProjectState.class,
                ProjectService.DEFAULT_PROJECT_LINK);

        assertNotNull(project);
        assertEquals(ProjectService.DEFAULT_PROJECT_ID, project.name);
        assertEquals(ProjectService.DEFAULT_PROJECT_ID, project.id);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testImportContentWithProjectAndUsers() throws Throwable {
        AuthContentBody body = Utils.fromJson(authContent, AuthContentBody.class);
        loadAuthContent(body);

        List<String> projectLinks = getDocumentLinksOfType(ProjectState.class);
        projectLinks.remove(ProjectService.DEFAULT_PROJECT_LINK);

        assertEquals(body.projects.size(), projectLinks.size());

        List<String> projectToImportNames = body.projects.stream()
                .map(p -> p.name)
                .collect(Collectors.toList());

        for (String link : projectLinks) {
            ProjectState state = getDocument(ProjectState.class, link);
            assertTrue(projectToImportNames.contains(state.name));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testGetPrincipal() {
        String principalId = ""connie@admiral.com"";
        DeferredResult<Principal> result = provider.getPrincipal(null, principalId);

        TestContext ctx = testCreate(1);
        result.whenComplete((p, ex) -> {
            if (ex != null) {
                ctx.failIteration(ex);
                return;
            }",No Smells
"@Test
    public void testGetPrincipalsOfTypeGroup() {
        String principalId = ""superusers@admiral.com"";
        DeferredResult<List<Principal>> result = provider.getPrincipals(null, principalId);

        TestContext ctx = testCreate(1);
        result.whenComplete((p, ex) -> {
            if (ex != null) {
                ctx.failIteration(ex);
                return;
            }",Eager Test
"@Test
    public void testGetPrincipalsOfTypeGroup() {
        String principalId = ""superusers@admiral.com"";
        DeferredResult<List<Principal>> result = provider.getPrincipals(null, principalId);

        TestContext ctx = testCreate(1);
        result.whenComplete((p, ex) -> {
            if (ex != null) {
                ctx.failIteration(ex);
                return;
            }",No Smells
"@Test
    public void testDeletePrincipalShouldDeleteUserState() throws Throwable {
        String fritzEmail = ""fritz@admiral.com"";
        String fritzSelfLink = LocalPrincipalFactoryService.SELF_LINK + ""/"" + encode(fritzEmail);

        doDelete(UriUtils.buildUri(host, fritzSelfLink), false);

        LocalPrincipalState state = getDocumentNoWait(LocalPrincipalState.class, fritzSelfLink);
        assertNull(state);

        UserState userState = getDocumentNoWait(UserState.class, buildUserServicePath(fritzEmail));
        assertNull(userState);

        ResourceGroupState resourceGroupState = getDocumentNoWait(ResourceGroupState.class,
                UriUtils.buildUriPath(ResourceGroupService.FACTORY_LINK, encode(fritzEmail)));
        assertNull(resourceGroupState);

        UserGroupState userGroupState = getDocumentNoWait(UserGroupState.class,
                UriUtils.buildUriPath(UserGroupService.FACTORY_LINK, encode(fritzEmail)));
        assertNull(userGroupState);

        RoleState roleState = getDocumentNoWait(RoleState.class,
                UriUtils.buildUriPath(RoleService.FACTORY_LINK, encode(fritzEmail)));
        assertNull(roleState);

    }",Mystery Guest + Resource Optimism
"@Test
    public void testUserSpecificResourceAreCreatedWhenUserIsCreated() throws Throwable {
        // Assert user specific UserGroup, ResourceGroup and Role are created.
        String fritzEmail = ""fritz@admiral.com"";
        String fritzSelfLink = LocalPrincipalFactoryService.SELF_LINK + ""/"" + encode(fritzEmail);

        LocalPrincipalState state = getDocumentNoWait(LocalPrincipalState.class, fritzSelfLink);
        assertNotNull(state);

        UserState userState = getDocumentNoWait(UserState.class, buildUserServicePath(fritzEmail));
        assertNotNull(userState);

        ResourceGroupState resourceGroupState = getDocumentNoWait(ResourceGroupState.class,
                UriUtils.buildUriPath(ResourceGroupService.FACTORY_LINK, encode(fritzEmail)));
        assertNotNull(resourceGroupState);

        UserGroupState userGroupState = getDocumentNoWait(UserGroupState.class,
                UriUtils.buildUriPath(UserGroupService.FACTORY_LINK, encode(fritzEmail)));
        assertNotNull(userGroupState);

        RoleState roleState = getDocumentNoWait(RoleState.class,
                UriUtils.buildUriPath(RoleService.FACTORY_LINK, encode(fritzEmail)));
        assertNotNull(roleState);
        assertEquals(userGroupState.documentSelfLink, roleState.userGroupLink);
        assertEquals(resourceGroupState.documentSelfLink, roleState.resourceGroupLink);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testInitConfig() {

        AuthConfigProvider provider = new LocalAuthConfigProvider();
        assertNull(provider.getAuthenticationService());
        assertEquals(BasicAuthenticationService.SELF_LINK,
                provider.getAuthenticationServiceSelfLink());

        Function<Claims, String> userLinkBuilder = provider
                .getAuthenticationServiceUserLinkBuilder();
        assertNotNull(userLinkBuilder);

        Claims claims = new Claims.Builder().setSubject(""test@admiral.com"").getResult();

        String userLink = userLinkBuilder.apply(claims);
        assertEquals(UserService.FACTORY_LINK + ""/test@admiral.com"", userLink);

        Function<Claims, String> userFactoryLinkBuilder = provider
                .getAuthenticationServiceUserFactoryLinkBuilder();
        assertNotNull(userFactoryLinkBuilder);

        String userFactoryLink = userFactoryLinkBuilder.apply(claims);
        assertEquals(UserService.FACTORY_LINK, userFactoryLink);

        assertTrue(provider.createServiceFactories().isEmpty());
    }",No Smells
"@Test
    public void testAssignRoleToUserGroup() throws Throwable {
        PrincipalRoleAssignment roleAssignment = new PrincipalRoleAssignment();
        roleAssignment.add = new ArrayList<>();
        roleAssignment.add.add(AuthRole.CLOUD_ADMIN.name());

        doRoleAssignment(roleAssignment, USER_GROUP_DEVELOPERS);

        RoleState roleState = getDocument(RoleState.class,
                UriUtils.buildUriPath(RoleService.FACTORY_LINK, AuthRole.CLOUD_ADMIN
                        .buildRoleWithSuffix(encode(USER_GROUP_DEVELOPERS))));
        assertNotNull(roleState);
        assertEquals(UriUtils.buildUriPath(UserGroupService.FACTORY_LINK,
                encode(USER_GROUP_DEVELOPERS)), roleState.userGroupLink);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testAssignRoleToUserTwice() throws Throwable {
        PrincipalRoleAssignment roleAssignment = new PrincipalRoleAssignment();
        roleAssignment.add = new ArrayList<>();
        roleAssignment.add.add(AuthRole.CLOUD_ADMIN.name());

        // Assign.
        doRoleAssignment(roleAssignment, USER_EMAIL_BASIC_USER);

        UserState state = getDocument(UserState.class, buildUserServicePath(USER_EMAIL_BASIC_USER));
        assertNotNull(state);
        assertTrue(state.userGroupLinks.contains(CLOUD_ADMINS_USER_GROUP_LINK));

        // Unassign.
        roleAssignment = new PrincipalRoleAssignment();
        roleAssignment.remove = new ArrayList<>();
        roleAssignment.remove.add(AuthRole.CLOUD_ADMIN.name());

        doRoleAssignment(roleAssignment, USER_EMAIL_BASIC_USER);

        state = getDocument(UserState.class, buildUserServicePath(USER_EMAIL_BASIC_USER));
        assertNotNull(state);
        assertTrue(!state.userGroupLinks.contains(CLOUD_ADMINS_USER_GROUP_LINK));

        // Assign again.
        roleAssignment = new PrincipalRoleAssignment();
        roleAssignment.add = new ArrayList<>();
        roleAssignment.add.add(AuthRole.CLOUD_ADMIN.name());

        doRoleAssignment(roleAssignment, USER_EMAIL_BASIC_USER);

        state = getDocument(UserState.class, buildUserServicePath(USER_EMAIL_BASIC_USER));
        assertNotNull(state);
        assertTrue(state.userGroupLinks.contains(CLOUD_ADMINS_USER_GROUP_LINK));
    }",Mystery Guest
"@Test
    public void testGetAllRolesForPrincipalWithIndirectRoles() throws Throwable {
        host.assumeIdentity(buildUserServicePath(USER_EMAIL_ADMIN2));
        // Scenario: create a group which will contain Connie which is basic user and the group
        // will be assigned to cloud admins. Create nested groups and add Connie in them, assign
        // the nested groups to project roles. Verify that PrincipalRoles for Connie contains all
        // roles where he is assigned indirectly.

        // root is the group where Connie belongs and we assign the group to cloud admins role.
        LocalPrincipalState root = new LocalPrincipalState();
        root.type = LocalPrincipalType.GROUP;
        root.name = ""root"";
        root.groupMembersLinks = Collections.singletonList(UriUtils.buildUriPath(
                LocalPrincipalFactoryService.SELF_LINK, encode(USER_EMAIL_CONNIE)));
        root = doPost(root, LocalPrincipalFactoryService.SELF_LINK);
        assertNotNull(root.documentSelfLink);

        // nestedGroup1 is the group where Connie belongs but we will add nestedGroup1 to
        // nestedGroup2 and we will indirectly assign roles to Connie as we assign a role to
        // nestedGroup2.
        LocalPrincipalState nestedGroup1 = new LocalPrincipalState();
        nestedGroup1.type = LocalPrincipalType.GROUP;
        nestedGroup1.name = ""nestedGroup1"";
        nestedGroup1.groupMembersLinks = Collections.singletonList(UriUtils.buildUriPath(
                LocalPrincipalFactoryService.SELF_LINK, encode(USER_EMAIL_CONNIE)));
        nestedGroup1 = doPost(nestedGroup1, LocalPrincipalFactoryService.SELF_LINK);
        assertNotNull(nestedGroup1.documentSelfLink);

        // nestedGroup2 is the group which contains nestedGroup1
        LocalPrincipalState nestedGroup2 = new LocalPrincipalState();
        nestedGroup2.type = LocalPrincipalType.GROUP;
        nestedGroup2.name = ""nestedGroup2"";
        nestedGroup2.groupMembersLinks = Collections.singletonList(nestedGroup1.documentSelfLink);
        nestedGroup2 = doPost(nestedGroup2, LocalPrincipalFactoryService.SELF_LINK);
        assertNotNull(nestedGroup2.documentSelfLink);

        // assign cloud admins role to root user group.
        PrincipalRoleAssignment roleAssignment = new PrincipalRoleAssignment();
        roleAssignment.add = Collections.singletonList(AuthRole.CLOUD_ADMIN.name());
        doPatch(roleAssignment, UriUtils.buildUriPath(PrincipalService.SELF_LINK, root.id,
                PrincipalService.ROLES_SUFFIX));

        // Create first project and assign nestedGroup1 as project admin.
        ProjectState firstProject = createProject(""first-project"");
        assertNotNull(firstProject.documentSelfLink);
        ProjectRoles projectRoles = new ProjectRoles();
        PrincipalRoleAssignment admins = new PrincipalRoleAssignment();
        admins.add = Collections.singletonList(nestedGroup1.id);
        projectRoles.administrators = admins;
        doPatch(projectRoles, firstProject.documentSelfLink);

        // Create second project and assign nestedGroup2 as project member.
        ProjectState secondProject = createProject(""second-project"");
        assertNotNull(secondProject.documentSelfLink);
        projectRoles = new ProjectRoles();
        PrincipalRoleAssignment members = new PrincipalRoleAssignment();
        members.add = Collections.singletonList(nestedGroup2.id);
        projectRoles.members = members;
        doPatch(projectRoles, secondProject.documentSelfLink);

        URI uri = UriUtils.buildUri(host, PrincipalService.SELF_LINK);
        uri = UriUtils.extendUriWithQuery(uri, PrincipalService.CRITERIA_QUERY, ""connie"",
                PrincipalService.ROLES_QUERY, PrincipalService.ROLES_QUERY_VALUE);

        List<PrincipalRoles> resultRoles = new ArrayList<>();

        TestContext ctx = testCreate(1);

        Operation getRoles = Operation
                .createGet(uri)
                .setReferer(host.getUri())
                .setCompletion((o, ex) -> {
                    if (ex != null) {
                        ctx.failIteration(ex);
                        return;
                    }",Eager Test + Mystery Guest
"@Test
    public void testGetSecurityContextWithIdAndInvalidPassword() {
        SecurityContextPostDto dto = new SecurityContextPostDto();
        dto.password = ""invalid"";

        TestContext ctx = testCreate(1);
        Operation post = Operation
                .createPost(host, UriUtils.buildUriPath(PrincipalService.SELF_LINK,
                        USER_EMAIL_GLORIA, PrincipalService.SECURITY_CONTEXT_SUFFIX))
                .setBody(dto)
                .setCompletion((o, ex) -> {
                    if (ex != null) {
                        ctx.completeIteration();
                        return;
                    }",No Smells
"@Test
    public void testPrincipalRoleHashCodeEquals() {
        PrincipalRoles pr1 = new PrincipalRoles();
        PrincipalRoles pr2 = new PrincipalRoles();
        assertEquals(31, pr1.hashCode());

        assertFalse(pr1.equals(null));
        assertFalse(pr1.equals(this));
        assertTrue(pr1.equals(pr2));

        pr1.id = ""name@domain"";
        assertNotEquals(31, pr1.hashCode());
        assertFalse(pr1.equals(pr2));

        pr2.id = ""name2@domain"";
        assertFalse(pr1.equals(pr2));

        pr2.id = ""name@domain"";
        assertTrue(pr1.equals(pr2));
    }",No Smells
"@Test
    public void testGetPublicProjectOnly() throws Throwable {
        ProjectState testProject1 = createProject(""test-project1"", ""test"", true);
        ProjectState testProject2 = createProject(""test-project2"", ""test"", true);
        ProjectState testProject3 = createProject(""test-project3"", ""test"", false);
        ProjectState testProject4 = createProject(""test-project4"", ""test"", false);
        assertDocumentExists(testProject1.documentSelfLink);
        assertDocumentExists(testProject2.documentSelfLink);
        assertDocumentExists(testProject3.documentSelfLink);
        assertDocumentExists(testProject4.documentSelfLink);

        host.assumeIdentity(buildUserServicePath(USER_EMAIL_BASIC_USER));

        URI uri = UriUtils.buildUri(ProjectFactoryService.SELF_LINK);
        uri = UriUtils.extendUriWithQuery(uri, ProjectFactoryService.QUERY_PARAM_PUBLIC, """");

        ServiceDocumentQueryResult getResult = getDocumentNoWait(ServiceDocumentQueryResult.class,
                uri.toString());

        assertEquals(Long.valueOf(2), getResult.documentCount);
        assertEquals(2, getResult.documentLinks.size());
        assertEquals(2, getResult.documents.size());
        assertTrue(getResult.documentLinks.contains(testProject1.documentSelfLink));
        assertTrue(getResult.documentLinks.contains(testProject2.documentSelfLink));
        assertTrue(!getResult.documentLinks.contains(testProject3.documentSelfLink));
        assertTrue(!getResult.documentLinks.contains(testProject4.documentSelfLink));
    }",Mystery Guest
"@Test
    public void testGetStateWithFilter() {
        URI uriWithFilter = UriUtils.extendUriWithQuery(
                UriUtils.buildUri(host, ProjectFactoryService.SELF_LINK),
                UriUtils.URI_PARAM_ODATA_FILTER, String.format(""%s eq '%s'"",
                        ServiceDocument.FIELD_NAME_SELF_LINK, project.documentSelfLink));

        host.testStart(1);
        Operation.createGet(uriWithFilter)
                .setReferer(host.getUri())
                .setCompletion((o, e) -> {
                    if (e != null) {
                        host.failIteration(e);
                    }",No Smells
"@Test
    public void testGetStateWithMembers() {
        URI uriWithExpand = UriUtils.extendUriWithQuery(
                UriUtils.buildUri(host, ProjectFactoryService.SELF_LINK),
                UriUtils.URI_PARAM_ODATA_EXPAND, Boolean.toString(true),
                UriUtils.URI_PARAM_ODATA_FILTER, String.format(""%s eq '%s'"",
                        ServiceDocument.FIELD_NAME_SELF_LINK, project.documentSelfLink));

        host.testStart(1);
        Operation.createGet(uriWithExpand)
                .setReferer(host.getUri())
                .setCompletion((o, e) -> {
                    if (e != null) {
                        host.failIteration(e);
                    }",No Smells
"@Test
    public void testAssignNotExistingPrincipalGroupShouldFail() {
        ProjectRoles projectRoles = new ProjectRoles();
        projectRoles.members = new PrincipalRoleAssignment();
        projectRoles.administrators = new PrincipalRoleAssignment();
        projectRoles.administrators.add = Collections.singletonList(""test-group"");

        host.testStart(1);

        rolesHandler.handleRolesUpdate(project, projectRoles, testOperationByAdmin)
                .whenComplete((ignore, ex) -> {
                    if (ex != null) {
                        if (ex.getCause() instanceof ServiceNotFoundException) {
                            host.completeIteration();
                            return;
                        }",No Smells
"@Test
    public void testAssignPrincipalOfTypeGroupTwice() {
        String groupId = ""superusers@admiral.com"";

        ProjectRoles projectRoles = new ProjectRoles();
        projectRoles.members = new PrincipalRoleAssignment();
        projectRoles.members.add = Collections.singletonList(groupId);

        String projectId = Service.getId(project.documentSelfLink);

        // patch twice and verify principal is present only once in the project.
        doPatch(projectRoles, project.documentSelfLink);

        doPatch(projectRoles, project.documentSelfLink);

        String resourceGroupLink = UriUtils.buildUriPath(ResourceGroupService.FACTORY_LINK,
                AuthRole.PROJECT_MEMBER_EXTENDED.buildRoleWithSuffix(projectId, encode(groupId)));

        String roleLink = UriUtils.buildUriPath(RoleService.FACTORY_LINK,
                AuthRole.PROJECT_MEMBER_EXTENDED.buildRoleWithSuffix(projectId, encode(groupId)));

        assertDocumentExists(resourceGroupLink);
        assertDocumentExists(roleLink);

        ExpandedProjectState projectState = getExpandedProjectState(project.documentSelfLink);
        assertEquals(1, projectState.members.size());
        // default one and the assigned one.
        assertEquals(2, projectState.membersUserGroupLinks.size());
    }",No Smells
"@Test
    public void testDeleteProjectAssociatedWithPlacement() throws Throwable {
        ResourcePoolState pool = createResourcePool();
        GroupResourcePlacementState placement = new GroupResourcePlacementState();
        placement.name = ""test-reservation"";
        placement.resourcePoolLink = pool.documentSelfLink;
        placement.tenantLinks = Arrays.asList(project.documentSelfLink);

        doPost(placement, GroupResourcePlacementService.FACTORY_LINK);

        try {
            deleteProject(project);
        }",No Smells
"@Test
    public void testCreateProjectWithDuplicateNameShouldFail() throws Throwable {
        createProject(""test-name"");

        try {
            createProjectExpectFailure(""test-name"");
            fail(""Project create with same name should've failed"");
        }",No Smells
"@Test
    public void testDefaultProjectUserGroupsAreCreated() throws Throwable {
        ProjectState defaultProject = getDocumentNoWait(ProjectState.class,
                ProjectService.DEFAULT_PROJECT_LINK);

        assertNotNull(defaultProject);
        assertNotNull(defaultProject.documentSelfLink);
        assertNotNull(defaultProject.administratorsUserGroupLinks);
        assertNotNull(defaultProject.membersUserGroupLinks);
        assertNotNull(defaultProject.viewersUserGroupLinks);

        assertEquals(1, defaultProject.administratorsUserGroupLinks.size());
        assertEquals(1, defaultProject.membersUserGroupLinks.size());
        assertEquals(1, defaultProject.viewersUserGroupLinks.size());

        String adminsGroupLink = defaultProject.administratorsUserGroupLinks.iterator().next();
        String membersGroupLink = defaultProject.membersUserGroupLinks.iterator().next();
        String viewersGroupLink = defaultProject.viewersUserGroupLinks.iterator().next();

        UserGroupState adminGroup = getDocumentNoWait(UserGroupState.class, adminsGroupLink);
        UserGroupState membersGroup = getDocumentNoWait(UserGroupState.class, membersGroupLink);
        UserGroupState viewersGroup = getDocumentNoWait(UserGroupState.class, viewersGroupLink);

        assertNotNull(adminGroup.documentSelfLink);
        assertNotNull(membersGroup.documentSelfLink);
        assertNotNull(viewersGroup.documentSelfLink);
    }",No Smells
"@Test
    public void testDelete() throws Throwable {
        String admins = project.administratorsUserGroupLinks.iterator().next();
        String members = project.membersUserGroupLinks.iterator().next();
        String viewers = project.viewersUserGroupLinks.iterator().next();
        deleteProject(project);

        // Verify the default UserGroups are deleted
        UserGroupState adminsGroup = getDocumentNoWait(UserGroupState.class, admins);
        assertNull(adminsGroup);

        UserGroupState membersGroups = getDocumentNoWait(UserGroupState.class, members);
        assertNull(membersGroups);

        UserGroupState viewersGroups = getDocumentNoWait(UserGroupState.class, viewers);
        assertNull(viewersGroups);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testDeleteProjectAssociatedWithPlacement() throws Throwable {
        ResourcePoolState pool = createResourcePool();
        GroupResourcePlacementState placement = new GroupResourcePlacementState();
        placement.name = ""test-reservation"";
        placement.resourcePoolLink = pool.documentSelfLink;
        placement.tenantLinks = Arrays.asList(project.documentSelfLink);

        doPost(placement, GroupResourcePlacementService.FACTORY_LINK);

        try {
            deleteProject(project);
        }",No Smells
"@Test
    public void testDevOpsAdminCanAssignUsersToProject() throws Throwable {
        ProjectState project = createProject(""project"");
        ProjectRoles roles = new ProjectRoles();
        roles.administrators = new PrincipalRoleAssignment();
        roles.administrators.add = Collections.singletonList(USER_EMAIL_BASIC_USER);
        doPatch(roles, project.documentSelfLink);

        host.assumeIdentity(buildUserServicePath(USER_EMAIL_BASIC_USER));
        ProjectRoles roles1 = new ProjectRoles();
        roles1.members = new PrincipalRoleAssignment();
        roles1.members.add = Collections.singletonList(USER_EMAIL_CONNIE);
        doPatch(roles1, project.documentSelfLink);

        ExpandedProjectState expandedProjectState = getExpandedProjectState(
                project.documentSelfLink);

        assertTrue(expandedProjectState.administrators.size() == 1);
        assertTrue(expandedProjectState.administrators.get(0).id.equals(USER_EMAIL_BASIC_USER));
        assertTrue(expandedProjectState.members.size() == 1);
        assertTrue(expandedProjectState.members.get(0).id.equals(USER_EMAIL_CONNIE));
    }",No Smells
"@Test
    public void testProjectRolesPatchGroups() throws Throwable {
        // verify initial state
        ExpandedProjectState expandedState = getExpandedProjectState(project.documentSelfLink);
        assertNotNull(expandedState.administratorsUserGroupLinks);
        assertNotNull(expandedState.membersUserGroupLinks);
        assertNotNull(expandedState.administrators);
        assertNotNull(expandedState.members);
        assertNotNull(expandedState.viewers);
        assertEquals(1, expandedState.administrators.size());
        assertEquals(1, expandedState.members.size());
        assertEquals(1, expandedState.viewers.size());
        assertEquals(USER_EMAIL_ADMIN, expandedState.administrators.iterator().next().email);
        assertEquals(USER_EMAIL_ADMIN, expandedState.members.iterator().next().email);
        assertEquals(USER_EMAIL_BASIC_USER, expandedState.viewers.iterator().next().email);

        String expectedAdministratorsUserGroupLink = UriUtils.buildUriPath(
                UserGroupService.FACTORY_LINK,
                AuthRole.PROJECT_ADMIN
                        .buildRoleWithSuffix(Service.getId(project.documentSelfLink)));
        String expectedMembersUserGroupLink = UriUtils.buildUriPath(UserGroupService.FACTORY_LINK,
                AuthRole.PROJECT_MEMBER
                        .buildRoleWithSuffix(Service.getId(project.documentSelfLink)));

        assertEquals(expectedAdministratorsUserGroupLink,
                expandedState.administratorsUserGroupLinks.iterator().next());
        assertEquals(expectedMembersUserGroupLink,
                expandedState.membersUserGroupLinks.iterator().next());

        // make a batch user operation: add group
        ProjectRoles projectRoles = new ProjectRoles();
        projectRoles.members = new PrincipalRoleAssignment();
        projectRoles.members.add = Arrays.asList(USER_GROUP_DEVELOPERS);

        // assert that the new role does not exist
        String roleLink = UriUtils.buildUriPath(RoleService.FACTORY_LINK,
                AuthRole.PROJECT_MEMBER.buildRoleWithSuffix(Service.getId(project.documentSelfLink),
                        encode(USER_GROUP_DEVELOPERS)));
        assertDocumentNotExists(roleLink);

        host.testStart(1);

        Operation.createPatch(host, expandedState.documentSelfLink)
                .setReferer(host.getUri())
                .setBody(projectRoles)
                .setCompletion((o, e) -> {
                    if (e != null) {
                        host.log(Level.SEVERE, Utils.toString(e));
                        host.failIteration(e);
                    }",Eager Test + Mystery Guest
"@Test
    public void testProjectServices() throws Throwable {
        verifyService(
                ProjectFactoryService.class,
                ProjectState.class,
                (prefix, index) -> {
                    ProjectState projectState = new ProjectState();
                    projectState.id = prefix + ""id"" + index;
                    projectState.name = prefix + ""name"" + index;
                    projectState.description = prefix + ""description"" + index;
                    projectState.isPublic = true;

                    return projectState;
                }",No Smells
"@Test
    public void testUserGroupsAutoCreatedOnProjectCreate() {
        String adminsLinks = UriUtils.buildUriPath(UserGroupService.FACTORY_LINK,
                AuthRole.PROJECT_ADMIN
                        .buildRoleWithSuffix(Service.getId(project.documentSelfLink)));
        String membersLinks = UriUtils.buildUriPath(UserGroupService.FACTORY_LINK,
                AuthRole.PROJECT_MEMBER
                        .buildRoleWithSuffix(Service.getId(project.documentSelfLink)));
        String viewersLinks = UriUtils.buildUriPath(UserGroupService.FACTORY_LINK,
                AuthRole.PROJECT_VIEWER
                        .buildRoleWithSuffix(Service.getId(project.documentSelfLink)));
        assertDocumentExists(adminsLinks);
        assertDocumentExists(membersLinks);
        assertDocumentExists(viewersLinks);
    }",No Smells
"@Test
    public void testBuildProjectViewersRole() {
        RoleState roleState = buildProjectViewersRole(SAMPLE_PROJECT_ID, SAMPLE_USER_GROUP_LINK,
                SAMPLE_RESOURCE_GROUP_LINK);

        String id = AuthRole.PROJECT_VIEWER.buildRoleWithSuffix(SAMPLE_PROJECT_ID,
                SAMPLE_USER_GROUP_LINK);
        String expectedSelfLink = UriUtils.buildUriPath(RoleService.FACTORY_LINK, id);
        assertEquals(expectedSelfLink, roleState.documentSelfLink);
        assertEquals(SAMPLE_USER_GROUP_LINK, roleState.userGroupLink);
        assertEquals(SAMPLE_RESOURCE_GROUP_LINK, roleState.resourceGroupLink);
    }",No Smells
"@Test
    public void testBuildRoleState() {
        EnumSet<Action> verbs = EnumSet.of(Action.GET);
        RoleState roleState = buildRoleState(SAMPLE_SELF_LINK, SAMPLE_USER_GROUP_LINK,
                SAMPLE_RESOURCE_GROUP_LINK, verbs, Policy.ALLOW);

        assertEquals(SAMPLE_SELF_LINK, roleState.documentSelfLink);
        assertEquals(SAMPLE_USER_GROUP_LINK, roleState.userGroupLink);
        assertEquals(SAMPLE_RESOURCE_GROUP_LINK, roleState.resourceGroupLink);
        assertEquals(verbs, roleState.verbs);
    }",No Smells
"@Test
    public void testBuildUserGroupState() {
        String testId = ""testIdentifier"";
        String testIdSelfLink = UriUtils.buildUriPath(UserGroupService.FACTORY_LINK, testId);
        UserGroupState userGroupState = buildUserGroupState(testId);
        assertEquals(testIdSelfLink, userGroupState.documentSelfLink);
    }",No Smells
"@Test
    public void testBuildUsersQuery() {

        List<String> testUsers = Arrays.asList(
                ""/users/user1@test.com"",
                ""/users/user2@test.com"",
                ""/users/admi@dev.local"");

        Query queryForUsers = AuthUtil.buildUsersQuery(testUsers);

        // kind and userlinks clauses
        List<Query> topLevelClauses = queryForUsers.booleanClauses;
        assertNotNull(topLevelClauses);
        assertEquals(2, topLevelClauses.size());

        topLevelClauses.forEach((query) -> {
            assertEquals(Occurance.MUST_OCCUR, query.occurance);
            assertTrue(query.booleanClauses == null
                    || query.booleanClauses.isEmpty()
                    || query.booleanClauses.size() == testUsers.size());

            if (query.booleanClauses == null || query.booleanClauses.isEmpty()) {
                assertEquals(MatchType.TERM, query.term.matchType);
            }",No Smells
"@Test
    public void testGetAllRolesForPrincipal() throws Throwable {
        Operation testOperationByAdmin = createAuthorizedOperation(
                host.assumeIdentity(buildUserServicePath(USER_EMAIL_ADMIN2)));

        // Scenario: create 2 projects, assign fritz as project admin in 1st and as project
        // member in 2nd project.

        // Create first project and assign fritz as project admin.
        ProjectState firstProject = createProject(""first-project"");
        assertNotNull(firstProject.documentSelfLink);
        ProjectRoles projectRoles = new ProjectRoles();
        PrincipalRoleAssignment admins = new PrincipalRoleAssignment();
        admins.add = Collections.singletonList(USER_EMAIL_ADMIN);
        projectRoles.administrators = admins;
        doPatch(projectRoles, firstProject.documentSelfLink);

        // Create second project and assign fritz as project member.
        ProjectState secondProject = createProject(""second-project"");
        assertNotNull(secondProject.documentSelfLink);
        projectRoles = new ProjectRoles();
        PrincipalRoleAssignment members = new PrincipalRoleAssignment();
        members.add = Collections.singletonList(USER_EMAIL_ADMIN);
        projectRoles.members = members;
        doPatch(projectRoles, secondProject.documentSelfLink);

        Principal fritz = getPrincipal(USER_EMAIL_ADMIN);
        DeferredResult<PrincipalRoles> result = PrincipalRolesUtil.getAllRolesForPrincipal(
                privilegedTestService, testOperationByAdmin, fritz);

        final PrincipalRoles[] resultRoles = new PrincipalRoles[1];

        TestContext ctx = testCreate(1);
        result.whenComplete((principalRoles, ex) -> {
            if (ex != null) {
                ctx.failIteration(ex);
                return;
            }",Eager Test
"@Test
    public void testGetAllRolesForPrincipalWithIndirectRoles() throws Throwable {
        Operation testOperationByAdmin = createAuthorizedOperation(
                host.assumeIdentity(buildUserServicePath(USER_EMAIL_ADMIN2)));

        // Scenario: create a group which will contain Connie which is basic user and the group
        // will be assigned to cloud admins. Create nested groups and add Connie in them, assign
        // the nested groups to project roles. Verify that PrincipalRoles for Connie contains all
        // roles where he is assigned indirectly.

        // root is the group where Connie belongs and we assign the group to cloud admins role.
        LocalPrincipalState root = new LocalPrincipalState();
        root.type = LocalPrincipalType.GROUP;
        root.name = ""root@admiral.com"";
        root.groupMembersLinks = Collections.singletonList(UriUtils.buildUriPath(
                LocalPrincipalFactoryService.SELF_LINK, encode(USER_EMAIL_CONNIE)));
        root = doPost(root, LocalPrincipalFactoryService.SELF_LINK);
        assertNotNull(root.documentSelfLink);

        // nestedGroup1 is the group where Connie belongs but we will add nestedGroup1 to
        // nestedGroup2 and we will indirectly assign roles to Connie as we assign a role to
        // nestedGroup2.
        LocalPrincipalState nestedGroup1 = new LocalPrincipalState();
        nestedGroup1.type = LocalPrincipalType.GROUP;
        nestedGroup1.name = ""nestedGroup1@admiral.com"";
        nestedGroup1.groupMembersLinks = Collections.singletonList(UriUtils.buildUriPath(
                LocalPrincipalFactoryService.SELF_LINK, encode(USER_EMAIL_CONNIE)));
        nestedGroup1 = doPost(nestedGroup1, LocalPrincipalFactoryService.SELF_LINK);
        assertNotNull(nestedGroup1.documentSelfLink);

        // nestedGroup2 is the group which contains nestedGroup1
        LocalPrincipalState nestedGroup2 = new LocalPrincipalState();
        nestedGroup2.type = LocalPrincipalType.GROUP;
        nestedGroup2.name = ""nestedGroup2@admiral.com"";
        nestedGroup2.groupMembersLinks = Collections.singletonList(nestedGroup1.documentSelfLink);
        nestedGroup2 = doPost(nestedGroup2, LocalPrincipalFactoryService.SELF_LINK);
        assertNotNull(nestedGroup2.documentSelfLink);

        // assign cloud admins role to root user group.
        PrincipalRoleAssignment roleAssignment = new PrincipalRoleAssignment();
        roleAssignment.add = Collections.singletonList(AuthRole.CLOUD_ADMIN.name());
        doPatch(roleAssignment, UriUtils.buildUriPath(PrincipalService.SELF_LINK, root.id,
                PrincipalService.ROLES_SUFFIX));

        // Create first project and assign nestedGroup1 as project admin.
        Map<String, String> customProperties = new HashMap<>();
        customProperties.put(""key1"", ""value1"");
        customProperties.put(""key2"", ""value2"");
        ProjectState firstProject = createProject(""first-project"", customProperties);
        assertNotNull(firstProject.documentSelfLink);
        ProjectRoles projectRoles = new ProjectRoles();
        PrincipalRoleAssignment admins = new PrincipalRoleAssignment();
        admins.add = Collections.singletonList(nestedGroup1.id);
        projectRoles.administrators = admins;
        doPatch(projectRoles, firstProject.documentSelfLink);

        // Create second project and assign nestedGroup2 as project member.
        ProjectState secondProject = createProject(""second-project"");
        assertNotNull(secondProject.documentSelfLink);
        projectRoles = new ProjectRoles();
        PrincipalRoleAssignment members = new PrincipalRoleAssignment();
        members.add = Collections.singletonList(nestedGroup2.id);
        projectRoles.members = members;
        doPatch(projectRoles, secondProject.documentSelfLink);

        Principal connie = getPrincipal(USER_EMAIL_CONNIE);
        DeferredResult<PrincipalRoles> result = PrincipalRolesUtil.getAllRolesForPrincipal(
                privilegedTestService, testOperationByAdmin, connie);

        final PrincipalRoles[] resultRoles = new PrincipalRoles[1];

        TestContext ctx = testCreate(1);
        result.whenComplete((principalRoles, ex) -> {
            if (ex != null) {
                ctx.failIteration(ex);
                return;
            }",Eager Test
"@Test
    public void testGetPrincipalRolesForBasicUser() throws GeneralSecurityException {
        Operation testOperationByAdmin = createAuthorizedOperation(
                host.assumeIdentity(buildUserServicePath(USER_EMAIL_ADMIN2)));

        Principal basicUser = getPrincipal(USER_EMAIL_BASIC_USER);
        DeferredResult<PrincipalRoles> result = PrincipalRolesUtil.getAllRolesForPrincipal(
                privilegedTestService, testOperationByAdmin, basicUser);

        final PrincipalRoles[] resultRoles = new PrincipalRoles[1];

        TestContext ctx = testCreate(1);
        result.whenComplete((principalRoles, ex) -> {
            if (ex != null) {
                ctx.failIteration(ex);
                return;
            }",No Smells
"@Test
    public void testCopyPrincipalData() {
        assertEquals(null, copyPrincipalData(null, new Principal()));

        Principal principal = new Principal();
        assertEquals(principal, copyPrincipalData(principal, null));

        principal = copyPrincipalData(testPrincipal, principal);
        assertEquals(testPrincipal.id, principal.id);
        assertEquals(testPrincipal.email, principal.email);
        assertEquals(testPrincipal.type, principal.type);
        assertEquals(testPrincipal.name, principal.name);
        assertEquals(testPrincipal.password, principal.password);
    }",No Smells
"@Test
    public void testEncodeDecodeVca() {
        ConfigurationState config = new ConfigurationState();
        config.key = ConfigurationUtil.VCA_MODE_PROPERTY;
        config.value = Boolean.toString(true);
        ConfigurationUtil.initialize(config);

        String fritzEmail = ""fritz@admiral.com"";
        String encodedEmail = encode(fritzEmail);
        assertEquals(fritzEmail, encodedEmail);
        String decodedEmail = decode(encodedEmail);
        assertEquals(fritzEmail, decodedEmail);

        ConfigurationUtil.initialize((ConfigurationState[]) null);
    }",No Smells
"@Test
    public void testSecurityContextContainsAllRolesForMultipleProjects() throws Throwable {
        Operation testOperationByAdmin = createAuthorizedOperation(
                host.assumeIdentity(buildUserServicePath(USER_EMAIL_ADMIN)));
        host.assumeIdentity(buildUserServicePath(USER_EMAIL_ADMIN2));

        // Scenario: create 2 projects, assign fritz as project admin in 1st and as project
        // member in 2nd project.

        // Create first project and assign fritz as project admin.
        ProjectState firstProject = createProject(""first-project"");
        assertNotNull(firstProject.documentSelfLink);
        ProjectRoles projectRoles = new ProjectRoles();
        PrincipalRoleAssignment admins = new PrincipalRoleAssignment();
        admins.add = Collections.singletonList(USER_EMAIL_ADMIN);
        projectRoles.administrators = admins;
        doPatch(projectRoles, firstProject.documentSelfLink);

        // Create second project and assign fritz as project member.
        ProjectState secondProject = createProject(""second-project"");
        assertNotNull(secondProject.documentSelfLink);
        projectRoles = new ProjectRoles();
        PrincipalRoleAssignment members = new PrincipalRoleAssignment();
        members.add = Collections.singletonList(USER_EMAIL_ADMIN);
        projectRoles.members = members;
        doPatch(projectRoles, secondProject.documentSelfLink);

        DeferredResult<SecurityContext> result = SecurityContextUtil.getSecurityContext(
                privilegedTestService, testOperationByAdmin);

        final SecurityContext[] context = new SecurityContext[1];
        TestContext ctx = testCreate(1);
        result.whenComplete((securityContext, ex) -> {
            if (ex != null) {
                ctx.failIteration(ex);
                return;
            }",Eager Test
"@Test
    public void testSecurityContextContainsIndirectAssignedRoles() throws Throwable {
        Operation testOperationByBasicUser = createAuthorizedOperation(
                host.assumeIdentity(buildUserServicePath(USER_EMAIL_CONNIE)));
        host.assumeIdentity(buildUserServicePath(USER_EMAIL_ADMIN2));

        // Scenario: create a group which will contain Connie which is basic user and the group
        // will be assigned to cloud admins. Create nested groups and add Connie in them, assign
        // the nested groups to project roles. Verify that PrincipalRoles for Connie contains all
        // roles where he is assigned indirectly.

        // root is the group where Connie belongs and we assign the group to cloud admins role.
        LocalPrincipalState root = new LocalPrincipalState();
        root.type = LocalPrincipalType.GROUP;
        root.name = ""root@admiral.com"";
        root.groupMembersLinks = Collections.singletonList(UriUtils.buildUriPath(
                LocalPrincipalFactoryService.SELF_LINK, encode(USER_EMAIL_CONNIE)));
        root = doPost(root, LocalPrincipalFactoryService.SELF_LINK);
        assertNotNull(root.documentSelfLink);

        // nestedGroup1 is the group where Connie belongs but we will add nestedGroup1 to
        // nestedGroup2 and we will indirectly assign roles to Connie as we assign a role to
        // nestedGroup2.
        LocalPrincipalState nestedGroup1 = new LocalPrincipalState();
        nestedGroup1.type = LocalPrincipalType.GROUP;
        nestedGroup1.name = ""nestedGroup1@admiral.com"";
        nestedGroup1.groupMembersLinks = Collections.singletonList(UriUtils.buildUriPath(
                LocalPrincipalFactoryService.SELF_LINK, encode(USER_EMAIL_CONNIE)));
        nestedGroup1 = doPost(nestedGroup1, LocalPrincipalFactoryService.SELF_LINK);
        assertNotNull(nestedGroup1.documentSelfLink);

        // nestedGroup2 is the group which contains nestedGroup1
        LocalPrincipalState nestedGroup2 = new LocalPrincipalState();
        nestedGroup2.type = LocalPrincipalType.GROUP;
        nestedGroup2.name = ""nestedGroup2@admiral.com"";
        nestedGroup2.groupMembersLinks = Collections.singletonList(nestedGroup1.documentSelfLink);
        nestedGroup2 = doPost(nestedGroup2, LocalPrincipalFactoryService.SELF_LINK);
        assertNotNull(nestedGroup2.documentSelfLink);

        // assign cloud admins role to root user group.
        PrincipalRoleAssignment roleAssignment = new PrincipalRoleAssignment();
        roleAssignment.add = Collections.singletonList(AuthRole.CLOUD_ADMIN.name());
        doPatch(roleAssignment, UriUtils.buildUriPath(PrincipalService.SELF_LINK, root.id,
                PrincipalService.ROLES_SUFFIX));

        // Create first project and assign nestedGroup1 as project admin.
        ProjectState firstProject = createProject(""first-project"");
        assertNotNull(firstProject.documentSelfLink);
        ProjectRoles projectRoles = new ProjectRoles();
        PrincipalRoleAssignment admins = new PrincipalRoleAssignment();
        admins.add = Collections.singletonList(nestedGroup1.id);
        projectRoles.administrators = admins;
        doPatch(projectRoles, firstProject.documentSelfLink);

        // Create second project and assign nestedGroup2 as project member.
        ProjectState secondProject = createProject(""second-project"");
        assertNotNull(secondProject.documentSelfLink);
        projectRoles = new ProjectRoles();
        PrincipalRoleAssignment members = new PrincipalRoleAssignment();
        members.add = Collections.singletonList(nestedGroup2.id);
        projectRoles.members = members;
        doPatch(projectRoles, secondProject.documentSelfLink);

        DeferredResult<SecurityContext> result = SecurityContextUtil.getSecurityContext(
                privilegedTestService, testOperationByBasicUser);

        final SecurityContext[] context = new SecurityContext[1];
        TestContext ctx = testCreate(1);
        result.whenComplete((securityContext, ex) -> {
            if (ex != null) {
                ctx.failIteration(ex);
                return;
            }",Eager Test
"@Test
    public void testSecurityContextForCloudAdminAndBasicUser() throws GeneralSecurityException {
        Operation testOperationByAdmin = createAuthorizedOperation(
                host.assumeIdentity(buildUserServicePath(USER_EMAIL_ADMIN)));
        Operation testOperationByBasicUser = createAuthorizedOperation(
                host.assumeIdentity(buildUserServicePath(USER_EMAIL_BASIC_USER)));
        host.assumeIdentity(buildUserServicePath(USER_EMAIL_ADMIN));

        // Verify for cloud admin.
        DeferredResult<SecurityContext> result = SecurityContextUtil.getSecurityContext(
                privilegedTestService, testOperationByAdmin);

        final SecurityContext[] context = new SecurityContext[1];
        TestContext ctx = testCreate(1);
        result.whenComplete((securityContext, ex) -> {
            if (ex != null) {
                ctx.failIteration(ex);
                return;
            }",No Smells
"@Test
    public void testUserGroupsUpdater() throws Throwable {
        // Create test user group.
        String userGroupSelfLink = UriUtils.buildUriPath(UserGroupService.FACTORY_LINK, encode(""testId""));
        Query userGroupQuery = AuthUtil.buildQueryForUsers(userGroupSelfLink);
        UserGroupState userGroupState = UserGroupState.Builder
                .create()
                .withQuery(userGroupQuery)
                .withSelfLink(userGroupSelfLink)
                .build();

        userGroupState = doPost(userGroupState, UserGroupService.FACTORY_LINK);
        assertNotNull(userGroupState);

        // Add users.
        DeferredResult<Void> result = UserGroupsUpdater.create()
                .setService(privilegedTestService)
                .setGroupLink(userGroupSelfLink)
                .setUsersToAdd(Arrays.asList(encode(USER_EMAIL_ADMIN), encode(USER_EMAIL_CONNIE)))
                .update();

        TestContext ctx = testCreate(1);
        result.whenComplete((o, ex) -> {
            if (ex != null) {
                ctx.failIteration(ex);
                return;
            }",Eager Test
"@Test
    public void executeJavaExtSourceAsZIPTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        int expectedInVar = 3;
        int expectedInVar2 = 4;
        int expectedResult = 7;

        closureDescState.sourceURL = testWebserverUri + ""/test_script_java.zip"";
        closureDescState.source = ""should not be used"";
        closureDescState.runtime = RUNTIME_JAVA_8;
        closureDescState.entrypoint = ""testpackage.Test.test"";

        ResourceConstraints constraints = new ResourceConstraints();
        constraints.timeoutSeconds = 10;
        constraints.ramMB = 300;
        closureDescState.resources = constraints;

        String taskDefPayload = Utils.toJson(closureDescState);
        ClosureDescription closureDescription = createClosureDescription(taskDefPayload,
                serviceClient);
        assertNotNull(closureDescription);

        // Create Closure
        Closure createdClosure = createClosure(closureDescription, serviceClient);
        assertEquals(closureDescription.documentSelfLink, createdClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.CREATED, createdClosure.state);

        // Execute the created Closure
        Closure closureRequest = new Closure();
        Map inputs = new HashMap<>();
        inputs.put(""a"", new JsonPrimitive(expectedInVar));
        inputs.put(""b"", new JsonPrimitive(expectedInVar2));
        closureRequest.inputs = inputs;

        executeClosure(createdClosure, closureRequest, serviceClient);

        // Wait for the completion timeout
        String imageRequestLink = waitForBuildCompletion(IMAGE_NAME, closureDescription);

        waitForTaskState(createdClosure.documentSelfLink, TaskState.TaskStage.FINISHED,
                serviceClient);

        Closure fetchedClosure = getClosure(createdClosure.documentSelfLink, serviceClient);

        assertEquals(closureDescription.documentSelfLink, fetchedClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.FINISHED, fetchedClosure.state);

        assertEquals(expectedInVar, fetchedClosure.inputs.get(""a"").getAsInt());
        assertEquals(expectedInVar2, fetchedClosure.inputs.get(""b"").getAsInt());
        assertEquals(expectedResult, fetchedClosure.outputs.get(""result"").getAsInt(), 0);

        cleanResource(imageRequestLink, serviceClient);
        cleanResource(createdClosure.documentSelfLink, serviceClient);
        cleanResource(closureDescription.documentSelfLink, serviceClient);
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void addDefaultTaskTest() throws Exception {
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";
        closureDescState.source = ""module.exports = function test(context) {""
                + "" var a = 1;""
                + "" console.log(\""Hello test \"" + a);""
                + "" }",No Smells
"@Test
    public void executeJSArrayOfNumberParametersTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        Integer[] expectedInVar = { 1, 2, 3 }",Eager Test
"@Test
    public void executeJSDependenciesTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        int expectedInVar = 3;
        double expectedResult = 4.0; // TODO: fix types
        closureDescState.source = ""var _ = require('lodash');""
                + ""var moment = require('moment');""
                + ""module.exports = function test(context) {""
                + "" console.log('Executed at : ' + moment().valueOf());""
                + "" context.outputs.result = context.inputs.a + 1;""
                + ""}",Eager Test
"@Test
    public void executeJSExtSourceAsZIPNoPackageJsonEntrypointTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";
        closureDescState.entrypoint = ""index.test"";

        String expectedInVar = ""a"";
        String expectedOutVar = ""b"";
        String expectedResult = ""ac"";

        closureDescState.sourceURL = testWebserverUri + ""/test_script_no_packagejson.zip"";
        closureDescState.source = ""should not be used"";
        closureDescState.runtime = RUNTIME_NODEJS_4;
        closureDescState.outputNames = new ArrayList<>(Collections.singletonList(""result""));
        ResourceConstraints constraints = new ResourceConstraints();
        constraints.timeoutSeconds = 20;
        constraints.ramMB = 300;
        closureDescState.resources = constraints;

        String taskDefPayload = Utils.toJson(closureDescState);
        ClosureDescription closureDescription = createClosureDescription(taskDefPayload,
                serviceClient);
        assertNotNull(closureDescription);

        // Create Closure
        Closure createdClosure = createClosure(closureDescription, serviceClient);
        assertEquals(closureDescription.documentSelfLink, createdClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.CREATED, createdClosure.state);

        // Execute the created Closure
        Closure closureRequest = new Closure();
        Map inputs = new HashMap<>();
        inputs.put(""a"", new JsonPrimitive(expectedInVar));
        closureRequest.inputs = inputs;

        executeClosure(createdClosure, closureRequest, serviceClient);

        // Wait for the completion timeout
        String imageRequestLink = waitForBuildCompletion(IMAGE_NAME, closureDescription);

        waitForTaskState(createdClosure.documentSelfLink, TaskState.TaskStage.FINISHED,
                serviceClient);
        Closure fetchedClosure = getClosure(createdClosure.documentSelfLink, serviceClient);

        assertEquals(closureDescription.documentSelfLink, fetchedClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.FINISHED, fetchedClosure.state);

        verifyRunDuration(fetchedClosure);

        assertEquals(expectedInVar, fetchedClosure.inputs.get(""a"").getAsString());
        assertEquals(expectedResult, fetchedClosure.outputs.get(""result"").getAsString());

        cleanResource(imageRequestLink, serviceClient);
        cleanResource(createdClosure.documentSelfLink, serviceClient);
        cleanResource(closureDescription.documentSelfLink, serviceClient);
    }",Eager Test
"@Test
    public void executeJSObjectParametersTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        TestObject expectedInVar = new TestObject();
        expectedInVar.strTest = ""test"";
        expectedInVar.intTest = 1;
        expectedInVar.boolTest = true;
        int expectedOutVar = 3;
        String expectedResult = expectedInVar.strTest + ""_changed"";

        closureDescState.source = ""module.exports = function test(context) {""
                + "" var x = context.inputs.a;""
                + "" console.log('Hello object: ' + x.strTest);""
                + "" x.strTest = x.strTest + '_changed';""
                + "" x.intTest = x.intTest + 1; x.boolTest = !x.boolTest;""
                + "" context.outputs.result = x;""
                + ""}",Eager Test
"@Test
    public void completeFailTimeoutedJSScriptTaskTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        closureDescState.source = ""#!/usr/bin/powershell\n""
                + ""function test($context)\n""
                + ""{\n""
                + ""    Write-Host \""Waiting...\""\n""
                + ""    Start-Sleep -s 60\n""
                + ""    Write-Host \""After sleep\""\n""
                + ""}",Eager Test
"@Test
    public void executePowershellBooleanParametersTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        String expectedInVar = ""True"";
        boolean expectedResult = false;

        closureDescState.source = ""function test($context)\n""
                + ""{\n""
                + ""    $result = -not $inputs.a\n""
                + ""    $context.outputs = @{\""result\"" = $result}",No Smells
"@Test
    public void executePowershellExtSourceAsZIPTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        String expectedInVar = ""a"";
        String expectedResult = ""ac"";

        closureDescState.sourceURL = testWebserverUri + ""/test_script_powershell.zip"";
        closureDescState.source = ""should not be used"";
        closureDescState.runtime = RUNTIME_POWERSHELL_6;
        closureDescState.outputNames = new ArrayList<>(Collections.singletonList(""result""));
        ResourceConstraints constraints = new ResourceConstraints();
        constraints.timeoutSeconds = 60;
        constraints.ramMB = 300;
        closureDescState.resources = constraints;

        String taskDefPayload = Utils.toJson(closureDescState);
        ClosureDescription closureDescription = createClosureDescription(taskDefPayload,
                serviceClient);
        assertNotNull(closureDescription);

        // Create Closure
        Closure createdClosure = createClosure(closureDescription, serviceClient);
        assertEquals(closureDescription.documentSelfLink, createdClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.CREATED, createdClosure.state);

        // Execute the created Closure
        Closure closureRequest = new Closure();
        Map inputs = new HashMap<>();
        inputs.put(""a"", new JsonPrimitive(expectedInVar));
        closureRequest.inputs = inputs;

        executeClosure(createdClosure, closureRequest, serviceClient);

        // Wait for the completion timeout
        String imageRequestLink = waitForBuildCompletion(IMAGE_NAME, closureDescription);

        waitForTaskState(createdClosure.documentSelfLink, TaskState.TaskStage.FINISHED,
                serviceClient);

        Closure fetchedClosure = getClosure(createdClosure.documentSelfLink, serviceClient);

        assertEquals(closureDescription.documentSelfLink, fetchedClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.FINISHED, fetchedClosure.state);

        assertEquals(expectedInVar, fetchedClosure.inputs.get(""a"").getAsString());
        assertEquals(expectedResult, fetchedClosure.outputs.get(""result"").getAsString());

        //        cleanResource(imageRequestLink, serviceClient);
        //        cleanResource(createdClosure.documentSelfLink, serviceClient);
        //        cleanResource(closureDescription.documentSelfLink, serviceClient);
    }",Mystery Guest + Resource Optimism
"@Test
    public void executePowerShellHelloWorldTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        closureDescState.source = ""function test($context)\n""
                + ""{\n""
                + ""    Write-Host \""Hello, world!\""""
                + ""}",No Smells
"@Test
    public void executePythonWithEntrypointAsZIPTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";
        closureDescState.entrypoint = ""main.handler"";

        int expectedInVar = 3;
        double expectedResult = 4;

        closureDescState.sourceURL = testWebserverUri + ""/test_script_powershell_entrypoint.zip"";
        closureDescState.source = ""should not be used"";
        closureDescState.runtime = RUNTIME_POWERSHELL_6;
        closureDescState.outputNames = new ArrayList<>(Collections.singletonList(""result""));
        ResourceConstraints constraints = new ResourceConstraints();
        constraints.timeoutSeconds = 60;
        constraints.ramMB = 300;
        closureDescState.resources = constraints;

        String taskDefPayload = Utils.toJson(closureDescState);
        ClosureDescription closureDescription = createClosureDescription(taskDefPayload,
                serviceClient);
        assertNotNull(closureDescription);

        // Create Closure
        Closure createdClosure = createClosure(closureDescription, serviceClient);
        assertEquals(closureDescription.documentSelfLink, createdClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.CREATED, createdClosure.state);

        // Execute the created Closure
        Closure closureRequest = new Closure();
        Map inputs = new HashMap<>();
        inputs.put(""a"", new JsonPrimitive(expectedInVar));
        closureRequest.inputs = inputs;

        executeClosure(createdClosure, closureRequest, serviceClient);

        // Wait for the completion timeout
        String imageRequestLink = waitForBuildCompletion(IMAGE_NAME, closureDescription);

        waitForTaskState(createdClosure.documentSelfLink, TaskState.TaskStage.FINISHED,
                serviceClient);

        Closure fetchedClosure = getClosure(createdClosure.documentSelfLink, serviceClient);

        assertEquals(closureDescription.documentSelfLink, fetchedClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.FINISHED, fetchedClosure.state);

        assertEquals(expectedInVar, fetchedClosure.inputs.get(""a"").getAsInt());
        assertEquals(expectedResult, fetchedClosure.outputs.get(""result"").getAsInt(), 0);

        cleanResource(imageRequestLink, serviceClient);
        cleanResource(createdClosure.documentSelfLink, serviceClient);
        cleanResource(closureDescription.documentSelfLink, serviceClient);
    }",No Smells
"@Test
    public void completeOrFailOutdatedJSScriptTaskTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";
        closureDescState.source = ""#!/usr/bin/python\n""
                + ""import time\n""
                + ""\n""
                + ""def test(ctx):\n""
                + ""     print('Waiting....')\n""
                + ""     time.sleep(60)\n""
                + ""\n"";
        closureDescState.runtime = RUNTIME_PYTHON_3;
        closureDescState.outputNames = new ArrayList<>(Collections.singletonList(""result""));
        ResourceConstraints constraints = new ResourceConstraints();
        constraints.timeoutSeconds = 1;
        closureDescState.resources = constraints;

        String taskDefPayload = Utils.toJson(closureDescState);
        ClosureDescription closureDescription = createClosureDescription(taskDefPayload,
                serviceClient);
        assertNotNull(closureDescription);

        // Create Closure
        Closure createdClosure = createClosure(closureDescription, serviceClient);
        assertEquals(closureDescription.documentSelfLink, createdClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.CREATED, createdClosure.state);

        // Executing the created Closure
        executeClosure(createdClosure, new Closure(), serviceClient);

        // Wait for the completion timeout
        waitForBuildCompletion(IMAGE_NAME, closureDescription);

        waitForTaskState(createdClosure.documentSelfLink, TaskState.TaskStage.CANCELLED,
                serviceClient);

        Closure fetchedClosure = getClosure(createdClosure.documentSelfLink, serviceClient);

        assertEquals(closureDescription.documentSelfLink, fetchedClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.CANCELLED, fetchedClosure.state);

        // Request bring new execution of the created Closure.
        executeClosure(createdClosure, fetchedClosure, serviceClient);

        // Wait for the completion timeout
        waitForBuildCompletion(IMAGE_NAME, closureDescription);

        waitForTaskState(createdClosure.documentSelfLink, TaskState.TaskStage.CANCELLED,
                serviceClient);

        fetchedClosure = getClosure(createdClosure.documentSelfLink, serviceClient);

        assertEquals(closureDescription.documentSelfLink, fetchedClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.CANCELLED, fetchedClosure.state);

        // Try to complete outdated Closure
        try {
            fetchedClosure.state = TaskState.TaskStage.FINISHED;
            SimpleHttpsClient.HttpResponse response = SimpleHttpsClient
                    .execute(SimpleHttpsClient.HttpMethod.PATCH, fetchedClosure.documentSelfLink,
                            Utils
                                    .toJson(fetchedClosure));
            if (response != null) {
                assertNotEquals(""Closure is not allowed to complete once it is CANCELLED"", 200,
                        response.statusCode);
            }",Eager Test
"@Test
    public void executePythonArrayOfBooleanParametersTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        Boolean[] expectedInVar = { true, true, true }",Eager Test
"@Test
    public void executePythonArrayOfNumberParametersTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        Integer[] expectedInVar = { 1, 2, 3 }",Eager Test
"@Test
    public void executePythonExtSourceAsZIPTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        String expectedInVar = ""a"";
        String expectedOutVar = ""b"";
        String expectedResult = ""ac"";

        closureDescState.sourceURL = testWebserverUri + ""/test_script_python.zip"";
        closureDescState.source = ""should not be used"";
        closureDescState.runtime = RUNTIME_PYTHON_3;
        closureDescState.outputNames = new ArrayList<>(Collections.singletonList(""result""));
        ResourceConstraints constraints = new ResourceConstraints();
        constraints.timeoutSeconds = 2;
        constraints.ramMB = 300;
        closureDescState.resources = constraints;

        String taskDefPayload = Utils.toJson(closureDescState);
        ClosureDescription closureDescription = createClosureDescription(taskDefPayload,
                serviceClient);
        assertNotNull(closureDescription);

        // Create Closure
        Closure createdClosure = createClosure(closureDescription, serviceClient);
        assertEquals(closureDescription.documentSelfLink, createdClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.CREATED, createdClosure.state);

        // Execute the created Closure
        Closure closureRequest = new Closure();
        Map inputs = new HashMap<>();
        inputs.put(""a"", new JsonPrimitive(expectedInVar));
        closureRequest.inputs = inputs;

        executeClosure(createdClosure, closureRequest, serviceClient);

        // Wait for the completion timeout
        String imageRequestLink = waitForBuildCompletion(IMAGE_NAME, closureDescription);

        waitForTaskState(createdClosure.documentSelfLink, TaskState.TaskStage.FINISHED,
                serviceClient);

        Closure fetchedClosure = getClosure(createdClosure.documentSelfLink, serviceClient);

        assertEquals(closureDescription.documentSelfLink, fetchedClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.FINISHED, fetchedClosure.state);

        verifyRunDuration(fetchedClosure);

        assertEquals(expectedInVar, fetchedClosure.inputs.get(""a"").getAsString());
        assertEquals(expectedResult, fetchedClosure.outputs.get(""result"").getAsString());

        cleanResource(imageRequestLink, serviceClient);
        cleanResource(createdClosure.documentSelfLink, serviceClient);
        cleanResource(closureDescription.documentSelfLink, serviceClient);
    }",Eager Test
"@Test
    public void executePythonNonExistingZIPTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        String expectedInVar = ""a"";
        String expectedOutVar = ""b"";
        String expectedResult = ""ac"";

        closureDescState.sourceURL = testWebserverUri + ""/non_existing.zip"";
        closureDescState.source = ""should not be used"";
        closureDescState.runtime = RUNTIME_PYTHON_3;
        closureDescState.outputNames = new ArrayList<>(Collections.singletonList(""result""));
        ResourceConstraints constraints = new ResourceConstraints();
        constraints.timeoutSeconds = 2;
        constraints.ramMB = 300;
        closureDescState.resources = constraints;

        String taskDefPayload = Utils.toJson(closureDescState);
        ClosureDescription closureDescription = createClosureDescription(taskDefPayload,
                serviceClient);
        assertNotNull(closureDescription);

        // Create Closure
        Closure createdClosure = createClosure(closureDescription, serviceClient);
        assertEquals(closureDescription.documentSelfLink, createdClosure.descriptionLink);
        assertEquals(TaskState.TaskStage.CREATED, createdClosure.state);

        // Execute the created Closure
        Closure closureRequest = new Closure();
        Map inputs = new HashMap<>();
        inputs.put(""a"", new JsonPrimitive(expectedInVar));
        closureRequest.inputs = inputs;

        executeClosure(createdClosure, closureRequest, serviceClient);

        // Wait for the completion timeout
        try {
            String imageRequestLink = waitForBuildCompletion(IMAGE_NAME, closureDescription);
            fail(""Build of the image is expected to fail!"");
        }",Eager Test
"@Test
    public void executePythonNumberParametersTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        int expectedInVar = 3;
        double expectedResult = 4;

        closureDescState.source = ""def test(context):\n""
                + ""    inputs = context.inputs\n""
                + ""    print('Hello numbers {}",No Smells
"@Test
    public void executePythonScriptFailureParametersTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        int expectedInVar = 3;
        int expectedOutVar = 3;
        double expectedResult = 4;

        closureDescState.source = ""def test(context):\n""
                + ""    raise Exception('test exception')\n""
                + ""\n"";
        closureDescState.runtime = RUNTIME_PYTHON_3;
        closureDescState.outputNames = new ArrayList<>(Collections.singletonList(""result""));
        ResourceConstraints constraints = new ResourceConstraints();
        constraints.timeoutSeconds = 3;
        closureDescState.resources = constraints;

        String taskDefPayload = Utils.toJson(closureDescState);
        ClosureDescription closureDescription = createClosureDescription(taskDefPayload,
                serviceClient);

        // Create Closure
        Closure createdClosure = createClosure(closureDescription, serviceClient);

        // Execute the created Closure
        Closure closureRequest = new Closure();
        Map inputs = new HashMap<>();
        inputs.put(""a"", new JsonPrimitive(expectedInVar));
        closureRequest.inputs = inputs;

        executeClosure(createdClosure, closureRequest, serviceClient);

        // Wait for the completion timeout
        waitForBuildCompletion(IMAGE_NAME, closureDescription);

        waitForTaskState(createdClosure.documentSelfLink, TaskState.TaskStage.FAILED,
                serviceClient);

        Closure closure = getClosure(createdClosure.documentSelfLink, serviceClient);
        assertNotNull(closure);

        assertEquals(createdClosure.descriptionLink, closure.descriptionLink);
        assertEquals(TaskState.TaskStage.FAILED, closure.state);

        verifyRunDuration(closure);

        cleanResource(createdClosure.documentSelfLink, serviceClient);
        cleanResource(closureDescription.documentSelfLink, serviceClient);
    }",No Smells
"@Test
    public void executePythonWithBilliardDependencyTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";

        int expectedInVar = 3;
        int expectedOutVar = 3;
        double expectedResult = 4;

        closureDescState.source = ""import billiard\n""
                + ""\n""
                + ""\n""
                + ""def f():\n""
                + ""    print('ok!')\n""
                + ""\n""
                + ""def test(context):\n""
                + ""    inputs = context.inputs\n""
                + ""    print('Hello number  {}",Eager Test
"@Test
    public void executePythonWithInvalidEntrypointParametersTest() throws Throwable {
        // Create Closure Definition
        ClosureDescription closureDescState = new ClosureDescription();
        closureDescState.name = ""test"";
        closureDescState.entrypoint = ""invalid.invalid"";

        int expectedInVar = 3;
        int expectedOutVar = 3;
        double expectedResult = 4;

        closureDescState.source = ""def handler(context):\n""
                + ""    inputs = context.inputs\n""
                + ""    print('Hello numbers {}",No Smells
"@Test
    public void executeJSArrayOfObjectParametersTest() throws Throwable {
        // Create Closure Definition
        URI factoryUri = UriUtils
                .buildFactoryUri(this.host, ClosureDescriptionFactoryService.class);
        this.host.testStart(1);
        ClosureDescription closureDefState = new ClosureDescription();
        closureDefState.name = ""test"";

        TestObject expectedInVar = new TestObject();
        expectedInVar.strTest = ""test"";
        expectedInVar.intTest = 1;
        expectedInVar.boolTest = true;
        int expectedOutVar = 3;
        String expectedResult = expectedInVar.strTest + ""_changed"";

        closureDefState.source = ""function test(x) { print('Hello object: ' + x[0].strTest);""
                + "" x[0].strTest = x[0].strTest + '_changed';""
                + "" x[0].intTest = x[0].intTest + 1; x[0].boolTest = !x[0].boolTest; return x;""
                + ""}",Eager Test
"@Test
    public void executeJSArrayOfStringParametersTest() throws Throwable {
        // Create Closure Definition
        URI factoryUri = UriUtils
                .buildFactoryUri(this.host, ClosureDescriptionFactoryService.class);
        this.host.testStart(1);
        ClosureDescription closureDefState = new ClosureDescription();
        closureDefState.name = ""test"";

        String[] expectedInVar = { ""a"", ""b"", ""c"" }",Eager Test
"@Test
    public void executeJSStringParametersTest() throws Throwable {
        // Create Closure Definition
        URI factoryUri = UriUtils
                .buildFactoryUri(this.host, ClosureDescriptionFactoryService.class);
        this.host.testStart(1);
        ClosureDescription closureDefState = new ClosureDescription();
        closureDefState.name = ""test"";

        String expectedInVar = ""a"";
        String expectedOutVar = ""b"";
        String expectedResult = ""ac"";

        closureDefState.source =
                ""function test(x) {print('Hello string: ' + x); return x.concat(\""c\"");}",Eager Test
"@Test
    public void executeTimeoutedJSScriptTaskTest() throws Throwable {
        // Create Closure Definition
        URI factoryUri = UriUtils
                .buildFactoryUri(this.host, ClosureDescriptionFactoryService.class);
        this.host.testStart(1);
        ClosureDescription closureDefState = new ClosureDescription();
        closureDefState.name = ""test"";
        closureDefState.source = ""function sleep(delay) {var start = new Date().getTime();while (new Date().getTime() < start + delay) {}",Eager Test
"@Test
    public void buildConfiguredCallbackInvalidUriTest() {
        assertNull(dockerDriver.buildConfiguredCallbackUri(""http://callbackUri"", ""/ invalid ;;;""));
    }",No Smells
"@Test
    public void inspectImageClosureTest() {
        final Object[] errors = { null }",No Smells
"@Test
    public void addTaskWithTooLowResourcesConstraintsTest() throws Throwable {
        URI factoryUri = UriUtils.buildFactoryUri(this.host, ClosureDescriptionFactoryService.class);
        this.host.testStart(1);
        ClosureDescription initialState = new ClosureDescription();
        initialState.name = ""test"";
        initialState.source = ""var a = 1; print(\""Hello \"" + a);"";
        initialState.runtime = ""nashorn"";
        ResourceConstraints resources = new ResourceConstraints();
        resources.ramMB = -1;
        resources.timeoutSeconds = -1;
        initialState.resources = resources;
        initialState.documentSelfLink = UUID.randomUUID().toString();
        ClosureDescription[] responses = new ClosureDescription[1];
        URI childURI = UriUtils.buildPublicUri(this.host, ClosureDescriptionFactoryService.FACTORY_LINK, initialState
                .documentSelfLink);
        Operation post = Operation
                .createPost(factoryUri)
                .setBody(initialState)
                .setCompletion(getSafeHandler((o, e) -> {
                    assertNull(e);
                    responses[0] = o.getBody(ClosureDescription.class);

                    assertEquals(initialState.source, responses[0].source);
                    assertEquals(initialState.runtime, responses[0].runtime);
                    assertNotNull(responses[0].resources);
                    assertEquals(ClosureProps.MIN_CPU_SHARES, responses[0].resources.cpuShares);
                    assertEquals(ClosureProps.MIN_MEMORY_MB_RES_CONSTRAINT, responses[0].resources.ramMB);
                    assertEquals(ClosureProps.MIN_EXEC_TIMEOUT_SECONDS, responses[0].resources.timeoutSeconds);
                }",No Smells
"@Test
    public void editClosureDescriptionTest() throws Throwable {
        URI factoryUri = UriUtils.buildFactoryUri(this.host, ClosureDescriptionFactoryService.class);
        this.host.testStart(1);
        ClosureDescription initialState = new ClosureDescription();
        initialState.name = ""test"";
        initialState.runtime = DriverConstants.RUNTIME_NODEJS_4;
        initialState.source = ""var a = 1; print(\""Hello \"" + a);"";
        Map inputs = new HashMap<>();
        inputs.put(""a"", new JsonPrimitive(10));
        initialState.inputs = inputs;
        initialState.entrypoint = ""modulename.handlername"";
        initialState.documentSelfLink = UUID.randomUUID().toString();
        ClosureDescription[] responses = new ClosureDescription[1];
        URI childURI = UriUtils.buildUri(this.host, ClosureDescriptionFactoryService.FACTORY_LINK + ""/"" + initialState
                .documentSelfLink);
        Operation post = Operation
                .createPost(factoryUri)
                .setBody(initialState)
                .setCompletion(getSafeHandler((o, e) -> {
                    assertNull(e);
                    responses[0] = o.getBody(ClosureDescription.class);

                    assertEquals(initialState.source, responses[0].source);
                    assertEquals(initialState.runtime, responses[0].runtime);
                    assertEquals(initialState.entrypoint, responses[0].entrypoint);
                    assertNotNull(initialState.inputs);
                    assertEquals(10, initialState.inputs.get(""a"").getAsInt());
                    assertNotNull(responses[0].resources);
                    assertEquals(ClosureProps.DEFAULT_CPU_SHARES, responses[0].resources.cpuShares);
                    assertEquals(ClosureProps.DEFAULT_MEMORY_MB_RES_CONSTRAINT, responses[0].resources.ramMB);
                    assertEquals(ClosureProps.DEFAULT_EXEC_TIMEOUT_SECONDS, responses[0].resources
                            .timeoutSeconds);
                }",Eager Test
"@Test
    public void invalidLanguageNegativeTest() throws Throwable {
        URI factoryUri = UriUtils.buildFactoryUri(this.host, ClosureDescriptionFactoryService.class);
        this.host.testStart(1);
        ClosureDescription initialState = new ClosureDescription();
        initialState.name = ""test"";
        initialState.documentSelfLink = UUID.randomUUID().toString();
        Operation post = Operation
                .createPost(factoryUri)
                .setBody(initialState)
                .setCompletion(getSafeHandler((o, e) -> assertOperationFailed(e)));
        this.host.send(post);
        this.host.testWait();
    }",No Smells
"@Test
    public void invalidNodeJsDependenciesFormatNegativeTest() throws Throwable {
        URI factoryUri = UriUtils.buildFactoryUri(this.host, ClosureDescriptionFactoryService.class);
        this.host.testStart(1);
        ClosureDescription initialState = new ClosureDescription();
        initialState.name = ""test"";
        initialState.documentSelfLink = UUID.randomUUID().toString();
        initialState.runtime = DriverConstants.RUNTIME_NODEJS_4;
        initialState.source = ""var a = 1; print(\""Hello \"" + a);"";
        initialState.dependencies = ""invalid json"";
        Operation post = Operation
                .createPost(factoryUri)
                .setBody(initialState)
                .setCompletion(getSafeHandler((o, e) -> assertOperationFailed(e)));
        this.host.send(post);
        this.host.testWait();
    }",No Smells
"@Test
    public void invalidRuntimeNegativeTest() throws Throwable {
        URI factoryUri = UriUtils.buildFactoryUri(this.host, ClosureDescriptionFactoryService.class);
        this.host.testStart(1);
        ClosureDescription initialState = new ClosureDescription();
        initialState.name = ""test"";
        initialState.source = ""var a = 1; print(\""Hello \"" + a);"";
        initialState.documentSelfLink = UUID.randomUUID().toString();
        Operation post = Operation
                .createPost(factoryUri)
                .setBody(initialState)
                .setCompletion(getSafeHandler((o, e) -> assertOperationFailed(e)));
        this.host.send(post);
        this.host.testWait();
    }",No Smells
"@Test
    public void testAddProjectLinkClauseWhenOnlyProjectIsSet() {
        List<String> tenantLinks = Arrays.asList(PROJECT_ID);
        Query query = QueryUtil.addTenantGroupAndUserClause(tenantLinks);

        assertNotNull(query);

        assertEquals(query.occurance, Occurance.MUST_OCCUR);
        assertEquals(query.term.matchValue, PROJECT_ID);
    }",No Smells
"@Test
    public void testAddTenantAndGroupClauseWhenOnlyTenantIsSet() {
        List<String> tenantLinks = Arrays.asList(TENANT_ID);
        Query query = QueryUtil.addTenantAndGroupClause(tenantLinks);

        assertNotNull(query);

        assertEquals(query.occurance, Occurance.MUST_OCCUR);
        assertEquals(query.term.matchValue, TENANT_ID);
    }",No Smells
"@Test
    public void testAddTenantAndGroupClauseWhenTenantAndUserAreSet() {
        List<String> tenantLinks = Arrays.asList(TENANT_ID, USER_ID);

        Query query = QueryUtil.addTenantAndGroupClause(tenantLinks);
        assertNull(""assumtion failed for query being single"", query.booleanClauses);
        assertTrue(query.term.matchValue.contains(TENANT_ID));
    }",No Smells
"@Test
    public void testAddTenantAndUserClauseWhenTenantAndUserAreSet() {
        List<String> tenantLinks = Arrays.asList(TENANT_ID, GROUP_ID);

        Query query = QueryUtil.addTenantAndUserClause(tenantLinks);
        assertNull(""assumtion failed for query being single"", query.booleanClauses);
        assertTrue(query.term.matchValue.contains(TENANT_ID));
    }",No Smells
"@Test
    public void testAddTenantGroupAndUserClauseWhenTenantAndSubTenantAreSet() {
        List<String> tenantLinks = Arrays.asList(TENANT_ID, GROUP_ID);

        Query query = QueryUtil.addTenantGroupAndUserClause(tenantLinks);

        Query tenantQuery = query.booleanClauses.stream()
                .filter(l -> l.term.matchValue.contains(TENANT_ID)).findFirst().get();
        Query subTenantQuery = query.booleanClauses.stream()
                .filter(l -> l.term.matchValue.contains(GROUP_ID)).findFirst().get();

        assertNotNull(tenantQuery);
        assertNotNull(subTenantQuery);

        assertEquals(tenantQuery.occurance, Occurance.MUST_OCCUR);
        assertEquals(subTenantQuery.occurance, Occurance.MUST_OCCUR);
    }",No Smells
"@Test
    public void testGetGroupsNull() throws Exception {
        List<String> tenants = QueryUtil.getGroups(null);
        Assert.assertNull(tenants);
    }",No Smells
"@Test
    public void testGetTenantsNull() throws Exception {
        List<String> tenants = QueryUtil.getTenants(null);
        Assert.assertNull(tenants);
    }",No Smells
"@Test
    public void testRemoveGroupsNull() throws Exception {
        List<String> tenants = QueryUtil.removeGroups(null);
        Assert.assertNull(tenants);
    }",No Smells
"@Test
    public void testToStringArrayAlreadyString() {
        Object alreadyStringArray = new String[] { ""One"", ""Two"" }",No Smells
"@Test
    public void testCertificateChain() {
        String certPem = testProperties.getProperty(CERT_CHAIN_PROP_NAME);
        assertFalse(CertificateUtilExtended.isSelfSignedCertificate(certPem));
    }",No Smells
"@Test
    public void testSelfSignedCertificate() {
        String certPem = testProperties.getProperty(SELF_SIGNED_CERT_PROP_NAME);
        assertTrue(CertificateUtilExtended.isSelfSignedCertificate(certPem));
    }",No Smells
"@Test
    public void testBinaryMemoryToBytes() throws Exception {
        assertEquals(2.0, ConversionUtil.memoryToBytes(2, ""B""), 0.01);
        assertEquals(2048.0, ConversionUtil.memoryToBytes(2, ""KiB""), 0.01);
        assertEquals(2097152.0, ConversionUtil.memoryToBytes(2, ""MiB""), 0.01);
        assertEquals(2147483648.0, ConversionUtil.memoryToBytes(2, ""GiB""), 0.01);
        assertEquals(2199023255552.0, ConversionUtil.memoryToBytes(2, ""TiB""), 0.01);
        assertEquals(2251799813685248.0, ConversionUtil.memoryToBytes(2, ""PiB""), 0.01);
    }",No Smells
"@Test
    public void testCpuToHertz() throws Exception {
        assertEquals(2, ConversionUtil.cpuToHertz(2, ""Hz""));
        assertEquals(2000, ConversionUtil.cpuToHertz(2, ""KHz""));
        assertEquals(2000000, ConversionUtil.cpuToHertz(2, ""MHz""));
        assertEquals(2000000000L, ConversionUtil.cpuToHertz(2, ""GHz""));
        assertEquals(2000000000000L, ConversionUtil.cpuToHertz(2, ""THz""));
        assertEquals(2000000000000000L, ConversionUtil.cpuToHertz(2, ""PHz""));
        assertEquals(0, ConversionUtil.cpuToHertz(0, ""NHz""));
    }",No Smells
"@Test
    public void testDecimalMemoryToBytes() throws Exception {
        assertEquals(2.0, ConversionUtil.memoryToBytes(2, ""B""), 0.01);
        assertEquals(2000.0, ConversionUtil.memoryToBytes(2, ""KB""), 0.01);
        assertEquals(2000000.0, ConversionUtil.memoryToBytes(2, ""MB""), 0.01);
        assertEquals(2000000000.0, ConversionUtil.memoryToBytes(2, ""GB""), 0.01);
        assertEquals(2000000000000.0, ConversionUtil.memoryToBytes(2, ""TB""), 0.01);
        assertEquals(2000000000000000.0, ConversionUtil.memoryToBytes(2, ""PB""), 0.01);
    }",No Smells
"@Test
    public void testLogException() {
        Exception e = new Exception(""err"");

        AtomicBoolean b = new AtomicBoolean();
        DeferredUtils.logException(e, Level.INFO, t -> {
            b.set(true);
            return ""-"";
        }",No Smells
"@Test
    public void testWrap() {
        Exception e = new Exception(""err"");

        CompletionException completionException = DeferredUtils.wrap(e);

        assertNotNull(completionException);
        assertNotSame(e, completionException);

        CompletionException completionException2 = DeferredUtils.wrap(completionException);
        assertNotNull(completionException2);
        assertSame(completionException, completionException2);
    }",No Smells
"@Test
    public void testRoundtrip() throws IOException {

        Map<String, String> source = new HashMap<>();
        source.put(k1, v1);
        source.put(k2, v2);

        String json = JsonMapper.toJSON(source);

        Assert.assertNotNull(json);
        Assert.assertEquals(JSON_SOURCE, json);

        Map cloned = JsonMapper.fromJSON(json, Map.class);
        Assert.assertNotNull(cloned);

        Assert.assertEquals(source, cloned);
    }",No Smells
"@Test
    public void testExtractTenantFromBGHeaderInvalid() throws Throwable {
        String businessGroup = ""test"";
        Operation op = new Operation();
        op.addRequestHeader(OperationUtil.PROJECT_ADMIRAL_HEADER, businessGroup);
        String tenantLink = OperationUtil.extractTenantFromProjectHeader(op);
        Assert.assertTrue(tenantLink == null);
    }",No Smells
"@Test
    public void getPropertyDoubleTest() {
        Map<String, String> props = new HashMap<>();
        String testKey = ""testKey"";
        String testValue = ""5.55"";
        props.put(testKey, testValue);

        Optional<Double> val = PropertyUtils.getPropertyDouble(props, testKey);
        assertEquals(Double.valueOf(testValue), val.get());

        props.put(testKey, ""non-number"");
        val = PropertyUtils.getPropertyDouble(props, testKey);
        assertEquals(Optional.empty(), val);
    }",No Smells
"@Test
    public void testFindRegistriesByHostnameWithDifferentSchemas() throws Throwable {
        List<RegistryState> expectedRegistries = new ArrayList<>();
        expectedRegistries.add(createRegistry(""http://test.registry.com:5000"", null));
        expectedRegistries.add(createRegistry(""https://test.registry.com:5000"", null));
        expectedRegistries.add(createRegistry(""test.registry.com:5000"", null));

        // unexpected registries
        createRegistry(""ftp://test.registry.com:5000"", null);
        createRegistry(""file://test.registry.com:5000"", null);
        createRegistry(""http://test.registry.com:5001"", null);
        createRegistry(""https://test.registry.com:5002"", null);

        verifyRegistryLinksByHostname(""test.registry.com:5000"", (String) null, expectedRegistries);
    }",No Smells
"@Test
    public void testFindRegistriesByRegistryFilterIncludeGlobals() throws Throwable {
        List<String> tenantLinks = Collections.singletonList(TENANT);
        List<String> otherTenantLinks = Collections.singletonList(DIFFERENT_TENANT);

        RegistryState globalRegistry = createRegistry(""https://test.registry.com:5001"", ""globalR"",
                null);
        RegistryState tenantRegistry = createRegistry(""http://test.registry.com:5002"", ""tenantR"",
                tenantLinks);
        RegistryState otherRegistry = createRegistry(""http://test.registry.com:5002"", ""dummyR"",
                otherTenantLinks);

        List<RegistryState> expectedRegistries = new ArrayList<>();
        expectedRegistries.add(globalRegistry);

        verifyRegistryLinksByRegistryFilter(""globalR"", tenantLinks, expectedRegistries);

        verifyRegistryLinksByRegistryFilter(""globalR"", null, expectedRegistries);

        expectedRegistries.clear();
        expectedRegistries.add(tenantRegistry);
        verifyRegistryLinksByRegistryFilter(""tenantR"", tenantLinks, expectedRegistries);

        verifyRegistryLinksByRegistryFilter(""tenantR"", null, Collections.emptyList());
    }",No Smells
"@Test
    public void testUntrustedCertificates() throws Exception {

        // Validate a custom certificate.
        // Is should fail as it is signed by untrusted CA
        try {
            trustManager.checkServerTrusted(
                    getCertificates(""/certs/untrusted-server.crt""), ""RSA"");
            fail(""Should not trust untrusted certificate"");
        }",Mystery Guest + Resource Optimism
"@Test
    public void sendSelfDelete() throws Exception {
        ServiceUtils.sendSelfDelete(new StatelessService() {
            private final String uri = ""uri"";
            @Override
            public URI getUri() {
                return URI.create(uri);
            }",No Smells
"@Test
    public void testIsNotProjectLink() {
        String functionName = ""TenantLinksUtil.isNotProjectLink"";

        assertBooleanOutput(false, functionName, TenantLinksUtil::isNotProjectLink,
                SAMPLE_PROJECT_LINK,
                SAMPLE_PROJECT_LINK_TRAILING_SLASH);

        assertBooleanOutput(true, functionName, TenantLinksUtil::isNotProjectLink,
                SAMPLE_TENANT_LINK,
                SAMPLE_TENANT_LINK_TRAILING_SLASH,
                SAMPLE_GROUP_LINK,
                SAMPLE_GROUP_LINK_TRAILING_SLASH,
                SAMPLE_USER_LINK,
                SAMPLE_USER_LINK_TRAILING_SLASH,
                SAMPLE_RANDOM_LINK,
                SAMPLE_RANDOM_LINK_TRAILING_SLASH,
                null);
    }",No Smells
"@Test
    public void testIsNotUserLink() {
        String functionName = ""TenantLinksUtil.isNotUserLink"";

        assertBooleanOutput(false, functionName, TenantLinksUtil::isNotUserLink,
                SAMPLE_USER_LINK,
                SAMPLE_USER_LINK_TRAILING_SLASH);

        assertBooleanOutput(true, functionName, TenantLinksUtil::isNotUserLink,
                SAMPLE_TENANT_LINK,
                SAMPLE_TENANT_LINK_TRAILING_SLASH,
                SAMPLE_GROUP_LINK,
                SAMPLE_GROUP_LINK_TRAILING_SLASH,
                SAMPLE_PROJECT_LINK,
                SAMPLE_PROJECT_LINK_TRAILING_SLASH,
                SAMPLE_RANDOM_LINK,
                SAMPLE_RANDOM_LINK_TRAILING_SLASH,
                null);
    }",No Smells
"@Test
    public void testClaimProperty() throws Throwable {
        String testEntry = ""test-entry"";
        String propertiesId = Service.getId(testState.documentSelfLink);

        TestContext ctx = testCreate(1);
        UniquePropertiesUtil.claimProperty(testService, propertiesId, testEntry)
                .whenComplete((isUsed, ex) -> {
                    if (ex != null) {
                        ctx.fail(ex);
                        return;
                    }",No Smells
"@Test
    public void testValidatePort() {
        try {
            ValidationUtils.validatePort(""-1"");
            fail(""expected to fail"");
        }",No Smells
"@Test
    public void testConvertFromYamlToJson() throws IOException {
        String yamlInput = ""---\n""
                + ""person:\n""
                + ""  name: test-name\n""
                + ""  age: 14\n"";

        String expectedJsonOutput = ""{\""person\"":{\""name\"":\""test-name\"",\""age\"":14}",No Smells
"@Test
    public void testSplitYamlWithSingleYaml() {
        String yamlInput = sampleYamlDefinition;

        List<String> expectedOutput = new ArrayList<>();
        expectedOutput.add(sampleYamlDefinition);

        List<String> actualOutput = YamlMapper.splitYaml(yamlInput);

        assertEquals(1, actualOutput.size());

        assertEquals(expectedOutput.get(0), actualOutput.get(0));
    }",No Smells
"@Test
    public void testEvaluateSimpleBindingFromObjectWithLinks() {

        List<Binding> bindings = Arrays
                .asList(binding(Arrays.asList(""parentLink""),
                        ""_resource~A~networkInterfaceLinks~0~address""));

        Map<String, NestedState> computes = new HashMap<>();
        TemplateComputeState computeStateA = new TemplateComputeState();
        computeStateA.parentLink = ""some-host"";

        computeStateA.networkInterfaceLinks = Arrays.asList(""nis-link"");
        NetworkInterfaceState nis = new NetworkInterfaceState();
        nis.documentSelfLink = ""nis-link"";
        nis.address = ""some-address"";

        NestedState nestedStateA = new NestedState(computeStateA);
        nestedStateA.children.put(""nis-link"", new NestedState(nis));

        computes.put(""A"", nestedStateA);

        TemplateComputeState computeState = new TemplateComputeState();

        NestedState nestedState = new NestedState(computeState);

        NestedState evalObj = BindingEvaluator
                .evaluateProvisioningTimeBindings(nestedState, bindings, computes);
        assertNotNull(evalObj);
        assertEquals(nis.address, ((TemplateComputeState) evalObj.object).parentLink);

    }",No Smells
"@Test
    public void testEvaluateSingleBindingCustomProperty() {
        ContainerDescription firstDescription = new ContainerDescription();
        firstDescription.name = ""A"";
        firstDescription.customProperties = new HashMap<>();
        firstDescription.customProperties.put(""key"", ""20"");

        ContainerDescription secondDescription = new ContainerDescription();
        secondDescription.name = ""B"";

        List<Binding> bindings = Arrays.asList(binding(Arrays.asList(""_cluster""), ""A~key""));
        Binding.ComponentBinding componentBinding = new Binding.ComponentBinding(""B"", bindings);

        CompositeTemplate compositeTemplate = createCompositeTemplate(Arrays
                .asList(firstDescription, secondDescription), Arrays.asList(componentBinding));

        BindingEvaluator.evaluateBindings(compositeTemplate);

        firstDescription = (ContainerDescription) compositeTemplate.components.get(""A"").data;
        secondDescription = (ContainerDescription) compositeTemplate.components.get(""B"").data;

        assertEquals(new Integer(20), secondDescription._cluster);
    }",No Smells
"@Test
    public void testEvaluateSingleBindingDifferentNumberTypes() {
        ContainerDescription firstDescription = new ContainerDescription();
        firstDescription.name = ""A"";
        firstDescription._cluster = 5;

        ContainerDescription secondDescription = new ContainerDescription();
        secondDescription.name = ""B"";

        List<Binding> bindings = Arrays
                .asList(binding(Arrays.asList(""memory_limit""), ""A~_cluster""));
        Binding.ComponentBinding componentBinding = new Binding.ComponentBinding(""B"", bindings);

        CompositeTemplate compositeTemplate = createCompositeTemplate(Arrays
                .asList(firstDescription, secondDescription), Arrays.asList(componentBinding));

        BindingEvaluator.evaluateBindings(compositeTemplate);

        firstDescription = (ContainerDescription) compositeTemplate.components.get(""A"").data;
        secondDescription = (ContainerDescription) compositeTemplate.components.get(""B"").data;

        assertNotNull(secondDescription.memoryLimit);
        assertEquals(firstDescription._cluster.toString(),
                secondDescription.memoryLimit.toString());
    }",No Smells
"@Test
    public void testEvaluateSingleBindingNestedSource() {
        ContainerDescription firstDescription = new ContainerDescription();
        firstDescription.name = ""A"";
        firstDescription.logConfig = new LogConfig();
        firstDescription.logConfig.type = ""type"";

        ContainerDescription secondDescription = new ContainerDescription();
        secondDescription.name = ""B"";

        List<Binding> bindings = Arrays
                .asList(binding(Arrays.asList(""hostname""), ""A~logConfig~type""));
        Binding.ComponentBinding componentBinding = new Binding.ComponentBinding(""B"", bindings);

        CompositeTemplate compositeTemplate = createCompositeTemplate(Arrays
                .asList(firstDescription, secondDescription), Arrays.asList(componentBinding));

        BindingEvaluator.evaluateBindings(compositeTemplate);

        firstDescription = (ContainerDescription) compositeTemplate.components.get(""A"").data;
        secondDescription = (ContainerDescription) compositeTemplate.components.get(""B"").data;

        assertEquals(firstDescription.logConfig.type, secondDescription.hostname);
    }",No Smells
"@Test
    public void testCreateVchClusterCustomNameAndDetails() throws Throwable {
        final String projectLink = buildProjectLink(""test-vch-project"");

        final String clusterName = ""ClusterTestName"";
        final String clusterDetails = ""Test cluster details."";

        ContainerHostSpec hostSpec = createContainerHostSpec(Collections.singletonList(projectLink),
                ContainerHostType.VCH, clusterName, clusterDetails);
        ClusterDto clusterDto = createCluster(hostSpec);
        verifyCluster(clusterDto, ClusterType.VCH, clusterName, projectLink);

        clusterDto = getOneCluster(Service.getId(clusterDto.documentSelfLink));
        verifyCluster(clusterDto, ClusterType.VCH, clusterName, projectLink);
        assertEquals(clusterDetails, clusterDto.details);
        assertNotNull(clusterDto.clusterCreationTimeMicros);
    }",No Smells
"@Test
    public void testDeleteVchCluster() throws Throwable {
        final String projectLink = buildProjectLink(""test-vch-project"");
        final String placementZoneName = PlacementZoneUtil
                .buildPlacementZoneDefaultName(ContainerHostType.VCH, COMPUTE_ADDRESS);

        ContainerHostSpec hostSpec = createContainerHostSpec(Collections.singletonList(projectLink),
                ContainerHostType.VCH);
        ClusterDto clusterDto = createCluster(hostSpec);
        verifyCluster(clusterDto, ClusterType.VCH, placementZoneName, projectLink);

        Map<String, ClusterDto> allClustersExpand = getClustersExpand();
        assertTrue(allClustersExpand.keySet().size() == 2);
        assertTrue(allClustersExpand.keySet().contains(clusterDto.documentSelfLink));
        Map<String, ComputeState> allComputesExpand = getAllComputeExpand();
        assertTrue(allComputesExpand.keySet().size() == 1);

        List<String> placementZonesLinks = getPlacementZonesLinks();
        assertEquals(2, placementZonesLinks.size());
        List<String> placementsLinks = getPlacementsLinks();
        assertEquals(2, placementsLinks.size());

        deleteCluster(Service.getId(clusterDto.documentSelfLink));

        allClustersExpand = getClustersExpand();
        assertTrue(allClustersExpand.keySet().size() == 1);
        assertTrue(!allClustersExpand.keySet().contains(clusterDto.documentSelfLink));
        allComputesExpand = getAllComputeExpand();
        assertTrue(allComputesExpand.keySet().isEmpty());

        placementZonesLinks = getPlacementZonesLinks();
        assertEquals(1, placementZonesLinks.size());
        placementsLinks = getPlacementsLinks();
        assertEquals(1, placementsLinks.size());
    }",No Smells
"@Test
    public void testFilterClustersByType() throws Throwable {
        final String projectLink = buildProjectLink(""test-vch-project"");

        ContainerHostSpec hostSpec = createContainerHostSpec(Collections.singletonList(projectLink),
                ContainerHostType.VCH, ""vch-host"");
        createCluster(hostSpec);

        hostSpec = createContainerHostSpec(Collections.singletonList(projectLink),
                ContainerHostType.DOCKER, ""docker-host"");
        createCluster(hostSpec);

        String query = UriUtils.buildUriQuery(""type"", ClusterType.VCH.toString(),
                UriUtils.URI_PARAM_ODATA_EXPAND, Boolean.TRUE.toString());
        URI clusterUri = UriUtils.buildUri(host, ClusterService.SELF_LINK, query);

        Set<Object> result = new HashSet<>();
        Operation get = Operation.createGet(clusterUri)
                .setReferer(host.getUri())
                .setCompletion((o, ex) -> {
                    if (ex != null) {
                        host.failIteration(ex);
                    }",No Smells
"@Test
    public void testGetSingleHostsInCluster() throws Throwable {
        final String projectLinkDocker = buildProjectLink(""test-docker-project"");
        PlacementZoneUtil
                .buildPlacementZoneDefaultName(ContainerHostType.DOCKER, COMPUTE_ADDRESS);

        ContainerHostSpec hostSpecDocker = createContainerHostSpec(
                Collections.singletonList(projectLinkDocker),
                ContainerHostType.DOCKER);

        final String projectLinkVCH = buildProjectLink(""test-vch-project"");
        PlacementZoneUtil
                .buildPlacementZoneDefaultName(ContainerHostType.VCH, COMPUTE_ADDRESS);

        ContainerHostSpec hostSpecVCH = createContainerHostSpec(
                Collections.singletonList(projectLinkVCH),
                ContainerHostType.VCH);
        ClusterDto clusterDocker = createCluster(hostSpecDocker);
        ClusterDto clusterVCH = createCluster(hostSpecVCH);

        ComputeState cs = getSingleHostInOneCluster(
                Service.getId(clusterDocker.documentSelfLink),
                Service.getId(clusterDocker.nodeLinks.get(0)), false);

        assertNotNull(cs);
        assertEquals(clusterDocker.nodeLinks.get(0), cs.documentSelfLink);

        cs = getSingleHostInOneCluster(
                Service.getId(clusterVCH.documentSelfLink),
                Service.getId(clusterDocker.nodeLinks.get(0)), true);
        assertTrue(cs == null);
    }",No Smells
"@Test
    public void testPatchCluster() throws Throwable {
        final String name1 = ""name_1"";
        final String details1 = ""details_1"";
        final String name2 = ""name_2"";
        final String details2 = ""details_2"";

        final String projectLinkDocker = buildProjectLink(""test-docker-project"");
        PlacementZoneUtil.buildPlacementZoneDefaultName(ContainerHostType.DOCKER, COMPUTE_ADDRESS);

        ContainerHostSpec hostSpecDocker = createContainerHostSpec(
                Collections.singletonList(projectLinkDocker),
                ContainerHostType.DOCKER, name1, details1);

        ClusterDto clusterDocker = createCluster(hostSpecDocker);

        clusterDocker = getOneCluster(Service.getId(clusterDocker.documentSelfLink));
        assertNotNull(clusterDocker);
        assertEquals(name1, clusterDocker.name);
        assertEquals(details1, clusterDocker.details);

        ClusterDto patchClusterDto = new ClusterDto();
        patchClusterDto.name = name2;
        patchClusterDto.details = details2;
        patchClusterDto.documentSelfLink = clusterDocker.documentSelfLink;
        patchClusterDto = patchCluster(patchClusterDto);

        assertNotNull(patchClusterDto);
        assertEquals(name2, patchClusterDto.name);
        assertEquals(details2, patchClusterDto.details);

        clusterDocker = getOneCluster(Service.getId(clusterDocker.documentSelfLink));
        assertNotNull(clusterDocker);
        assertEquals(name2, clusterDocker.name);
        assertEquals(details2, clusterDocker.details);

    }",No Smells
"@Test
    public void testShouldUpdateContainerLinksWhenUpdatesToContainers() throws Throwable {
        compositeComponent = createCompositeComponent();
        ContainerState containerState1 = createContainer(compositeComponent.documentSelfLink);

        // add a new container:
        waitFor(() -> {
            compositeComponent = getDocument(CompositeComponent.class,
                    compositeComponent.documentSelfLink);
            if (compositeComponent.componentLinks == null
                    || compositeComponent.componentLinks.isEmpty()) {
                return false;
            }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testCloneCompositeDescriptionWithoutContainersAndReverseParentLinks()
            throws Throwable {
        initObjectsWithoutContainers();

        CompositeDescription clonedCompositeDesc = cloneCompositeDesc(
                createdCompositeWithoutContainers, true);

        checkCompositeForEquality(createdCompositeWithoutContainers, clonedCompositeDesc, true);
    }",No Smells
"@Test
    public void testCloneCompositeDescriptionWithTwoContainers() throws Throwable {
        initObjectsWithTwoContainers();

        CompositeDescription clonedCompositeDesc = cloneCompositeDesc(
                createdCompositeWithTwoContainers, false);

        checkCompositeForEquality(createdCompositeWithTwoContainers, clonedCompositeDesc, false);

        List<String> containerDescriptions = clonedCompositeDesc.descriptionLinks;

        ContainerDescription clonedFirstContainer = getDocument(ContainerDescription.class,
                containerDescriptions.get(0));
        checkContainersForquality(createdFirstContainer, clonedFirstContainer, false);

        ContainerDescription clonedSecondContainer = getDocument(ContainerDescription.class,
                containerDescriptions.get(1));
        checkContainersForquality(createdSecondContainer, clonedSecondContainer, false);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testGetCompositeDescriptionExpanded() throws Throwable {
        CompositeDescriptionExpanded[] result = new CompositeDescriptionExpanded[] { null }",No Smells
"@Test
    public void testPutExpanded() throws Throwable {
        ContainerDescription container = new ContainerDescription();
        container.name = ""container"";
        container.image = ""registry.hub.docker.com/kitematic/hello-world-nginx"";
        container = doPost(container, ContainerDescriptionService.FACTORY_LINK);

        ComponentDescription containerComponent = new ComponentDescription();
        containerComponent.name = ""container"";
        container.name = ""updated"";
        containerComponent.updateServiceDocument(container);
        containerComponent.type = ResourceType.CONTAINER_TYPE.getContentType();

        CompositeDescription cd = new CompositeDescription();
        cd.name = ""testComposite"";
        cd = doPost(cd, CompositeDescriptionFactoryService.SELF_LINK);

        // Make PUT but as expanded state, so that components are also updated
        CompositeDescriptionExpanded cdUpdate = new CompositeDescriptionExpanded();
        cdUpdate.documentSelfLink = cd.documentSelfLink;
        cdUpdate.name = cd.name;
        cdUpdate.componentDescriptions = new ArrayList<>();
        cdUpdate.componentDescriptions.add(containerComponent);
        cdUpdate = doPut(cdUpdate);

        // Explicitly search for document to validate that the list returns the right document kind
        CompositeDescription foundCd = searchForDocument(CompositeDescription.class,
                cd.documentSelfLink);
        assertEquals(Utils.buildKind(CompositeDescription.class), foundCd.documentKind);

        container = getDocument(ContainerDescription.class, container.documentSelfLink);
        assertEquals(""updated"", container.name);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testTenantsLinksInCompositeDescriptionEmbedded() throws Throwable {

        testTenantsLinksInCompositeDescription(true);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testTenantsLinksInCompositeDescriptionNotEmbedded() throws Throwable {

        testTenantsLinksInCompositeDescription(false);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testCannotAddSameVolumeMoreThanOnce() {
        String volumeToAdd = ""volume:/var/storage"";
        ContainerDescription createdContDesc = postContainerDescription(createContainerDescription());

        createdContDesc.volumes = new String[] {volumeToAdd, volumeToAdd}",No Smells
"@Test
    public void testDeleteContainerDescPartOfComposite() throws Throwable {
        ContainerDescription containerDescription = createContainerDescription();
        containerDescription.name = ""containerDescription"";

        containerDescription = doPost(containerDescription,
                ContainerDescriptionService.FACTORY_LINK);

        CompositeDescription composite = new CompositeDescription();
        composite.name = ""composite"";
        composite.descriptionLinks = Collections
                .singletonList(containerDescription.documentSelfLink);
        composite = doPost(composite, CompositeDescriptionFactoryService.SELF_LINK);

        delete(containerDescription.documentSelfLink);

        List<String> resourceLinks = findResourceLinks(ContainerDescription.class,
                Arrays.asList(containerDescription.documentSelfLink));

        Assert.assertEquals(""Container description must be deleted on DELETE"", 0,
                resourceLinks.size());
    }",No Smells
"@Test
    public void testValidateShouldFailWithInvalidMemoryLimit() throws Throwable {
        ContainerDescription contDesc = createContainerDescription();
        contDesc.memoryLimit = -1L;

        Operation op = Operation.createPost(getContainerDescriptionUri())
                .setBody(contDesc)
                .setCompletion((o, e) -> {
                    if (e != null) {
                        if (o.getStatusCode() != Operation.STATUS_CODE_BAD_REQUEST) {
                            host.log(""Unexpected exception: %s"", Utils.toString(e));
                            host.failIteration(new IllegalStateException(
                                    ""Validation exception expected""));
                            return;
                        }",No Smells
"@Test
    public void testValidateShouldFailWithInvalidRestartPolicy() throws Throwable {
        ContainerDescription contDesc = createContainerDescription();
        contDesc.restartPolicy = ""invalid"";

        Operation op = Operation.createPost(getContainerDescriptionUri())
                .setBody(contDesc)
                .setCompletion((o, e) -> {
                    if (e != null) {
                        if (o.getStatusCode() != Operation.STATUS_CODE_BAD_REQUEST) {
                            host.log(""Unexpected exception: %s"", Utils.toString(e));
                            host.failIteration(new IllegalStateException(
                                    ""Validation exception expected""));
                            return;
                        }",No Smells
"@Test
    public void testContainersCountOnHostWithContainersNoSystem() throws Throwable {
        String hostId = UUID.randomUUID().toString();
        String hostLink = UriUtils.buildUriPath(ComputeService.FACTORY_LINK, hostId);
        // add preexisting container
        addContainerToMockAdapter(hostLink, preexistingContainerId, preexistingContainerNames);

        ComputeDescription hostDescription = createComputeDescription();
        hostDescription = doPost(hostDescription, ComputeDescriptionService.FACTORY_LINK);

        ComputeState cs = createComputeState(hostId, hostDescription);

        cs = doPost(cs, ComputeService.FACTORY_LINK);

        ContainerState containerState = new ContainerState();
        containerState.id = UUID.randomUUID().toString();
        containerState.names = containerNames;
        containerState.parentLink = UriUtils.buildUriPath(
                ComputeService.FACTORY_LINK,
                hostId);
        containerState.powerState = PowerState.STOPPED;
        containerState = doPost(containerState, ContainerFactoryService.SELF_LINK);
        addContainerToMockAdapter(hostLink, containerState.id, containerState.names);

        doOperation(new ContainerHostDataCollectionState(), UriUtils.buildUri(host,
                ContainerHostDataCollectionService.HOST_INFO_DATA_COLLECTION_LINK),
                false,
                Service.Action.PATCH);

        String csLink = cs.documentSelfLink;
        waitFor(() -> {
            ComputeState computeState = getDocument(ComputeState.class, csLink);
            String containers = computeState.customProperties == null ? null
                    : computeState.customProperties
                            .get(ContainerHostService.NUMBER_OF_CONTAINERS_PER_HOST_PROP_NAME);
            String systemContainers = computeState.customProperties == null ? null
                    : computeState.customProperties
                            .get(ContainerHostService.NUMBER_OF_SYSTEM_CONTAINERS_PROP_NAME);
            //the test container created above and the missing container coming from the host.
            host.log(""testContainersCountOnHostWithContainer - countainer count: %s"", containers);
            return ""2"".equals(containers) && ""0"".equals(systemContainers);
        }",Mystery Guest + Resource Optimism
"@Test
    public void testContainersCountSystemAndNotSystem() throws Throwable {
        String hostId = UUID.randomUUID().toString();
        String hostLink = UriUtils.buildUriPath(ComputeService.FACTORY_LINK, hostId);
        // add preexisting container
        addContainerToMockAdapter(hostLink, preexistingContainerId, preexistingContainerNames);

        ComputeDescription hostDescription = createComputeDescription();
        hostDescription = doPost(hostDescription, ComputeDescriptionService.FACTORY_LINK);

        ComputeState cs = createComputeState(hostId, hostDescription);

        cs = doPost(cs, ComputeService.FACTORY_LINK);

        ContainerState containerState = new ContainerState();
        containerState.id = UUID.randomUUID().toString();
        containerState.names = containerNames;
        containerState.parentLink = UriUtils.buildUriPath(
                ComputeService.FACTORY_LINK, hostId);
        containerState.powerState = PowerState.STOPPED;
        containerState.system = Boolean.TRUE;
        containerState = doPost(containerState, ContainerFactoryService.SELF_LINK);
        addContainerToMockAdapter(hostLink, containerState.id, containerState.names);

        doOperation(new ContainerHostDataCollectionState(), UriUtils.buildUri(host,
                ContainerHostDataCollectionService.HOST_INFO_DATA_COLLECTION_LINK),
                false,
                Service.Action.PATCH);

        String csLink = cs.documentSelfLink;
        waitFor(() -> {
            ComputeState computeState = getDocument(ComputeState.class, csLink);
            String containers = computeState.customProperties == null ? null
                    : computeState.customProperties
                            .get(ContainerHostService.NUMBER_OF_CONTAINERS_PER_HOST_PROP_NAME);
            String systemContainers = computeState.customProperties == null ? null
                    : computeState.customProperties
                            .get(ContainerHostService.NUMBER_OF_SYSTEM_CONTAINERS_PROP_NAME);
            // the test container created above and the missing container coming from the host.
            host.log(""testContainersCountOnHostWithContainer - countainer count: %s"", containers);
            return ""2"".equals(containers) && ""1"".equals(systemContainers);
        }",Mystery Guest + Resource Optimism
"@Test
    public void testDataCollectionDuringProvisioning() throws Throwable {
        // stop the mock adapter service and start the mock inspector adapter service:
        stopService(mockAdapterService);
        mockAdapterService = null;
        final MockInspectAdapterService mockInspectAdapterService = new MockInspectAdapterService();
        String containerBeingProvisioned = ""containerBeingProvisioned"";
        try {
            String hostId = UUID.randomUUID().toString();
            String hostLink = UriUtils.buildUriPath(ComputeService.FACTORY_LINK, hostId);
            // add preexisting container
            addContainerToMockAdapter(hostLink, preexistingContainerId, preexistingContainerNames);

            URI adapterServiceUri = UriUtils.buildUri(host, ManagementUriParts.ADAPTER_DOCKER);
            host.startService(Operation.createPost(adapterServiceUri), mockInspectAdapterService);
            waitForServiceAvailability(ManagementUriParts.ADAPTER_DOCKER);

            ComputeDescription hostDescription = createComputeDescription();
            hostDescription = doPost(hostDescription, ComputeDescriptionService.FACTORY_LINK);

            ComputeState cs = createComputeState(hostId, hostDescription);

            cs = doPost(cs, ComputeService.FACTORY_LINK);

            // container being provisioned should not be discovered by the data collection
            // Do not set id - the container is still being provisioned
            ContainerState containerState = new ContainerState();
            containerState.names = containerNames;
            containerState.parentLink = UriUtils.buildUriPath(
                    ComputeService.FACTORY_LINK,
                    hostId);
            containerState.powerState = PowerState.PROVISIONING;
            containerState = doPost(containerState, ContainerFactoryService.SELF_LINK);
            addContainerToMockAdapter(hostLink, containerBeingProvisioned, containerState.names);

            doOperation(new ContainerHostDataCollectionState(), UriUtils.buildUri(host,
                    ContainerHostDataCollectionService.HOST_INFO_DATA_COLLECTION_LINK),
                    false,
                    Service.Action.PATCH);

            host.log("">>>> testDiscoverCreateAndInspectContainer: Container Host %s created.""
                            + "" Waiting for data collection..."", cs.documentSelfLink);
            String csLink = cs.documentSelfLink;
            waitFor(() -> {
                ComputeState computeState = getDocument(ComputeState.class, csLink);
                String containers = computeState.customProperties == null ? null
                        : computeState.customProperties
                                .get(ContainerHostService.NUMBER_OF_CONTAINERS_PER_HOST_PROP_NAME);

                if (containers != null) {
                    host.log("">>>> # of containers per host %s is %s"",
                            computeState.documentSelfLink, containers);
                }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testDataCollectionWhenAHostIsMarkedForDeletion() throws Throwable {
        String hostId = UUID.randomUUID().toString();

        ComputeDescription hostDescription = createComputeDescription();
        hostDescription = doPost(hostDescription, ComputeDescriptionService.FACTORY_LINK);

        ComputeState cs = createComputeState(hostId, hostDescription);
        cs.lifecycleState = LifecycleState.SUSPEND;
        cs = doPost(cs, ComputeService.FACTORY_LINK);

        // create a dummy ContainerState on the ComputeState (that will be marked as missing by the
        // collection)
        missingContainerState = new ContainerState();
        missingContainerState.id = UUID.randomUUID().toString();
        missingContainerState.names = containerNames;
        missingContainerState.parentLink = UriUtils.buildUriPath(
                ComputeService.FACTORY_LINK,
                hostId);
        missingContainerState.powerState = PowerState.STOPPED;
        missingContainerState.system = false;
        missingContainerState = doPost(missingContainerState, ContainerFactoryService.SELF_LINK);

        doOperation(new ContainerHostDataCollectionState(), UriUtils.buildUri(host,
                ContainerHostDataCollectionService.HOST_INFO_DATA_COLLECTION_LINK),
                false,
                Service.Action.PATCH);

        String csLink = cs.documentSelfLink;
        final long timoutInMillis = 5000; // 5sec
        long startTime = System.currentTimeMillis();

        waitFor(() -> {
            ComputeState computeState = getDocument(ComputeState.class, csLink);
            String containers = computeState.customProperties == null ? null
                    : computeState.customProperties
                            .get(ContainerHostService.NUMBER_OF_CONTAINERS_PER_HOST_PROP_NAME);

            if (containers != null && Integer.parseInt(containers) >= 1) {
                fail(""Should not have any containers."");
            }",Mystery Guest + Resource Optimism
"@Test
    public void testDataCollectionDuringProvisioning() throws Throwable {
        // stop the mock adapter service and start the mock inspector adapter service:
        stopService(mockAdapterService);
        mockAdapterService = null;
        final MockInspectAdapterService mockInspectAdapterService = new MockInspectAdapterService();
        String containerBeingProvisioned = ""containerBeingProvisioned"";
        try {
            String hostId = UUID.randomUUID().toString();
            String hostLink = UriUtils.buildUriPath(ComputeService.FACTORY_LINK, hostId);
            // add preexisting container
            addContainerToMockAdapter(hostLink, preexistingContainerId, preexistingContainerNames);

            URI adapterServiceUri = UriUtils.buildUri(host, ManagementUriParts.ADAPTER_DOCKER);
            host.startService(Operation.createPost(adapterServiceUri), mockInspectAdapterService);
            waitForServiceAvailability(ManagementUriParts.ADAPTER_DOCKER);

            ComputeDescription hostDescription = createComputeDescription();
            hostDescription = doPost(hostDescription, ComputeDescriptionService.FACTORY_LINK);

            ComputeState cs = createComputeState(hostId, hostDescription);

            cs = doPost(cs, ComputeService.FACTORY_LINK);

            // container being provisioned should not be discovered by the data collection
            // Do not set id - the container is still being provisioned
            ContainerState containerState = new ContainerState();
            containerState.names = containerNames;
            containerState.parentLink = UriUtils.buildUriPath(
                    ComputeService.FACTORY_LINK,
                    hostId);
            containerState.powerState = PowerState.PROVISIONING;
            containerState = doPost(containerState, ContainerFactoryService.SELF_LINK);
            addContainerToMockAdapter(hostLink, containerBeingProvisioned, containerState.names);

            doOperation(new ContainerHostDataCollectionState(), UriUtils.buildUri(host,
                    ContainerHostDataCollectionService.HOST_INFO_DATA_COLLECTION_LINK),
                    false,
                    Service.Action.PATCH);

            host.log("">>>> testDiscoverCreateAndInspectContainer: Container Host %s created.""
                            + "" Waiting for data collection..."", cs.documentSelfLink);
            String csLink = cs.documentSelfLink;
            waitFor(() -> {
                ComputeState computeState = getDocument(ComputeState.class, csLink);
                String containers = computeState.customProperties == null ? null
                        : computeState.customProperties
                                .get(ContainerHostService.NUMBER_OF_CONTAINERS_PER_HOST_PROP_NAME);

                if (containers != null) {
                    host.log("">>>> # of containers per host %s is %s"",
                            computeState.documentSelfLink, containers);
                }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testPatchExpiration() throws Throwable {
        ContainerState container = createContainer(""/parent/1"", ""tenant1"");
        URI containerUri = UriUtils.buildUri(host, container.documentSelfLink);

        ContainerState patch = new ContainerState();
        long expirationTime = Utils.fromNowMicrosUtc(TimeUnit.SECONDS.toMicros(30));
        patch.documentExpirationTimeMicros = expirationTime;

        doOperation(patch, containerUri, false, Action.PATCH);
        ContainerState updatedContainer = getDocument(ContainerState.class,
                container.documentSelfLink);
        assertEquals(expirationTime, updatedContainer.documentExpirationTimeMicros);

        patch = new ContainerState();
        patch.documentExpirationTimeMicros = -1;

        doOperation(patch, containerUri, false, Action.PATCH);
        updatedContainer = getDocument(ContainerState.class, container.documentSelfLink);
        assertEquals(0, updatedContainer.documentExpirationTimeMicros);
    }",No Smells
"@Test
    public void testGetShellWhenEmbeddedShouldFail() throws Throwable {

        ConfigurationState config = new ConfigurationState();
        config.key = ConfigurationUtil.EMBEDDED_MODE_PROPERTY;
        config.value = ""true"";
        config.documentSelfLink = config.key;
        doPost(config, ConfigurationFactoryService.SELF_LINK);

        try {
            getDocument(String.class, ContainerShellService.SELF_LINK);
            fail(""It should have been forbidden!"");
        }",Mystery Guest + Resource Optimism
"@Test
    public void testGetShellInvalidIdShouldFail() throws Throwable {
        try {
            getDocument(String.class, ContainerShellService.SELF_LINK + ""?id=invalid"");
            fail(""It should have failed!"");
        }",Mystery Guest + Resource Optimism
"@Test
    public void testGetShellNoIdShouldFail() throws Throwable {
        try {
            getDocument(String.class, ContainerShellService.SELF_LINK);
            fail(""It should have failed!"");
        }",Mystery Guest + Resource Optimism
"@Test
    public void testContainerStatsNoParam() {
        TestRequestSender sender = host.getTestRequestSender();
        FailureResponse failureResponse = sender.sendAndWaitFailure(Operation
                .createGet(host, ContainerStatsService.SELF_LINK));
        assertEquals(Operation.STATUS_CODE_FAILURE_THRESHOLD, failureResponse.op.getStatusCode());
        assertTrue(failureResponse.failure instanceof IllegalArgumentException);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testContainerStatsNoParam() {
        TestRequestSender sender = host.getTestRequestSender();
        FailureResponse failureResponse = sender.sendAndWaitFailure(Operation
                .createGet(host, ContainerStatsService.SELF_LINK));
        assertEquals(Operation.STATUS_CODE_FAILURE_THRESHOLD, failureResponse.op.getStatusCode());
        assertTrue(failureResponse.failure instanceof IllegalArgumentException);
    }",No Smells
"@Test
    public void testContainerStatsWrongParam() {
        TestRequestSender sender = host.getTestRequestSender();
        String query = ContainerStatsService.CONTAINER_ID_QUERY_PARAM + ""=no-container"";
        URI uri = UriUtils.buildUri(host, ContainerStatsService.SELF_LINK, query);
        FailureResponse failureResponse = sender.sendAndWaitFailure(Operation.createGet(uri));
        assertEquals(Operation.STATUS_CODE_NOT_FOUND, failureResponse.op.getStatusCode());
    }",No Smells
"@Test
    public void testDelete() throws Throwable {
        ComputeDescription computeDescription =
                doPost(new ComputeDescription(), ComputeDescriptionService.FACTORY_LINK);
        DeploymentPolicy deploymentPolicy =
                doPost(createDeploymentPolicy(), DeploymentPolicyService.FACTORY_LINK);

        ResourcePoolState resourcePool = new ResourcePoolState();
        resourcePool.name = ""test-resource-pool"";
        resourcePool = doPost(resourcePool, ResourcePoolService.FACTORY_LINK);

        ComputeState compute = new ComputeState();
        compute.customProperties = new HashMap<>();
        compute.customProperties.put(ContainerHostService.CUSTOM_PROPERTY_DEPLOYMENT_POLICY,
                deploymentPolicy.documentSelfLink);
        compute.descriptionLink = computeDescription.documentSelfLink;
        compute = doPost(compute, ComputeService.FACTORY_LINK);

        GroupResourcePlacementState resourcePlacement = new GroupResourcePlacementState();
        resourcePlacement.deploymentPolicyLink = deploymentPolicy.documentSelfLink;
        resourcePlacement.maxNumberInstances = 1;
        resourcePlacement.name = ""test-group-resource-placement"";
        resourcePlacement.resourcePoolLink = resourcePool.documentSelfLink;
        resourcePlacement = doPost(resourcePlacement, GroupResourcePlacementService.FACTORY_LINK);

        try {
            doDelete(UriUtils.buildUri(host, deploymentPolicy.documentSelfLink), true);
            fail(""expect validation error during deletion"");
        }",Mystery Guest + Resource Optimism
"@Test
    public void testDeleteWhenActiveReservation() throws Throwable {
        GroupResourcePlacementState placementState = createAndStoreGroupResourcePlacement();
        placementState = makeResourcePlacementReservationRequest(placementState, 5);

        boolean expectedFailure = true;
        try {
            DeploymentProfileConfig.getInstance().setTest(false);
            doDelete(UriUtils.buildUri(host, placementState.documentSelfLink), expectedFailure);
            fail(""expect validation error during deletion"");
        }",Mystery Guest + Resource Optimism
"@Test
    public void testGetGroupResourcePlacementState() throws Throwable {
        GroupResourcePlacementState placementState = new GroupResourcePlacementState();
        placementState.name = ""reservation-test"";
        placementState.tenantLinks = Collections.singletonList(""testGroup"");
        placementState.maxNumberInstances = 10;
        placementState.resourcePoolLink = resourcePool.documentSelfLink;

        GroupResourcePlacementState outPlacementState = doPost(placementState,
                GroupResourcePlacementService.FACTORY_LINK);

        GroupResourcePlacementState[] result = new GroupResourcePlacementState[] { null }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testGroupPlacementValidation() throws Throwable {
        createAndStoreGroupResourcePlacement(""negative-memory-limit"", -1L, 0L, 0, 0,
                resourcePool.documentSelfLink, true /* expectFailure */);

        createAndStoreGroupResourcePlacement(""negative-cpu-shares"", 0L, 0L, 0, -1,
                resourcePool.documentSelfLink, true /* expectFailure */);

        createAndStoreGroupResourcePlacement(""negative-priority-shares"", 0L, 0L, -1, 0,
                resourcePool.documentSelfLink, true /* expectFailure */);
    }",No Smells
"@Test
    public void testGroupResourcePlacementServiceTenantAndGroup() throws Throwable {
        verifyService(
                FactoryService.create(GroupResourcePlacementService.class),
                GroupResourcePlacementState.class,
                (prefix, index) -> {
                    List<String> tenantAndGroup = new LinkedList<String>();
                    tenantAndGroup.add(TENANT);
                    tenantAndGroup.add(BUSINESS_GROUP);
                    GroupResourcePlacementState reservationState =
                            new GroupResourcePlacementState();
                    reservationState.name = prefix + ""reservation-test"";
                    reservationState.tenantLinks = tenantAndGroup;
                    reservationState.resourcePoolLink = resourcePool.documentSelfLink;
                    reservationState.maxNumberInstances = 10;
                    reservationState.customProperties = new HashMap<>();

                    return reservationState;
                }",No Smells
"@Test
    public void testMemoryPlacementPatchRequest() throws Throwable {
        GroupResourcePlacementState placementState = createAndStoreGroupResourcePlacement();
        String descLink = containerDescription.documentSelfLink;
        int count = 8;

        boolean expectFailure = false;

        placementState = makeResourcePlacementReservationRequest(count, descLink, placementState,
                expectFailure);

        // Set the memory limit to something smaller than what's already reserved
        placementState.memoryLimit = 700;
        expectFailure = true;

        host.testStart(1);
        host.send(Operation
                .createPut(UriUtils.buildUri(host, placementState.documentSelfLink))
                .setBody(placementState)
                .setCompletion(expectFailure ? host.getExpectedFailureCompletion()
                        : host.getCompletion()));
        host.testWait(""Asd"", (int) TimeUnit.MINUTES.toSeconds(1));

        releasePlacement(placementState, descLink, count);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testUpdateWhenNoActiveReservations() throws Throwable {
        GroupResourcePlacementState placementState = createAndStoreGroupResourcePlacement();
        String newName = ""newName"";
        int newMaxInstance = 7;
        String newResourcePoolLink = resourcePool.documentSelfLink;
        int newPriority = 23;
        long newMemoryLimit = MIN_MEMORY;
        long newStorageLimit = 5789L;
        int newCpuShares = 45;
        List<String> newTenantLinks = Arrays.asList(BUSINESS_GROUP);

        placementState.name = newName;
        placementState.maxNumberInstances = newMaxInstance;
        placementState.priority = newPriority;
        placementState.resourcePoolLink = newResourcePoolLink;
        placementState.memoryLimit = newMemoryLimit;
        placementState.storageLimit = newStorageLimit;
        placementState.cpuShares = newCpuShares;
        placementState.tenantLinks = newTenantLinks;

        doOperation(placementState, UriUtils.buildUri(host, placementState.documentSelfLink),
                false, Action.PUT);

        placementState = getDocument(GroupResourcePlacementState.class,
                placementState.documentSelfLink);

        assertEquals(newName, placementState.name);
        assertEquals(newMaxInstance, placementState.maxNumberInstances);
        assertEquals(newPriority, placementState.priority);
        assertEquals(newResourcePoolLink, placementState.resourcePoolLink);
        assertEquals(newMemoryLimit, placementState.memoryLimit);
        assertEquals(newStorageLimit, placementState.storageLimit);
        assertEquals(newCpuShares, placementState.cpuShares);
        assertEquals(newTenantLinks, placementState.tenantLinks);

        doDelete(UriUtils.buildUri(host, placementState.documentSelfLink), false);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testProvisionSystemContainerWhenDoesNotExistsOnHost() throws Throwable {
        // add preexisting container to the adapter service
        addContainerToMockAdapter(COMPUTE_HOST_LINK, TEST_PREEXISTING_CONTAINER_ID,
                TEST_PREEXISTING_CONTAINER_ID, ""TestName"", computeState.tenantLinks);

        // run data collection on preexisting container
        startAndWaitHostContainerListDataCollection();

        ContainerState systemContainer = waitForContainer(systemContainerLink, image, null, null);
        assertNotNull(""System container not created or can't be retrieved."", systemContainer);
        assertEquals(systemContainerLink, systemContainer.documentSelfLink);
        assertEquals(SystemContainerDescriptions.AGENT_CONTAINER_NAME,
                systemContainer.names.get(0));
        assertNotNull(""System container not provisioned"", systemContainer.id);
        assertEquals(SystemContainerDescriptions.AGENT_CONTAINER_DESCRIPTION_LINK,
                systemContainer.descriptionLink);
        assertEquals(Boolean.TRUE, systemContainer.system);
        assertEquals(TENANT_LINKS, systemContainer.tenantLinks);
    }",No Smells
"@Test
    public void testContainerVersion() throws Throwable {
        ContainerVersion cv22 = ContainerVersion.fromImageName(""abc:2.2"");
        ContainerVersion cv23 = ContainerVersion.fromImageName(""abc:2.3"");
        ContainerVersion cvLatest = ContainerVersion.fromImageName(""abc:latest"");

        assertTrue(cv22.hashCode() != cv23.hashCode());
        assertTrue(!cv23.equals(cvLatest));

        assertEquals(0, cvLatest.compareTo(cvLatest));
        assertEquals(0, cv22.compareTo(cv22));

        assertTrue(cv22.compareTo(cv23) < 0);
        assertTrue(cv23.compareTo(cv22) > 0);

        assertTrue(cv23.compareTo(cvLatest) < 0);
        assertTrue(cvLatest.compareTo(cv22) > 0);
    }",No Smells
"@Test
    public void testProvisionSystemContainerWhenExistsOnHost() throws Throwable {
        String systemContainerId = extractId(systemContainerLink);

        // add system container to the adapter service because it already exists on host
        addContainerToMockAdapter(COMPUTE_HOST_LINK, systemContainerId,
                SystemContainerDescriptions.AGENT_CONTAINER_NAME, image, computeState.tenantLinks);

        // run data collection on preexisting system container
        startAndWaitHostContainerListDataCollection();

        ContainerState systemContainer = waitForContainer(systemContainerLink, image, null, null);
        assertNotNull(""System container not created or can't be retrieved."", systemContainer);
        assertEquals(systemContainerLink, systemContainer.documentSelfLink);
        assertEquals(SystemContainerDescriptions.AGENT_CONTAINER_NAME,
                systemContainer.names.get(0));
        assertNotNull(""System container not discovered"", systemContainer.id);
        assertEquals(SystemContainerDescriptions.AGENT_CONTAINER_DESCRIPTION_LINK,
                systemContainer.descriptionLink);
        assertEquals(image, systemContainer.image);
        assertEquals(Boolean.TRUE, systemContainer.system);
        assertEquals(TENANT_LINKS, systemContainer.tenantLinks);
    }",No Smells
"@Test
    public void testStateStuckInProvisioningWhenExistsOnHost() throws Throwable {
        testStateStuckInProvisioning(false);
    }",No Smells
"@Test
    public void testStateStuckInProvisioningWhenExistsOnHost() throws Throwable {
        testStateStuckInProvisioning(false);
    }",No Smells
"@Test
    public void testHostPortProfileServices() throws Throwable {
        verifyService(
                FactoryService.create(HostPortProfileService.class),
                HostPortProfileService.HostPortProfileState.class,
                (prefix, index) -> {
                    return createHostPortProfile();
                }",Mystery Guest + Resource Optimism
"@Test
    public void testPatchRelease() throws Throwable {
        HostPortProfileService.HostPortProfileState profile = createHostPortProfile();
        profile = doPost(profile, HostPortProfileService.FACTORY_LINK);

        HostPortProfileService.HostPortProfileReservationRequest allocateRequest =
                new HostPortProfileService.HostPortProfileReservationRequest();
        allocateRequest.containerLink = UUID.randomUUID().toString();
        allocateRequest.mode = HostPortProfileService.HostPortProfileReservationRequestMode.ALLOCATE;
        allocateRequest.additionalHostPortCount = 1;

        patch(profile, allocateRequest, false);

        allocateRequest = new HostPortProfileService.HostPortProfileReservationRequest();
        allocateRequest.containerLink = UUID.randomUUID().toString();
        allocateRequest.mode = HostPortProfileService.HostPortProfileReservationRequestMode.ALLOCATE;
        allocateRequest.additionalHostPortCount = 1;

        patch(profile, allocateRequest, false);

        HostPortProfileService.HostPortProfileReservationRequest releaseRequest =
                new HostPortProfileService.HostPortProfileReservationRequest();
        releaseRequest.containerLink = allocateRequest.containerLink;
        releaseRequest.mode = HostPortProfileService.HostPortProfileReservationRequestMode.RELEASE;

        HostPortProfileService.HostPortProfileState result = patch(profile, releaseRequest, false);
        assertEquals(1, result.reservedPorts.size());
        assertTrue(result.reservedPorts
                .entrySet()
                .stream()
                .noneMatch(p -> releaseRequest.containerLink.equals(p.getValue())));
    }",No Smells
"@Test
    public void testUpdate() throws Throwable {
        HostPortProfileService.HostPortProfileState profile = createHostPortProfile();
        profile = doPost(profile, HostPortProfileService.FACTORY_LINK);

        profile.startPort = new Long(""5000"");

        HostPortProfileService.HostPortProfileState result = doPut(profile);
        assertEquals(profile.startPort, result.startPort);
    }",No Smells
"@Test
    public void testDiscoverExistingVolumeOnHost() throws Throwable {
        // add preexisting volume to the adapter service
        addVolumeToMockAdapter(COMPUTE_HOST_LINK, TEST_PREEXISTING_VOLUME_NAME, LOCAL_DRIVER, LOCAL_SCOPE);

        // run data collection on preexisting volume
        startAndWaitHostVolumeListDataCollection();

        List<ContainerVolumeState> volumeStates = getVolumeStates();
        assertEquals(1, volumeStates.size());
        ContainerVolumeState preexistingVolumeState = volumeStates.get(0);
        assertNotNull(""Preexisting volume not created or can't be retrieved."", preexistingVolumeState);
        assertEquals(TEST_PREEXISTING_VOLUME_NAME, preexistingVolumeState.name);
        assertTrue(Boolean.TRUE.equals(preexistingVolumeState.external));
        assertTrue(""Preexisting volume belongs to the host."",
                COMPUTE_HOST_LINK.equals(preexistingVolumeState.originatingHostLink));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testPostStateToPut() throws Throwable {
        HostVolumeListDataCollectionState hostVolumeListDataCollection =
                getDocument(HostVolumeListDataCollectionState.class ,HostVolumeListDataCollection
                        .DEFAULT_HOST_VOLUME_LIST_DATA_COLLECTION_LINK);
        assertEquals(0, hostVolumeListDataCollection.containerHostLinks.size());

        HostVolumeListDataCollectionState hostVolumeListDataCollectionNew = new
                HostVolumeListDataCollectionState();
        hostVolumeListDataCollectionNew.documentSelfLink = hostVolumeListDataCollection
                .documentSelfLink;
        hostVolumeListDataCollectionNew.containerHostLinks = new HashMap<>();
        hostVolumeListDataCollectionNew.containerHostLinks.put(COMPUTE_HOST_LINK, 1L);

        //converted to put which should be ignored
        doPost(hostVolumeListDataCollectionNew, HostVolumeListDataCollection.FACTORY_LINK);
        hostVolumeListDataCollection =
                getDocument(HostVolumeListDataCollectionState.class ,HostVolumeListDataCollection
                        .DEFAULT_HOST_VOLUME_LIST_DATA_COLLECTION_LINK);
        assertEquals(0, hostVolumeListDataCollection.containerHostLinks.size());
    }",No Smells
"@Test
    public void testUpdateVolumePowerState() throws Throwable {

        addVolumeToMockAdapter(COMPUTE_HOST_LINK, TEST_PREEXISTING_VOLUME_NAME, LOCAL_DRIVER,
                LOCAL_SCOPE);

        startAndWaitHostVolumeListDataCollection();

        List<ContainerVolumeState> volumeStates = getVolumeStates();
        assertEquals(1, volumeStates.size());
        assertEquals(PowerState.CONNECTED, volumeStates.get(0).powerState);
        ContainerVolumeState containerVolumeState = new ContainerVolumeState();
        containerVolumeState.powerState = PowerState.PROVISIONING;
        containerVolumeState.driver = LOCAL_DRIVER;
        doPatch(containerVolumeState, volumeStates.get(0).documentSelfLink);

        volumeStates = getVolumeStates();
        assertEquals(1, volumeStates.size());
        assertEquals(PowerState.PROVISIONING, volumeStates.get(0).powerState);

        startAndWaitHostVolumeListDataCollection();

        volumeStates = getVolumeStates();
        assertEquals(1, volumeStates.size());
        assertEquals(PowerState.CONNECTED, volumeStates.get(0).powerState);
    }",No Smells
"@Test
    public void testContainerServices() throws Throwable {
        verifyService(
                FactoryService.create(ContainerNetworkService.class),
                ContainerNetworkState.class,
                (prefix, index) -> {
                    ContainerNetworkState networkState = new ContainerNetworkState();
                    networkState.id = prefix + ""id"" + index;
                    networkState.name = prefix + ""name"" + index;

                    Ipam ipam = new Ipam();
                    ipam.driver = IPAM_DRIVER;

                    IpamConfig ipamConfig = new IpamConfig();
                    ipamConfig.subnet = String.format(SUBNET_TEMPLATE, index % 256);
                    ipamConfig.ipRange = String.format(IP_RANGE_TEMPLATE, index % 256, index % 256);
                    ipamConfig.gateway = String.format(GATEWAY_TEMPLATE, index % 256);
                    ipamConfig.auxAddresses = new HashMap<>();
                    ipamConfig.auxAddresses.put(prefix + IPAM_ADDITIONAL_HOST_KEY,
                            String.format(IPAM_ADDITIONAL_HOST_IP_ADDRESS_TEMPLATE, index % 256));

                    ipam.config = new IpamConfig[] { ipamConfig }",Mystery Guest + Resource Optimism
"@Test
    public void testPatchDriverOptions() throws Throwable {
        ContainerNetworkState network = createNetwork(""tenant1"");
        URI networkUri = UriUtils.buildUri(host, network.documentSelfLink);

        // Test add option to empty map
        ContainerNetworkState patch = new ContainerNetworkState();
        patch.options = new HashMap<>();
        patch.options.put(DRIVER_OPTIONS_KEY_1, DRIVER_OPTIONS_VALUE_1);

        doOperation(patch, networkUri, false, Action.PATCH);
        ContainerNetworkState updatedNetwork = getDocument(ContainerNetworkState.class,
                network.documentSelfLink);
        assertEquals(1, updatedNetwork.options.size());
        assertEquals(DRIVER_OPTIONS_VALUE_1,
                updatedNetwork.options.get(DRIVER_OPTIONS_KEY_1));

        // Test append option to existing list
        patch = new ContainerNetworkState();
        patch.options = new HashMap<>();
        patch.options.put(DRIVER_OPTIONS_KEY_2, DRIVER_OPTIONS_VALUE_2);

        doOperation(patch, networkUri, false, Action.PATCH);
        updatedNetwork = getDocument(ContainerNetworkState.class, network.documentSelfLink);
        assertEquals(2, updatedNetwork.options.size());
        assertEquals(DRIVER_OPTIONS_VALUE_1,
                updatedNetwork.options.get(DRIVER_OPTIONS_KEY_1));
        assertEquals(DRIVER_OPTIONS_VALUE_2,
                updatedNetwork.options.get(DRIVER_OPTIONS_KEY_2));

        // Test overwrite existing options
        patch = new ContainerNetworkState();
        patch.options = new HashMap<>();
        patch.options.put(DRIVER_OPTIONS_KEY_1, DRIVER_OPTIONS_VALUE_2);
        patch.options.put(DRIVER_OPTIONS_KEY_2, DRIVER_OPTIONS_VALUE_1);

        doOperation(patch, networkUri, false, Action.PATCH);
        updatedNetwork = getDocument(ContainerNetworkState.class, network.documentSelfLink);
        assertEquals(2, updatedNetwork.options.size());
        assertEquals(DRIVER_OPTIONS_VALUE_1,
                updatedNetwork.options.get(DRIVER_OPTIONS_KEY_2));
        assertEquals(DRIVER_OPTIONS_VALUE_2,
                updatedNetwork.options.get(DRIVER_OPTIONS_KEY_1));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testPatchExpiration() throws Throwable {
        ContainerNetworkState network = createNetwork(null);
        URI networkUri = UriUtils.buildUri(host, network.documentSelfLink);

        ContainerNetworkState patch = new ContainerNetworkState();
        long nowMicrosUtc = Utils.fromNowMicrosUtc(TimeUnit.SECONDS.toMicros(30));
        patch.documentExpirationTimeMicros = nowMicrosUtc;

        doOperation(patch, networkUri, false, Action.PATCH);
        ContainerNetworkState updatedNetwork = getDocument(ContainerNetworkState.class,
                network.documentSelfLink);
        assertEquals(nowMicrosUtc, updatedNetwork.documentExpirationTimeMicros);

        patch = new ContainerNetworkState();
        patch.documentExpirationTimeMicros = -1;

        doOperation(patch, networkUri, false, Action.PATCH);
        updatedNetwork = getDocument(ContainerNetworkState.class, network.documentSelfLink);
        assertEquals(0, updatedNetwork.documentExpirationTimeMicros);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testPropertiesValidationOnCreate() {
        // Test with valid properties
        try {
            createNetwork(null);
        }",No Smells
"@Test
    public void testDefaultResourcePrefixNameCreatedOnStartUp() throws Throwable {
        waitForServiceAvailability(
                ResourceNamePrefixService.DEFAULT_RESOURCE_NAME_PREFIX_SELF_LINK);
        ResourceNamePrefixState defaultNamePrefixState = getDocument(ResourceNamePrefixState.class,
                ResourceNamePrefixService.DEFAULT_RESOURCE_NAME_PREFIX_SELF_LINK);
        assertNotNull(defaultNamePrefixState);
        assertNull(defaultNamePrefixState.tenantLinks);
    }",No Smells
"@Test
    public void testResourcePrefixWithRandomGeneratedToken() throws Throwable {
        ResourceNamePrefixState state = createValidResourceNamePrefixState();
        state.numberOfDigits = 3;
        state.nextNumber = 994;
        state.addRandomToken = true;
        state = doPost(state, ResourceNamePrefixService.FACTORY_LINK);

        int currentCount = 0;
        NamePrefixRequest request = new NamePrefixRequest();
        request.resourceCount = 2;

        NamePrefixResponse response = patch(state, request);
        assertEquals(request.resourceCount, response.resourceNamePrefixes.size());
        for (int i = currentCount; i < request.resourceCount; i++) {
            String expectedNamePrefix = state.prefix
                    + (state.nextNumber + currentCount + i);
            String namePrefix = response.resourceNamePrefixes.get(i);
            int delimiterIndex = namePrefix
                    .indexOf(ResourceNamePrefixState.RANDOM_GENERATED_TOKEN_DELIMITER);
            assertEquals(expectedNamePrefix.length(), delimiterIndex);
            int minimalRandomTokenLenght = 6;
            assertTrue(namePrefix.length() - delimiterIndex >= minimalRandomTokenLenght);
            assertEquals(expectedNamePrefix, namePrefix.substring(0, delimiterIndex));
        }",No Smells
"@Test
    public void testQueryResultLimit() throws Throwable {
        final String queryTaskDocumentSelfLink = UriUtils.buildUriPath(
                ServiceUriPaths.CORE_QUERY_TASKS, ""/testQueryTaskResultLimit"");
        QuerySpecification qs = new QuerySpecification();
        qs.query = Query.Builder.create().addKindFieldClause(ContainerDescription.class).build();
        QueryTask qt = QueryTask.create(qs);
        qt.documentSelfLink = queryTaskDocumentSelfLink + 1;

        final AtomicReference<QueryTask> q = new AtomicReference<>();
        host.testStart(1);
        new ServiceDocumentQuery<>(host, ContainerDescription.class)
                .query(qt, handler(false, q, qt.documentSelfLink));
        host.testWait();
        qt = q.getAndSet(null);
        assertNotNull(qt);
        assertEquals(ServiceDocumentQuery.DEFAULT_QUERY_RESULT_LIMIT,
                qt.querySpec.resultLimit);

        Integer resourceLimit = 1000;
        qs = new QuerySpecification();
        qs.query = Query.Builder.create().addKindFieldClause(ContainerDescription.class).build();
        qt = QueryTask.create(qs);
        qt.querySpec.resultLimit = resourceLimit;
        qt.documentSelfLink = queryTaskDocumentSelfLink + 2;
        host.testStart(1);
        new ServiceDocumentQuery<>(host, ContainerDescription.class)
                .query(qt, handler(false, q, qt.documentSelfLink));
        host.testWait();
        qt = q.getAndSet(null);
        assertNotNull(qt);
        assertEquals(resourceLimit, qt.querySpec.resultLimit);

        qs = new QuerySpecification();
        qs.query = Query.Builder.create().addKindFieldClause(ContainerDescription.class).build();
        qt = QueryTask.create(qs);
        QueryUtil.addCountOption(qt);
        qt.documentSelfLink = queryTaskDocumentSelfLink + 3;
        host.testStart(1);
        new ServiceDocumentQuery<>(host, ContainerDescription.class)
                .query(qt, handler(true, q, qt.documentSelfLink));
        host.testWait();
        qt = q.getAndSet(null);
        assertNotNull(qt);
        assertNull(qt.querySpec.resultLimit);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testQueryTaskDeleted() throws Throwable {
        final String queryTaskDocumentSelfLink = UriUtils.buildUriPath(
                ServiceUriPaths.CORE_QUERY_TASKS, ""/testQueryTaskResultLimit"");
        final String queryTaskLink = queryTaskDocumentSelfLink + 1;
        QuerySpecification qs = new QuerySpecification();
        qs.query = Query.Builder.create().addKindFieldClause(ContainerDescription.class).build();
        QueryTask qt = QueryTask.create(qs);
        qt.documentSelfLink = queryTaskLink;
        int fiveSec = 5000000;
        qt.documentExpirationTimeMicros = ServiceUtils.getExpirationTimeFromNowInMicros(fiveSec);

        final AtomicReference<QueryTask> q = new AtomicReference<>();
        host.testStart(1);
        new ServiceDocumentQuery<>(host, ContainerDescription.class)
                .query(qt, handler(false, q, qt.documentSelfLink));
        host.testWait();
        qt = q.getAndSet(null);
        //validate query task exists
        assertNotNull(qt);
        // validate query task is deleted
        waitFor(() -> {
            QueryTask queryTask = getDocumentNoWait(QueryTask.class, queryTaskLink);
            return queryTask == null;
        }",Mystery Guest + Resource Optimism
"@Test
    public void testQueryUpdatedDocumentSince() throws Throwable {
        long startTime = Utils.getNowMicrosUtc();
        descs = queryDocumentUpdatedSince(startTime, ""testLink"");
        assertEquals(0, descs.size());

        ContainerDescription desc = new ContainerDescription();
        desc.image = image1;
        desc = doPost(desc, ContainerDescriptionService.FACTORY_LINK);

        long timeAfterPost = Utils.getNowMicrosUtc();

        // match time but invalid link
        descs = queryDocumentUpdatedSince(startTime, ""testLink"");
        assertEquals(0, descs.size());

        // match link but invalid time
        descs = queryDocumentUpdatedSince(timeAfterPost, desc.documentSelfLink);
        assertEquals(0, descs.size());

        // match link but invalid time
        descs = queryDocumentUpdatedSince(startTime, desc.documentSelfLink);
        assertEquals(1, descs.size());

        desc.image = image2;
        doOperation(desc, UriUtils.buildUri(host, desc.documentSelfLink), false,
                Service.Action.PATCH);

        long timeAfterPatch = Utils.getNowMicrosUtc();

        // the delta for the update should be retrieved
        descs = queryDocumentUpdatedSince(timeAfterPost, desc.documentSelfLink);
        assertEquals(1, descs.size());
        assertEquals(image2, descs.get(0).image);

        // no updates after patch
        descs = queryDocumentUpdatedSince(timeAfterPatch, desc.documentSelfLink);
        assertEquals(0, descs.size());

        delete(desc.documentSelfLink);

        long timeAfterDelete = Utils.getNowMicrosUtc();

        descs = queryDocumentUpdatedSince(timeAfterPatch, desc.documentSelfLink);
        assertEquals(1, descs.size());
        assertTrue(ServiceDocument.isDeleted(descs.get(0)));

        descs = queryDocumentUpdatedSince(timeAfterDelete, desc.documentSelfLink);
        assertEquals(0, descs.size());
    }",No Smells
"@Test
    public void verifyDefaultContainerDescriptionCreatedOnStartup() throws Throwable {

        ContainerDescription agentContainerDesc = getDocument(
                ContainerDescription.class,
                SystemContainerDescriptions.AGENT_CONTAINER_DESCRIPTION_LINK);
        assertNotNull(agentContainerDesc);
        assertEquals(SystemContainerDescriptions.AGENT_CONTAINER_NAME,
                agentContainerDesc.name);
        String expectedImageName = String.format(""%s:%s"",
                SystemContainerDescriptions.AGENT_IMAGE_NAME,
                SystemContainerDescriptions.getAgentImageVersion());
        assertEquals(expectedImageName, agentContainerDesc.image);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testNoDuplicateResultWhenBothMatch() throws Throwable {
        verifyTemplateSearchResult(TEST_COMMON);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testDeleteClonedCompositeDescriptionInUseShouldFail() throws Throwable {
        CompositeDescription compositeDescription = createClonedCompositeDescription(
                ""/fake-component-link"");
        createCompositeComponent(compositeDescription.documentSelfLink);

        try {
            deleteClonedCompositeDescription(compositeDescription.documentSelfLink,
                    CompositeDescription.class);
            fail(""Expected composite description deletion to fail because a composite component is using it."");
        }",No Smells
"@Test
    public void testDeleteCompositeDescriptionShouldFail() throws Throwable {
        CompositeDescription compositeDescription = createCompositeDescription(
                ""/fake-component-link"");

        try {
            deleteClonedCompositeDescription(compositeDescription.documentSelfLink,
                    CompositeDescription.class);
            fail(""Expected composite description deletion to fail because it is not a cloned composite description."");
        }",No Smells
"@Test
    public void testDeleteUnusedClonedCompositeDescriptionShouldSucceed() throws Throwable {
        ContainerDescription containerDescription = createContainerDescription();
        ContainerNetworkDescription networkDescription = createNetworkDescription();
        ContainerVolumeDescription volumeDescription = createVolumeDescription();
        CompositeDescription clonedCompositeDescription = createClonedCompositeDescription(
                containerDescription.documentSelfLink,
                networkDescription.documentSelfLink,
                volumeDescription.documentSelfLink);
        deleteClonedCompositeDescription(clonedCompositeDescription.documentSelfLink,
                CompositeDescription.class);
        verifyDocumentDoesNotExist(containerDescription.documentSelfLink,
                ContainerDescription.class);
        verifyDocumentDoesNotExist(networkDescription.documentSelfLink,
                ContainerNetworkDescription.class);
        verifyDocumentDoesNotExist(volumeDescription.documentSelfLink,
                ContainerVolumeDescription.class);
    }",No Smells
"@Test
    public void testDeleteVolumeDescriptionInUseShouldFail() throws Throwable {
        ContainerVolumeDescription volumeDescription = createVolumeDescription();
        createVolumeState(volumeDescription.documentSelfLink);

        try {
            deleteResourceDescription(volumeDescription.documentSelfLink,
                    ContainerNetworkDescription.class);
            fail(""Expected volume description deletion to fail because a volume state is using it."");
        }",No Smells
"@Test
    public void testUpdateContainerPorts() throws Throwable {
        ComputeService.ComputeState computeState = createComputeHost();
        ContainerState containerState = createContainerState(computeState.documentSelfLink, true);
        HostPortProfileService.HostPortProfileState profile = createHostPortProfile(computeState,
                containerState, new Long[] { new Long(5000), new Long(3045) }",Mystery Guest + Resource Optimism
"@Test
    public void testReleaseRetiredContainerPorts() throws Throwable {
        ComputeService.ComputeState computeState = createComputeHost();
        ContainerState containerState = createContainerState(computeState.documentSelfLink, false);
        doPut(containerState);
        HostPortProfileService.HostPortProfileState profile = createHostPortProfile(computeState,
                containerState, new Long[] { new Long(5000), new Long(3045) }",Mystery Guest + Resource Optimism
"@Test
    public void testRemoveTagFromContainerImageName() {
        String[] input = new String[] { ""postgres"", ""postgres:9.4"", ""test-repo/postgres"",
                ""test-repo/postgres:9.4"", ""test-repo:5005/postgres"",
                ""test-repo:5005/postgres:9.4"" }",Eager Test
"@Test
    public void testPatchOperation() throws Throwable {
        ContainerVolumeState volume = createVolume(""tenant/coke"");

        URI volumeUri = UriUtils.buildUri(host, volume.documentSelfLink);

        ContainerVolumeState patch = new ContainerVolumeState();

        // Update driver.
        patch.driver = CONTAINER_VOLUME_VMDK_DRIVER;

        ContainerVolumeState updatedVolume = updateVolume(patch, volumeUri,
                volume.documentSelfLink);

        assertTrue(!volume.driver.equals(updatedVolume.driver));
        assertEquals(updatedVolume.driver, CONTAINER_VOLUME_VMDK_DRIVER);

        // Update name.
        assertNotNull(volume.name);
        patch = new ContainerVolumeState();
        String newName = UUID.randomUUID().toString();
        patch.name = newName;

        updatedVolume = updateVolume(patch, volumeUri, volume.documentSelfLink);

        assertNotNull(updatedVolume.name);
        assertNotEquals(volume.name, updatedVolume.name);
        assertEquals(updatedVolume.name, newName);

        // Update component links
        patch.compositeComponentLinks = new ArrayList<>();
        patch.compositeComponentLinks.add(""app-1"");
        patch.compositeComponentLinks.add(""app-2"");
        updatedVolume = updateVolume(patch, volumeUri, volume.documentSelfLink);
        assertEquals(2, updatedVolume.compositeComponentLinks.size());

        patch.compositeComponentLinks.remove(""app-1"");
        updatedVolume = updateVolume(patch, volumeUri, volume.documentSelfLink);
        assertEquals(1, updatedVolume.compositeComponentLinks.size());
    }",No Smells
"@Test
    public void testVolumeString() {
        if (expectError) {
            try {
                VolumeBinding.fromString(volume);
                fail(""Validation should have failed!"");
            }",No Smells
"@Test
    public void testExerciseExceptionOnSendAdapterRequest() throws Throwable {
        // 1. Shutdown host-docker-service
        TestContext ctx = testCreate(1);
        Operation deleteOp = Operation.createDelete(
                UriUtils.buildUri(host, ManagementUriParts.ADAPTER_DOCKER_HOST))
                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NO_INDEX_UPDATE)
                .setReplicationDisabled(true)
                .setCompletion(ctx.getCompletion())
                .setReferer(host.getUri());
        host.send(deleteOp);
        ctx.await();

        // 2. Create Container Host Spec.
        List<String> tenantLinks = Arrays.asList(FIRST_TENANT_ID);

        ContainerHostSpec hostSpec = createContainerHostSpec(tenantLinks, FIRST_COMPUTE_DESC_ID);

        // 3. Try to create Container Host with Adapter Docker Host service stopped.
        try {
            createContainerHostSpec(hostSpec);
            fail(""Should have thrown an exception since the service is stopped."");
        }",No Smells
"@Test
    public void testPutEmptyHostType() throws Throwable {
        List<String> tenantLinks = Arrays.asList(
                FIRST_TENANT_ID);

        ContainerHostSpec hostSpec = createContainerHostSpec(tenantLinks, SECOND_COMPUTE_DESC_ID);
        hostSpec.hostState.customProperties.put(ContainerHostService.CONTAINER_HOST_TYPE_PROP_NAME, ""invalid"");
        String errorMessage = String.format(
                ContainerHostUtil.CONTAINER_HOST_TYPE_NOT_SUPPORTED_MESSAGE_FORMAT, ""invalid"");
        try {
            createContainerHostSpec(hostSpec);
            fail(""Should've thrown LocalizableValidationException - "" + errorMessage);
        }",No Smells
"@Test
    public void testPutFromSameTenantDifferentUsers() throws Throwable {
        List<String> tenantLinks = Arrays.asList(
                FIRST_TENANT_ID,
                FIRST_USER_ID);

        ComputeState cs = createComputeHost(tenantLinks, FIRST_COMPUTE_DESC_ID);
        doPost(cs, ComputeService.FACTORY_LINK);

        List<String> tenantLinksWithDifferentUser = Arrays.asList(
                FIRST_TENANT_ID,
                SECOND_USER_ID);

        ContainerHostSpec hostSpec = createContainerHostSpec(tenantLinksWithDifferentUser,
                SECOND_COMPUTE_DESC_ID);

        createContainerHostSpec(hostSpec);

        assertComputeStateExists(hostSpec);
    }",No Smells
"@Test
    public void testToReadableErrorMessage() throws Throwable {
        ContainerHostService service = new ContainerHostService();
        Method m = service.getClass().getDeclaredMethod(""toReadableErrorMessage"", Throwable.class,
                Operation.class);
        m.setAccessible(true);

        Exception e = new Exception();
        String result = (String) m.invoke(service, e, null);
        assertNotNull(result);
        assertTrue(result.contains(""Unexpected error:""));

        e = new io.netty.handler.codec.DecoderException(""Received fatal alert: bad_certificate"");
        result = (String) m.invoke(service, e, null);
        assertNotNull(result);
        assertTrue(result.contains(""Check login credentials""));

        e = new IllegalStateException(""Socket channel closed:"");
        result = (String) m.invoke(service, e, null);
        assertNotNull(result);
        assertTrue(result.contains(""Check login credentials""));

        e = new Exception(new ConnectTimeoutException());
        result = (String) m.invoke(service, e, null);
        assertNotNull(result);
        assertTrue(result.contains(""Connection timeout""));

        e = new Exception(new ProtocolException());
        result = (String) m.invoke(service, e, null);
        assertNotNull(result);
        assertTrue(result.contains(""Protocol exception""));

        e = new IllegalArgumentException();
        result = (String) m.invoke(service, e, null);
        assertNotNull(result);
        assertTrue(result.contains(""Illegal argument exception:""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testGetDriver() {
        final String driver = ""overlay"";
        ComputeService.ComputeState state = new ComputeService.ComputeState();
        state.customProperties = new HashMap<>();
        state.customProperties.put(ContainerHostUtil.PROPERTY_NAME_DRIVER, driver);

        String result = ContainerHostUtil.getDriver(state);
        assertEquals(driver, result);

        // negative test
        state.customProperties = null;
        result = ContainerHostUtil.getDriver(state);
        assertNull(result);
    }",No Smells
"@Test
    public void testGetTrustAlias() {
        final String alias = ""alias"";
        ComputeService.ComputeState state = new ComputeService.ComputeState();
        state.customProperties = new HashMap<>();
        state.customProperties.put(ContainerHostService.SSL_TRUST_ALIAS_PROP_NAME, alias);

        String result = ContainerHostUtil.getTrustAlias(state);
        assertEquals(alias, result);

        // negative test
        state.customProperties = null;
        result = ContainerHostUtil.getTrustAlias(state);
        assertNull(result);
    }",No Smells
"@Test
    public void testConvertDockerComposeToCompositeTemplate() throws IOException {
        CompositeTemplate expectedTemplate = deserializeCompositeTemplate(
                getContent(""composite.wordpress.yaml""));

        String expectedTemplateYaml = serializeCompositeTemplate(expectedTemplate);

        // Docker Compose with environment values as array

        DockerCompose compose1 = deserializeDockerCompose(
                getContent(""docker.wordpress.1.yaml""));

        CompositeTemplate template1 = fromDockerComposeToCompositeTemplate(compose1);
        template1.name = expectedTemplate.name; // because of the timestamp

        assertComponentTypes(template1.components);

        assertContainersComponents(ResourceType.CONTAINER_TYPE.getContentType(), 2,
                template1.components);
        assertContainersComponents(ResourceType.NETWORK_TYPE.getContentType(), 0,
                template1.components);
        assertContainersComponents(ResourceType.VOLUME_TYPE.getContentType(), 0,
                template1.components);

        String template1Yaml = serializeCompositeTemplate(template1);

        assertEqualsYamls(expectedTemplateYaml, template1Yaml, true);

        // Docker Compose with environment values as dictionary

        DockerCompose compose2 = deserializeDockerCompose(
                getContent(""docker.wordpress.2.yaml""));

        CompositeTemplate template2 = fromDockerComposeToCompositeTemplate(compose2);
        template2.name = expectedTemplate.name; // because of the timestamp

        assertComponentTypes(template2.components);
        assertContainersComponents(ResourceType.CONTAINER_TYPE.getContentType(), 2,
                template1.components);
        assertContainersComponents(ResourceType.NETWORK_TYPE.getContentType(), 0,
                template1.components);
        assertContainersComponents(ResourceType.VOLUME_TYPE.getContentType(), 0,
                template1.components);

        String template2Yaml = serializeCompositeTemplate(template2);

        assertEqualsYamls(expectedTemplateYaml, template2Yaml, true);
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testConvertDockerComposeToCompositeTemplateWithNetwork() throws IOException {

        // Docker Compose with simple network entities

        CompositeTemplate expectedTemplate = deserializeCompositeTemplate(
                getContent(""composite.simple.network.yaml""));

        String expectedTemplateYaml = serializeCompositeTemplate(expectedTemplate);

        DockerCompose compose1 = deserializeDockerCompose(
                getContent(""docker.simple.network.yaml""));

        CompositeTemplate template1 = fromDockerComposeToCompositeTemplate(compose1);
        template1.name = expectedTemplate.name; // because of the timestamp

        assertComponentTypes(template1.components);
        assertContainersComponents(ResourceType.CONTAINER_TYPE.getContentType(), 3,
                template1.components);
        assertContainersComponents(ResourceType.NETWORK_TYPE.getContentType(), 2,
                template1.components);
        assertContainersComponents(ResourceType.VOLUME_TYPE.getContentType(), 0,
                template1.components);

        String template1Yaml = serializeCompositeTemplate(template1);

        assertEqualsYamls(toUnixLineEnding(expectedTemplateYaml),
                toUnixLineEnding(getContent(""composite.simple.network.expected2.yaml"")), true);
        assertEqualsYamls(toUnixLineEnding(template1Yaml),
                toUnixLineEnding(getContent(""composite.simple.network.yaml"")), true);

        // Docker Compose with complex network entities

        expectedTemplate = deserializeCompositeTemplate(
                getContent(""composite.complex.network.yaml""));

        expectedTemplateYaml = serializeCompositeTemplate(expectedTemplate);

        DockerCompose compose2 = deserializeDockerCompose(
                getContent(""docker.complex.network.yaml""));

        CompositeTemplate template2 = fromDockerComposeToCompositeTemplate(compose2);
        template2.name = expectedTemplate.name; // because of the timestamp

        assertComponentTypes(template2.components);
        assertContainersComponents(ResourceType.CONTAINER_TYPE.getContentType(), 3,
                template2.components);
        assertContainersComponents(ResourceType.NETWORK_TYPE.getContentType(), 3,
                template2.components);
        assertContainersComponents(ResourceType.VOLUME_TYPE.getContentType(), 0,
                template2.components);

        String template2Yaml = serializeCompositeTemplate(template2);

        assertEqualsYamls(toUnixLineEnding(getContent(""composite.simple.network.expected.yaml"")),
                toUnixLineEnding(template2Yaml), true);
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testDeserializeCompositeTemplateWithBindings() throws IOException {
        String expectedContent = getContent(""composite.bindings.yaml"");

        CompositeTemplate compositeTemplate = deserializeCompositeTemplate(expectedContent);

        ContainerDescription wpData = (ContainerDescription) compositeTemplate.components
                .get(""wordpress"").data;
        assertEquals(null, wpData._cluster);
        assertFalse(wpData.customProperties.containsKey(""mysql_user""));

        assertEquals(1, compositeTemplate.bindings.size());

        List<Binding> bindings = compositeTemplate.bindings.iterator().next().bindings;
        assertEquals(3, bindings.size());

        Map<Boolean, List<Binding>> partitionedBindings = bindings.stream()
                .collect(Collectors.partitioningBy(b -> b.isProvisioningTimeBinding()));

        assertEquals(1, partitionedBindings.get(false).size());

        Binding binding = partitionedBindings.get(false).get(0);
        assertFalse(binding.isProvisioningTimeBinding());
        assertEquals(""db~_cluster"", binding.placeholder.bindingExpression);

        // provisioning time bindings
        assertEquals(2, partitionedBindings.get(true).size());

        binding = partitionedBindings.get(true).get(0);
        assertTrue(binding.isProvisioningTimeBinding());
        assertEquals(""_resource~db~address"", binding.placeholder.bindingExpression);

        binding = partitionedBindings.get(true).get(1);
        assertTrue(binding.isProvisioningTimeBinding());
        assertEquals(""_resource~db~env~MYSQL_USER"", binding.placeholder.bindingExpression);

        // validate ""normalizeBindings""

        String expectedContentSerialized = serializeCompositeTemplate(compositeTemplate);

        assertFalse(expectedContent.contains(""bindings:""));
        assertFalse(expectedContentSerialized.contains(""bindings:""));

        assertTrue(expectedContent.contains(""${db~_cluster}",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testDeserializeSerializeComplexDockerComposeWithNetwork() throws IOException {

        String expectedContent = getContent(""docker.complex.network.yaml"");

        DockerCompose compose = deserializeDockerCompose(expectedContent);

        String content = serializeDockerCompose(compose);

        assertEqualsYamls(toUnixLineEnding(expectedContent), toUnixLineEnding(content));

        CompositeTemplate template = fromDockerComposeToCompositeTemplate(compose);

        assertNull(template.id);
        assertNull(template.status);
        assertComponentTypes(template.components);
        assertContainersComponents(ResourceType.CONTAINER_TYPE.getContentType(), 3,
                template.components);
        assertContainersComponents(ResourceType.NETWORK_TYPE.getContentType(), 3,
                template.components);
        assertContainersComponents(ResourceType.VOLUME_TYPE.getContentType(), 0,
                template.components);

        String contentTemplate = serializeCompositeTemplate(template);

        assertTrue((contentTemplate != null) && (!contentTemplate.isEmpty()));
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testSeriaizeDeserializeCompositeTemplateWithHealthCheck() throws IOException {

        // Assert that healthConfig.ignoreOnProvision is serialized when false
        String expectedContent = getContent(""composite.simple.health.yaml"");

        CompositeTemplate template = deserializeCompositeTemplate(expectedContent);

        ContainerDescription data = (ContainerDescription) template.components.get(""hello"").data;
        assertNotNull(data.healthConfig);
        assertEquals(false, data.healthConfig.ignoreOnProvision);

        // Assert that healthConfig.ignoreOnProvision is serialized when true
        data.healthConfig.ignoreOnProvision = true;
        String content = serializeCompositeTemplate(template);

        template = deserializeCompositeTemplate(content);

        data = (ContainerDescription) template.components.get(""hello"").data;
        assertNotNull(data.healthConfig);
        assertEquals(true, data.healthConfig.ignoreOnProvision);

        // Assert that healthConfig.ignoreOnProvision is not serialized when null
        data.healthConfig = null;
        content = serializeCompositeTemplate(template);
        assertFalse(content.contains(""health_config""));
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testWrongDeserializationExceptions() throws IOException {
        try {
            deserializeCompositeTemplate(getContent(""composite.bad.yaml""));
            fail(""wrong content!"");
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testFromPodContainerEnvVarToContainerDescriptionEnv() {
        EnvVar env = new EnvVar();
        env.value = ""value"";
        env.name = ""name"";

        List<EnvVar> envVars = Arrays.asList(env);

        String[] envs = KubernetesConverter.fromPodContainerEnvVarToContainerDescriptionEnv(envVars);
        assertNotNull(envs);
        assertEquals(String.format(""%s=%s"", env.name, env.value), envs[0]);
    }",No Smells
"@Test
    public void testConstructKubeConfigWithBearerToken() {
        String clusterAddress = ""https://testhost:8443"";
        String token = ""bearer_token"";

        AuthCredentialsServiceState creds = new AuthCredentialsServiceState();
        creds.privateKey = token;
        creds.type = AuthCredentialsType.Bearer.toString();
        KubeConfig config = KubernetesUtil.constructKubeConfig(clusterAddress, creds);

        assertNotNull(config);
        assertEquals(token, config.users.get(0).user.token);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testConstructKubeConfigWithPassword() {
        String clusterAddress = ""https://testhost:8443"";
        String username = ""user1"";
        String password = ""password123"";

        AuthCredentialsServiceState creds = new AuthCredentialsServiceState();
        creds.userEmail = username;
        creds.privateKey = password;
        creds.type = AuthCredentialsType.Password.toString();
        KubeConfig config = KubernetesUtil.constructKubeConfig(clusterAddress, creds);

        assertNotNull(config);
        assertEquals(username, config.users.get(0).user.username);
        assertEquals(password, config.users.get(0).user.password);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testDeserializeKubernetesEntityHasCorrectClass() throws IOException {
        assertEquals(Pod.class,
                KubernetesUtil.deserializeKubernetesEntity(podYaml).getClass());
        assertEquals(PodTemplate.class,
                KubernetesUtil.deserializeKubernetesEntity(podTemplateYaml).getClass());
        assertEquals(ReplicationController.class,
                KubernetesUtil.deserializeKubernetesEntity(replicationControllerYaml).getClass());
        assertEquals(Deployment.class,
                KubernetesUtil.deserializeKubernetesEntity(deploymentYaml).getClass());
        assertEquals(Service.class,
                KubernetesUtil.deserializeKubernetesEntity(serviceYamlFormat).getClass());
        assertEquals(BaseKubernetesObject.class,
                KubernetesUtil.deserializeKubernetesEntity(secretYaml).getClass());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testFromContainerDescriptionHealthConfigToPodContainerProbe() {
        Probe expectedProbe1 = new Probe();
        expectedProbe1.exec = new ExecAction();
        expectedProbe1.exec.command = new String[] { ""test"", ""command"" }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testFromPodContainerCommandToContainerDescriptionCommand() {
        assertNull(fromPodContainerCommandToContainerDescriptionCommand(null, null));

        assertNull(fromPodContainerCommandToContainerDescriptionCommand(new ArrayList<>(),
                Collections.singletonList(""ps"")));

        List<String> podCommand = Arrays.asList(""admiral"", ""rm"");
        List<String> podCommandArgs = Arrays.asList(""container1"", ""container2"", ""container3"");

        List<String> expectedContainerDescriptionCmd = Arrays.asList(""admiral"", ""rm"", ""container1"",
                ""container2"", ""container3"");
        List<String> actualContainerDescriptionCmd = fromPodContainerCommandToContainerDescriptionCommand(
                podCommand, podCommandArgs);

        for (int i = 0; i < expectedContainerDescriptionCmd.size(); i++) {
            assertEquals(expectedContainerDescriptionCmd.get(i), actualContainerDescriptionCmd
                    .get(i));
        }",No Smells
"@Test
    public void testGetStateTypeFromSelfLink() {
        String selfLink = ""/resources/kubernetes-pods/376fdq673"";
        Class<? extends BaseKubernetesState> expectedClass = PodState.class;
        Class<? extends BaseKubernetesState> actualClass = getStateTypeFromSelfLink(selfLink);
        assertEquals(expectedClass, actualClass);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testMapApplicationSuffix() throws IOException {
        String suffix = ""generate-mcm-10"";
        String serviceYaml = serviceYamlFormat.replaceAll(""_sufix"", """");
        String expetedMappedServiceYaml = serviceYamlFormat.replaceAll(""_sufix"", ""-"" + suffix);

        KubernetesDescription kd = new KubernetesDescription();
        kd.kubernetesEntity = serviceYaml;

        kd = KubernetesUtil.mapApplicationAffix(kd, suffix);

        assertEquals(expetedMappedServiceYaml, kd.kubernetesEntity);
    }",No Smells
"@Test
    public void testSetApplicationLabelOnInvalidDeployment() {
        KubernetesDescription kd = new KubernetesDescription();
        kd.kubernetesEntity = invalidDeploymentYaml;
        kd.type = DEPLOYMENT_TYPE;

        String testCompositeId = ""123456"";

        // Make sure the is no NPE
        kd = KubernetesUtil.setApplicationLabel(kd, testCompositeId);
    }",No Smells
"@Test
    public void testSetApplicationLabelOnReplicaSet() throws IOException {
        KubernetesDescription kd = new KubernetesDescription();
        kd.kubernetesEntity = replicaSetYaml;
        kd.type = KubernetesUtil.REPLICA_SET_TYPE;

        String testCompositeId = ""123456"";

        kd = KubernetesUtil.setApplicationLabel(kd, testCompositeId);

        ReplicaSet replicaSet = kd.getKubernetesEntity(ReplicaSet.class);

        assertNotNull(replicaSet);
        assertNotNull(replicaSet.metadata);
        assertNotNull(replicaSet.metadata.labels);
        assertEquals(testCompositeId,
                replicaSet.metadata.labels.get(KUBERNETES_LABEL_APP_ID));

        assertNotNull(replicaSet.spec);
        assertNotNull(replicaSet.spec.template);
        assertNotNull(replicaSet.spec.template.metadata);
        assertNotNull(replicaSet.spec.template.metadata.labels);
        assertEquals(testCompositeId,
                replicaSet.spec.template.metadata.labels.get(KUBERNETES_LABEL_APP_ID));
    }",No Smells
"@Test
    public void testSetApplicationLabelOnReplicationController() throws IOException {
        KubernetesDescription kd = new KubernetesDescription();
        kd.kubernetesEntity = replicationControllerYaml;
        kd.type = KubernetesUtil.REPLICATION_CONTROLLER_TYPE;

        String testCompositeId = ""123456"";

        kd = KubernetesUtil.setApplicationLabel(kd, testCompositeId);

        ReplicationController replicationController = kd
                .getKubernetesEntity(ReplicationController.class);

        assertNotNull(replicationController);
        assertNotNull(replicationController.metadata);
        assertNotNull(replicationController.metadata.labels);
        assertEquals(testCompositeId,
                replicationController.metadata.labels.get(KUBERNETES_LABEL_APP_ID));

        assertNotNull(replicationController.spec);
        assertNotNull(replicationController.spec.template);
        assertNotNull(replicationController.spec.template.metadata);
        assertNotNull(replicationController.spec.template.metadata.labels);
        assertEquals(testCompositeId,
                replicationController.spec.template.metadata.labels.get(KUBERNETES_LABEL_APP_ID));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testSetApplicationLabelOnService() throws IOException {
        KubernetesDescription kd = new KubernetesDescription();
        kd.kubernetesEntity = serviceYamlFormat;
        kd.type = SERVICE_TYPE;

        String testCompositeId = ""123456"";

        kd = KubernetesUtil.setApplicationLabel(kd, testCompositeId);

        Service service = kd.getKubernetesEntity(Service.class);

        assertNotNull(service);
        assertNotNull(service.metadata);
        assertNotNull(service.metadata.labels);
        assertEquals(testCompositeId, service.metadata.labels.get(KUBERNETES_LABEL_APP_ID));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testSetPodContainerResourcesToContainerDescriptionResources() {
        Container podContainer = new Container();
        podContainer.resources = new ResourceRequirements();
        podContainer.resources.limits = new HashMap<>();
        podContainer.resources.limits.put(""memory"", ""100M"");
        podContainer.resources.limits.put(""cpu"", ""500m"");

        ContainerDescription containerDescription = new ContainerDescription();

        setPodContainerResourcesToContainerDescriptionResources(podContainer, containerDescription);

        Long expectedMemoryLimit = 100000000L;
        Long actualMemoryLimit = containerDescription.memoryLimit;

        Integer expectedCpuShares = 1;
        Integer actualCpuShares = containerDescription.cpuShares;

        assertEquals(expectedMemoryLimit, actualMemoryLimit);
        assertEquals(expectedCpuShares, actualCpuShares);
    }",No Smells
"@Test
    public void testCreateDelete() throws Throwable {
        ElasticPlacementZoneConfigurationState state = createState(true);
        state.resourcePoolState = buildRpState();
        state.epzState = buildEpzState(null, ""tag1"", ""tag2"");
        ElasticPlacementZoneConfigurationState createdState = sendState(state, Action.POST);

        delete(ElasticPlacementZoneConfigurationService.SELF_LINK
                + createdState.resourcePoolState.documentSelfLink);

        assertNull(
                searchForDocument(ResourcePoolState.class, createdState.resourcePoolState.documentSelfLink));
        assertNull(searchForDocument(ElasticPlacementZoneState.class,
                createdState.epzState.documentSelfLink));
    }",Mystery Guest
"@Test
    public void testCreateNoEpz() throws Throwable {
        ElasticPlacementZoneConfigurationState state = createState(true);
        state.resourcePoolState = buildRpState();
        ElasticPlacementZoneConfigurationState returnedState = sendState(state, Action.POST);

        assertNotNull(returnedState.resourcePoolState.documentSelfLink);
        assertNotNull(searchForDocument(ResourcePoolState.class,
                returnedState.resourcePoolState.documentSelfLink));
        assertEquals(state.resourcePoolState.name, returnedState.resourcePoolState.name);
    }",Mystery Guest
"@Test
    public void testUpdateNoChange() throws Throwable {
        // create through the config service
        ElasticPlacementZoneConfigurationState state = createState(true);
        state.resourcePoolState = buildRpState();
        ElasticPlacementZoneConfigurationState createdState = sendState(state, Action.POST);

        // update through the config service
        ElasticPlacementZoneConfigurationState patchState = createState(false);
        patchState.resourcePoolState = buildRpState();
        patchState.resourcePoolState.documentSelfLink =
                createdState.resourcePoolState.documentSelfLink;
        ElasticPlacementZoneConfigurationState latestState = sendState(patchState, Action.PATCH);

        // validate returned state
        assertNull(latestState.resourcePoolState);
        assertNull(latestState.epzState);
    }",No Smells
"@Test
    public void testUpdateNoEpz() throws Throwable {
        // create through the config service
        ElasticPlacementZoneConfigurationState state = createState(false);
        state.resourcePoolState = buildRpState();
        ElasticPlacementZoneConfigurationState createdState = sendState(state, Action.POST);

        // update through the config service
        ElasticPlacementZoneConfigurationState patchState = createState(false);
        patchState.resourcePoolState.documentSelfLink =
                createdState.resourcePoolState.documentSelfLink;
        patchState.resourcePoolState.name = ""new-name"";
        ElasticPlacementZoneConfigurationState latestState = sendState(patchState, Action.PATCH);

        // validate returned state
        assertEquals(""new-name"", latestState.resourcePoolState.name);
        assertNotNull(latestState.resourcePoolState.query);

        // validate the actual RP state
        ResourcePoolState rp = getDocument(ResourcePoolState.class,
                createdState.resourcePoolState.documentSelfLink);
        assertEquals(""new-name"", rp.name);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testCreateAndDelete() throws Throwable {
        // create a non-elastic RP
        ResourcePoolState rp = createRp();
        assertEquals(EnumSet.noneOf(ResourcePoolProperty.class), rp.properties);
        assertTrue(isNonElasticQuery(rp.query));

        // create EPZ for the RP
        String epzLink = createEpz(rp.documentSelfLink, ""tag1"", ""tag2"").documentSelfLink;

        // verify RP is now elastic
        rp = getDocument(ResourcePoolState.class, rp.documentSelfLink);
        assertEquals(EnumSet.of(ResourcePoolProperty.ELASTIC), rp.properties);
        assertFalse(isNonElasticQuery(rp.query));

        // delete EPZ and verify RP is back to non-elastic
        delete(epzLink);
        rp = getDocument(ResourcePoolState.class, rp.documentSelfLink);
        assertEquals(EnumSet.noneOf(ResourcePoolProperty.class), rp.properties);
        assertTrue(isNonElasticQuery(rp.query));
    }",No Smells
"@Test
    public void testElasticQuery() throws Throwable {
        ResourcePoolState containerRp = createRp(null, Arrays.asList(""A"", ""B""));

        createEpz(containerRp.documentSelfLink, ""tag1"", ""tag2"");

        containerRp = getDocument(ResourcePoolState.class, containerRp.documentSelfLink);

        List<ComputeState> matchingContainerHosts = Arrays.asList(
                createCompute(ComputeType.VM_GUEST, null, null, Arrays.asList(""tag1"", ""tag2""),
                        Arrays.asList(""A"", ""B"")),
                createCompute(ComputeType.VM_GUEST, null, containerRp.documentSelfLink, null,
                        Arrays.asList(""A"", ""B"")),
                createCompute(ComputeType.VM_GUEST, null, null, Arrays.asList(""tag1"", ""tag2"", ""tag3""),
                        Arrays.asList(""A"", ""B"")));
        List<ComputeState> notMatchingContainerHosts = Arrays.asList(
                createCompute(ComputeType.VM_GUEST, null, null, Arrays.asList(""tag1""),
                        Arrays.asList(""A"", ""B"")),
                createCompute(ComputeType.VM_GUEST, null, null, Arrays.asList(""tag1"", ""tag2""),
                        Arrays.asList(""X"", ""Y"", ""Z"")));

        assertEqualComputes(executeRpQuery(containerRp), matchingContainerHosts);
    }",No Smells
"@Test
    public void testPatch() throws Throwable {
        // create a non-elastic RP
        ResourcePoolState rp = createRp();
        assertEquals(EnumSet.noneOf(ResourcePoolProperty.class), rp.properties);
        assertTrue(isNonElasticQuery(rp.query));

        // create EPZ for the RP
        String epzLink = createEpz(rp.documentSelfLink, ""tag1"", ""tag2"").documentSelfLink;

        // verify RP is now elastic
        rp = getDocument(ResourcePoolState.class, rp.documentSelfLink);
        assertEquals(EnumSet.of(ResourcePoolProperty.ELASTIC), rp.properties);
        assertFalse(isNonElasticQuery(rp.query));

        // add more tags and verify RP query is updated
        patchEpz(epzLink, ""tag3"", ""tag4"");
        rp = getDocument(ResourcePoolState.class, rp.documentSelfLink);
        assertEquals(EnumSet.of(ResourcePoolProperty.ELASTIC), rp.properties);
    }",No Smells
"@Test
    public void testPatchNoChange() throws Throwable {
        // create a non-elastic RP
        ResourcePoolState rp = createRp();
        assertEquals(EnumSet.noneOf(ResourcePoolProperty.class), rp.properties);
        assertTrue(isNonElasticQuery(rp.query));

        // create EPZ for the RP
        String epzLink = createEpz(rp.documentSelfLink, ""tag1"", ""tag2"").documentSelfLink;

        ElasticPlacementZoneState patchState = new ElasticPlacementZoneState();
        patchState.tagLinksToMatch = tagSet(""tag1"");

        Operation patchOp = Operation.createPatch(host, epzLink).setBody(patchState).forceRemote();
        Operation returnedOp = ((CompletableFuture<Operation>) host.sendWithDeferredResult(patchOp)
                .toCompletionStage()).get(60, TimeUnit.SECONDS);
        assertEquals(Operation.STATUS_CODE_NOT_MODIFIED, returnedOp.getStatusCode());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testCreateKubernetesDescriptionWithInvalidKubernetesShouldFail() {
        KubernetesDescription description = new KubernetesDescription();
        description.kubernetesEntity = sampleYamlInvalidKubernetesDefinition;

        Operation op = Operation.createPost(UriUtils.buildUri(host, KubernetesDescriptionService
                .FACTORY_LINK))
                .setBody(description)
                .setCompletion((o, ex) -> {
                    if (ex != null) {
                        host.log(""Creating kubernetes description failed."");
                        host.completeIteration();
                        return;
                    }",No Smells
"@Test
    public void testCreateKubernetesDescriptionWithInvalidYamlInputShouldFail() {
        KubernetesDescription description = new KubernetesDescription();
        description.kubernetesEntity = ""invalid\nyaml\ninput"";

        Operation op = Operation.createPost(UriUtils.buildUri(host, KubernetesDescriptionService
                .FACTORY_LINK))
                .setBody(description)
                .setCompletion((o, ex) -> {
                    if (ex != null) {
                        host.log(""Creating kubernetes description failed."");
                        if (!ex.getMessage().startsWith(""Invalid YAML input."")) {
                            host.failIteration(
                                    new IllegalStateException(
                                            ""Creation of kubernetes description failed with unexpected message: ""
                                                    + ex.getMessage()));
                        }",No Smells
"@Test
    public void testDiscoverSingleEntity() throws Throwable {
        BaseKubernetesState entity = new PodState();
        entity.name = ""entity"";
        entity.id = ""id"";
        MockKubernetesAdapterService
                .addEntity(makeEntity(entity.id, entity.name, KubernetesUtil.POD_TYPE, null));

        startDataCollectionAndWait();

        List<PodState> entities = getEntities(PodState.class);
        Assert.assertEquals(1, entities.size());
        Assert.assertEquals(entity.id, entities.get(0).id);
        Assert.assertEquals(entity.name, entities.get(0).name);
    }",No Smells
"@Test
    public void testLog() throws Throwable {
        PodState podState = createPodState();
        createLogStates(podState);
        Map<String, LogServiceState> logsMap = getPodLogs(podState);

        assertNotNull(logsMap);
        assertEquals(6, logsMap.size());
        for (int i = 0; i < podState.pod.spec.containers.size(); i++) {
            Container temp = podState.pod.spec.containers.get(i);
            assertTrue(logsMap.containsKey(temp.name));
            assertEquals(""test-log-"" + i, new String(logsMap.get(temp.name).logs));

        }",No Smells
"@Test
    public void testCreateTheSameEndpointInDifferentTenantPasses() throws Throwable {
        Endpoint endpoint = new Endpoint();
        endpoint.apiEndpoint = ""https://localhost"";
        endpoint.uaaEndpoint = ""https://localhost"";
        endpoint.tenantLinks = Collections
                .singletonList(QueryUtil.TENANT_IDENTIFIER + ""some-tenant"");

        EndpointSpec endpointSpec = new EndpointSpec();
        endpointSpec.acceptHostAddress = true;
        endpointSpec.acceptCertificate = true;
        endpointSpec.endpoint = endpoint;

        createEndpoint(endpointSpec);

        endpoint = new Endpoint();
        endpoint.apiEndpoint = ""https://localhost"";
        endpoint.uaaEndpoint = ""https://localhost"";
        endpoint.tenantLinks = Collections
                .singletonList(QueryUtil.TENANT_IDENTIFIER + ""another-tenant"");
        endpointSpec.endpoint = endpoint;

        createEndpoint(endpointSpec);
    }",No Smells
"@Test
    public void testStoreCertLinkInEndpoint() {
        EndpointSpec spec = new EndpointSpec();
        Endpoint endpoint = new Endpoint();
        spec.endpoint = endpoint;
        assertNull(endpoint.customProperties);

        final String testProp = ""test-property"";
        final String testValue = ""test-value"";

        PKSCreateEndpointService.storeCertLinkInEndpoint(spec, testProp, testValue);
        assertNotNull(endpoint.customProperties);
        assertEquals(testValue, endpoint.customProperties.get(testProp));
    }",No Smells
"@Test
    public void testValidateConnection() {
        // validate

        Endpoint endpoint = new Endpoint();
        endpoint.apiEndpoint = ""https://localhost"";
        endpoint.uaaEndpoint = ""https://localhost"";

        EndpointSpec endpointSpec = new EndpointSpec();
        endpointSpec.acceptHostAddress = true;
        endpointSpec.acceptCertificate = true;
        endpointSpec.endpoint = endpoint;

        Operation o = Operation
                .createPut(UriUtils.buildUri(host, PKSCreateEndpointService.SELF_LINK,
                        ManagementUriParts.REQUEST_PARAM_VALIDATE_OPERATION_NAME))
                .setBodyNoCloning(endpointSpec);

        TestRequestSender.FailureResponse failure = sender.sendAndWaitFailure(o);
        assertNotNull(failure);
        assertTrue(failure.failure.getMessage().startsWith(""Unexpected error: Service not found:""));
        assertTrue(failure.failure.getMessage().endsWith(""/adapters/pks-service""));
    }",No Smells
"@Test
    public void testCreate() {
        Endpoint endpoint = new Endpoint();
        endpoint.apiEndpoint = ""http://localhost"";
        endpoint.uaaEndpoint = ""https://localhost"";

        createEndpoint(endpoint);

        endpoint.apiEndpoint = null;
        endpoint.uaaEndpoint = ""http://localhost"";
        createEndpointExpectFailure(endpoint, ser -> {
            assertEquals(Operation.STATUS_CODE_BAD_REQUEST, ser.statusCode);
            assertEquals(""'API endpoint' is required"", ser.message);
        }",Mystery Guest + Resource Optimism
"@Test
    public void testDelete() throws Throwable {
        Endpoint endpoint = new Endpoint();
        endpoint.apiEndpoint = ""http://localhost"";
        endpoint.uaaEndpoint = ""https://localhost"";

        endpoint = createEndpoint(endpoint);

        delete(endpoint.documentSelfLink);
        endpoint = getDocumentNoWait(Endpoint.class, endpoint.documentSelfLink);
        assertNull(endpoint);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testDeleteEndpointAndClusters() throws Throwable {
        Endpoint endpoint = new Endpoint();
        endpoint.apiEndpoint = ""http://localhost"";
        endpoint.uaaEndpoint = ""https://localhost"";

        endpoint = createEndpoint(endpoint);
        ClusterDto clusterDto = createCluster(endpoint.documentSelfLink);

        delete(endpoint.documentSelfLink);
        endpoint = getDocumentNoWait(Endpoint.class, endpoint.documentSelfLink);
        assertNull(endpoint);

        clusterDto = getDocumentNoWait(ClusterDto.class, clusterDto.documentSelfLink);
        assertNull(endpoint);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testComputeCalculations() throws Throwable {
        ResourcePoolState rp = createResourcePool();
        ComputeDescription cd1 = createComputeDescription(ComputeType.VM_GUEST.toString(),
                1_000_000L, 2L, 1_000L);
        ComputeDescription cd2 = createComputeDescription(ComputeType.VM_GUEST.toString(),
                2_000_000L, 4L, 2_000L);
        ComputeDescription cd3 = createComputeDescription(ComputeType.VM_GUEST.toString(),
                3_000_000L, 8L, 4_000L);
        createComputeState(cd1.documentSelfLink, rp.documentSelfLink);
        createComputeState(cd2.documentSelfLink, rp.documentSelfLink);
        ComputeState c3 = createComputeState(cd3.documentSelfLink, rp.documentSelfLink);

        startAndWaitForTask(rp.documentSelfLink);
        validateFigures(rp.documentSelfLink, 6_000_000L, null, 6_000_000L, 0.0);

        delete(c3.documentSelfLink);
        startAndWaitForTask(rp.documentSelfLink);
        validateFigures(rp.documentSelfLink, 3_000_000L, null, 3_000_000L, 0.0);
    }",No Smells
"@Test
    public void testPlainHttpRegistriesAllowed() throws Throwable {

        // allow plain HTTP registries explicitly
        ConfigurationState config = new ConfigurationState();
        config.key = RegistryHostConfigService.ALLOW_REGISTRY_PLAIN_HTTP_CONNECTION_PROP_NAME;
        config.value = Boolean.toString(true);
        ConfigurationUtil.initialize(config);

        RegistryState registryState = new RegistryState();
        registryState.name = UUID.randomUUID().toString();
        registryState.address = host.getUri().toString();
        assertTrue(registryState.address.startsWith(""http://""));
        registryState.endpointType = RegistryState.DOCKER_REGISTRY_ENDPOINT_TYPE;

        RegistryHostSpec registryHostSpec = new RegistryHostSpec();
        registryHostSpec.hostState = registryState;

        URI registryUri = UriUtils.buildUri(host, RegistryHostConfigService.SELF_LINK);

        // Try to create/update the registry
        try {
            doOperation(registryHostSpec, registryUri, RegistryHostSpec.class, false, Action.PUT);
            fail(""Plain HTTP should be supported!"");
        }",No Smells
"@Test
    public void testContainerHostDataCollectionServiceCreatedOnStartUp() throws Throwable {
        waitForServiceAvailability(ContainerHostDataCollectionService
                .HOST_INFO_DATA_COLLECTION_LINK);
        ContainerHostDataCollectionState dataCollectionState = getDocument(
                ContainerHostDataCollectionState.class,
                ContainerHostDataCollectionService.HOST_INFO_DATA_COLLECTION_LINK);

        assertNotNull(dataCollectionState);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testDefaultGroupPlacementServiceCreatedOnStartUp() throws Throwable {
        waitForServiceAvailability(GroupResourcePlacementService.DEFAULT_RESOURCE_PLACEMENT_LINK);
        GroupResourcePlacementState groupResourcePlacementState = getDocument(
                GroupResourcePlacementState.class,
                GroupResourcePlacementService.DEFAULT_RESOURCE_PLACEMENT_LINK);

        assertNotNull(groupResourcePlacementState);
        assertEquals(GroupResourcePlacementService.DEFAULT_RESOURCE_PLACEMENT_ID,
                groupResourcePlacementState.name);
        assertEquals(GroupResourcePlacementService.DEFAULT_RESOURCE_POOL_LINK,
                groupResourcePlacementState.resourcePoolLink);
        assertEquals(1000000, groupResourcePlacementState.maxNumberInstances);
        assertEquals(100, groupResourcePlacementState.priority);
        assertNull(groupResourcePlacementState.tenantLinks);// assert global default group placement
    }",Mystery Guest + Resource Optimism
"@Test
    public void testHostContainerListDataCollectionServiceCreatedOnStartUp() throws Throwable {
        waitForServiceAvailability(HostContainerListDataCollection
                .DEFAULT_HOST_CONTAINER_LIST_DATA_COLLECTION_LINK);
        HostContainerListDataCollectionState dataCollectionState = getDocument(
                HostContainerListDataCollectionState.class,
                HostContainerListDataCollection.DEFAULT_HOST_CONTAINER_LIST_DATA_COLLECTION_LINK);

        assertNotNull(dataCollectionState);
        assertEquals(TaskStage.STARTED, dataCollectionState.taskInfo.stage);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testSearchForDockerImageSucceeds() throws Exception {
        verifyImageIsFound(TEST_IMAGE_DOCKER_HUB_FULL_ADDRESS, TENANT);
    }",No Smells
"@Test
    public void testSearchForDockerImageSucceeds() throws Exception {
        verifyImageIsFound(TEST_IMAGE_DOCKER_HUB_FULL_ADDRESS, TENANT);
    }",No Smells
"@Test
    public void testFailForNonexistentRegistry() throws Exception {
        String imageName = toFullImageName(""nonexisting-registry.admiral.test"", TEST_IMAGE);
        verifyListTagsFailure(imageName, TENANT);
    }",No Smells
"@Test
    public void testSearchImageFromDocker() throws Exception {

        // Simple search against the ContainerImageService. No extra registry is configured but the
        // default Docker one should be available at least.

        URI searchUri = UriUtils.buildUri(host, ContainerImageService.SELF_LINK);
        searchUri = UriUtils.extendUriWithQuery(searchUri,
                RegistryAdapterService.SEARCH_QUERY_PROP_NAME, TEST_IMAGE);

        HttpResponse search = SimpleHttpsClient.execute(HttpMethod.GET, searchUri.toString());
        assertEquals(HTTP_OK, search.statusCode);

        assertNotNull(search.responseBody);
        RegistrySearchResponse response = Utils.fromJson(search.responseBody,
                RegistrySearchResponse.class);

        assertNotNull(response);
        assertTrue(response.numResults > 0);
        assertNotNull(response.results);

        response.results.forEach((result) -> {
            assertNotNull(result);
            assertNotNull(result.name);
            assertEquals(DOCKER_REGISTRY, result.registry); // from the Docker registry
            assertTrue(result.name.startsWith(DEFAULT_REGISTRY_HOSTNAME));
            assertTrue(result.name.contains(TEST_IMAGE));
        }",No Smells
"@Test
    public void testCreateClusterWithIntercept() throws Throwable {
        ContainerHostSpec hostSpec = new ContainerHostSpec();
        hostSpec.hostState = new ComputeState();
        hostSpec.hostState.id = UUID.randomUUID().toString();
        hostSpec.hostState.address = ""test"";
        hostSpec.hostState.customProperties = new HashMap<>();
        hostSpec.hostState.customProperties.put(ContainerHostService
                        .HOST_DOCKER_ADAPTER_TYPE_PROP_NAME, ""API"");
        hostSpec.hostState.customProperties.put(ContainerHostService.CONTAINER_HOST_TYPE_PROP_NAME,
                ""DOCKER"");

        ClusterDto dto = doPostWithProjectHeader(hostSpec, ClusterService.SELF_LINK, project
                .documentSelfLink, ClusterDto.class);

        ComputeState computeState = getDocument(ComputeState.class, dto.nodeLinks.get(0));

        assertTrue(computeState.tenantLinks.contains(project.documentSelfLink));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testCreateCompositeComponentIntercept() {
        CompositeComponent state = new CompositeComponent();
        state.name = ""test"";
        state.componentLinks = Collections.singletonList(""test"");

        CompositeComponent doc = doPostWithProjectHeader(state, CompositeComponentFactoryService
                .SELF_LINK, project.documentSelfLink, CompositeComponent.class);

        assertTenantLinks(doc, project.documentSelfLink);
        assertEquals(state.name, doc.name);
        assertEquals(state.componentLinks, doc.componentLinks);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testCreateContainerDescriptionIntercept() throws Throwable {
        ContainerDescription desc = new ContainerDescription();
        desc.name = ""test"";
        desc.image = ""test"";

        ContainerDescription newDesc = doPostWithProjectHeader(desc, ContainerDescriptionService
                .FACTORY_LINK, project.documentSelfLink, ContainerDescription.class);

        assertTenantLinks(newDesc, project.documentSelfLink);
        assertEquals(desc.name, newDesc.name);
        assertEquals(desc.image, newDesc.image);
    }",No Smells
"@Test
    public void testCreateContainerNetworkIntercept() {
        ContainerNetworkState state = new ContainerNetworkState();
        state.name = ""test"";
        state.powerState = PowerState.CONNECTED;

        ContainerNetworkState doc = doPostWithProjectHeader(state, ContainerNetworkService
                .FACTORY_LINK, project.documentSelfLink, ContainerNetworkState.class);

        assertTenantLinks(doc, project.documentSelfLink);
        assertEquals(state.name, doc.name);
        assertEquals(state.powerState, doc.powerState);
    }",No Smells
"@Test
    public void testCreateContainerVolumeDescriptionIntercept() {
        ContainerVolumeDescription state = new ContainerVolumeDescription();
        state.name = ""test"";
        state.externalName = ""test"";

        ContainerVolumeDescription doc = doPostWithProjectHeader(state,
                ContainerVolumeDescriptionService.FACTORY_LINK, project.documentSelfLink,
                ContainerVolumeDescription.class);

        assertTenantLinks(doc, project.documentSelfLink);
        assertEquals(state.name, doc.name);
        assertEquals(state.externalName, doc.externalName);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testGetCompositeComponent() {
        CompositeComponent state1 = new CompositeComponent();
        state1.name = ""test"";
        state1.componentLinks = Collections.singletonList(""test"");

        CompositeComponent state2 = new CompositeComponent();
        state2.name = ""test"";
        state2.componentLinks = Collections.singletonList(""test"");

        state1 = doPostWithProjectHeader(state1, CompositeComponentFactoryService
                .SELF_LINK, testProject1.documentSelfLink, CompositeComponent.class);

        state2 = doPostWithProjectHeader(state2, CompositeComponentFactoryService
                .SELF_LINK, testProject2.documentSelfLink, CompositeComponent.class);

        ServiceDocumentQueryResult project1Docs = getDocumentsWithinProject(
                CompositeComponentFactoryService.SELF_LINK, testProject1.documentSelfLink);
        assertEquals(1, project1Docs.documentLinks.size());
        assertTrue(project1Docs.documentLinks.contains(state1.documentSelfLink));

        ServiceDocumentQueryResult project2Docs = getDocumentsWithinProject(
                CompositeComponentFactoryService.SELF_LINK, testProject2.documentSelfLink);
        assertEquals(1, project2Docs.documentLinks.size());
        assertTrue(project2Docs.documentLinks.contains(state2.documentSelfLink));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testGetContainerVolumeDescription() {
        ContainerVolumeDescription state1 = new ContainerVolumeDescription();
        state1.name = ""test"";
        state1.externalName = ""test"";

        ContainerVolumeDescription state2 = new ContainerVolumeDescription();
        state2.name = ""test"";
        state2.externalName = ""test"";

        state1 = doPostWithProjectHeader(state1,
                ContainerVolumeDescriptionService.FACTORY_LINK, testProject1.documentSelfLink,
                ContainerVolumeDescription.class);

        state2 = doPostWithProjectHeader(state2,
                ContainerVolumeDescriptionService.FACTORY_LINK, testProject2.documentSelfLink,
                ContainerVolumeDescription.class);

        ServiceDocumentQueryResult project1Docs = getDocumentsWithinProject(
                ContainerVolumeDescriptionService.FACTORY_LINK, testProject1.documentSelfLink);
        assertEquals(1, project1Docs.documentLinks.size());
        assertTrue(project1Docs.documentLinks.contains(state1.documentSelfLink));

        ServiceDocumentQueryResult project2Docs = getDocumentsWithinProject(
                ContainerVolumeDescriptionService.FACTORY_LINK, testProject2.documentSelfLink);
        assertEquals(1, project2Docs.documentLinks.size());
        assertTrue(project2Docs.documentLinks.contains(state2.documentSelfLink));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testGetContainerVolumeDescription() {
        ContainerVolumeDescription state1 = new ContainerVolumeDescription();
        state1.name = ""test"";
        state1.externalName = ""test"";

        ContainerVolumeDescription state2 = new ContainerVolumeDescription();
        state2.name = ""test"";
        state2.externalName = ""test"";

        state1 = doPostWithProjectHeader(state1,
                ContainerVolumeDescriptionService.FACTORY_LINK, testProject1.documentSelfLink,
                ContainerVolumeDescription.class);

        state2 = doPostWithProjectHeader(state2,
                ContainerVolumeDescriptionService.FACTORY_LINK, testProject2.documentSelfLink,
                ContainerVolumeDescription.class);

        ServiceDocumentQueryResult project1Docs = getDocumentsWithinProject(
                ContainerVolumeDescriptionService.FACTORY_LINK, testProject1.documentSelfLink);
        assertEquals(1, project1Docs.documentLinks.size());
        assertTrue(project1Docs.documentLinks.contains(state1.documentSelfLink));

        ServiceDocumentQueryResult project2Docs = getDocumentsWithinProject(
                ContainerVolumeDescriptionService.FACTORY_LINK, testProject2.documentSelfLink);
        assertEquals(1, project2Docs.documentLinks.size());
        assertTrue(project2Docs.documentLinks.contains(state2.documentSelfLink));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testCreateSchedulerPlacementZoneWithTagsShouldFail() throws Throwable {
        ResourcePoolState resourcePoolState = createResourcePoolState(
                ""scheduler-placement-zone-with-tags"", true);
        addTags(resourcePoolState);
        try {
            createPlacementZone(resourcePoolState);
            Assert.fail(""Should fail to create a scheduler placement zone with tags"");
        }",No Smells
"@Test
    public void testPutDockerPZInUseToSchedulerPZShouldFail() throws Throwable {
        // First create a docker placement zone.
        ResourcePoolState createdPlacementZone = createPlacementZone(""docker-placement-zone"",
                false);
        assertNotNull(createdPlacementZone);

        // Now create a compute state that uses this placement zone
        createComputeState(createdPlacementZone);

        // Now update the type of the zone to scheduler and issue a PUT. This should fail
        markSchedulerPlacementZone(createdPlacementZone);
        try {
            doPut(createdPlacementZone);
            Assert.fail(
                    ""PUT should fail to update the type of a used ""
                    + ""docker placement zone to a scheduler zone"");
        }",No Smells
"@Test
    public void testUpdateDockerPZInUseByMultipleVicHostsToSchedulerPZShouldPass() throws Throwable {
        // First create a docker placement zone.
        ResourcePoolState createdPlacementZone = createPlacementZone(""docker-placement-zone"",
                false);
        assertNotNull(createdPlacementZone);

        // Now create 2 VIC hosts that use this placement zone. This can be achieved if the VIC
        // hosts were initially declared as docker but were later on marked as VIC
        createComputeState(createdPlacementZone);
        createComputeState(createdPlacementZone);

        // Now create a PATCH that updates the type of the zone to scheduler. This should fail
        // because there will be multiple container in the placement zone (even if they are all
        // schedulers)
        ResourcePoolState patchState = new ResourcePoolState();
        markSchedulerPlacementZone(patchState);
        try {
            doPatch(patchState, createdPlacementZone.documentSelfLink);
            Assert.fail(
                    ""PATCH should fail to update the type of a docker placement ""
                    + ""zone to a scheduler zone when the placement zone is in use by multiple scheduler hosts"");
        }",No Smells
"@Test
    public void testUpdateEmptyDockerPZToSchedulerPZShouldPass() throws Throwable {
        // First create a docker placement zone.
        ResourcePoolState createdPlacementZone = createPlacementZone(""docker-placement-zone"", false);
        assertNotNull(createdPlacementZone);

        // Now create a PATCH that updates its type to scheduler. This should pass
        ResourcePoolState patchState = new ResourcePoolState();
        markSchedulerPlacementZone(patchState);
        ResourcePoolState patchedState = doPatch(patchState, createdPlacementZone.documentSelfLink);
        assertNotNull(patchedState);
    }",No Smells
"@Test
    public void testUpdateSchedulerPlacementZoneWithTagsShouldFail() throws Throwable {
        // First create a scheduler placement zone.
        ResourcePoolState createdPlacementZone = createPlacementZone(""docker-placement-zone"", true);
        assertNotNull(createdPlacementZone);

        // Now create a PATCH with tags. This should fail
        ResourcePoolState patchState = new ResourcePoolState();
        addTags(patchState);
        try {
            doPatch(patchState, createdPlacementZone.documentSelfLink);
            Assert.fail(""PATCH should fail to set tags for scheduler placement zone"");
        }",No Smells
"@Test
    public void testCredentialsDelete() throws Throwable {
        try (TestManagementHost host = new TestManagementHost(true)) {
            host.start();
            host.startFabricServices();
            host.startManagementServices();

            host.registerForServiceAvailability(host.getTestContext().getCompletion(),
                    AuthCredentialsService.FACTORY_LINK,
                    ComputeDescriptionService.FACTORY_LINK,
                    ComputeService.FACTORY_LINK);
            host.getTestContext().await();

            ComputeDescription computeDescription = doPost(host, new ComputeDescription(),
                    ComputeDescriptionService.FACTORY_LINK);
            AuthCredentialsServiceState credentials = doPost(host,
                    new AuthCredentialsServiceState(), AuthCredentialsService.FACTORY_LINK);

            ComputeState compute = new ComputeState();
            compute.customProperties = new HashMap<>();
            compute.customProperties.put(ComputeConstants.HOST_AUTH_CREDENTIALS_PROP_NAME,
                    credentials.documentSelfLink);
            compute.descriptionLink = computeDescription.documentSelfLink;
            compute = doPost(host, compute, ComputeService.FACTORY_LINK);

            try {
                doDelete(host, UriUtils.buildUri(host, credentials.documentSelfLink));
                fail(""expect validation error during deletion"");
            }",No Smells
"@Test
    public void testManagementHostInitializationNoErrors() throws Throwable {
        try (TestManagementHost host = new TestManagementHost(false)) {
            // we're just verifying that no exceptions are thrown
            assertNull(host.getSecureListener());
        }",No Smells
"@Test
    public void testManagementHostInitializationNoErrorsWithNodeGroup() throws Throwable {
        try (TestManagementHost host = new TestManagementHost(false,
                ARGUMENT_PREFIX + ""publicUri"" + ARGUMENT_ASSIGNMENT + ""http://127.0.0.1:8292"",
                ARGUMENT_PREFIX + ""nodeGroupPublicUri"" + ARGUMENT_ASSIGNMENT
                        + ""http://127.0.0.1:8292"",
                ARGUMENT_PREFIX + ""peerList"" + ARGUMENT_ASSIGNMENT + ""http://127.0.0.1:8292"")) {
            // we're just verifying that no exceptions are thrown
        }",No Smells
"@Test
    public void testManagementHostInitializationWithEncryptionNoErrors() throws Throwable {

        File keyFile = Paths.get(folder.newFolder().getPath(), ""encryption.key"").toFile();
        System.setProperty(EncryptionUtils.ENCRYPTION_KEY, keyFile.getPath());
        System.setProperty(EncryptionUtils.INIT_KEY_IF_MISSING, ""true"");
        EncryptionUtils.initEncryptionService();

        try (TestManagementHost host = new TestManagementHost(false)) {
            // we're just verifying that no exceptions are thrown
            assertNull(host.getSecureListener());
        }",No Smells
"@Test
    public void testMigration() throws Throwable {
        startMigrationTaskService(targetHost);

        // do the migration
        MigrationRequest request = new MigrationRequest();
        request.sourceNodeGroup = host.getPublicUriAsString() + DEAFULT_NODE_GROUP;
        this.targetHost.testStart(1);
        Operation post = Operation.createPost(UriUtils.buildUri(targetHost.getUri(),
                NodeMigrationService.SELF_LINK));
        post.setBody(request);
        post.setCompletion((o, e) -> {
            if (e != null) {
                this.targetHost.failIteration(e);
                return;
            }",No Smells
"@Test
    public void testMigrationServiceNotAvailable() {
        // Do not start migration service on target host

        MigrationRequest request = new MigrationRequest();
        request.sourceNodeGroup = host.getPublicUriAsString() + DEAFULT_NODE_GROUP;
        this.targetHost.testStart(1);
        Operation post = Operation
                .createPost(UriUtils.buildUri(targetHost.getUri(), NodeMigrationService.SELF_LINK));
        post.setBody(request);
        post.setCompletion((o, e) -> {
            if (e != null) {
                // failure is expected!
                assertEquals(""Failure when calling migration task"", e.getMessage());
                this.targetHost.completeIteration();
                return;
            }",No Smells
"@Test
    public void testMigrationTaskFailure() throws Throwable {
        startMigrationTaskService(targetHost);

        // stop compute service in order to produce migration task failure
        ComputeService computeService = new ComputeService();
        computeService.setSelfLink(ComputeService.FACTORY_LINK);
        targetHost.stopService(computeService);

        MigrationRequest request = new MigrationRequest();
        request.sourceNodeGroup = host.getPublicUriAsString() + DEAFULT_NODE_GROUP;
        this.targetHost.testStart(1);
        Operation post = Operation
                .createPost(UriUtils.buildUri(targetHost.getUri(), NodeMigrationService.SELF_LINK));
        post.setBody(request);
        post.setCompletion((o, e) -> {
            if (e != null) {
                // failure is expected!
                assertEquals(""One or more migration tasks failed"", e.getMessage());
                this.targetHost.completeIteration();
                return;
            }",No Smells
"@Test
    public void testGetApiMethods() throws NoSuchMethodException {
        List<Method> actualMethods = SwaggerDocumentationUtils.getApiMethods(AnnotatedServiceMock.class).collect(Collectors.toList());
        List<Method> expectedMethods = new LinkedList<>();
        expectedMethods.add(AnnotatedServiceMock.class.getMethod(""handleGet""));
        expectedMethods.add(AnnotatedServiceMock.class.getMethod(""handlePost""));

        Assert.assertTrue(expectedMethods.containsAll(actualMethods));
    }",No Smells
"@Test
    public void testAddImageToFavoritesNonexistentRegistry() throws Throwable {
        FavoriteImage fictionalRegistryImage = new FavoriteImage();
        fictionalRegistryImage.name = ""library/photon"";
        fictionalRegistryImage.description = ""This is a non-existing image"";
        fictionalRegistryImage.registry = ""non-existing registry"";

        assertAddImageThrowsRegistryNotValidException(fictionalRegistryImage);
        checkImages();
    }",No Smells
"@Test
    public void testGetExternalPopularImages() throws Throwable {

        // with the 'container.user.resources.path' configuration attribute set
        // the images of the popular-images.json file there will be returned

        HostInitCommonServiceConfig.startServices(host);

        waitForServiceAvailability(ConfigurationFactoryService.SELF_LINK);
        waitForServiceAvailability(UriUtils.buildUriPath(UriUtils.buildUriPath(
                ConfigurationFactoryService.SELF_LINK, FileUtil.USER_RESOURCES_PATH_VARIABLE)));

        ConfigurationState config = new ConfigurationState();
        config.documentSelfLink = UriUtils.buildUriPath(ConfigurationFactoryService.SELF_LINK, FileUtil.USER_RESOURCES_PATH_VARIABLE);
        config.key = FileUtil.USER_RESOURCES_PATH_VARIABLE;
        config.value = Paths.get(PopularImagesServiceTest.class.getResource(""/containers"").toURI())
                .toString();

        ConfigurationState storedConfig = doPut(config);
        assertNotNull(storedConfig);

        HostInitImageServicesConfig.startServices(host);
        waitForServiceAvailability(PopularImagesService.SELF_LINK);

        Collection<?> images = getDocument(Collection.class, PopularImagesService.SELF_LINK);
        assertNotNull(images);
        assertEquals(5, images.size());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testGetSingleEventLog() throws Throwable {
        EventLogState createdState = doPost(eventLogState, EventLogFactoryService.SELF_LINK);

        EventLogState retrievedState = getDocument(EventLogState.class, createdState.documentSelfLink);
        assertEventLogEquals(createdState, retrievedState);

        doDelete(UriUtils.buildUri(host, createdState.documentSelfLink), false);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testPost() throws Throwable {
        EventLogState createdState = doPost(eventLogState, EventLogFactoryService.SELF_LINK);
        assertNotNull(createdState.documentSelfLink);
        assertEventLogEquals(eventLogState, createdState);

        List<String> allStatesLinks = getDocumentLinksOfType(EventLogState.class);
        assertEquals(""Unexpected number of existing entries"",1, allStatesLinks.size());

        doDelete(UriUtils.buildUri(host, createdState.documentSelfLink), false);
    }",No Smells
"@Test
    public void testFilterDoesNotAffectHosts() throws Throwable {
        filter = new BinpackAffinityHostFilter(host, containerDesc);
        assertTrue(filter.isActive());
        Map<String, HostSelection> selected = filter();
        assertEquals(3, selected.size());
    }",No Smells
"@Test
    public void testReturnInitialHostListWhenNoPreviousContainers() throws Throwable {
        ContainerDescription desc = createDescription();

        filter = new ClusterAntiAffinityHostFilter(host, desc);

        filter(expectedLinks);
    }",No Smells
"@Test
    public void testFilterInReservation() throws Throwable {
        String serviceLink = UriUtils.buildUriPath(ReservationTaskFactoryService.SELF_LINK,
                UUID.randomUUID().toString());
        state.serviceTaskCallback = ServiceTaskCallback.create(serviceLink);

        ContainerVolumeDescription volumeDesc = createVolumeDescription(""Postgres"",
                DEFAULT_VOLUME_DRIVER);
        String[] volumes = new String[] { volumeDesc.name + "":/tmp"" }",No Smells
"@Test
    public void testFilterWithoutNamedVolumes() throws Throwable {
        ContainerDescription desc = createDescription();
        desc.volumes = new String[] { ""/var/some-volume:/var/some-volume"" }",No Smells
"@Test
    public void testSelectHostWhenNoClustering() throws Throwable {
        // create composite component
        CompositeComponent component = createComponent(""App-With-Links-Test"");

        // create 2 container descriptions with links wordpress -> mysql
        ContainerDescription desc1 = createDescription(""mysql"", null);
        ContainerDescription desc2 = createDescription(""wordpress"", new String[] {""mysql:mysql""}",No Smells
"@Test
    public void testAffinityConstraintsToNetworks() throws Throwable {
        ContainerDescription desc = createDescription(new String[] { ""net1"", ""net2"", ""net3"" }",No Smells
"@Test
    public void testFilterHostsWhenNoClustersAvailable() throws Throwable {
        ContainerDescription desc = createContainerWithNetworksDescription();
        filter = new ContainerToNetworkAffinityHostFilter(host, desc);
        assertTrue(filter.isActive());

        // One host is selected randomly from the initialHostLinks
        Map<String, HostSelection> selected = filter();
        assertEquals(1, selected.size());
    }",No Smells
"@Test
    public void testFilterVCHHostsForSpecificNetworkModeNull() throws Throwable {
        testFilterVCHHostsForSpecificNetworkMode(null, 3);
    }",No Smells
"@Test
    public void testResolveContainerActualStateNames() throws Throwable {
        ContainerNetworkDescription networkDescription1 = createNetworkDescription(""my-test-net"");
        String randomName = networkDescription1.name + ""-name35"";
        ContainerNetworkState networkState1 = createNetwork(networkDescription1, randomName);

        ContainerNetworkDescription networkDescription2 = createNetworkDescription(
                ""my-other-test-net"");
        randomName = networkDescription2.name + ""-name270"";
        ContainerNetworkState networkState2 = createNetwork(networkDescription2, randomName);

        CompositeDescription compositeDesc = createCompositeDesc(false, false, networkDescription1,
                networkDescription2);
        ContainerDescription desc = createDescription(new String[] { networkDescription1.name,
                networkDescription2.name }",No Smells
"@Test
    public void testDuplicateHostPortsWithLinearDependencies() throws Throwable {
        PortBinding portBinding = new PortBinding();
        portBinding.containerPort = ""80"";
        portBinding.hostPort = ""8080"";
        PortBinding[] bindings = new PortBinding[] { portBinding }",No Smells
"@Test
    public void testDuplicateHostPortsWithPredefinedComplexDependencies() throws Throwable {
        PortBinding portBinding = new PortBinding();
        portBinding.containerPort = ""80"";
        portBinding.hostPort = ""8080"";
        PortBinding[] bindings = new PortBinding[] { portBinding }",No Smells
"@Test
    public void testFailWhenLocalVolumesShared2() throws Throwable {
        ContainerVolumeDescription local1 = createVolumeDescription(""vol1"", ""local"");
        ContainerDescription c1 = createContainerDescription(new String[] { ""vol1:/tmp"" }",No Smells
"@Test
    public void testFilterDoesNotAffectHosts() throws Throwable {
        assertEquals(3, initialHostLinks.size());

        ContainerDescription desc = createContainerDescription(new String[] {}",No Smells
"@Test
    public void testErrorWhenContainerDescHasSamePodAndSecondContainerButNoContainersFound()
            throws Throwable {
        ContainerDescription desc = createDescriptionsWithPodDefined(""linked-container"", 5).get(0);

        // marked as dependent, which means not the first container associated with a given pod
        state.customProperties.put(ContainerAllocationTaskState.FIELD_NAME_CONTEXT_POD_DEPENDENT,
                POD_ID);
        filter = new PodAffinityHostFilter(host, desc);

        Throwable e = filter(initialHostLinks);
        if (e == null) {
            fail(""Expected exception for no container found."");
        }",No Smells
"@Test
    public void testDoNotErrorWhenMoreThanOneContainersWithDifferentHostsInAffinityAndSoftAfinity()
            throws Throwable {
        ContainerDescription desc1 = createDescriptions(CONTAINER_NAME, 2, null).get(0);
        String hostLink1 = initialHostLinks.get(0);
        createContainer(desc1, hostLink1);

        String secondContainerName = ""second_container"";
        ContainerDescription desc2 = createDescriptions(secondContainerName, 2, null).get(0);
        String hostLink2 = initialHostLinks.get(1);
        createContainer(desc2, hostLink2);

        String[] affinity = new String[] { CONTAINER_NAME,
                secondContainerName + SOFT.getValue() }",No Smells
"@Test
    public void testErrorWhenMoreThanOneContainersButDifferentHostsInAffinity() throws Throwable {
        ContainerDescription desc1 = createDescriptions(CONTAINER_NAME, 2, null).get(0);
        String hostLink1 = initialHostLinks.get(0);
        createContainer(desc1, hostLink1);

        String secondContainerName = ""second_container"";
        ContainerDescription desc2 = createDescriptions(secondContainerName, 2, null).get(0);
        String hostLink2 = initialHostLinks.get(1);
        createContainer(desc2, hostLink2);

        String[] affinity = new String[] { CONTAINER_NAME, secondContainerName }",No Smells
"@Test
    public void testProvisionContainerWhenAnotherAlreadyProvisionedAndHasAffinityRules()
            throws Throwable {

        //Create a container A which has affinity to B. Deploy A, then deploy B. B should be placed on the same host as A
        String secondContainerName = ""second_container"";
        ContainerDescription desc2 = createDescriptions(secondContainerName, 2, null).get(0);

        ContainerDescription desc1 = createDescriptions(CONTAINER_NAME, 2,
                new String[] { secondContainerName + HARD.getValue() }",No Smells
"@Test
    public void testSelectContainerHostWhenMoreThanOneContainersInAffinityOnTheSameHost()
            throws Throwable {
        ContainerDescription desc1 = createDescriptions(CONTAINER_NAME, 2, null).get(0);
        String hostLink = initialHostLinks.get(0);
        createContainer(desc1, hostLink);

        String secondContainerName = ""second_container"";
        ContainerDescription desc2 = createDescriptions(secondContainerName, 2, null).get(0);
        createContainer(desc2, hostLink);

        String[] affinity = new String[] { CONTAINER_NAME, secondContainerName }",No Smells
"@Test
    public void testMoreThanOneContainersWithDifferentHostsInAffinity() throws Throwable {
        ContainerDescription desc1 = createDescriptions(CONTAINER_NAME1);
        String hostLink1 = initialHostLinks.get(0);
        createContainer(desc1, hostLink1);

        ContainerDescription desc2 = createDescriptions(CONTAINER_NAME2);
        String hostLink2 = initialHostLinks.get(1);
        createContainer(desc2, hostLink2);

        String[] anti_affinity = new String[] {
                ANTI_AFFINITY_PREFIX + CONTAINER_NAME1,
                ANTI_AFFINITY_PREFIX + CONTAINER_NAME2 }",No Smells
"@Test
    public void testReturnInitialHostListWhenNoMatchingContainerDescNameWithAntiAfinity()
            throws Throwable {
        ContainerDescription desc1 = createDescriptions(CONTAINER_NAME1);
        createContainer(desc1, initialHostLinks.get(0));

        String[] anti_affinity = new String[] { ANTI_AFFINITY_PREFIX
                + ""not-existing-container-name"" }",No Smells
"@Test
    public void testSoftAntiAfinity() throws Throwable {
        ContainerDescription desc1 = createDescriptions(CONTAINER_NAME1);
        String hostLink1 = initialHostLinks.get(0);
        createContainer(desc1, hostLink1);

        ContainerDescription desc2 = createDescriptions(CONTAINER_NAME2);
        String hostLink2 = initialHostLinks.get(1);
        createContainer(desc2, hostLink2);

        ContainerDescription desc3 = createDescriptions(CONTAINER_NAME3);
        String hostLink3 = initialHostLinks.get(2);
        createContainer(desc3, hostLink3);

        String[] anti_affinity = new String[] {
                ANTI_AFFINITY_PREFIX + CONTAINER_NAME1,
                ANTI_AFFINITY_PREFIX + CONTAINER_NAME2,
                ANTI_AFFINITY_PREFIX + CONTAINER_NAME3 }",No Smells
"@Test
    public void testRemoveCompositeComponentsWithExternalNetwork() throws Throwable {
        CompositeComponent composite1 = createCompositeComponent();
        ContainerState container1 = createContainer(composite1);
        ContainerNetworkState network = createNetwork(composite1, true);

        RequestBrokerState day2RemovalRequest = new RequestBrokerState();
        day2RemovalRequest.resourceType = ResourceType.COMPOSITE_COMPONENT_TYPE.getName();
        day2RemovalRequest.resourceLinks = new HashSet<>(
                Arrays.asList(composite1.documentSelfLink));
        day2RemovalRequest.operation = ContainerOperationType.DELETE.id;

        day2RemovalRequest = startRequest(day2RemovalRequest);
        waitForRequestToComplete(day2RemovalRequest);

        verifyRemoved(composite1);
        verifyRemoved(container1);

        ContainerNetworkState net = getDocument(ContainerNetworkState.class,
                network.documentSelfLink);

        assertEquals(0, net.compositeComponentLinks.size());
    }",No Smells
"@Test
    public void testRemoveEmptyCompositeComponent() throws Throwable {
        CompositeComponent composite = createCompositeComponent();

        RequestBrokerState day2RemovalRequest = new RequestBrokerState();
        day2RemovalRequest.resourceType = ResourceType.COMPOSITE_COMPONENT_TYPE.getName();
        day2RemovalRequest.resourceLinks = new HashSet<>(Collections.singletonList(
                composite.documentSelfLink));
        day2RemovalRequest.operation = ContainerOperationType.DELETE.id;

        day2RemovalRequest = startRequest(day2RemovalRequest);
        waitForRequestToComplete(day2RemovalRequest);

        // verify the CompositeComponent has been removed
        composite = searchForDocument(CompositeComponent.class, composite.documentSelfLink);
        assertNull(composite);
    }",No Smells
"@Test
    public void testBindingDependencies() {
        ContainerDescription desc1 = createContainerDescription(""name1"");
        ContainerDescription desc2 = createContainerDescription(""name2"");
        ContainerDescription desc3 = createContainerDescription(""name3"");

        ComponentBinding cbDesc1 = new ComponentBinding(desc1.name, Arrays.asList(
                binding(Collections.emptyList(),
                        RESOURCE + FIELD_SEPARATOR + desc2.name + ""~address""),
                binding(Collections.emptyList(),
                        RESOURCE + FIELD_SEPARATOR + desc3.name + ""~address"")
        ));

        ComponentBinding cbDesc2 = new ComponentBinding(desc2.name, Arrays.asList(
                binding(Collections.emptyList(),
                        RESOURCE + FIELD_SEPARATOR + desc3.name + ""~address"")
        ));

        CompositeDescriptionExpanded compositeDesc = createCompositeDesc(
                Arrays.asList(desc1, desc2, desc3), Arrays.asList(cbDesc1, cbDesc2));

        List<ResourceNode> nodes = graph.calculateGraph(compositeDesc);
        //the order should be name3 -> name2 -> name1
        Object[] actualOrder = nodes.stream().map(node -> node.name).toArray();
        assertArrayEquals(new String[] { desc3.name, desc2.name, desc1.name }",No Smells
"@Test
    public void testAllocationOfContainersWithAffinityAndVolumeFrom() throws Throwable {
        createDockerHost(createDockerHostDescription(), createResourcePool(), true);
        createDockerHost(createDockerHostDescription(), createResourcePool(), true);
        createDockerHost(createDockerHostDescription(), createResourcePool(), true);

        // create first container:
        ContainerDescription desc1 = TestRequestStateFactory.createContainerDescription();
        desc1.documentSelfLink = UUID.randomUUID().toString();
        desc1.name = ""name1"";
        desc1.portBindings = null;
        desc1 = doPost(desc1, ContainerDescriptionService.FACTORY_LINK);
        assertNotNull(desc1);
        addForDeletion(desc1);

        String contextId = UUID.randomUUID().toString();
        // all instances of this request should be allocated on the same hosts because of the pod.
        ContainerAllocationTaskState allocationTask1 = createContainerAllocationTask(
                desc1.documentSelfLink, 1);
        allocationTask1.customProperties.put(RequestUtils.FIELD_NAME_CONTEXT_ID_KEY, contextId);
        allocationTask1 = allocate(allocationTask1);
        ContainerState container1 = getDocument(ContainerState.class,
                allocationTask1.resourceLinks.iterator().next());

        // create second container with afinity dependent on the first container:
        ContainerDescription desc2 = TestRequestStateFactory.createContainerDescription();
        desc2.documentSelfLink = UUID.randomUUID().toString();
        desc2.name = ""name2-links"";
        desc2.portBindings = null;
        desc2.affinity = new String[] { desc1.name }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testAllocationOfContainersWithSameHostPodConstraint() throws Throwable {
        createDockerHost(createDockerHostDescription(), createResourcePool(), true);
        createDockerHost(createDockerHostDescription(), createResourcePool(), true);
        createDockerHost(createDockerHostDescription(), createResourcePool(), true);

        String pod = ""host-pod1"";

        // create a description with a pod defined:
        ContainerDescription desc1 = TestRequestStateFactory.createContainerDescription();
        desc1.documentSelfLink = UUID.randomUUID().toString();
        desc1.name = ""linked-container1"";
        desc1.pod = pod;
        desc1.portBindings = null;
        desc1 = doPost(desc1, ContainerDescriptionService.FACTORY_LINK);
        assertNotNull(desc1);
        addForDeletion(desc1);

        String contextId = UUID.randomUUID().toString();
        // all instances of this request should be allocated on the same hosts because of the pod.
        ContainerAllocationTaskState allocationTask1 = createContainerAllocationTask(
                desc1.documentSelfLink, 1);
        allocationTask1.customProperties.put(RequestUtils.FIELD_NAME_CONTEXT_ID_KEY, contextId);
        allocationTask1 = allocate(allocationTask1);
        ContainerState container = getDocument(ContainerState.class,
                allocationTask1.resourceLinks.iterator().next());

        String hostLink = container.parentLink;

        // loop a few times to make sure the right host is not chosen by a chance
        for (int i = 0; i < 5; i++) {
            ContainerDescription desc2 = TestRequestStateFactory.createContainerDescription();
            desc2.documentSelfLink = UUID.randomUUID().toString();
            desc2.name = ""linked-container"" + i;
            desc2.pod = pod;
            desc2.portBindings = null;
            desc2 = doPost(desc2, ContainerDescriptionService.FACTORY_LINK);
            assertNotNull(desc2);
            addForDeletion(desc2);

            // all instances of this request should be allocated on the same host as the one already
            // selected by the previous request since the desc1.pod == desc2.pod
            ContainerAllocationTaskState allocationTask2 = createContainerAllocationTask(
                    desc2.documentSelfLink, 2);
            allocationTask2.customProperties.put(RequestUtils.FIELD_NAME_CONTEXT_ID_KEY, contextId);
            allocationTask2 = allocate(allocationTask2);
            for (String resourceLink : allocationTask2.resourceLinks) {
                ContainerState currContainer = getDocument(ContainerState.class, resourceLink);
                assertEquals(""Same host not selected for allocation request: ""
                        + allocationTask2.documentSelfLink + "" - in iteration: "" + i, hostLink,
                        currContainer.parentLink);
            }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testContainerAllocationWithFollowingProvisioningRequest() throws Throwable {
        host.log("">>>>>>Start: testContainerAllocationWithFollowingProvisioningRequest <<<<< "");
        doOperation(containerDesc, UriUtils.buildUri(host, containerDesc.documentSelfLink),
                false, Action.PUT);

        ContainerAllocationTaskState allocationTask = createContainerAllocationTask();
        allocationTask.customProperties = new HashMap<>();
        allocationTask.customProperties.put(RequestUtils.FIELD_NAME_ALLOCATION_REQUEST,
                Boolean.TRUE.toString());
        allocationTask = allocate(allocationTask);

        assertContainerStateAfterAllocation(allocationTask);

        // Request provisioning after allocation:
        RequestBrokerState provisioningRequest = new RequestBrokerState();
        provisioningRequest.resourceType = allocationTask.resourceType;
        provisioningRequest.resourceLinks = allocationTask.resourceLinks;
        provisioningRequest.resourceDescriptionLink = containerDesc.documentSelfLink;
        provisioningRequest.operation = ContainerOperationType.CREATE.id;

        provisioningRequest = doPost(provisioningRequest, RequestBrokerFactoryService.SELF_LINK);
        assertNotNull(provisioningRequest);

        waitForTaskSuccess(allocationTask.documentSelfLink, ContainerAllocationTaskState.class);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testRedeploymentWithAutoRedeployOptionDisabled() throws Throwable {
        final long timeoutInMillis = 5000; // 5sec
        ContainerDescription cd = createContainerDescription(false);

        ContainerState state = provisionContainer(cd.documentSelfLink);
        // change the power state of one of them
        setContainerPowerState(state, PowerState.ERROR);

        doOperation(new ContainerControlLoopState(), UriUtils.buildUri(host,
                ContainerControlLoopService.CONTROL_LOOP_INFO_LINK),
                false,
                Service.Action.PATCH);

        state = getDocument(ContainerState.class, state.documentSelfLink);
        host.log(""Power state = %s"", state.powerState.name());

        long startTime = System.currentTimeMillis();
        final String link = state.documentSelfLink;
        AtomicBoolean healthyContainersFound = new AtomicBoolean(false);
        waitFor(() -> {
            ContainerState st = getDocument(ContainerState.class, link);
            host.log(""Power state = %s"", st.powerState.name());
            retrieveContainerStates(cd.documentSelfLink)
                    .thenAccept(containerStates -> {
                        long healthyContainers = containerStates.stream()
                                .filter(cs -> PowerState.RUNNING == cs.powerState)
                                .count();
                        host.log(""healthyContainers = %d"", healthyContainers);
                        if (healthyContainers != 0) {
                            healthyContainersFound.set(true);
                        }",Mystery Guest + Resource Optimism
"@Test
    public void testEquals() {
        ContainerPropertyDiff envDiff = new ContainerPropertyDiff<>(ContainerDescription
                .FIELD_NAME_ENV, ContainerState.FIELD_NAME_ENV, new String[]{""a=b""}",No Smells
"@Test
    public void testContainerHostRemovalResourceOperationCycle() throws Throwable {
        request = startRequest(request);
        waitForRequestToComplete(request);

        request = getDocument(RequestBrokerState.class, request.documentSelfLink);
        assertNotNull(request);

        // verify the resources are created as expected:
        assertEquals(request.resourceCount, request.resourceLinks.size());
        List<String> containerStateLinks = findResourceLinks(ContainerState.class,
                request.resourceLinks);

        // create a host removal task
        ContainerHostRemovalTaskState state = new ContainerHostRemovalTaskState();
        state.resourceLinks = new HashSet<>(Collections.singletonList(
                computeHost.documentSelfLink));
        state = doPost(state, ContainerHostRemovalTaskFactoryService.SELF_LINK);

        assertNotNull(""task is null"", state);
        waitForTaskSuccess(state.documentSelfLink, ContainerHostRemovalTaskState.class);

        validateHostRemoved(containerStateLinks);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testRequestBrokerContainerHostRemovalWithSystemContainerAndVolumes()
            throws Throwable {
        request = startRequest(request);
        waitForRequestToComplete(request);

        request = getDocument(RequestBrokerState.class, request.documentSelfLink);
        assertNotNull(request);

        // create a system container
        ContainerState container = TestRequestStateFactory.createContainer();
        container.descriptionLink = containerDesc.documentSelfLink;
        container.adapterManagementReference = containerDesc.instanceAdapterReference;
        container.groupResourcePlacementLink = groupPlacementState.documentSelfLink;
        container.parentLink = computeHost.documentSelfLink;
        container.system = Boolean.TRUE;
        container = doPost(container, ContainerFactoryService.SELF_LINK);

        // verify the resources are created as expected:
        assertEquals(request.resourceCount, request.resourceLinks.size());
        List<String> containerStateLinks = findResourceLinks(ContainerState.class,
                request.resourceLinks);

        // create a volume
        ContainerVolumeDescription volumeDesc = TestRequestStateFactory
                .createContainerVolumeDescription(""test-volume"");
        volumeDesc = doPost(volumeDesc, ContainerVolumeDescriptionService.FACTORY_LINK);
        addForDeletion(volumeDesc);

        ContainerVolumeState volume = TestRequestStateFactory.createVolume(""test-volume-003"");
        volume.adapterManagementReference = volumeDesc.instanceAdapterReference;
        volume.descriptionLink = volumeDesc.documentSelfLink;
        volume = doPost(volume, ContainerVolumeService.FACTORY_LINK);

        // verify the volume is created as expected
        List<String> containerVolumeStateLinks = findResourceLinks(ContainerVolumeState.class,
                Arrays.asList(volume.documentSelfLink));
        assertEquals(1, containerVolumeStateLinks.size());

        // create a host removal task - RequestBroker
        RequestBrokerState request = new RequestBrokerState();
        request.resourceType = ResourceType.CONTAINER_HOST_TYPE.getName();
        request.resourceLinks = new HashSet<>(Collections.singletonList(
                computeHost.documentSelfLink));
        request.operation = RequestBrokerState.REMOVE_RESOURCE_OPERATION;

        request = startRequest(request);
        waitForRequestToComplete(request);

        // verify that the volume state was removed
        containerVolumeStateLinks = findResourceLinks(ContainerVolumeState.class,
                Arrays.asList(volume.documentSelfLink));
        assertTrue(""ContainerVolumeState not removed: "" + containerVolumeStateLinks,
                containerVolumeStateLinks.isEmpty());

        // verify that the container states were removed
        containerStateLinks = findResourceLinks(ContainerState.class, containerStateLinks);
        assertTrue(""ContainerState not removed: "" + containerStateLinks,
                containerStateLinks.isEmpty());

        // verify that the host was removed
        Collection<String> computeSelfLinks = findResourceLinks(ComputeState.class,
                Collections.singletonList(computeHost.documentSelfLink));

        assertTrue(""ComputeState was not deleted: "" + computeSelfLinks, computeSelfLinks.isEmpty());

        // verify that the containers where removed from the docker mock
        Set<ContainerState> containerStates = getExistingContainersInAdapter();
        for (ContainerState containerState : containerStates) {
            for (String containerLink : containerStateLinks) {
                if (containerState.documentSelfLink.endsWith(containerLink)) {
                    fail(""Container State not removed with link: "" + containerLink);
                }",Mystery Guest + Resource Optimism
"@Test
    public void testNetworkProvisioningTaskWithProvidedHostIds() throws Throwable {

        ContainerNetworkDescription networkDesc = TestRequestStateFactory
                .createContainerNetworkDescription(""My-Net"");
        networkDesc.documentSelfLink = UUID.randomUUID().toString();
        networkDesc = doPost(networkDesc, ContainerNetworkDescriptionService.FACTORY_LINK);

        ComputeDescription dockerHostDesc = createDockerHostDescription();
        if (dockerHostDesc.customProperties == null) {
            dockerHostDesc.customProperties = new HashMap<>();
        }",Mystery Guest + Resource Optimism
"@Test
    public void testStateRecommend() throws Throwable {
        ContainerDescription containerDescription = TestRequestStateFactory
                .createContainerDescription();
        ContainerState containerState = TestRequestStateFactory.createContainer();
        containerState.powerState = PowerState.ERROR;

        List<ContainerDiff> containerDiffs = ContainerDiff.inspect(containerDescription, Lists
                .newArrayList(containerState));

        assertEquals(ContainerRecommendation.Recommendation.REDEPLOY, ContainerRecommendation
                .recommend(containerDiffs.get(0)));
    }",No Smells
"@Test
    public void testRemoveAllocatedOnlyContainers() throws Throwable {
        request.customProperties = new HashMap<>();
        request.customProperties.put(RequestUtils.FIELD_NAME_ALLOCATION_REQUEST,
                Boolean.TRUE.toString());
        request = startRequest(request);
        waitForRequestToComplete(request);

        request = getDocument(RequestBrokerState.class, request.documentSelfLink);
        assertNotNull(request);

        // verify the resources are created as expected:
        assertEquals(request.resourceCount, request.resourceLinks.size());
        Collection<String> containerStateLinks = findResourceLinks(ContainerState.class,
                request.resourceLinks);
        assertEquals(request.resourceCount, containerStateLinks.size());
        // verify containers are not provisioned:
        for (String containerSelfLink : containerStateLinks) {
            ContainerState container = getDocument(ContainerState.class, containerSelfLink);
            assertNotNull(container);
            assertNull(container.id);
            waitForContainerPowerState(PowerState.PROVISIONING, container.documentSelfLink);
        }",Mystery Guest + Resource Optimism
"@Test
    public void testRemoveApplicationWithScaledContainer() throws Throwable {
        ContainerDescription desc1 = TestRequestStateFactory.createContainerDescription(""name1"",
                true, true);
        ContainerDescription desc2 = TestRequestStateFactory.createContainerDescription(""name2"",
                true, false);
        desc2.affinity = new String[] { desc1.name }",Mystery Guest + Resource Optimism
"@Test
    public void testRemoveOfStaleContainerOperationFromHostRemoval() throws Throwable {
        // try to remove a container as part of host removal when the container was already removed
        testRemoveOfStaleContainerOperationFromContainerRemovalTask(
                ManagementUriParts.REQUEST_HOST_REMOVAL_OPERATIONS);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testVolumeProvisioningTaskWithProvidedHostIds() throws Throwable {

        ContainerVolumeDescription volumeDesc = TestRequestStateFactory
                .createContainerVolumeDescription(""My-Vol"");
        volumeDesc.documentSelfLink = UUID.randomUUID().toString();
        volumeDesc = doPost(volumeDesc, ContainerVolumeDescriptionService.FACTORY_LINK);

        ComputeDescription dockerHostDesc = createDockerHostDescription();
        if (dockerHostDesc.customProperties == null) {
            dockerHostDesc.customProperties = new HashMap<>();
        }",Mystery Guest + Resource Optimism
"@Test
    public void volumeProvisionAndDelete() throws Throwable {
        // Setup Docker host and resource pool.
        ResourcePoolState resourcePool = createResourcePool();
        ComputeDescription dockerHostDesc = createDockerHostDescription();

        ComputeState dockerHost1 = createDockerHost(dockerHostDesc, resourcePool, true);
        addForDeletion(dockerHost1);

        // setup Group Placement:
        GroupResourcePlacementState groupPlacementState = createGroupResourcePlacement(
                resourcePool);

        ContainerVolumeDescription volumeDesc = new ContainerVolumeDescription();
        volumeDesc.name = ""Postgres"";
        volumeDesc.external = false;
        volumeDesc.customProperties = new HashMap<>();
        volumeDesc.customProperties.put(""__containerHostId"", Service.getId(dockerHost1.documentSelfLink));
        volumeDesc.instanceAdapterReference = UriUtils
                .buildUri(ManagementUriParts.ADAPTER_DOCKER_VOLUME);
        volumeDesc = doPost(volumeDesc, ContainerVolumeDescriptionService.FACTORY_LINK);

        // 1. Request a composite container:
        RequestBrokerState request = TestRequestStateFactory.createRequestState(
                ResourceType.VOLUME_TYPE.getName(), volumeDesc.documentSelfLink);

        request.tenantLinks = groupPlacementState.tenantLinks;
        host.log(""########  Start of request ######## "");
        request = startRequest(request);

        // wait for request completed state:
        request = waitForRequestToComplete(request);

        String volumeLink = request.resourceLinks.iterator().next();
        ContainerVolumeState volume = getDocument(ContainerVolumeState.class, volumeLink);

        assertNotNull(volume);

        assertEquals(PowerState.CONNECTED, volume.powerState);
        assertEquals(""local"", volume.scope);

        request = TestRequestStateFactory.createRequestState(ResourceType.VOLUME_TYPE.getName(), null);
        request.tenantLinks = groupPlacementState.tenantLinks;
        request.resourceLinks = new HashSet<>();
        request.resourceLinks.add(volumeLink);
        request.operation = VolumeOperationType.DELETE.id;
        request = startRequest(request);

        // wait for request completed state:
        request = waitForRequestToComplete(request);
        assertEquals(SubStage.COMPLETED, request.taskSubStage);
        assertEquals(TaskStage.FINISHED, request.taskInfo.stage);

        volume = getDocumentNoWait(ContainerVolumeState.class, volumeLink);

        assertTrue(volume == null);
    }",No Smells
"@Test
    public void testCreateClusterFail() throws Throwable {
        request.customProperties.put(PKS_CLUSTER_NAME_PROP_NAME,
                MockPKSAdapterService.CLUSTER_NAME_CREATE_FAIL);

        MockPKSAdapterService.setLastAction(PKS_LAST_ACTION_CREATE);
        request = startRequest(request);
        waitForRequestToFail(request);
    }",No Smells
"@Test
    public void testGetFailedCallbackResponse() throws Throwable {
        PKSClusterProvisioningTaskService service = new PKSClusterProvisioningTaskService();
        Method m = service.getClass().getDeclaredMethod(""getFailedCallbackResponse"",
                PKSProvisioningTaskState.class);
        m.setAccessible(true);

        PKSProvisioningTaskState task = new PKSProvisioningTaskState();
        task.serviceTaskCallback = ServiceTaskCallback.createEmpty();
        task.taskInfo = new TaskState();
        task.resourceLinks = new HashSet<>();
        task.resourceLinks.add(""link1"");

        CallbackCompleteResponse response = (CallbackCompleteResponse) m.invoke(service, task);

        assertNotNull(response);
        assertNotNull(response.resourceLinks);
        assertEquals(1, response.resourceLinks.size());
        assertEquals(""link1"", response.resourceLinks.iterator().next());
    }",No Smells
"@Test
    public void testNumberOfSelectedHostShouldBeSameAsResourceCount() throws Throwable {
        boolean expectError = false;
        String deploymentPolicyId = ""testDeploymentPolicy11"";

        ContainerDescription desc = TestRequestStateFactory.createContainerDescription();
        desc.deploymentPolicyId = deploymentPolicyId;
        desc = storeDescription(desc);

        String hostLink1 = initialHostLinks.get(0);
        String hostLink2 = initialHostLinks.get(1);
        resourceCount = 4;

        PlacementHostSelectionTaskState placementTask = createHostPlacementTask(
                desc.documentSelfLink, resourceCount, expectError);

        // verify all host will be used when neither one of them has deploymentPolicyId set
        assertEquals(4, placementTask.hostSelections.size());

        long count = placementTask.hostSelections.stream().map((r) -> r.hostLink)
                .filter((l) -> l.equals(hostLink1) || l.equals(hostLink2))
                .count();

        // make sure the host are equally distributed when no other constraints
        // in this case all 4 host are selected for clustering use case and
        // only 2 are with the first and the second hostLink
        assertEquals(2, count);

        // Patch 2 out of 4 hosts with deploymentPolicyId:
        ComputeState patchBody = new ComputeState();
        patchBody.customProperties = new HashMap<>();
        patchBody.customProperties.put(ContainerHostService.CUSTOM_PROPERTY_DEPLOYMENT_POLICY,
                deploymentPolicyId);

        doOperation(patchBody, UriUtils.buildUri(host, hostLink1), expectError, Action.PATCH);
        doOperation(patchBody, UriUtils.buildUri(host, hostLink2), expectError, Action.PATCH);

        placementTask = createHostPlacementTask(desc.documentSelfLink, resourceCount, expectError);
        // verify only the host with deploymentPolicyId will be returned:
        assertEquals(4, placementTask.hostSelections.size());

        count = placementTask.hostSelections.stream().map((r) -> r.hostLink)
                .filter((l) -> l.equals(hostLink1) || l.equals(hostLink2))
                .count();
        // In this case, only the two host with deploymentPolicyId are
        // selected and repeated for the 3 and 4 resource.
        assertEquals(4, count);
    }",No Smells
"@Test
    public void testSameHostSelectionWhenPodVolumeFromAndAffinity() throws Throwable {
        String pod = ""test-pod"";
        String hostLink = initialHostLinks.get(0);

        ContainerDescription desc1 = TestRequestStateFactory.createContainerDescription();
        desc1.pod = pod;
        desc1 = storeDescription(desc1);
        createContainer(desc1, hostLink);

        ContainerDescription desc = TestRequestStateFactory.createContainerDescription();
        desc.pod = pod;
        desc.volumesFrom = new String[] { desc1.name }",No Smells
"@Test
    public void testRequestLifeCycle() throws Throwable {
        host.log(""########  Start of testRequestLifeCycle ######## "");
        // setup Docker Host:
        ResourcePoolState resourcePool = createResourcePool();
        ComputeDescription dockerHostDesc = createDockerHostDescription();
        createDockerHost(dockerHostDesc, resourcePool);

        // setup Container desc:
        ContainerDescription containerDesc = createContainerDescription();

        // setup Group Placement:
        GroupResourcePlacementState groupPlacementState = createGroupResourcePlacement(
                resourcePool);

        // 1. Request a container instance:
        RequestBrokerState request = TestRequestStateFactory.createRequestState();
        request.resourceDescriptionLink = containerDesc.documentSelfLink;
        request.tenantLinks = groupPlacementState.tenantLinks;
        host.log(""########  Start of request ######## "");
        request = startRequest(request);

        // wait for request completed state:
        request = waitForRequestToComplete(request);

        RequestBrokerGraphResponse graph = getDocument(RequestBrokerGraphResponse.class,
                ManagementUriParts.REQUEST_GRAPH, RequestBrokerGraphService.QUERY_PARAM,
                extractId(request.documentSelfLink));
        assertNotNull(graph);
        assertNotNull(graph.tasks);

        TaskServiceDocumentHistory requestTask = graph.tasks.remove(0);
        assertTaskPassingStages(requestTask, RequestBrokerFactoryService.SELF_LINK,
                RequestBrokerState.SubStage.values());

        TaskServiceDocumentHistory reservationTask = graph.tasks.remove(0);
        assertTaskPassingStages(reservationTask, ReservationTaskFactoryService.SELF_LINK,
                ReservationTaskState.SubStage.values());

        TaskServiceDocumentHistory placementReservationTask = graph.tasks.remove(0);
        assertTaskPassingStages(placementReservationTask,
                PlacementHostSelectionTaskService.FACTORY_LINK,
                PlacementHostSelectionTaskState.SubStage.values());

        TaskServiceDocumentHistory allocationTask = graph.tasks.remove(0);
        assertTaskPassingStages(allocationTask, ContainerAllocationTaskFactoryService.SELF_LINK,
                ContainerAllocationTaskState.SubStage.values());

        TaskServiceDocumentHistory placementTask = graph.tasks.remove(0);
        assertTaskPassingStages(placementTask, PlacementHostSelectionTaskService.FACTORY_LINK,
                PlacementHostSelectionTaskState.SubStage.values());
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testCompositeComponentWithClusterAndLocalContainerVolumeRequestLifeCycle()
            throws Throwable {
        host.log(
                ""########  Start of testCompositeComponentWithClusterAndLocalContainerVolumeRequestLifeCycle ######## "");

        // setup Docker Host:
        ResourcePoolState resourcePool = createResourcePool();
        ComputeDescription dockerHostDesc = createDockerHostDescription();

        delete(computeHost.documentSelfLink);
        computeHost = null;

        ComputeState dockerHost1 = createDockerHost(dockerHostDesc, resourcePool, true);
        addForDeletion(dockerHost1);

        ComputeState dockerHost2 = createDockerHost(dockerHostDesc, resourcePool, true);
        addForDeletion(dockerHost2);

        String sharedVolumeName = ""Postgres"";
        String volumeName = String.format(""%s:/etc/pgdata/postgres"", sharedVolumeName);

        ContainerVolumeDescription volumeDesc = TestRequestStateFactory
                .createContainerVolumeDescription(sharedVolumeName);
        volumeDesc.documentSelfLink = UUID.randomUUID().toString();

        ContainerDescription container1Desc = TestRequestStateFactory.createContainerDescription();
        container1Desc.documentSelfLink = UUID.randomUUID().toString();
        container1Desc.name = ""Container1"";
        container1Desc.volumes = new String[] { volumeName }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testCompositeComponentWithContainerNetworkRequestLifeCycle() throws Throwable {
        host.log(
                ""########  Start of testCompositeComponentWithContainerNetworkRequestLifeCycle ######## "");

        // setup Docker Host:
        ResourcePoolState resourcePool = createResourcePool();
        ComputeDescription dockerHostDesc = createDockerHostDescription();

        delete(computeHost.documentSelfLink);
        computeHost = null;

        // ""set"" the same KV-store for the Docker Hosts created
        dockerHostDesc.customProperties.put(
                ContainerHostService.DOCKER_HOST_CLUSTER_STORE_PROP_NAME, ""my-kv-store"");

        ComputeState dockerHost1 = createDockerHost(dockerHostDesc, resourcePool, true);
        addForDeletion(dockerHost1);

        ComputeState dockerHost2 = createDockerHost(dockerHostDesc, resourcePool, true);
        addForDeletion(dockerHost2);

        // setup Composite description with 2 containers and 1 network

        String networkName = ""MyNet"";

        ContainerNetworkDescription networkDesc = TestRequestStateFactory
                .createContainerNetworkDescription(networkName);
        networkDesc.documentSelfLink = UUID.randomUUID().toString();

        ContainerDescription container1Desc = TestRequestStateFactory.createContainerDescription();
        container1Desc.documentSelfLink = UUID.randomUUID().toString();
        container1Desc.name = ""Container1"";
        container1Desc.networks = new HashMap<>();
        container1Desc.networks.put(networkName, new ServiceNetwork());

        ContainerDescription container2Desc = TestRequestStateFactory.createContainerDescription();
        container2Desc.documentSelfLink = UUID.randomUUID().toString();
        container2Desc.name = ""Container2"";
        container2Desc.affinity = new String[] { ""!Container1:hard"" }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testCompositeComponentWithContainerVolumeRequestLifeCycle() throws Throwable {
        host.log(
                ""########  Start of testCompositeComponentWithContainerVolumeRequestLifeCycle ######## "");

        // setup Docker Host:
        ResourcePoolState resourcePool = createResourcePool();
        ComputeDescription dockerHostDesc = createDockerHostDescription();

        delete(computeHost.documentSelfLink);
        computeHost = null;

        ComputeState dockerHost1 = createDockerHost(dockerHostDesc, resourcePool, true);
        addForDeletion(dockerHost1);

        ComputeState dockerHost2 = createDockerHost(dockerHostDesc, resourcePool, true);
        addForDeletion(dockerHost2);

        String sharedVolumeName = ""Postgres"";
        String volumeName = String.format(""%s:/etc/pgdata/postgres"", sharedVolumeName);

        ContainerVolumeDescription volumeDesc = TestRequestStateFactory
                .createContainerVolumeDescription(sharedVolumeName);
        volumeDesc.documentSelfLink = UUID.randomUUID().toString();

        ContainerDescription container1Desc = TestRequestStateFactory.createContainerDescription();
        container1Desc.documentSelfLink = UUID.randomUUID().toString();
        container1Desc.name = ""Container1"";
        container1Desc.volumes = new String[] { volumeName }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testRequestFail() throws Throwable {
        host.log(""########  Start of testRequestFail ######## "");
        // setup Docker Host:
        ResourcePoolState resourcePool = createResourcePool();
        ComputeDescription dockerHostDesc = createDockerHostDescription();
        createDockerHost(dockerHostDesc, resourcePool);

        // setup Group Placement:
        GroupResourcePlacementState groupPlacementState = createGroupResourcePlacement(
                resourcePool);

        // 1. Request a container instance:
        RequestBrokerState request = TestRequestStateFactory.createRequestState();
        request.resourceDescriptionLink = ""non-existing"";
        request.tenantLinks = groupPlacementState.tenantLinks;
        host.log(""########  Start of request ######## "");
        request = startRequest(request);

        // wait for request completed state:
        request = waitForRequestToFail(request);
    }",No Smells
"@Test
    public void testRequestFailShouldNotDeleteDescriptionsInUse() throws Throwable {
        host.log(""########  Start of testRequestFailShouldNotDeleteDescriptionsInUse ######## "");

        // ****** Start of testing a single container instance clean up ******
        host.log(""### Request a single container instance."");
        RequestBrokerState request = TestRequestStateFactory.createRequestState();
        request.resourceDescriptionLink = containerDesc.documentSelfLink;

        host.log(""########  Start of request ######## "");
        request = startRequest(request);

        // wait for request completed state:
        waitForRequestToComplete(request);

        host.log(""### Request a single container instance. Expected to fail because there is no placement created.""
                + ""Should not delete the description as there is already a container associated with it ###."");
        request = TestRequestStateFactory.createRequestState();
        request.resourceDescriptionLink = containerDesc.documentSelfLink;
        request.tenantLinks = Arrays.asList(""unknown"");

        host.log(""########  Start of request ######## "");
        request = startRequest(request);

        // wait for request completed state:
        waitForRequestToFail(request);

        final String containerDescLink = containerDesc.documentSelfLink;

        final long timoutInMillis = 3000; // 3sec
        long startRequestTime = System.currentTimeMillis();

        waitFor(() -> {
            if (System.currentTimeMillis() - startRequestTime > timoutInMillis) {
                return true;
            }",Mystery Guest + Resource Optimism
"@Test
    public void testRequestLifeCycleFailureShouldCleanReservations() throws Throwable {
        // setup Docker Host:
        ResourcePoolState resourcePool = createResourcePool();
        ComputeDescription dockerHostDesc = createDockerHostDescription();
        createDockerHost(dockerHostDesc, resourcePool);

        // setup Container desc:
        ContainerDescription containerDesc = createContainerDescription();

        // setup Group Placement:
        GroupResourcePlacementState groupPlacementState = createGroupResourcePlacement(
                resourcePool);
        assertEquals(0, groupPlacementState.allocatedInstancesCount);

        // 1. Request a container instance:
        RequestBrokerState request = TestRequestStateFactory.createRequestState();
        request.resourceDescriptionLink = containerDesc.documentSelfLink;
        request.tenantLinks = groupPlacementState.tenantLinks;
        request.customProperties = new HashMap<>();
        request.customProperties.put(MockDockerAdapterService.FAILURE_EXPECTED,
                Boolean.TRUE.toString());

        request = startRequest(request);

        // 2. Wait for reservation removed substage
        waitForRequestToFail(request);

        // 3. Verify that the group placement has been released.
        groupPlacementState = getDocument(GroupResourcePlacementState.class,
                groupPlacementState.documentSelfLink);
        assertEquals(0, groupPlacementState.allocatedInstancesCount);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testRequestLifeCycleWithContainerNetworkAndServiceAntiAffinityFilterFailureShouldCleanNetworks()
            throws Throwable {
        host.log(
                ""########  Start of testRequestLifeCycleWithContainerNetworkAndServiceAntiAffinityFilterFailureShouldCleanNetworks ######## "");

        // setup Docker Host:
        ResourcePoolState resourcePool = createResourcePool();
        ComputeDescription dockerHostDesc = createDockerHostDescription();

        delete(computeHost.documentSelfLink);
        computeHost = null;

        // DO NOT ""set"" the same KV-store for the Docker Hosts created!
        // In this way the ContainerToNetworkAffinityFilter and ServiceAntiAffinityHostFilter will
        // work as expected by saying that there are no hosts available.
        // Containers should be set on the same host because of the network but they ""can't""
        // because of the container2 anti-affinity rule.

        ComputeState dockerHost1 = createDockerHost(dockerHostDesc, resourcePool, true);
        addForDeletion(dockerHost1);

        ComputeState dockerHost2 = createDockerHost(dockerHostDesc, resourcePool, true);
        addForDeletion(dockerHost2);

        // setup Composite description with 2 containers and 1 network

        String networkName = ""MyNet"";

        ContainerNetworkDescription networkDesc = TestRequestStateFactory
                .createContainerNetworkDescription(networkName);
        networkDesc.documentSelfLink = UUID.randomUUID().toString();

        ContainerDescription container1Desc = TestRequestStateFactory
                .createContainerDescription(""Container1"");
        container1Desc.documentSelfLink = UUID.randomUUID().toString();
        container1Desc.networks = new HashMap<>();
        container1Desc.networks.put(networkName, new ServiceNetwork());

        ContainerDescription container2Desc = TestRequestStateFactory
                .createContainerDescription(""Container2"");
        container2Desc.documentSelfLink = UUID.randomUUID().toString();
        container2Desc.affinity = new String[] { ""!Container1:hard"" }",Mystery Guest + Resource Optimism
"@Test
    public void testRequestLifeCycleWithContainerNetworkFailureShouldCleanNetworks()
            throws Throwable {
        host.log(
                ""########  Start of testRequestLifeCycleWithContainerNetworkFailureShouldCleanNetworks ######## "");

        // setup Docker Host:
        ResourcePoolState resourcePool = createResourcePool();
        ComputeDescription dockerHostDesc = createDockerHostDescription();

        delete(computeHost.documentSelfLink);
        computeHost = null;

        // ""set"" the same KV-store for the Docker Hosts created
        dockerHostDesc.customProperties.put(
                ContainerHostService.DOCKER_HOST_CLUSTER_STORE_PROP_NAME, ""my-kv-store"");

        ComputeState dockerHost1 = createDockerHost(dockerHostDesc, resourcePool, true);
        addForDeletion(dockerHost1);

        ComputeState dockerHost2 = createDockerHost(dockerHostDesc, resourcePool, true);
        addForDeletion(dockerHost2);

        // setup Composite description with 2 containers and 1 network

        String networkName = ""MyNet"";

        ContainerNetworkDescription networkDesc = TestRequestStateFactory
                .createContainerNetworkDescription(networkName);
        networkDesc.documentSelfLink = UUID.randomUUID().toString();

        ContainerDescription container1Desc = TestRequestStateFactory.createContainerDescription();
        container1Desc.documentSelfLink = UUID.randomUUID().toString();
        container1Desc.name = ""Container1"";
        container1Desc.networks = new HashMap<>();
        container1Desc.networks.put(networkName, new ServiceNetwork());

        ContainerDescription container2Desc = TestRequestStateFactory.createContainerDescription();
        container2Desc.documentSelfLink = UUID.randomUUID().toString();
        container2Desc.name = ""Container2"";
        container2Desc.affinity = new String[] { ""!Container1:hard"" }",Mystery Guest + Resource Optimism
"@Test
    public void testRequestLifecycleWithContainerNetworkShouldCleanNetworkStatesOnProvisionAndDeletionFailure()
            throws Throwable {
        host.log(
                ""########  Start of ""
                        + ""testRequestLifecycleWithContainerNetworkShouldCleanNetworkStatesOnProvisionAndDeletionFailure ######## "");

        // 1. Request a network with expected failure:
        RequestBrokerState request = TestRequestStateFactory.createRequestState(
                ResourceType.NETWORK_TYPE.getName(),
                containerNetworkDesc.documentSelfLink);
        request.tenantLinks = groupPlacementState.tenantLinks;
        request.customProperties.put(
                ReservationAllocationTaskService.CONTAINER_HOST_ID_CUSTOM_PROPERTY, computeHost.id);

        // This should ensure that both the provisioning and the deletion (cleanup) requests to the
        // mock adapter will fail - during the allocation, the custom properties will be copied into
        // the network state. During the provisioning, the mock adapter will read the
        // EXPECTED_FAILURE from the request's custom properties and during deletion (cleanup) -
        // from the network state.
        request.customProperties.put(MockDockerNetworkAdapterService.FAILURE_EXPECTED,
                Boolean.TRUE.toString());

        host.log(""########  Start of request ######## "");
        request = startRequest(request);

        // 2. Wait for reservation removed substage
        waitForRequestToFail(request);

        // and there must be no container network state left
        ServiceDocumentQueryResult networkStates = getDocument(ServiceDocumentQueryResult.class,
                ContainerNetworkService.FACTORY_LINK);
        assertEquals(0L, networkStates.documentCount.longValue());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testValidateOnStart() throws Throwable {
        RequestBrokerState request = TestRequestStateFactory.createRequestState();
        request.resourceType = ""-"";
        request.resourceDescriptionLink = ""-"";
        RequestBrokerService r = new RequestBrokerService();
        Method m = r.getClass().getDeclaredMethod(""validateStateOnStart"", RequestBrokerState.class);
        m.setAccessible(true);

        validateLocalizableException(() -> {
            try {
                m.invoke(r, request);
            }",Mystery Guest + Resource Optimism
"@Test
    public void testApiCallsWithoutAuthentication() throws Throwable {
        VerificationHost savedState = null;
        if (host.isAuthorizationEnabled()) {
            savedState = host;
            host = VerificationHost.create(new Arguments());
        }",No Smells
"@Test
    public void testReservationAllocationTask() throws Throwable {

        verifyService(FactoryService.create(ReservationAllocationTaskService.class),
                ReservationAllocationTaskState.class,
                (prefix, index) -> {
                    ReservationAllocationTaskState reservationState = new ReservationAllocationTaskState();
                    reservationState.tenantLinks = Collections.singletonList(""testGroup"");
                    reservationState.resourceDescriptionLink = prefix + ""test"";
                    reservationState.customProperties = containerDesc.customProperties;
                    reservationState.name = containerDesc.name;
                    reservationState.resourceCount = 1;
                    Assert.assertNull(reservationState.groupResourcePlacementLink);

                    return reservationState;

                }",Mystery Guest + Resource Optimism
"@Test
    public void testReservationAllocationThroughReservationTask() throws Throwable {
        ReservationTaskState task = new ReservationTaskState();
        task.tenantLinks = containerDesc.tenantLinks;
        task.resourceDescriptionLink = containerDesc.documentSelfLink;
        task.resourceCount = 1;
        task.serviceTaskCallback = ServiceTaskCallback.createEmpty();
        task.groupResourcePlacementLink = null;
        task.resourcePoolsPerGroupPlacementLinks = null;

        task = doPost(task, ReservationTaskFactoryService.SELF_LINK);
        assertNotNull(task);

        ReservationTaskState result = waitForTaskSuccess(task.documentSelfLink,
                ReservationTaskState.class);

        assertNotNull(result.groupResourcePlacementLink);
        assertNotNull(result.resourcePoolsPerGroupPlacementLinks);
        assertTrue(result.resourcePoolsPerGroupPlacementLinks.size() == 1);
        assertTrue(result.groupResourcePlacementLink.contains(containerDesc.name));
        assertTrue(result.resourcePoolsPerGroupPlacementLinks.keySet()
                .contains(result.groupResourcePlacementLink));

        ReservationAllocationTaskState rsvAllocation = getDocument(
                ReservationAllocationTaskState.class,
                task.documentSelfLink);
        assertNotNull(rsvAllocation);
        assertEquals(result.groupResourcePlacementLink, rsvAllocation.groupResourcePlacementLink);
        assertEquals(result.resourcePoolsPerGroupPlacementLinks,
                rsvAllocation.resourcePoolsPerGroupPlacementLinks);

        GroupResourcePlacementState groupResourcePlacement = getDocument(
                GroupResourcePlacementState.class, result.groupResourcePlacementLink);
        assertNotNull(groupResourcePlacement);
        assertNotNull(groupResourcePlacement.resourcePoolLink);

        assertEquals(groupResourcePlacement.documentSelfLink, rsvAllocation.groupResourcePlacementLink);

    }",Mystery Guest + Resource Optimism
"@Test
    public void testDeploymentPoliciesOnHost() throws Throwable {
        DeploymentPolicy policy = createDeploymentPolicy();

        containerDesc.deploymentPolicyId = extractId(policy.documentSelfLink);
        doPut(containerDesc);

        GroupResourcePlacementState placementState = TestRequestStateFactory
                .createGroupResourcePlacementState();
        placementState = doPost(placementState, GroupResourcePlacementService.FACTORY_LINK);
        addForDeletion(placementState);

        ReservationTaskState task = new ReservationTaskState();
        task.tenantLinks = placementState.tenantLinks;
        task.resourceDescriptionLink = containerDesc.documentSelfLink;
        task.resourceCount = 1;
        task.serviceTaskCallback = ServiceTaskCallback.createEmpty();

        task = doPost(task, ReservationTaskFactoryService.SELF_LINK);
        assertNotNull(task);

        task = waitForTaskSuccess(task.documentSelfLink, ReservationTaskState.class);

        // update the container host and succeed
        computeHost.customProperties.put(ContainerHostService.CUSTOM_PROPERTY_DEPLOYMENT_POLICY,
                policy.documentSelfLink);
        doPut(computeHost);

        task = new ReservationTaskState();
        task.tenantLinks = placementState.tenantLinks;
        task.resourceDescriptionLink = containerDesc.documentSelfLink;
        task.resourceCount = 1;
        task.serviceTaskCallback = ServiceTaskCallback.createEmpty();
        task = doPost(task, ReservationTaskFactoryService.SELF_LINK);
        assertNotNull(task);

        task = waitForTaskSuccess(task.documentSelfLink, ReservationTaskState.class);

        placementState = getDocument(GroupResourcePlacementState.class,
                placementState.documentSelfLink);
        assertEquals(placementState.documentSelfLink, task.groupResourcePlacementLink);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testDeploymentPoliciesOnPolicy() throws Throwable {
        DeploymentPolicy policy = createDeploymentPolicy();

        containerDesc.deploymentPolicyId = extractId(policy.documentSelfLink);
        doPut(containerDesc);

        GroupResourcePlacementState placementState = TestRequestStateFactory
                .createGroupResourcePlacementState();
        placementState = doPost(placementState, GroupResourcePlacementService.FACTORY_LINK);
        addForDeletion(placementState);

        ReservationTaskState task = new ReservationTaskState();
        task.tenantLinks = placementState.tenantLinks;
        task.resourceDescriptionLink = containerDesc.documentSelfLink;
        task.resourceCount = 1;
        task.serviceTaskCallback = ServiceTaskCallback.createEmpty();

        task = doPost(task, ReservationTaskFactoryService.SELF_LINK);
        assertNotNull(task);

        task = waitForTaskSuccess(task.documentSelfLink, ReservationTaskState.class);

        // update the placement and succeed
        placementState.deploymentPolicyLink = policy.documentSelfLink;
        doPut(placementState);

        task = new ReservationTaskState();
        task.tenantLinks = placementState.tenantLinks;
        task.resourceDescriptionLink = containerDesc.documentSelfLink;
        task.resourceCount = 1;
        task.serviceTaskCallback = ServiceTaskCallback.createEmpty();

        task = doPost(task, ReservationTaskFactoryService.SELF_LINK);
        assertNotNull(task);

        task = waitForTaskSuccess(task.documentSelfLink, ReservationTaskState.class);

        placementState = getDocument(GroupResourcePlacementState.class,
                placementState.documentSelfLink);
        assertEquals(placementState.documentSelfLink, task.groupResourcePlacementLink);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testReservationTaskLifeCycleWhenNoAvailableGroupPlacements() throws Throwable {
        GroupResourcePlacementState groupPlacementState = doPost(
                TestRequestStateFactory.createGroupResourcePlacementState(),
                GroupResourcePlacementService.FACTORY_LINK);
        addForDeletion(groupPlacementState);

        ReservationTaskState task = new ReservationTaskState();
        task.tenantLinks = groupPlacementState.tenantLinks;
        task.resourceDescriptionLink = containerDesc.documentSelfLink;
        task.resourceCount = groupPlacementState.maxNumberInstances + 1;
        task.serviceTaskCallback = ServiceTaskCallback.createEmpty();

        task = doPost(task, ReservationTaskFactoryService.SELF_LINK);
        assertNotNull(task);

        waitForTaskError(task.documentSelfLink, ReservationTaskState.class);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testReservationTaskLifeCycleWhenNoAvailableGroupPlacements() throws Throwable {
        GroupResourcePlacementState groupPlacementState = doPost(
                TestRequestStateFactory.createGroupResourcePlacementState(),
                GroupResourcePlacementService.FACTORY_LINK);
        addForDeletion(groupPlacementState);

        ReservationTaskState task = new ReservationTaskState();
        task.tenantLinks = groupPlacementState.tenantLinks;
        task.resourceDescriptionLink = containerDesc.documentSelfLink;
        task.resourceCount = groupPlacementState.maxNumberInstances + 1;
        task.serviceTaskCallback = ServiceTaskCallback.createEmpty();

        task = doPost(task, ReservationTaskFactoryService.SELF_LINK);
        assertNotNull(task);

        waitForTaskError(task.documentSelfLink, ReservationTaskState.class);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testDeleteEventsWhenNoneAreAvailable() throws Throwable {
        verifyEventsCount(0);

        ServiceDocumentDeleteTaskState deleteTaskState = doPost(request,
                ServiceDocumentDeleteTaskService.FACTORY_LINK);

        waitForTaskSuccess(deleteTaskState.documentSelfLink,
                ServiceDocumentDeleteTaskService.ServiceDocumentDeleteTaskState.class);

        verifyEventsCount(0);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testAssignmentAndUnassignment() throws Throwable {
        ComputeState compute = createCompute();

        // addition
        updateTags(compute.documentSelfLink,
                Arrays.asList(""prop"", ""key1:value2"", ""key2:value2""),
                Arrays.asList(),
                Arrays.asList(""prop"", ""key1:value2"", ""key2:value2""));

        // addition + removal
        updateTags(compute.documentSelfLink,
                Arrays.asList(""location:somewhere""),
                Arrays.asList(""key2:value2""),
                Arrays.asList(""prop"", ""key1:value2"", ""location:somewhere""));

        // no change
        updateTags(compute.documentSelfLink,
                Arrays.asList(""location:somewhere""),
                Arrays.asList(""key2:value2""),
                Arrays.asList(""prop"", ""key1:value2"", ""location:somewhere""));

        // empty request
        updateTags(compute.documentSelfLink,
                Arrays.asList(),
                Arrays.asList(),
                Arrays.asList(""prop"", ""key1:value2"", ""location:somewhere""));

        // null addition
        updateTags(compute.documentSelfLink,
                null,
                Arrays.asList(),
                Arrays.asList(""prop"", ""key1:value2"", ""location:somewhere""));

        // null removal
        updateTags(compute.documentSelfLink,
                Arrays.asList(),
                null,
                Arrays.asList(""prop"", ""key1:value2"", ""location:somewhere""));

        // removal
        updateTags(compute.documentSelfLink,
                Arrays.asList(),
                Arrays.asList(""key1:value2""),
                Arrays.asList(""prop"", ""location:somewhere""));

        // removal of all
        updateTags(compute.documentSelfLink,
                null,
                Arrays.asList(""prop"", ""location:somewhere""),
                Arrays.asList());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testBadRequest() {

        // implicit content-type (= ""application/json"")

        String body = ""whatever"";

        Operation op = Operation
                .createPost(UriUtils.buildUri(host.getUri(), LongURIGetService.SELF_LINK))
                .setBody(body);

        FailureResponse failure = sender.sendAndWaitFailure(op);

        assertNotNull(failure.failure);
        assertEquals(Operation.MEDIA_TYPE_APPLICATION_JSON, failure.op.getContentType());
        assertEquals(Operation.STATUS_CODE_BAD_REQUEST, failure.op.getStatusCode());

        // explicit content-type

        op = Operation
                .createPost(UriUtils.buildUri(host.getUri(), LongURIGetService.SELF_LINK))
                .setContentType(""application/html"")
                .setBody(body);

        failure = sender.sendAndWaitFailure(op);

        assertNotNull(failure.failure);
        assertNotNull(failure.op.getBody(String.class));
        assertEquals(Operation.STATUS_CODE_BAD_REQUEST, failure.op.getStatusCode());

        // invalid target URI and content type

        LongURIRequest request = new LongURIRequest();
        request.uri = ""<script>alert(\""surprise!\"");</script>"";

        op = Operation
                .createPost(UriUtils.buildUri(host.getUri(), LongURIGetService.SELF_LINK))
                .setContentType(""application/html"")
                .setBody(request);

        failure = sender.sendAndWaitFailure(op);

        assertNotNull(failure.failure);
        assertEquals(Operation.MEDIA_TYPE_APPLICATION_JSON, failure.op.getContentType());
        assertEquals(Operation.STATUS_CODE_NOT_FOUND, failure.op.getStatusCode());
        assertTrue(failure.op.getBody(String.class)
                .startsWith(""{\""message\"":\""Service not found:""));
    }",No Smells
"@Test
    public void testDefaultResourcePrefixNameCreatedOnStartUp() throws Throwable {
        waitForServiceAvailability(
                ResourceNamePrefixService.DEFAULT_RESOURCE_NAME_PREFIX_SELF_LINK);
        ResourceNamePrefixState defaultNamePrefixState = getDocument(ResourceNamePrefixState.class,
                ResourceNamePrefixService.DEFAULT_RESOURCE_NAME_PREFIX_SELF_LINK);
        assertNotNull(defaultNamePrefixState);
        assertNull(defaultNamePrefixState.tenantLinks);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testCreateEventRegistryTopic() {
        EventTopicState state = createEventTopicState(""dummy-link"", EVENT_NAME, EVENT_TASK,
                TaskStage.FINISHED.name(), DefaultSubStage.COMPLETED.name(), false, new String());

        URI uri = UriUtils.buildUri(host, EventTopicService.FACTORY_LINK);
        EventTopicState result = sender
                .sendPostAndWait(uri, state, EventTopicState.class);

        assertNotNull(result);
        assertNotNull(result.documentSelfLink);
        assertNotNull(result.topicTaskInfo);

        assertEquals(state.topicTaskInfo.task, result.topicTaskInfo.task);
        assertEquals(state.topicTaskInfo.stage, result.topicTaskInfo.stage);
        assertEquals(state.topicTaskInfo.substage, result.topicTaskInfo.substage);

        uri = UriUtils.buildUri(host, result.documentSelfLink);
        result = sender.sendGetAndWait(uri, EventTopicState.class);
        assertNotNull(result);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testCreateionOfChangeComputeNameTopic() {
        // On start service creates new topic. No need for explicit post for creation.
        TestContext context = new TestContext(1, Duration.ofSeconds(120));
        verifyThatTopicExists(CHANGE_COMPUTE_NAME_SELF_LINK, context);
        context.await();
    }",Mystery Guest + Resource Optimism
"@Test
    public void testEmptyTask() {
        EventTopicState state = createEventTopicState(null, EVENT_NAME, null,
                TaskStage.FINISHED.name(), DefaultSubStage.COMPLETED.name(), false, new String());

        URI uri = UriUtils.buildUri(host, EventTopicService.FACTORY_LINK);
        Operation op = Operation
                .createPost(uri)
                .setBody(state);

        FailureResponse failure = sender.sendAndWaitFailure(op);
        assertNotNull(failure);
        assertEquals(""'Task' is required."", failure.failure.getMessage());
    }",No Smells
"@Test
    public void testTimeout() throws Throwable {
        ExtensibilitySubscriptionCallback state = createExtensibilityCallback(
                ExtensibilitySubscriptionCallback.Status.BLOCKED);

        state.due = LocalDateTime.now().plus(5, SECONDS);
        state.serviceTaskCallback = new ServiceTaskCallback();
        state.serviceTaskCallback.serviceSelfLink = TestStatelessService.SELF_LINK;
        state.replyPayload = new ServiceTaskCallbackResponse();
        state.replyPayload.taskInfo = TaskState.createAsStarted();
        state.replyPayload.taskSubStage = DefaultSubStage.CREATED;
        state.taskStateJson = TestStatelessService.class.getSimpleName();

        DeferredResult<Void> done = new DeferredResult<>();
        this.host.startService(new TestStatelessService(done));
        this.host.waitForServiceAvailable(TestStatelessService.SELF_LINK);

        URI uri = UriUtils.buildUri(host, ExtensibilitySubscriptionCallbackService.FACTORY_LINK);
        sender.sendPostAndWait(uri, state, ExtensibilitySubscriptionCallback.class);

        this.waitFor(""Task did not time out."", () -> done.isDone());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testCreateAndGet() {
        ExtensibilitySubscription state = createExtensibilityState();

        URI uri = UriUtils.buildUri(host, ExtensibilitySubscriptionService.FACTORY_LINK);
        ExtensibilitySubscription result = sender
                .sendPostAndWait(uri, state, ExtensibilitySubscription.class);

        assertNotNull(result);
        assertNotNull(result.documentSelfLink);
        assertEquals(state.task, result.task);
        assertEquals(state.stage, result.stage);
        assertEquals(state.substage, result.substage);

        uri = UriUtils.buildUri(host, result.documentSelfLink);
        result = sender.sendGetAndWait(uri, ExtensibilitySubscription.class);
        assertNotNull(result);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testGetEmpty() throws InterruptedException {
        ServiceDocumentQueryResult result = sender.sendAndWait(
                Operation.createGet(host, ExtensibilitySubscriptionService.FACTORY_LINK),
                ServiceDocumentQueryResult.class);
        assertNotNull(result);
        assertNotNull(result.documentCount);
        assertEquals(0L, (long) result.documentCount);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testRedirect() {
        String movedLocation = ""moved"";
        URI targetUri = UriUtils.buildUri(SAMPLE_HARBOR_URI, SAMPLE_API_PATH);

        HarborApiProxyService service = new HarborApiProxyService();
        service.setHost(VerificationHost.create());
        ServiceClient client = new MockServiceClient() {
            @Override
            public void sendRequest(Operation op) {
                String authHeader = op.getRequestHeader(Operation.AUTHORIZATION_HEADER);
                assertNull(""Authorization header should be empty"", authHeader);
                op.setStatusCode(Operation.STATUS_CODE_MOVED_PERM);
                op.addResponseHeader(Operation.LOCATION_HEADER, movedLocation);
                op.setUri(targetUri);
                op.complete();
            }",Mystery Guest + Resource Optimism
"@Test
    public void testSkipImportSSLCertificateOnStart() {
        AtomicBoolean certificateImportCalled = new AtomicBoolean();

        HarborApiProxyService service = new HarborApiProxyService() {
            @Override
            public void sendRequest(Operation op) {
                String path = op.getUri().getPath();
                if (path.equals(UriUtils.buildUriPath(ManagementUriParts.CONFIG_PROPS,
                        Harbor.CONFIGURATION_URL_PROPERTY_NAME))) {
                    ConfigurationState state = new ConfigurationState();
                    state.key = Harbor.CONFIGURATION_URL_PROPERTY_NAME;
                    state.value = SAMPLE_HARBOR_URI.toString();
                    op.setBody(state);
                    op.complete();
                }",No Smells
"@Test
    public void testWrongSelfLink() {
        AtomicBoolean completed = new AtomicBoolean();

        HarborApiProxyService service = new HarborApiProxyService();

        setPrivateField(service, HARBOR_URI_FIELD_NAME, SAMPLE_HARBOR_URI);

        Operation actualOp = Operation.createGet(UriUtils
                .buildUri(""http://localhost/some-path""))
                .setCompletion((o, e) -> {
                    assertNotNull(e);
                    assertTrue(e.getMessage()
                            .contains(""Invalid target URI""));

                    completed.set(true);
                }",No Smells
"@Test
    public void testDeleteDefaultRegistryOnStartup() throws Throwable {
        RegistryState registryState = new RegistryState();
        registryState.documentSelfLink = RegistryService.DEFAULT_INSTANCE_LINK;
        registryState.endpointType = RegistryState.DOCKER_REGISTRY_ENDPOINT_TYPE;
        registryState.address = RegistryService.DEFAULT_REGISTRY_ADDRESS;
        registryState = doPost(registryState, RegistryFactoryService.SELF_LINK);

        assertNotNull(""Failed to create default registry"", registryState);

        ConfigurationState config = new ConfigurationState();
        config.key = RegistryService.DISABLE_DEFAULT_REGISTRY_PROP_NAME;
        config.value = Boolean.toString(true);

        ConfigurationUtil.initialize(config);

        RegistryService.buildDefaultStateInstance(host);

        waitFor(""Ensure default registry is deleted."", () -> {
            List<String> resourceLinks = findResourceLinks(RegistryState.class,
                    Collections.singletonList(RegistryService.DEFAULT_INSTANCE_LINK));
            return resourceLinks.size() == 0;
        }",Mystery Guest + Resource Optimism
"@Test
    public void testOperationForbiddenWhenEmbedded() throws Throwable {

        toggleConfig(ConfigurationUtil.EMBEDDED_MODE_PROPERTY, true);

        try {
            testOperation(Operation::createGet, null);
            fail(""It should have been forbidden!"");
        }",No Smells
"@Test
    public void testPut() throws Throwable {
        testOperation(Operation::createPut, MockPingService.BODY_PING);
    }",No Smells
"@Test
    public void testPatch() throws Throwable {
        String testEntry = ""test-entry"";
        UniquePropertiesRequest patch = new UniquePropertiesRequest();
        patch.toAdd = Collections.singletonList(testEntry);

        doPatch(patch, testState.documentSelfLink);

        testState = getDocumentNoWait(UniquePropertiesState.class, testState.documentSelfLink);
        assertEquals(1, testState.uniqueProperties.size());
        assertTrue(testState.uniqueProperties.contains(testEntry));

        try {
            doPatch(patch, testState.documentSelfLink);
            fail(""Adding entry that already exist should fail the operation."");
        }",Mystery Guest + Resource Optimism
"@Test
    public void testProvisionApplication() throws Exception {
        setupCoreOsHost(DockerAdapterType.API, false, null);
        checkNumberOfNetworks(serviceClient, NUMBER_OF_NETWORKS_PER_APPLICATION);

        ContainerVolumeState volume = setupExternalVolume();
        compositeDescriptionLink = importTemplateWithExternalVolume(serviceClient,
                TEMPLATE_FILENAME, volume.name);

        logger.info(
                ""---------- 5. Request simple application with a container, a network and an external volume. --------"");
        requestContainerAndDelete(getResourceDescriptionLink(false, null));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testAddRemoveDockerHostInCluster() throws Throwable {

        ClusterDto dtoCreated = createCluster();

        ClusterDto dtoGet = getCluster(dtoCreated.documentSelfLink);

        assertEquals(1, dtoGet.nodeLinks.size());
        assertTrue(dtoGet.nodeLinks.contains(dtoCreated.nodeLinks.get(0)));
        assertEquals(getDockerHostAddressWithPort1, dtoGet.nodes.get(dtoCreated.nodeLinks.get(0))
                .address);

        ContainerHostSpec hostSpecDocker = createContainerHostSpec(
                Collections.singletonList(projectLink),
                ContainerHostType.DOCKER, true);
        hostSpecDocker.hostState.address = getDockerHostAddressWithPort2;
        String pathHostsInCluster = UriUtils.buildUriPath(ClusterService.SELF_LINK, Service
                .getId(dtoCreated.documentSelfLink), ""hosts"");

        sendRequest(HttpMethod.POST, pathHostsInCluster, Utils.toJson
                (hostSpecDocker));

        dtoGet = getCluster(dtoCreated.documentSelfLink);

        assertEquals(2, dtoGet.nodeLinks.size());
        assertTrue(dtoGet.nodeLinks.contains(dtoCreated.nodeLinks.get(0)));

        String secondComputeLink;
        if (dtoGet.nodeLinks.get(0).equals(dtoCreated.nodeLinks.get(0))) {
            secondComputeLink = dtoGet.nodeLinks.get(1);
        }",No Smells
"@Test
    public void testStoreHostSelfSignedCertificateAndAddHost() throws Throwable {
        computeState.address = VALID_DOCKER_HOST_NODE1_ADDRESS;
        SslTrustCertificateState[] certs = new SslTrustCertificateState[] { null }",Eager Test
"@Test
    public void testValidateSelfSignWhenAccepted() throws Throwable {
        computeState.address = VALID_DOCKER_HOST_NODE1_ADDRESS;
        containerHostSpec.acceptCertificate = true;

        Operation op = Operation
                .createPut(getContainerHostValidateUri())
                .setBody(containerHostSpec)
                .setCompletion((o, e) -> {
                    if (e != null) {
                        host.failIteration(e);
                        return;
                    }",No Smells
"@Test
    public void testProvision() throws Exception {
        doProvisionDockerContainerOnCoreOS(false, DockerAdapterType.API);
    }",No Smells
"@Test
    public void testNegativeInvalidTemplateProvision() throws Exception {
        setupCoreOsHost(ContainerHostService.DockerAdapterType.API, false, null);

        logger.info(""********************************************************************"");
        logger.info(""---------- Create RequestBrokerState and start the request --------"");
        logger.info(""********************************************************************"");

        logger.info(""---------- 1. Request invalid closure template instance. --------"");
        try {
            requestContainer(compositeInvalidDescriptionLink);
            fail(""Unexpected successful request on invalid closure template"");
        }",No Smells
"@Test
    public void testNegativeTimeoutProvision() throws Exception {
        setupCoreOsHost(ContainerHostService.DockerAdapterType.API, false, null);

        logger.info(""********************************************************************"");
        logger.info(""---------- Create RequestBrokerState and start the request --------"");
        logger.info(""********************************************************************"");

        logger.info(""---------- 1. Request invalid closure template instance. --------"");
        try {
            requestContainer(compositeTimeoutDescriptionLink);
            fail(""Unexpected successful request on timeout closure template"");
        }",No Smells
"@Test
    public void testProvisionDockerContainerOnCoreOSWithImageDownloadAPI() throws Exception {
        // not using registry, but instead upload the image to the host
        doProvisionDockerContainerOnCoreOS(true, DockerAdapterType.API);
    }",No Smells
"@Test
    public void testProvisionDockerContainerOnCoreOSWithInsecureRegistryImageAPI() throws Exception {
        doProvisionDockerContainerOnCoreOS(false, DockerAdapterType.API,
                RegistryType.V1_HTTP_INSECURE);
    }",No Smells
"@Test
    public void testHostStats() throws Exception {
        // The total memory, available memory, cpu usage should be populated in
        // the host's custom properties. We don't know what the exact values will be,
        // so just check if the properties exist
        waitForStateChange(cluster.nodeLinks.get(0), (body) -> {
            JsonObject object = new JsonParser().parse(body).getAsJsonObject();
            JsonObject customProperties = object
                    .get(ComputeService.ComputeState.FIELD_NAME_CUSTOM_PROPERTIES)
                    .getAsJsonObject();

            JsonElement totalMemory = customProperties
                    .get(ContainerHostService.DOCKER_HOST_TOTAL_MEMORY_PROP_NAME);
            boolean totalMemoryCondition = totalMemory != null && !totalMemory.isJsonNull();

            JsonElement availableMemory = customProperties
                    .get(ContainerHostService.DOCKER_HOST_AVAILABLE_MEMORY_PROP_NAME);
            boolean availableMemoryCondition =
                    availableMemory != null && !availableMemory.isJsonNull();

            JsonElement cpuUsage = customProperties
                    .get(ContainerHostService.DOCKER_HOST_CPU_USAGE_PCT_PROP_NAME);
            boolean cpuUsageCondition = cpuUsage != null && !cpuUsage.isJsonNull();

            return totalMemoryCondition && availableMemoryCondition && cpuUsageCondition;
        }",No Smells
"@Test
    public void testUploadRegistryCertificateOnDockerHostConfig() throws Exception {
        configureRegistries(registryAddress, null);

        boolean exists = waitUntilRegistryCertificateExists(dockerHostCompute.documentSelfLink,
                registryHostAndPort);

        assertTrue(""Cert does not exist."", exists);
    }",No Smells
"@Test
    public void testAddHostWithTrailingForwardSlashes() throws Throwable {
        RegistryState rs = new RegistryState();
        rs.address = TEST_REGISTRY_ADDRESS + ""///"";
        rs.name = getClass().getName();
        rs.endpointType = RegistryState.DOCKER_REGISTRY_ENDPOINT_TYPE;

        RegistryHostSpec hs = new RegistryHostSpec();
        hs.hostState = rs;
        hs.acceptHostAddress = true;

        String[] result = new String[] { null }",Mystery Guest + Resource Optimism
"@Test
    public void testValidateSelfSignNotAccepted() throws Throwable {
        registryState.address = TEST_REGISTRY_ADDRESS;

        Operation op = Operation.createPut(helperWithValidationUri)
                .setBody(hostState)
                .setCompletion((o, e) -> {
                    if (e != null) {
                        host.failIteration(e);
                        return;
                    }",Mystery Guest + Resource Optimism
"@Test
    public void testRegistryProxyNoExceptions() throws Exception {
        logger.info(""Add docker host."");
        setupCoreOsHost(DockerAdapterType.API, false, null);
        registryProxyHelper(false, RETRY_COUNT);
    }",No Smells
"@Test
    public void testSearchImagesWhenRegistriesAreDisabled() throws Exception {
        logger.info(""Assert the default registry is there"");
        RegistryState dockerHub = getDocument(RegistryService.DEFAULT_INSTANCE_LINK,
                RegistryState.class);
        assertNotNull(dockerHub);
        dockerHub.name = dockerHub.address; // required name when updating a registry

        logger.info(""Assert the preconfigured registry is there"");
        RegistryState configuredReg = getDocument(configuredRegistry.documentSelfLink,
                RegistryState.class);
        assertNotNull(configuredReg);

        List<RegistryState> disabledRegistries = disableRegistries(Arrays.asList(dockerHub,
                configuredReg));
        registriesToEnable.addAll(disabledRegistries);

        URI templateSearchUri = UriUtils.buildUri(new URI(getBaseUrl()),
                TemplateSearchService.SELF_LINK);

        final List<String> keyValues = new ArrayList<>(Arrays.asList(
                TemplateSearchService.IMAGES_ONLY_PARAM, Boolean.toString(true),
                TemplateSearchService.QUERY_PARAM, ""vmware""));

        templateSearchUri = UriUtils.extendUriWithQuery(templateSearchUri,
                keyValues.toArray(new String[0]));

        logger.info(""Search URI built: "" + templateSearchUri);

        HashMap<String, String> headers = new HashMap<>();
        headers.put(OperationUtil.PROJECT_ADMIRAL_HEADER, ProjectService.DEFAULT_PROJECT_LINK);

        HttpResponse httpResponse = SimpleHttpsClient.execute(HttpMethod.GET,
                templateSearchUri.toString(), null, headers, null);
        RegistrySearchResponse searchResponse = Utils.fromJson(httpResponse.responseBody,
                RegistrySearchResponse.class);

        assertEquals(0, searchResponse.results.size());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testSearchImagesWithRegistryFilter() throws Exception {
        // assert the default registry is there
        RegistryState dockerHub = getDocument(RegistryService.DEFAULT_INSTANCE_LINK,
                RegistryState.class);
        assertNotNull(dockerHub);

        URI templateSearchUri = UriUtils.buildUri(new URI(getBaseUrl()),
                TemplateSearchService.SELF_LINK);

        // exclude results from the default registry
        final List<String> keyValues = new ArrayList<>(Arrays.asList(
                TemplateSearchService.IMAGES_ONLY_PARAM, Boolean.toString(true),
                ContainerImageService.REGISTRY_FILTER_QUERY_PARAM_NAME, REGISTRY_NAME,
                TemplateSearchService.QUERY_PARAM, ""vmware""));

        templateSearchUri = UriUtils.extendUriWithQuery(templateSearchUri,
                keyValues.toArray(new String[0]));

        final HashMap<String, String> headers = new HashMap<>();
        headers.put(OperationUtil.PROJECT_ADMIRAL_HEADER, ProjectService.DEFAULT_PROJECT_LINK);
        HttpResponse httpResponse = SimpleHttpsClient.execute(HttpMethod.GET,
                templateSearchUri.toString(), null, headers, null);
        RegistrySearchResponse searchResponse = Utils.fromJson(httpResponse.responseBody,
                RegistrySearchResponse.class);
        assertEquals(2, searchResponse.results.size());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testProvision() throws Exception {
        setupCoreOsHost(DockerAdapterType.API, false, null);
        checkNumberOfNetworks(serviceClient, NUMBER_OF_NETWORKS_PER_APPLICATION);

        logger.info(""---------- 5. Create test docker image container description. --------"");
        requestContainerAndDelete(getResourceDescriptionLink(false, RegistryType.V1_SSL_SECURE));
    }",No Smells
"@Test
    public void testClose() {
        assertFalse(""client should not be closed after initialization"", tillerClient.isClosed());
        tillerClient.close();
        assertTrue(""client should be closed after a call to close()"", tillerClient.isClosed());
        try {
            tillerClient.healthCheck();
            fail(""Should have failed to execute health check after the client was closed"");
        }",No Smells
"@Test
    public void testGetTillerClientProviderWithUnsatisfiablePreference() {
        TillerClientProvider provider = TillerClientProviderUtil
                .getTillerClientProvider(""no-such-class-name"");
        assertNotNull(provider);
        assertEquals(MockTillerClientProvider.class.getName(), provider.getClass().getName());
    }",No Smells
"@Test
    public void testGetPods() {
        try (DefaultKubernetesClient client = new DefaultKubernetesClient()) {
            client.pods().list().getItems().forEach(p -> {
                logger.info(""Found pod %s"", p.getMetadata().getName());
            }",No Smells
"@Test
    public void testNewTiller() throws Throwable {
        for (TillerConnectionType connectionType : TillerConnectionType.values()) {
            Tiller tiller = TillerFactory.newTiller(buildTillerConfig(connectionType));
            assertNotNull(tiller);
            assertNotNull(tiller.getHealthStub());
            tiller.close();
        }",No Smells
"@Test
    public void testStringToStream() {
        assertNull(TillerFactory.stringToStream(null));

        final String testString = ""test-string"";
        InputStream stream = TillerFactory.stringToStream(testString);
        try (Scanner scanner = new Scanner(stream, StandardCharsets.UTF_8.name())) {
            // \A matches String beginning, i.e. this will match the whole stream
            String readString = scanner.useDelimiter(""\\A"").next();
            assertEquals(testString, readString);
        }",No Smells
"@Test
    public void testTillerService() throws Throwable {
        final String name = ""name"";
        final String k8sClusterLink = ""k8s-cluster-link"";
        final String tillerNamespace = ""tiller-namespace"";
        final String tillerCaLink = ""tiller-ca-link"";
        final String tillerCredentialsLink = ""tiller-credentials-link"";

        verifyService(
                FactoryService.create(TillerService.class),
                TillerState.class,
                (prefix, index) -> {
                    TillerState tillerState = new TillerState();
                    tillerState.name = prefix + name + index;
                    tillerState.k8sClusterSelfLink = prefix + k8sClusterLink + index;
                    tillerState.tillerNamespace = prefix + tillerNamespace + index;
                    tillerState.tillerCertificateAuthorityLink = prefix + tillerCaLink + index;
                    tillerState.tillerCredentialsLink = prefix + tillerCredentialsLink + index;
                    return tillerState;
                }",No Smells
"@Test
    public void testForwardIndexHtmlWithXFrameOptions() {
        UiService service = new UiService();
        service.setSelfLink(""/"");
        VerificationHost vh = new VerificationHost() {
            @Override
            public void sendRequest(Operation op) {
                if (op.getUri().getPath().equals(""/index.html"")) {
                    op.setBody(""OK"");
                    op.complete();
                }",Mystery Guest + Resource Optimism
"@Test
    public void testRedirect() {
        UiService service = new UiService();
        service.setSelfLink(""/sample"");
        service.setHost(new VerificationHost());

        AtomicBoolean completionCalled = new AtomicBoolean();

        service.handleGet(new Operation().setUri(UriUtils.buildUri(""http://localhost/sample""))
                .setCompletion((o, e) -> {
                    assertEquals(""/sample/"", o.getResponseHeader(Operation.LOCATION_HEADER));
                    completionCalled.set(true);

                }",Mystery Guest + Resource Optimism
"@Test
    public void testMultipleApplications() throws Throwable {
        List<String> tenantLinks = new ArrayList<String>();
        tenantLinks.add(""project1"");
        tenantLinks.add(""project2"");

        ContainerState containerState1 = createContainer(tenantLinks);
        containerState1 = doPost(containerState1, ContainerFactoryService.SELF_LINK);
        ContainerState containerState2 = createContainer(tenantLinks);

        tenantLinks.add(""project3"");
        containerState2 = doPost(containerState2, ContainerFactoryService.SELF_LINK);

        ContainerNetworkState network = createNetwork(tenantLinks);
        network = doPost(network, ContainerNetworkFactoryService.SELF_LINK);

        ContainerVolumeState volume = createVolume(tenantLinks);
        volume = doPost(volume, ContainerVolumeFactoryService.SELF_LINK);

        List<String> componentLinks = new ArrayList<>();
        componentLinks.add(containerState1.documentSelfLink);

        CompositeComponent application = createCompositeComponent(componentLinks);
        application = doPost(application, CompositeComponentFactoryService.SELF_LINK);

        componentLinks = new ArrayList<>();
        componentLinks.add(containerState2.documentSelfLink);
        componentLinks.add(network.documentSelfLink);
        componentLinks.add(volume.documentSelfLink);

        CompositeComponent application2 = createCompositeComponent(componentLinks);
        application2 = doPost(application2, CompositeComponentFactoryService.SELF_LINK);

        doOperation(new ServiceDocument(),
                UriUtils.buildUri(host, CompositeComponentsTransformationService.SELF_LINK), false,
                Service.Action.POST);

        application = getDocument(CompositeComponent.class, application.documentSelfLink);
        application2 = getDocument(CompositeComponent.class, application2.documentSelfLink);
        Assert.assertTrue(application.tenantLinks.size() == 2);
        Assert.assertTrue(application.tenantLinks.containsAll(containerState1.tenantLinks));

        Assert.assertTrue(application2.tenantLinks.size() == 3);
        Assert.assertTrue(application2.tenantLinks.containsAll(containerState2.tenantLinks));
        Assert.assertTrue(application2.tenantLinks.containsAll(network.tenantLinks));
        Assert.assertTrue(application2.tenantLinks.containsAll(volume.tenantLinks));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testSingleApplicationOneContainer() throws Throwable {
        List<String> tenantLinks = new ArrayList<String>();
        tenantLinks.add(""project1"");
        ContainerState containerState = createContainer(tenantLinks);
        containerState = doPost(containerState, ContainerFactoryService.SELF_LINK);
        List<String> componentLinks = new ArrayList<>();
        componentLinks.add(containerState.documentSelfLink);
        CompositeComponent application = createCompositeComponent(componentLinks);
        application = doPost(application, CompositeComponentFactoryService.SELF_LINK);

        doOperation(new ServiceDocument(),
                UriUtils.buildUri(host, CompositeComponentsTransformationService.SELF_LINK), false,
                Service.Action.POST);
        application = getDocument(CompositeComponent.class, application.documentSelfLink);
        Assert.assertTrue(application.tenantLinks.size() == 1);
        Assert.assertTrue(application.tenantLinks.containsAll(tenantLinks));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testThereShouldNotBeDuplicatedTenantLinks() throws Throwable {
        List<String> tenantLinks = new ArrayList<String>();
        tenantLinks.add(""project1"");
        tenantLinks.add(""project2"");

        ContainerState containerState1 = createContainer(tenantLinks);
        containerState1 = doPost(containerState1, ContainerFactoryService.SELF_LINK);
        ContainerState containerState2 = createContainer(tenantLinks);
        containerState2 = doPost(containerState2, ContainerFactoryService.SELF_LINK);

        tenantLinks.add(""project3"");
        ContainerNetworkState network = createNetwork(tenantLinks);
        network = doPost(network, ContainerNetworkFactoryService.SELF_LINK);

        ContainerVolumeState volume = createVolume(tenantLinks);
        volume = doPost(volume, ContainerVolumeFactoryService.SELF_LINK);

        List<String> componentLinks = new ArrayList<>();
        componentLinks.add(containerState1.documentSelfLink);
        componentLinks.add(containerState2.documentSelfLink);
        componentLinks.add(network.documentSelfLink);
        componentLinks.add(volume.documentSelfLink);
        CompositeComponent application = createCompositeComponent(componentLinks);
        application.tenantLinks = new ArrayList<>();
        application.tenantLinks.add(""project1"");
        application.tenantLinks.add(""project2"");
        application = doPost(application, CompositeComponentFactoryService.SELF_LINK);

        doOperation(new ServiceDocument(),
                UriUtils.buildUri(host, CompositeComponentsTransformationService.SELF_LINK), false,
                Service.Action.POST);

        application = getDocument(CompositeComponent.class, application.documentSelfLink);
        Assert.assertTrue(application.tenantLinks.size() == 3);
        Assert.assertTrue(application.tenantLinks.containsAll(tenantLinks));
        Assert.assertTrue(application.tenantLinks.containsAll(containerState1.tenantLinks));
        Assert.assertTrue(application.tenantLinks.containsAll(network.tenantLinks));
        Assert.assertTrue(application.tenantLinks.containsAll(volume.tenantLinks));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testDefaultPlacementDefaultPoolOneHost() throws Throwable {
        List<String> links = getDocumentLinksOfType(ResourcePoolState.class);
        Assert.assertTrue(links.size() == 1);
        ComputeState compute = createComputeState(""host1"",
                GroupResourcePlacementService.DEFAULT_RESOURCE_POOL_LINK);
        compute = doPost(compute, ComputeService.FACTORY_LINK);
        Assert.assertTrue(compute.tagLinks == null);
        doOperation(new ServiceDocument(),
                UriUtils.buildUri(host, ComputePlacementPoolRelationTransformationService.SELF_LINK), false,
                Service.Action.POST);
        compute = getDocument(ComputeState.class, compute.documentSelfLink);
        // check that a tag is added to the compute
        Assert.assertTrue(compute.tagLinks != null);
        Assert.assertTrue(compute.tagLinks.size() == 1);
        Assert.assertTrue(compute.tenantLinks.size() == 1);
        Assert.assertTrue(compute.tenantLinks.get(0).equals(ProjectService.DEFAULT_PROJECT_LINK));
        // Check that the pool has the default project
        ElasticPlacementZoneConfigurationState pool = getDocument(
                ElasticPlacementZoneConfigurationState.class,
                ElasticPlacementZoneConfigurationService.SELF_LINK
                        + links.get(0));
        Assert.assertTrue(pool.epzState.tagLinksToMatch.size() == 1);
        Assert.assertTrue(pool.epzState.tagLinksToMatch.containsAll(compute.tagLinks));
        GroupResourcePlacementState placement = getDocument(GroupResourcePlacementState.class,
                GroupResourcePlacementService.DEFAULT_RESOURCE_PLACEMENT_LINK);
        Assert.assertTrue(placement.tenantLinks.size() == 1);
        Assert.assertTrue(placement.tenantLinks.get(0).equals(ProjectService.DEFAULT_PROJECT_LINK));

        host.testStart(1);
        doPost(compute, ResourcePoolTransformationService.SELF_LINK);
        DeferredResult<List<ComputeState>> hostsWithinPlacementZone = ClusterUtils
                .getHostsWithinPlacementZone(pool.epzState.resourcePoolLink,
                        ProjectService.DEFAULT_PROJECT_LINK, host);
        hostsWithinPlacementZone.whenComplete((computeStates, ex) -> {
            if (ex != null) {
                host.failIteration(ex);
                return;
            }",Mystery Guest + Resource Optimism
"@Test
    public void testHostWithoutNetworks() throws Throwable {
        List<String> tenantLinks = new ArrayList<String>();
        tenantLinks.add(""project1"");
        ComputeState cs = createComputeState(""TestID1"", tenantLinks);
        cs = doPost(cs, ComputeService.FACTORY_LINK);
        List<String> links = getDocumentLinksOfType(ContainerNetworkState.class);
        Assert.assertTrue(links.isEmpty());
        doOperation(new ServiceDocument(),
                UriUtils.buildUri(host, ContainerNetworksTransformationService.SELF_LINK), false,
                Service.Action.POST);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testNetworkHasTenantLinks() throws Throwable {
        List<String> tenantLinks = new ArrayList<String>();
        String tenant = ""project1"";
        tenantLinks.add(tenant);
        ComputeState cs = createComputeState(""TestID1"", tenantLinks);
        cs = doPost(cs, ComputeService.FACTORY_LINK);

        ContainerNetworkState containerNetwork1 = createNetwork(cs.documentSelfLink);
        containerNetwork1.tenantLinks = new ArrayList<>();
        containerNetwork1.tenantLinks.add(tenant);
        containerNetwork1 = doPost(containerNetwork1, ContainerNetworkFactoryService.SELF_LINK);
        ContainerNetworkState containerNetwork2 = createNetwork(cs.documentSelfLink);
        containerNetwork2 = doPost(containerNetwork2, ContainerNetworkFactoryService.SELF_LINK);
        doOperation(new ServiceDocument(),
                UriUtils.buildUri(host, ContainerNetworksTransformationService.SELF_LINK), false,
                Service.Action.POST);

        containerNetwork1 = getDocument(ContainerNetworkState.class,
                containerNetwork1.documentSelfLink);
        containerNetwork2 = getDocument(ContainerNetworkState.class,
                containerNetwork2.documentSelfLink);

        Assert.assertTrue(containerNetwork1.tenantLinks.size() == 1);
        Assert.assertTrue(containerNetwork2.tenantLinks.size() == 1);
        Assert.assertTrue(containerNetwork1.tenantLinks.containsAll(tenantLinks));
        Assert.assertTrue(containerNetwork2.tenantLinks.containsAll(tenantLinks));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testNoNetworksNoHosts() throws Throwable {
        List<String> links = getDocumentLinksOfType(ComputeState.class);
        Assert.assertTrue(links.isEmpty());
        doOperation(new ServiceDocument(),
                UriUtils.buildUri(host, ContainerNetworksTransformationService.SELF_LINK), false,
                Service.Action.POST);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testMultipleHosts() throws Throwable {
        List<String> tenantLinksHost1 = new ArrayList<String>();
        tenantLinksHost1.add(""project1"");
        tenantLinksHost1.add(""project2"");
        List<String> tenantLinksHost2 = new ArrayList<String>();
        tenantLinksHost2.add(""host2-project"");

        ComputeState cs = createComputeState(""TestID1"", tenantLinksHost1);
        cs = doPost(cs, ComputeService.FACTORY_LINK);
        ComputeState cs2 = createComputeState(""TestID2"", tenantLinksHost2);
        cs2 = doPost(cs2, ComputeService.FACTORY_LINK);

        ContainerState firstContainerHost1 = createContainer(cs.documentSelfLink);
        firstContainerHost1 = doPost(firstContainerHost1, ContainerFactoryService.SELF_LINK);
        ContainerState secondContainerHost1 = createContainer(cs.documentSelfLink);
        secondContainerHost1 = doPost(secondContainerHost1, ContainerFactoryService.SELF_LINK);

        ContainerState firstContainerHost2 = createContainer(cs2.documentSelfLink);
        firstContainerHost2 = doPost(firstContainerHost2, ContainerFactoryService.SELF_LINK);
        ContainerState secondContainerHost2 = createContainer(cs2.documentSelfLink);
        // set tenant links to the container to check that the old tenant links are not overwritten
        secondContainerHost2.tenantLinks = new ArrayList<>();
        String containerTenantLink = ""test-business-group"";
        secondContainerHost2.tenantLinks.add(containerTenantLink);
        secondContainerHost2 = doPost(secondContainerHost2, ContainerFactoryService.SELF_LINK);
        doOperation(new ServiceDocument(),
                UriUtils.buildUri(host, ContainersTransformationService.SELF_LINK), false,
                Service.Action.POST);

        firstContainerHost1 = getDocument(ContainerState.class,
                firstContainerHost1.documentSelfLink);
        secondContainerHost1 = getDocument(ContainerState.class,
                secondContainerHost1.documentSelfLink);
        firstContainerHost2 = getDocument(ContainerState.class,
                firstContainerHost2.documentSelfLink);
        secondContainerHost2 = getDocument(ContainerState.class,
                secondContainerHost2.documentSelfLink);

        Assert.assertTrue(firstContainerHost1.tenantLinks.containsAll(tenantLinksHost1));
        Assert.assertTrue(secondContainerHost1.tenantLinks.containsAll(tenantLinksHost1));
        Assert.assertTrue(secondContainerHost1.tenantLinks.equals(firstContainerHost1.tenantLinks));

        Assert.assertTrue(firstContainerHost2.tenantLinks.containsAll(tenantLinksHost2));
        Assert.assertTrue(secondContainerHost2.tenantLinks.containsAll(tenantLinksHost2));
        Assert.assertTrue(secondContainerHost2.tenantLinks
                .size() == firstContainerHost2.tenantLinks.size() + 1);
        Assert.assertTrue(secondContainerHost2.tenantLinks.contains(containerTenantLink));
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testNoContainersNoHosts() throws Throwable {
        List<String> links = getDocumentLinksOfType(ComputeState.class);
        Assert.assertTrue(links.isEmpty());
        doOperation(new ServiceDocument(),
                UriUtils.buildUri(host, ContainersTransformationService.SELF_LINK), false,
                Service.Action.POST);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testVolumeHasTenantLinks() throws Throwable {
        List<String> tenantLinks = new ArrayList<String>();
        tenantLinks.add(""project1"");
        String commonTenantLink = ""tenant"";
        tenantLinks.add(commonTenantLink);
        ComputeState cs = createComputeState(""TestID1"", tenantLinks);
        cs = doPost(cs, ComputeService.FACTORY_LINK);

        ContainerVolumeState containerVolume1 = createVolume(cs.documentSelfLink);
        containerVolume1.tenantLinks = new ArrayList<>();
        containerVolume1.tenantLinks.add(commonTenantLink);
        containerVolume1 = doPost(containerVolume1, ContainerVolumeFactoryService.SELF_LINK);
        ContainerVolumeState containerVolume2 = createVolume(cs.documentSelfLink);
        containerVolume2 = doPost(containerVolume2, ContainerVolumeFactoryService.SELF_LINK);
        doOperation(new ServiceDocument(),
                UriUtils.buildUri(host, ContainerVolumesTransformationService.SELF_LINK), false,
                Service.Action.POST);

        containerVolume1 = getDocument(ContainerVolumeState.class,
                containerVolume1.documentSelfLink);
        containerVolume2 = getDocument(ContainerVolumeState.class,
                containerVolume2.documentSelfLink);

        Assert.assertTrue(containerVolume1.tenantLinks.size() == 2);
        Assert.assertTrue(containerVolume2.tenantLinks.size() == 2);
        Assert.assertTrue(containerVolume1.tenantLinks.containsAll(tenantLinks));
        Assert.assertTrue(containerVolume2.tenantLinks.containsAll(tenantLinks));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testNoPlacementsForPool() throws Throwable {
        ResourcePoolState pool1 = createResourcePool();
        doPost(pool1, ResourcePoolTransformationService.SELF_LINK);
        pool1 = getDocument(ResourcePoolState.class, pool1.documentSelfLink);
        Assert.assertTrue(pool1.tenantLinks == null);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testPlacementsBolongToDifferentPools() throws Throwable {
        ResourcePoolState pool1 = createResourcePool();

        GroupResourcePlacementState placement1 = new GroupResourcePlacementState();
        placement1.name = ""placement"";
        placement1.resourcePoolLink = pool1.documentSelfLink;
        placement1.tenantLinks = new ArrayList<>();
        placement1.tenantLinks.add(""tenant1"");
        placement1 = doPost(placement1, GroupResourcePlacementService.FACTORY_LINK);

        ResourcePoolState pool2 = createResourcePool();
        GroupResourcePlacementState placement2 = new GroupResourcePlacementState();
        placement2.name = ""placement2"";
        placement2.resourcePoolLink = pool2.documentSelfLink;
        placement2.tenantLinks = new ArrayList<>();
        placement2.tenantLinks.add(""tenant2"");
        placement2 = doPost(placement2, GroupResourcePlacementService.FACTORY_LINK);

        doPost(placement2, ResourcePoolTransformationService.SELF_LINK);
        pool1 = getDocument(ResourcePoolState.class, pool1.documentSelfLink);
        pool2 = getDocument(ResourcePoolState.class, pool2.documentSelfLink);

        // verify the tenant links of the pools
        Assert.assertTrue(pool1.tenantLinks.size() == 1);
        Assert.assertTrue(pool2.tenantLinks.size() == 1);
        Assert.assertTrue(pool1.tenantLinks.contains(""tenant1""));
        Assert.assertTrue(pool2.tenantLinks.contains(""tenant2""));

        // Verify that the pools are not changed
        Assert.assertTrue(getDocument(GroupResourcePlacementState.class,
                placement1.documentSelfLink).resourcePoolLink.equals(pool1.documentSelfLink));
        Assert.assertTrue(getDocument(GroupResourcePlacementState.class,
                placement2.documentSelfLink).resourcePoolLink.equals(pool2.documentSelfLink));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testOverrideBasic() {
        AuthConfig authConfig =
                AuthConfig.builder().registerAuthProvider(AuthConfig.BASIC, new ProprietaryAuthenticator()).build();
        assertEquals(""Default AuthConfig should have just 2 authenticators"", authConfig.getAuthenticators().size(), 2);
        assertTrue(""AuthConfig should have Proprietary authenticator mapped as Basic"",
                   authConfig.getAuthenticators().get(AuthConfig.BASIC) instanceof ProprietaryAuthenticator);
    }",No Smells
"@Test
    public void testGetPasswordString() throws Exception {
        Credentials credentials = new Credentials(USERNAME, PASSWORD_STRING);

        assertArrayEquals(PASSWORD_STRING.getBytes(AuthConfig.CHARACTER_SET), credentials.getPassword());
    }",No Smells
"@Test
    public void testCallCreateRequestTwice() throws DeploymentException {
        ClientEngine engine = getClientEngine(Collections.<String, Object>emptyMap());

        UpgradeRequest upgradeRequest = engine.createUpgradeRequest(null);
        assertNotNull(""First call must return instance of UpgradeRequest"", upgradeRequest);
        try {
            engine.createUpgradeRequest(null);
            fail(""Second call of createUpgradeRequest must fail"");
        }",No Smells
"@Test
    public void testCloseServer() throws Throwable {
        CountDownLatch latch = new CountDownLatch(1);
        SslEchoServer server = new SslEchoServer();
        try {
            server.start();
            String message = ""Hello world\n"";
            ByteBuffer readBuffer = ByteBuffer.allocate(message.length());
            Filter clientSocket = openClientSocket(""localhost"", readBuffer, latch, null);

            clientSocket.write(stringToBuffer(message), new CompletionHandler<ByteBuffer>() {
                @Override
                public void failed(Throwable t) {
                    t.printStackTrace();
                }",Mystery Guest
"@Test
    public void testCustomHostameVerificationFail() throws Throwable {
        CountDownLatch latch = new CountDownLatch(1);
        SslEchoServer server = new SslEchoServer();
        try {
            server.start();
            HostnameVerifier verifier = new HostnameVerifier() {
                @Override
                public boolean verify(String s, SSLSession sslSession) {
                    return false;
                }",Mystery Guest
"@Test
    public void testEcho100k() throws Throwable {
        CountDownLatch latch = new CountDownLatch(1);
        SslEchoServer server = new SslEchoServer();
        try {
            server.start();
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 1000; i++) {
                sb.append(""1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"");
            }",Mystery Guest
"@Test
    public void testRehandshakeClient() throws Throwable {
        CountDownLatch latch = new CountDownLatch(1);
        final SslEchoServer server = new SslEchoServer();
        try {
            server.start();
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 1000; i++) {
                sb.append(""1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"");
            }",Mystery Guest
"@Test
    public void testRehandshakeServer() throws Throwable {
        CountDownLatch latch = new CountDownLatch(1);
        final SslEchoServer server = new SslEchoServer();
        try {
            server.start();
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 1000; i++) {
                sb.append(""1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"");
            }",Mystery Guest
"@Test
    public void testIsRsv2() throws Exception {
        assertTrue(new Frame.Builder().rsv2(true).build().isRsv2());
        assertFalse(new Frame.Builder().rsv2(false).build().isRsv2());
    }",No Smells
"@Test
    public void testIsRsv3() throws Exception {
        assertTrue(new Frame.Builder().rsv3(true).build().isRsv3());
        assertFalse(new Frame.Builder().rsv3(false).build().isRsv3());
    }",No Smells
"@Test
    public void testPayloadDataChange() throws Exception {
        byte[] payload = {'0', '1', '2'}",No Smells
"@Test
    public void testParseHeadersQuoted1() {
        final List<Extension> extensions = TyrusExtension.fromHeaders(Arrays.asList(""ext1;param=\""  value  \""""));

        assertEquals(1, extensions.size());
        assertEquals(""ext1"", extensions.get(0).getName());
        assertTrue(extensions.get(0).getParameters().size() == 1);
        assertEquals(""param"", extensions.get(0).getParameters().get(0).getName());
        assertEquals(""  value  "", extensions.get(0).getParameters().get(0).getValue());
    }",No Smells
"@Test
    public void testParseHeadersQuoted2() {
        final List<Extension> extensions = TyrusExtension.fromHeaders(
                Arrays.asList(""ext1;param=\""  value  \"",ext2;param=\""  value \\\"" \""""));

        assertEquals(2, extensions.size());
        assertEquals(""ext1"", extensions.get(0).getName());
        assertTrue(extensions.get(0).getParameters().size() == 1);
        assertEquals(""param"", extensions.get(0).getParameters().get(0).getName());
        assertEquals(""  value  "", extensions.get(0).getParameters().get(0).getValue());
        assertEquals(""ext2"", extensions.get(1).getName());
        assertTrue(extensions.get(1).getParameters().size() == 1);
        assertEquals(""param"", extensions.get(1).getParameters().get(0).getName());
        assertEquals(""  value \"" "", extensions.get(1).getParameters().get(0).getValue());
    }",No Smells
"@Test
    public void testIsDone() {
        TyrusFuture<Void> voidTyrusFuture = new TyrusFuture<Void>();
        assertFalse(voidTyrusFuture.isDone());
        voidTyrusFuture.setResult(null);
        assertTrue(voidTyrusFuture.isDone());
    }",No Smells
"@Test
    public void testGetSendStream() throws IOException {

        TestRemoteEndpoint tre = new TestRemoteEndpoint();
        TyrusSession testSession = createTestSession(tre, endpointWrapper);
        TyrusRemoteEndpoint.Basic rew = new TyrusRemoteEndpoint.Basic(testSession, tre, endpointWrapper);
        OutputStream stream = rew.getSendStream();

        for (byte b : sentBytes) {
            stream.write(b);
        }",Mystery Guest + Resource Optimism
"@Test
    public void testParseHttpDateAnsiCAsc() {
        try {
            Date date = Utils.parseHttpDate(""Sun Nov  6 08:49:37 1994"");
            assertNotNull(""Date cannot be null"", date);
        }",No Smells
"@Test
    public void testParseHttpDateFail() {
        try {
            Utils.parseHttpDate(""2014-08-08 23:11:22 GMT"");
            fail(""Invalid date cannot be parsed"");
        }",No Smells
"@Test
    public void testParseHttpDateRfc1036() {
        try {
            Date date = Utils.parseHttpDate(""Sunday, 06-Nov-94 08:49:37 GMT"");
            assertNotNull(""Date cannot be null"", date);
        }",No Smells
"@Test
  public void acceptCharsetHeader() throws Exception {
    final AtomicReference<String> header = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        header.set(request.getHeader(""Accept-Charset""));
      }",No Smells
"@Test
  public void appendNullMappedQueryParams() throws Exception {
    assertEquals(""http://test.com/1"",
        HttpRequest.append(""http://test.com/1"", (Map<?, ?>) null));
  }",No Smells
"@Test
  public void appendVarargsQueryParamsWithPath() throws Exception {
    assertEquals(""http://test.com/segment1?a=b"",
        HttpRequest.append(""http://test.com/segment1"", ""a"", ""b""));
    assertEquals(""http://test.com/?a=b"",
        HttpRequest.append(""http://test.com/"", ""a"", ""b""));
  }",No Smells
"@Test
  public void appendWithNullVaragsQueryParamValues() throws Exception {
    assertEquals(""http://test.com/1?a=&b="",
        HttpRequest.append(""http://test.com/1"", ""a"", null, ""b"", null));
  }",No Smells
"@Test
  public void cacheControlHeader() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        response.setHeader(""Cache-Control"", ""no-cache"");
      }",No Smells
"@Test
  public void chunkPost() throws Exception {
    final AtomicReference<String> body = new AtomicReference<String>();
    final AtomicReference<String> encoding = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        body.set(new String(read()));
        response.setStatus(HTTP_OK);
        encoding.set(request.getHeader(""Transfer-Encoding""));
      }",No Smells
"@Test
  public void expiresHeader() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        response.setDateHeader(""Expires"", 1234000);
      }",No Smells
"@Test
  public void deleteEmpty() throws Exception {
    final AtomicReference<String> method = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        method.set(request.getMethod());
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void getEmptyParameter() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        response.setHeader(""a"", ""b;c="");
      }",No Smells
"@Test
  public void getError() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HttpServletResponse.SC_NOT_FOUND);
        write(""error"");
      }",No Smells
"@Test
  public void getMissingParameter() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        response.setHeader(""a"", ""b;c=d"");
      }",No Smells
"@Test
  public void getParameterFromMissingHeader() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        response.setHeader(""a"", ""b;c=d"");
      }",No Smells
"@Test
  public void getQuotedParameters() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        response.setHeader(""a"", ""value;b=\""c\"";d=\""e\"""");
      }",No Smells
"@Test
  public void getReaderWithCharset() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        write(""hello"");
      }",No Smells
"@Test
  public void getToOutputBody() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        try {
          response.getWriter().print(""hello world"");
        }",No Smells
"@Test
  public void getUrlEmpty() throws Exception {
    final AtomicReference<String> method = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        method.set(request.getMethod());
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void getUrlEncodedWithUnicode() throws Exception {
    String unencoded = ""/\u00DF"";
    final AtomicReference<String> path = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        path.set(request.getPathInfo());
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void getWithMappedQueryParams() throws Exception {
    Map<String, String> inputParams = new HashMap<String, String>();
    inputParams.put(""name"", ""user"");
    inputParams.put(""number"", ""100"");
    final Map<String, String> outputParams = new HashMap<String, String>();
    final AtomicReference<String> method = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        method.set(request.getMethod());
        outputParams.put(""name"", request.getParameter(""name""));
        outputParams.put(""number"", request.getParameter(""number""));
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void httpsTrust() throws Exception {
    assertNotNull(get(""https://localhost"").trustAllCerts().trustAllHosts());
  }",No Smells
"@Test
  public void ifNoneMatchHeader() throws Exception {
    final AtomicReference<String> header = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        header.set(request.getHeader(""If-None-Match""));
      }",No Smells
"@Test
  public void locationHeader() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        response.setHeader(""Location"", ""http://nowhere"");
      }",No Smells
"@Test
  public void malformedIntHeader() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        response.setHeader(""malformed"", ""not an integer"");
      }",No Smells
"@Test
  public void noError() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void nullUploadProgress() throws Exception {
    final AtomicReference<String> body = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        body.set(new String(read()));
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void postWithEscapedVarargsQueryParams() throws Exception {
    final Map<String, String> outputParams = new HashMap<String, String>();
    final AtomicReference<String> method = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        method.set(request.getMethod());
        outputParams.put(""name"", request.getParameter(""name""));
        outputParams.put(""number"", request.getParameter(""number""));
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void putEmpty() throws Exception {
    final AtomicReference<String> method = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        method.set(request.getMethod());
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void putWithEscapedMappedQueryParams() throws Exception {
    Map<String, String> inputParams = new HashMap<String, String>();
    inputParams.put(""name"", ""us er"");
    inputParams.put(""number"", ""100"");
    final Map<String, String> outputParams = new HashMap<String, String>();
    final AtomicReference<String> method = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        method.set(request.getMethod());
        outputParams.put(""name"", request.getParameter(""name""));
        outputParams.put(""number"", request.getParameter(""number""));
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void putWithVarargsQueryParams() throws Exception {
    final Map<String, String> outputParams = new HashMap<String, String>();
    final AtomicReference<String> method = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        method.set(request.getMethod());
        outputParams.put(""name"", request.getParameter(""name""));
        outputParams.put(""number"", request.getParameter(""number""));
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void receiveAppendable() throws Exception {
    final StringBuilder body = new StringBuilder();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        try {
          response.getWriter().print(""content"");
        }",No Smells
"@Test
  public void receiveFile() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        try {
          response.getWriter().print(""content"");
        }",No Smells
"@Test
  public void receivePrintStream() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        try {
          response.getWriter().print(""content"");
        }",No Smells
"@Test
  public void requestContentTypeEmptyCharset() throws Exception {
    final AtomicReference<String> contentType = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        contentType.set(request.getContentType());
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void sendErrorCloseStream() throws Exception {
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        response.setStatus(HTTP_OK);
        try {
          response.getWriter().print(""content"");
        }",No Smells
"@Test
  public void singleSslSocketFactory() {
    HttpRequest request1 = get(""https://localhost"").trustAllCerts();
    HttpRequest request2 = get(""https://localhost"").trustAllCerts();
    assertNotNull(((HttpsURLConnection) request1.getConnection())
        .getSSLSocketFactory());
    assertNotNull(((HttpsURLConnection) request2.getConnection())
        .getSSLSocketFactory());
    assertEquals(
        ((HttpsURLConnection) request1.getConnection()).getSSLSocketFactory(),
        ((HttpsURLConnection) request2.getConnection()).getSSLSocketFactory());
  }",Mystery Guest + Resource Optimism
"@Test
  public void uploadProgressSend() throws Exception {
    final AtomicReference<String> body = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        body.set(new String(read()));
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
  public void uploadProgressSendReader() throws Exception {
    final AtomicReference<String> body = new AtomicReference<String>();
    handler = new RequestHandler() {

      @Override
      public void handle(Request request, HttpServletResponse response) {
        body.set(new String(read()));
        response.setStatus(HTTP_OK);
      }",No Smells
"@Test
    public void testNormal01() throws Exception {
        // start mock fluentd
        int port = MockFluentd.randomPort();
        final List<Event> elist = new ArrayList<Event>();
        MockFluentd fluentd = new MockFluentd(port, new MockFluentd.MockProcess() {
            public void process(MessagePack msgpack, Socket socket) throws IOException {
                BufferedInputStream in = new BufferedInputStream(socket.getInputStream());
                try {
                    Unpacker unpacker = msgpack.createUnpacker(in);
                    while (true) {
                        Event e = unpacker.read(Event.class);
                        elist.add(e);
                    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testReconnection() throws Exception {
        // start mock fluentd
        int port = MockFluentd.randomPort();
        String host = ""localhost"";
        final List<Event> elist1 = new ArrayList<Event>();
        final AtomicReference<Exception> lastError = new AtomicReference<Exception>();

        FixedThreadManager threadManager = new FixedThreadManager(2);

        // run a fluentd
        MockFluentd fluentd1 = new MockFluentd(port, new MockFluentd.MockProcess() {
            public void process(MessagePack msgpack, Socket socket) throws IOException {
                BufferedInputStream in = new BufferedInputStream(socket.getInputStream());
                try {
                    Unpacker unpacker = msgpack.createUnpacker(in);
                    while (true) {
                        Event e = unpacker.read(Event.class);
                        elist1.add(e);

                        if (elist1.size() >= 1)
                            break;
                    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testDataFields() {
        AISMessage aisMessage = AISMessage.create(NMEAMessage.fromString(""!AIVDO,1,1,,A,E>lt;MIas0h3V:@;4a::h0b7W005Jh4nq:3l800003v010,4*08""));
        Map<String, Object> dataFields = aisMessage.dataFields();

        assertNotNull(dataFields);
        dataFields.forEach((k,v) -> System.out.format(""%s=%s\n"", k, v));

        assertEquals(25, dataFields.size());

        assertEquals(""AidToNavigationReport"", dataFields.get(""messageType""));
        assertEquals(0, dataFields.get(""repeatIndicator""));
        assertEquals(995036021, dataFields.get(""sourceMmsi.MMSI""));
        assertEquals(""BeaconSpecialMark"", dataFields.get(""aidType""));
        assertEquals(""S6A GLT VIRTU ATON"", dataFields.get(""name""));
        assertEquals(false, dataFields.get(""positionAccurate""));
        assertEquals(151.49791f, dataFields.get(""longitude""));
        assertEquals(-23.917385f, dataFields.get(""latitude""));
        assertEquals(0, dataFields.get(""toStern""));
        assertEquals(0, dataFields.get(""toBow""));
        assertEquals(0, dataFields.get(""toPort""));
        assertEquals(0, dataFields.get(""toStarboard""));
        assertEquals(""Surveyed"", dataFields.get(""positionFixingDevice""));
        assertEquals(60, dataFields.get(""second""));
        assertEquals(false, dataFields.get(""offPosition""));
        assertEquals(""00000000"", dataFields.get(""atoNStatus""));
        assertEquals(false, dataFields.get(""raimFlag""));
        assertEquals(true, dataFields.get(""virtualAid""));
        assertEquals(false, dataFields.get(""assignedMode""));
        assertEquals(0, dataFields.get(""spare1""));
        assertEquals(0, dataFields.get(""spare2""));
        assertNull(dataFields.get(""nameExtension""));

        assertFalse(dataFields.containsKey(""class""));
        assertFalse(dataFields.containsKey(UUID.randomUUID().toString()));
    }",No Smells
"@Test
    public void isSerializable() {
        // Type 1
        assertTrue(isSerializable(AISMessage.create(
            NMEAMessage.fromString(""!BSVDM,1,1,,A,1:02Ih001U0d=V:Op85<2aT>0<0F,0*3B"")
        )));

        // Type 4
        assertTrue(isSerializable(AISMessage.create(
            NMEAMessage.fromString(""!AIVDM,1,1,,B,4h3Ovk1udp6I9o>jPHEdjdW000S:,0*0C"")
        )));

        // Type 5
        assertTrue(isSerializable(AISMessage.create(
            NMEAMessage.fromString(""!BSVDM,2,1,5,A,5:02Ih01WrRsEH57J20H5P8u8N222222222222167H66663k085QBS1H,0*55""),
            NMEAMessage.fromString(""!BSVDM,2,2,5,A,888888888888880,2*38"")
        )));
    }",No Smells
"@Test
    public void canDecode() {
        AISMessage aisMessage = AISMessage.create(NMEAMessage.fromString(""!AIVDM,1,1,,B,4h3Ovk1udp6I9o>jPHEdjdW000S:,0*0C""));

        System.out.println(aisMessage.toString());

        assertEquals(AISMessageType.BaseStationReport, aisMessage.getMessageType());
        assertEquals((Integer) 3, aisMessage.getRepeatIndicator());
        BaseStationReport message = (BaseStationReport) aisMessage;
        assertEquals(MMSI.valueOf(3669708), message.getSourceMmsi());
        assertEquals((Integer) 2011, message.getYear());
        assertEquals((Integer) 3, message.getMonth());
        assertEquals((Integer) 16, message.getDay());
        assertEquals((Integer) 6, message.getHour());
        assertEquals((Integer) 25, message.getMinute());
        assertEquals((Integer) 9, message.getSecond());
        assertTrue(message.getPositionAccurate());
        assertEquals(Float.valueOf(37.923283f), message.getLatitude());
        assertEquals(Float.valueOf(-122.59837f), message.getLongitude());
        assertEquals(PositionFixingDevice.Surveyed, message.getPositionFixingDevice());
        assertFalse(message.getRaimFlag());
    }",No Smells
"@Test
    public void canDecodeDac200Fi10InlandShipStaticAndVoyageRelatedData1() {
        AISMessage aisMessage = AISMessage.create(NMEAMessage.fromString(""!AIVDM,1,1,,B,839udkPj2d<dteLMt1T0a?bP01L0,0*79""));
        System.out.println(aisMessage.toString());

        assertTrue(aisMessage instanceof BinaryBroadcastMessage);
        BinaryBroadcastMessage binaryBroadcastMessage = (BinaryBroadcastMessage) aisMessage;
        assertEquals(200, binaryBroadcastMessage.getDesignatedAreaCode().intValue());
        assertEquals(10, binaryBroadcastMessage.getFunctionalId().intValue());

        ApplicationSpecificMessage asm = binaryBroadcastMessage.getApplicationSpecificMessage();
        assertEquals(200, asm.getDesignatedAreaCode());
        assertEquals(10, asm.getFunctionalId());

        assertTrue(asm instanceof InlandShipStaticAndVoyageRelatedData);
        InlandShipStaticAndVoyageRelatedData inlandMessage = (InlandShipStaticAndVoyageRelatedData) asm;

        assertEquals(""02325170"", inlandMessage.getUniqueEuropeanVesselIdentificationNumber());
        assertEquals(Float.valueOf(80.0f), inlandMessage.getLengthOfShip());
        assertEquals(Float.valueOf(8.2f), inlandMessage.getBeamOfShip());
        assertEquals(Integer.valueOf(8020), inlandMessage.getShipOrCombinationType());
        assertEquals(Integer.valueOf(0), inlandMessage.getHazardousCargo());
        assertEquals(Float.valueOf(0.0f), inlandMessage.getDraught());
        assertEquals(Integer.valueOf(2), inlandMessage.getLoaded());
        assertEquals(Integer.valueOf(1), inlandMessage.getQualityOfSpeedInformation());
        assertEquals(Integer.valueOf(1), inlandMessage.getQualityOfCourseInformation());
        assertEquals(Integer.valueOf(1), inlandMessage.getQualityOfHeadingInformation());
    }",No Smells
"@Test
    public void canDecodeShortVariant1() {
        AISMessage aisMessage = AISMessage.create(NMEAMessage.fromString(""!AIVDM,1,1,,A,Dh3Ovk1UAN>4,0*0A""));

        System.out.println(aisMessage.toString());

        assertEquals(AISMessageType.DataLinkManagement, aisMessage.getMessageType());
        DataLinkManagement message = (DataLinkManagement) aisMessage;
        assertEquals(Integer.valueOf(3), message.getRepeatIndicator());
        assertEquals(MMSI.valueOf(3669708), message.getSourceMmsi());
        assertEquals((Integer) 1620, message.getOffsetNumber1());
        assertEquals((Integer) 5, message.getReservedSlots1());
        assertEquals((Integer) 7, message.getTimeout1());
        assertEquals((Integer) 225, message.getIncrement1());
        assertNull(message.getOffsetNumber2());
        assertNull(message.getReservedSlots2());
        assertNull(message.getTimeout2());
        assertNull(message.getIncrement2());
        assertNull(message.getOffsetNumber3());
        assertNull(message.getReservedSlots3());
        assertNull(message.getTimeout3());
        assertNull(message.getIncrement3());
    }",No Smells
"@Test
    public void canDecodeShortVariant2() {
        AISMessage aisMessage = AISMessage.create(NMEAMessage.fromString(""!AIVDM,1,1,,B,Dh3Ovk1cEN>4,0*3B""));

        System.out.println(aisMessage.toString());

        assertEquals(AISMessageType.DataLinkManagement, aisMessage.getMessageType());
        DataLinkManagement message = (DataLinkManagement) aisMessage;
        assertEquals(Integer.valueOf(3), message.getRepeatIndicator());
        assertEquals(MMSI.valueOf(3669708), message.getSourceMmsi());
        assertEquals((Integer) 1717, message.getOffsetNumber1());
        assertEquals((Integer) 5, message.getReservedSlots1());
        assertEquals((Integer) 7, message.getTimeout1());
        assertEquals((Integer) 225, message.getIncrement1());
        assertNull(message.getOffsetNumber2());
        assertNull(message.getReservedSlots2());
        assertNull(message.getTimeout2());
        assertNull(message.getIncrement2());
        assertNull(message.getOffsetNumber3());
        assertNull(message.getReservedSlots3());
        assertNull(message.getTimeout3());
        assertNull(message.getIncrement3());
    }",No Smells
"@Test
    public void canDecode() {
		/*
		User ID	304911000
		Navigation Status	0	Under way using engine
		Rate of Turn (ROT)	0	Turning right at up to 708 degrees per minute or higher
		Speed Over Ground (SOG)	13.6
		Position Accuracy	1	A DGPS-quality fix with an accuracy of < 10 ms
		Longitude	-123.450533333333	West
		Latitude	37.2111266666667	North
		Course Over Ground (COG)	329.7
		True Heading (HDG)	331
		Time Stamp	7
		Reserved for regional	0	Not available (default)
		RAIM flag	0	RAIM not in use (default)
		Communication State	133392	Sync state: UTC Indirect; Slot Timeout: This was the last transmission in this slot; Slot offset: 2320
		COMMUNICATION_SYNC_STATE	1	Sync state: UTC Indirect
		COMMUNICATION_SLOT_TIMEOUT	0	Slot Timeout: This was the last transmission in this slot
		COMMUNICATION_SUB_MESSAGE	2320
		COMMUNICATION_UTC_HOUR	No value
		COMMUNICATION_UTC_MINUTE	No value
		COMMUNICATION_TIME_STAMP	No value
		COMMUNICATION_SLOT_NUMBER	No value
		COMMUNICATION_RECEIVED_STATIONS	No value
		COMMUNICATION_SLOT_OFFSET	2320
		*/

        AISMessage aisMessage = AISMessage.create(NMEAMessage.fromString(""!AIVDM,1,1,,A,24RjBV0028o:pnNEBeU<pJF>0PT@,0*3F""));

        System.out.println(aisMessage.toString());

        assertEquals(AISMessageType.PositionReportClassAAssignedSchedule, aisMessage.getMessageType());
        assertEquals((Integer) 0, aisMessage.getRepeatIndicator());
        PositionReportClassAAssignedSchedule message = (PositionReportClassAAssignedSchedule) aisMessage;
        assertEquals(MMSI.valueOf(304911000), message.getSourceMmsi());
        assertEquals(NavigationStatus.UnderwayUsingEngine, message.getNavigationStatus());
        assertEquals((Integer) 0, message.getRateOfTurn());
        assertEquals((Float) 13.6f, message.getSpeedOverGround());
        assertTrue(message.getPositionAccuracy());
        assertEquals(Float.valueOf(37.21113f), message.getLatitude());
        assertEquals((Integer) 22326676, message.getRawLatitude());
        assertEquals(Float.valueOf(-123.45053f), message.getLongitude());
        assertEquals((Integer) (-74070321), message.getRawLongitude());
        assertEquals(Float.valueOf(329.7f), message.getCourseOverGround());
        assertEquals((Integer) 3297, message.getRawCourseOverGround());
        assertEquals((Integer) 331, message.getTrueHeading());
        assertEquals((Integer) 7, message.getSecond());
        assertEquals(ManeuverIndicator.NotAvailable, message.getSpecialManeuverIndicator());
        assertFalse(message.getRaimFlag());
    }",No Smells
"@Test
    public void canDecodeCommunicationState() {
        AISMessage aisMessage = AISMessage.create(NMEAMessage.fromString(""!AIVDM,1,1,,A,17OoHr?P009qtlQd6T<0<?wN041P,0*01""));

        System.out.println(aisMessage.toString());

        assertEquals(AISMessageType.PositionReportClassAScheduled, aisMessage.getMessageType());
        assertEquals((Integer) 0, aisMessage.getRepeatIndicator());
        PositionReportClassAScheduled message = (PositionReportClassAScheduled) aisMessage;
        assertEquals(MMSI.valueOf(503175400), message.getSourceMmsi());
        assertEquals(NavigationStatus.Undefined, message.getNavigationStatus());
        assertEquals(Integer.valueOf(-731), message.getRateOfTurn());
        assertEquals(Float.valueOf(0.0f), message.getSpeedOverGround());
        assertFalse(message.getPositionAccuracy());
        assertEquals(Float.valueOf(-34.773254f), message.getLatitude());
        assertEquals(Float.valueOf(138.48856f), message.getLongitude());
        assertEquals(Float.valueOf(4.8f), message.getCourseOverGround());
        assertEquals(Integer.valueOf(47), message.getSecond());
        assertEquals(Integer.valueOf(511), message.getTrueHeading());
        assertEquals(ManeuverIndicator.NotAvailable, message.getSpecialManeuverIndicator());
        assertFalse(message.getRaimFlag());

        CommunicationState communicationState = message.getCommunicationState();
        assertEquals(SyncState.UTCDirect, communicationState.getSyncState());

        assertTrue(communicationState instanceof SOTDMACommunicationState);
        SOTDMACommunicationState sotdmaCommunicationState = (SOTDMACommunicationState) communicationState;
        assertNull(sotdmaCommunicationState.getNumberOfReceivedStations());
        assertNull(sotdmaCommunicationState.getSlotNumber());
        assertNull(sotdmaCommunicationState.getSlotOffset());
        assertEquals(Integer.valueOf(1), sotdmaCommunicationState.getSlotTimeout());
        assertEquals(Integer.valueOf(0), sotdmaCommunicationState.getUtcHour());
        assertEquals(Integer.valueOf(24), sotdmaCommunicationState.getUtcMinute());
    }",No Smells
"@Test
    public void digest() throws NoSuchAlgorithmException {
        String expectedDigest = ""2ca6350a33d7b19f0ef49799aa96dd61da9e081e"";

        AISMessage aisMessage = AISMessage.create(
            NMEAMessage.fromString(""!AIVDM,2,1,0,B,539S:k40000000c3G04PPh63<00000000080000o1PVG2uGD:00000000000,0*34""),
            NMEAMessage.fromString(""!AIVDM,2,2,0,B,00000000000,2*27"")
        );
        byte[] digest = aisMessage.digest();
        String digestAsString = String.format(""%040x"", new java.math.BigInteger(1, digest));
        assertEquals(expectedDigest, digestAsString);

        // Change line 1
        aisMessage = AISMessage.create(
            NMEAMessage.fromString(""!AIVDM,2,1,0,B,539S:k40000000c3G04PPh63<00000000080000o1PVG2uGD:00000000001,0*34""),
            NMEAMessage.fromString(""!AIVDM,2,2,0,B,00000000000,2*27"")
        );
        digest = aisMessage.digest();
        digestAsString = String.format(""%040x"", new java.math.BigInteger(1, digest));
        assertNotEquals(expectedDigest, digestAsString);

        // Change line 2
        aisMessage = AISMessage.create(
            NMEAMessage.fromString(""!AIVDM,2,1,0,B,539S:k40000000c3G04PPh63<00000000080000o1PVG2uGD:00000000000,0*34""),
            NMEAMessage.fromString(""!AIVDM,2,2,0,B,00000000001,2*27"")
        );
        digest = aisMessage.digest();
        digestAsString = String.format(""%040x"", new java.math.BigInteger(1, digest));
        assertNotEquals(expectedDigest, digestAsString);


    }",No Smells
"@Test
    public void canDecode1() {
        AISMessage aisMessage = AISMessage.create(NMEAMessage.fromString(""!AIVDM,1,1,,A,B5NJ;PP005l4ot5Isbl03wsUkP06,0*76""));

        System.out.println(aisMessage.toString());

        assertEquals(AISMessageType.StandardClassBCSPositionReport, aisMessage.getMessageType());
        StandardClassBCSPositionReport message = (StandardClassBCSPositionReport) aisMessage;
        assertEquals(Integer.valueOf(0), message.getRepeatIndicator());
        assertEquals(MMSI.valueOf(367430530), message.getSourceMmsi());
        assertEquals(""00000000"", message.getRegionalReserved1());
        assertEquals((Float) 0.0f, message.getSpeedOverGround());
        assertEquals((Integer) 0, message.getRawSpeedOverGround());
        assertFalse(message.getPositionAccurate());
        assertEquals(Float.valueOf(37.785034f), message.getLatitude());
        assertEquals((Integer)22671021, message.getRawLatitude());
        assertEquals(Float.valueOf(-122.26732f), message.getLongitude());
        assertEquals((Integer)(-73360392), message.getRawLongitude());
        assertEquals(Float.valueOf(0.0f), message.getCourseOverGround());
        assertEquals((Integer) 0, message.getRawCourseOverGround());
        assertEquals((Integer) 511, message.getTrueHeading());
        assertEquals((Integer) 55, message.getSecond());
        assertEquals(""00"", message.getRegionalReserved2());
        assertTrue(message.getCsUnit());
        assertFalse(message.getDisplay());
        assertTrue(message.getDsc());
        assertTrue(message.getBand());
        assertTrue(message.getMessage22());
        assertFalse(message.getAssigned());
        assertFalse(message.getRaimFlag());
        //assertEquals(""11100000000000000110"", message.getRadioStatus());
    }",No Smells
"@Test
    public void c_canFlushEmpty() {
        NMEAMessage unfragmentedNMEAMessage = NMEAMessage.fromString(""!AIVDM,1,1,,B,15MqdBP000G@qoLEi69PVGaN0D0=,0*3A"");
        NMEAMessage fragmentedNMEAMessage1 = NMEAMessage.fromString(""!AIVDM,2,1,3,B,55DA><02=6wpPuID000qTf059@DlU<00000000171lMDD4q20LmDp3hB,0*27"");
        NMEAMessage fragmentedNMEAMessage2 = NMEAMessage.fromString(""!AIVDM,2,2,3,B,p=Mh00000000000,2*4C"");

        final ArgumentCaptor<AISMessage> aisMessage = new ArgumentCaptor<>();

        context.checking(new Expectations() {{
            exactly(3).of(aisMessageHandler).accept(with(aisMessage.getMatcher()));
        }",No Smells
"@Test
    public void a_canHandleUnfragmentedMessageReceived() {
        NMEAMessage unfragmentedNMEAMessage = NMEAMessage.fromString(""!AIVDM,1,1,,B,15MqdBP000G@qoLEi69PVGaN0D0=,0*3A"");

        final ArgumentCaptor<AISMessage> aisMessage = new ArgumentCaptor<>();

        context.checking(new Expectations() {{
            oneOf(aisMessageHandler).accept(with(aisMessage.getMatcher()));
        }",No Smells
"@Test
    public void testConstructor() {

        BasicListener bl = new BasicListener();

        assertNull(bl.received);
        assertEquals(bl.messageType, AISMessage01.class);
    }",No Smells
"@Test
    public void testOnMessageWithExpectedMessage() {

        BasicListener bl = new BasicListener();

        bl.sentenceRead(AIS_01);
        assertEquals(bl.received.toString(), MSG_01.toString());
    }",No Smells
"@Test
    public void getLongitudeInDegrees() throws Exception {
        assertEquals(31.033513, msg.getLongitudeInDegrees(), 0.000001);
    }",No Smells
"@Test
    public void getETAHour() throws Exception {
        assertEquals(19, msg.getETAHour());
    }",No Smells
"@Test
    public void getDTEFlag() throws Exception {
        // 1 == false, ""not available"" (default)
        assertEquals(false, msg.getDTEFlag());
    }",No Smells
"@Test
    public void getRadioStatus() throws Exception {
        assertEquals(0, msg.getRadioStatus());
    }",No Smells
"@Test
    public void getBow() throws Exception {
        assertEquals(5, msg.getBow());
    }",No Smells
"@Test
    public void getOffPositionIndicator() throws Exception {
        assertEquals(true, msg.getOffPositionIndicator());
    }",No Smells
"@Test
    public void getPort() throws Exception {
        assertEquals(3, msg.getPort());
    }",No Smells
"@Test
    public void getRegional() throws Exception {
        // ""00001010"" ?
        assertEquals(10, msg.getRegional());
    }",No Smells
"@Test
    public void getStern() throws Exception {
        assertEquals(3, msg.getStern());
    }",No Smells
"@Test
    public void hasLatitude() {
        assertEquals(true, msg.hasLatitude());
    }",No Smells
"@Test
    public void hasLongitude() {
        assertEquals(true, msg.hasLongitude());
    }",No Smells
"@Test
    public void getPartNumber() throws Exception {
        assertEquals(0, partA.getPartNumber());
        assertEquals(1, partB.getPartNumber());
    }",No Smells
"@Test
    public void getStern() throws Exception {
        assertEquals(4, partB.getStern());
    }",No Smells
"@Test
    public void getUnitModelCode() throws Exception {
        // TODO correct?
        assertEquals(13, partB.getUnitModelCode());
    }",No Smells
"@Test
    public void getVendorId() throws Exception {
        // TODO correct? should be ""1234567"" according to http://www.maritec.co.za/tools/aisvdmvdodecoding/
        assertEquals(""123"", partB.getVendorId());
    }",No Smells
"@Test
    public void testCreateWithIncorrectOrder() {
        try {
            amf.create(split2, split1);
            fail(""AISMessageFactory didn't throw on incorrect order"");
        }",No Smells
"@Test
    public void testAppendNegativeFillBits() {
        try {
            AISMessageParser msg = new AISMessageParser();
            msg.append(payload, 1, -1);
            fail(""AISMessageParser.append() did not throw exception"");
        }",No Smells
"@Test
    public void testGetMessageType() {
        assertEquals(1, parser.getMessageType());
    }",No Smells
"@Test
    public void testGetRepeatIndicator() {
        assertEquals(0, parser.getRepeatIndicator());
    }",No Smells
"@Test
    public void getPositionAccuracy() throws Exception {
        assertEquals(false, msg.isAccurate());
    }",No Smells
"@Test
    public void getSpeedOverGround() throws Exception {
        assertEquals(1.4, msg.getSpeedOverGround(), 0.1);
    }",No Smells
"@Test
    public void getTimeStamp() throws Exception {
        assertEquals(34, msg.getTimeStamp());
    }",No Smells
"@Test
    public void hasLongitude() {
        assertEquals(true, msg.hasLongitude());
    }",No Smells
"@Test
    public void getCourseOverGround() throws Exception {
        assertEquals(40.4, msg.getCourseOverGround(), 0.1);
    }",No Smells
"@Test
    public void getRateOfTurn() throws Exception {
        assertEquals(-2.9, msg.getRateOfTurn(), 0.1);
    }",No Smells
"@Test
    public void getTimeStamp() throws Exception {
        assertEquals(53, msg.getTimeStamp());
    }",No Smells
"@Test
    public void hasCourseOverGround() {
        assertEquals(true, msg.hasCourseOverGround());
    }",No Smells
"@Test
    public void hasSpeedOverGround() {
        assertEquals(true, msg.hasSpeedOverGround());
    }",No Smells
"@Test
    public void hasTimeStamp() {
        assertEquals(true, msg.hasTimeStamp());
    }",No Smells
"@Test
    public void conversionReturnsOnInvalidValues() {
        assertEquals(-101.1, Latitude27.toDegrees(Double.valueOf(-101.1*60*10000).intValue()), DELTA);
        assertEquals(91.1, Latitude27.toDegrees(Double.valueOf(91.1*60*10000).intValue()), DELTA);
        assertEquals(102.3, Latitude27.toDegrees(Double.valueOf(102.3*60*10000).intValue()), DELTA);
    }",No Smells
"@Test
    public void conversionToKnotsWorks() {
        assertEquals(-90.0, Latitude27.toDegrees(Double.valueOf(-90.0*60*10000).intValue()), DELTA);
        assertEquals(-45.1, Latitude27.toDegrees(Double.valueOf(-45.1*60*10000).intValue()), DELTA);
        assertEquals(0.0, Latitude27.toDegrees(0), 0.00001);
        assertEquals(45.9, Latitude27.toDegrees(Double.valueOf(45.9*60*10000).intValue()), DELTA);
        assertEquals(90.0, Latitude27.toDegrees(Double.valueOf(90.0*60*10000).intValue()), DELTA);
    }",No Smells
"@Test
    public void defaultValueIsNotAvailable() {
        assertFalse(Latitude27.isAvailable(91*60*10000));
    }",No Smells
"@Test
    public void largeValueIsNotCorrect() {
        assertFalse(Latitude27.isCorrect(1+90*60*10000));
    }",No Smells
"@Test
    public void maxValueIsAvailable() {
        assertTrue(Latitude27.isAvailable(90*60*10000));
    }",No Smells
"@Test
    public void zeroIsAvailable() {
        assertTrue(Latitude27.isAvailable(0));
    }",No Smells
"@Test
    public void conversionToKnotsWorks() {
        assertEquals(-180.0, Longitude28.toDegrees(Double.valueOf(-180.0*60*10000).intValue()), DELTA);
        assertEquals(-45.1, Longitude28.toDegrees(Double.valueOf(-45.1*60*10000).intValue()), DELTA);
        assertEquals(0.0, Longitude28.toDegrees(0), 0.00001);
        assertEquals(45.9, Longitude28.toDegrees(Double.valueOf(45.9*60*10000).intValue()), DELTA);
        assertEquals(180.0, Longitude28.toDegrees(Double.valueOf(180.0*60*10000).intValue()), DELTA);
    }",No Smells
"@Test
    public void defaultValueIsCorrect() {
        assertTrue(Longitude28.isCorrect(181*60*10000));
    }",No Smells
"@Test
    public void minValueIsAvailable() {
        assertTrue(Longitude28.isAvailable(-180*60*10000));
    }",No Smells
"@Test
    public void conversionReturnsOnInvalidValues() {
        assertEquals(-10.1, SpeedOverGround.toKnots(-101), DELTA);
        assertEquals(102.3, SpeedOverGround.toKnots(1023), DELTA);
        assertEquals(4567.8, SpeedOverGround.toKnots(45678), DELTA);
    }",No Smells
"@Test
    public void maxValueIsAvailable() {
        assertTrue(SpeedOverGround.isAvailable(1022));
    }",No Smells
"@Test
    public void minValueIsAvailable() {
        assertTrue(SpeedOverGround.isAvailable(0));
    }",No Smells
"@Test
    public void testExtendedGenericsListenerWithExpectedSentence() {
        ExtendedGenericsListener<String, Integer, GGASentence> egl = new ExtendedGenericsListener<>(GGASentence.class);
        egl.sentenceRead(GGA_EVENT);
        assertNotNull(egl.received);
        assertEquals(GGA.toSentence(), egl.received.toSentence());
        assertEquals(3556498, egl.hashify(""test""));
        assertEquals(""3"", egl.stringify(3));
    }",No Smells
"@Test
    public void testGenericsHidingListenerWithExpectedSentence() {
        GenericsHidingListener<Double> ghl = new GenericsHidingListener<>();
        ghl.sentenceRead(BOD_EVENT);
        assertNotNull(ghl.received);
        assertEquals(BOD.toSentence(), ghl.received.toSentence());
        assertEquals(""4.5"", ghl.dummy(4.5));
        assertEquals(""5"", ghl.stringify(5));
    }",No Smells
"@Test
    public void testGenericsHidingListenerWithUnexpectedSentence() {
        GenericsHidingListener<Double> ghl = new GenericsHidingListener<>();
        ghl.sentenceRead(GGA_EVENT);
        assertNull(ghl.received);
    }",No Smells
"@Test
	public void testAddSentenceListenerSentenceListenerString() {
		DummySentenceListener dummy = new DummySentenceListener();
		reader.addSentenceListener(dummy, ""GLL"");
	}",No Smells
"@Test
	public void testDataListener() {

		// expected non-NMEA line in TEST_DATA
		final String expected = ""=~=~=~=~=~=~=~=~=~=~=~= PuTTY log 2010.02.13 13:08:23 =~=~=~=~=~=~=~=~=~=~=~="";

		DataListener listener = new DataListener() {
			@Override
			public void dataRead(String data) {
				assertEquals(expected, data);
				reader.stop();
			}",No Smells
"@Test
	public void testFireReadingPaused() {
		assertFalse(paused);
		reader.fireReadingPaused();
		assertTrue(paused);
	}",No Smells
"@Test
	public void testFireReadingStarted() {
		assertFalse(started);
		reader.fireReadingStarted();
		assertTrue(started);
	}",No Smells
"@Test
	public void testRemoveSentenceListener() {
		assertFalse(started);
		reader.removeSentenceListener(testListener);
		reader.fireReadingStarted();
		assertFalse(started);
	}",No Smells
"@Test
	public void testAdd() {
		String a = ""$GPGLL,6011.552,N,02501.941,E,120045,A"";
		String b = ""$GPGLL,6011.552,N,02501.941,E,120045,A*"";
		String c = ""$GPGLL,6011.552,N,02501.941,E,120045,A*00"";
		final String expected = a.concat(""*26"");
		assertEquals(expected, Checksum.add(a));
		assertEquals(expected, Checksum.add(b));
		assertEquals(expected, Checksum.add(c));
	}",No Smells
"@Test
	public void testSetLatHemisphere() {
		instance.setLatHemisphere(1, CompassPoint.SOUTH);
		assertTrue(instance.toString().contains("",S,""));
		assertEquals(CompassPoint.SOUTH, instance.parseHemisphereLat(1));
	}",No Smells
"@Test
	public void testSetLongitude() {
		// 02801.941
		final double lon = 28 + (01.941 / 60);
		instance.setLongitude(2, lon);
		assertTrue(instance.toString().contains("",02801.941""));
		assertEquals(lon, instance.parseDegrees(2), 0.000001);
	}",No Smells
"@Test
	public void testSetLonHemisphere() {
		instance.setLonHemisphere(3, CompassPoint.WEST);
		assertTrue(instance.toString().contains("",W,""));
		assertEquals(CompassPoint.WEST, instance.parseHemisphereLon(3));
	}",No Smells
"@Test
	public void testCreateParser() {
		Sentence bod = instance.createParser(BODTest.EXAMPLE);
		assertNotNull(bod);
		assertTrue(bod instanceof Sentence);
		assertTrue(bod instanceof BODSentence);
		assertTrue(bod instanceof BODParser);
		assertEquals(BODTest.EXAMPLE, bod.toSentence());
	}",No Smells
"@Test
	public void testCreateParserWithEmptyString() {
		try {
			instance.createParser("""");
			fail(""Did not throw exception"");
		}",No Smells
"@Test
	public void testGetInstance() {
		assertNotNull(instance);
		assertTrue(instance == SentenceFactory.getInstance());
		assertEquals(instance, SentenceFactory.getInstance());
	}",No Smells
"@Test
	public void testSupportedTypesRegistered() {
		for (SentenceId id : SentenceId.values()) {
			String msg = ""Parser not registered: "" + id;
			assertTrue(msg, instance.hasParser(id.toString()));
		}",Eager Test
"@Test
	public void testConstructorWithAIVDO() {
        testConstructorWithAIS(VDO_EXAMPLE);
    }",No Smells
"@Test
	public void testConstructorWithInvalidSentence() {
		try {
			String sent = ""GPBOD,234.9,T,228.8,M,RUSKI,*1D"";
			new SentenceParser(sent);
			fail(""Did not throw exception"");
		}",No Smells
"@Test
	public void testEqualsWithNonEqual() {
		assertFalse(instance.equals(new SentenceParser(RMBTest.EXAMPLE)));
	}",No Smells
"@Test
	public void testEqualsWithSelf() {
		assertTrue(instance.equals(instance));
	}",No Smells
"@Test
	public void testGetDoubleValueWithEmptyFields() {
		String nmea = ""$GPGLL,,,,,,"";
		SentenceParser s = new SentenceParser(nmea);
		try {
			s.getDoubleValue(2);
			fail(""Did not throw exception"");
		}",No Smells
"@Test
	public void testGetDoubleValueWithInvalidValue() {
		String nmea = ""$GPGLL,a,b,c,d,e,f"";
		SentenceParser s = new SentenceParser(nmea);
		try {
			s.getDoubleValue(2);
			fail(""Did not throw exception"");
		}",No Smells
"@Test
	public void testGetStringValueWithIndexGreaterThanAllowed() {
		try {
			instance.getStringValue(instance.getFieldCount());
			fail(""Did not throw IndexOutOfBoundsException"");
		}",No Smells
"@Test
	public void testSetFieldCountHigherByOne() {

		final int count = instance.getFieldCount() + 1;
		final int lastIndex = instance.getFieldCount() - 1;
		final String value = instance.getStringValue(lastIndex);

		instance.setFieldCount(count);
		assertEquals(count, instance.getFieldCount());
		assertEquals(value, instance.getStringValue(lastIndex));
	}",No Smells
"@Test
	public void testSetFieldCountHigherByOne() {

		final int count = instance.getFieldCount() + 1;
		final int lastIndex = instance.getFieldCount() - 1;
		final String value = instance.getStringValue(lastIndex);

		instance.setFieldCount(count);
		assertEquals(count, instance.getFieldCount());
		assertEquals(value, instance.getStringValue(lastIndex));
	}",No Smells
"@Test
	public void testToSentenceWithMaxLengthExceeded() {
		try {
			int max = instance.toString().length() - 1;
			assertEquals(RMCTest.EXAMPLE, instance.toSentence(max));
			fail(""didn't throw exception"");
		}",No Smells
"@Test
	public void testIsSentenceWithChecksumAndNewline() {

		String nmea = ""$GPRMC,142312.000,V,,,,,,,080514,,*20\r\n"";
		assertTrue(SentenceValidator.isSentence(nmea));

		nmea = ""$GPRMC,142312.000,V,,,,,,,080514,,*20\n\r"";
		assertTrue(SentenceValidator.isSentence(nmea));

		nmea = ""$GPRMC,142312.000,V,,,,,,,080514,,*20\r"";
		assertTrue(SentenceValidator.isSentence(nmea));

		nmea = ""$GPRMC,142312.000,V,,,,,,,080514,,*20\n"";
		assertTrue(SentenceValidator.isSentence(nmea));

		nmea = ""$GPRMC,142312.000,V,,,,,,,080514,,*20\r\n\r\n"";
		assertFalse(SentenceValidator.isSentence(nmea));
	}",No Smells
"@Test
	public void testIsSentenceWithoutChecksum() {
		String nmea = ""$GPRMC,142312.000,V,,,,,,,080514,,"";
		assertTrue(SentenceValidator.isSentence(nmea));
	}",No Smells
"@Test
	public void testIsValidWithInvalidInput() {
		// invalid checksum, otherwise valid
		assertFalse(SentenceValidator.isValid(""$ABCDE,1,2,3,4,5,6,7,8,9*00""));
		// something weird
		assertFalse(SentenceValidator.isValid(null));
		assertFalse(SentenceValidator.isValid(""""));
		assertFalse(SentenceValidator.isValid(""$""));
		assertFalse(SentenceValidator.isValid(""*""));
		assertFalse(SentenceValidator.isValid(""$,*""));
		assertFalse(SentenceValidator.isValid(""$GPGSV*""));
		assertFalse(SentenceValidator.isValid(""foobar""));
		assertFalse(SentenceValidator.isValid(""$gpgga,1,2,3,4,5,6,7,8,9""));
		assertFalse(SentenceValidator.isValid(""GPGGA,1,2,3,4,5,6,7,8,9""));
		assertFalse(SentenceValidator.isValid(""$GpGGA,1,2,3,4,5,6,7,8,9""));
		assertFalse(SentenceValidator.isValid(""$GPGGa,1,2,3,4,5,6,7,8,9""));
		assertFalse(SentenceValidator.isValid(""$GPGG#,1,2,3,4,5,6,7,8,9""));
		assertFalse(SentenceValidator.isValid(""$AB,1,2,3,4,5,6,7,8,9""));
		assertFalse(SentenceValidator.isValid(""$ABCDEFGHIJK,1,2,3,4,5,6,7,8,9""));
		assertFalse(SentenceValidator.isValid(""$GPGGA,1,2,3,4,5,6,7,8,9*00""));
	}",No Smells
"@Test
	public void testEqualsWrongType() {
		Object str = new String(""foobar"");
		Object dbl = Double.valueOf(123);
		assertFalse(instance.equals(str));
		assertFalse(instance.equals(dbl));
	}",No Smells
"@Test
	public void testGetYear() {
		assertEquals(cal.get(Calendar.YEAR), instance.getYear());
	}",No Smells
"@Test
	public void testSetYearTwoDigit() {
		int century = 2000;
		for (int year = 0; year < 100; year++) {
			instance.setYear(year);
			assertEquals((century + year), instance.getYear());
			if (year == Date.PIVOT_YEAR) {
				century = 1900;
			}",Eager Test
"@Test
	public void testToISO8601FourDigitYear() {
		Date d = new Date(2013, 9, 2);
		assertEquals(""2013-09-02"", d.toISO8601());
	}",No Smells
"@Test
	public void testToISO8601WithTime() {
		Date d = new Date(2013, 9, 2);
		Time t = new Time(2, 7, 9);
		assertEquals(""2013-09-02T02:07:09+00:00"", d.toISO8601(t));
	}",No Smells
"@Test
	public void testToISO8601WithTimeAndZeroZone() {
		Date d = new Date(2013, 9, 2);
		Time t = new Time(2, 7, 9, 0, 0);
		assertEquals(""2013-09-02T02:07:09+00:00"", d.toISO8601(t));
	}",No Smells
"@Test
	public void testGetLatitudeHemisphere() {
		assertEquals(CompassPoint.NORTH, instance.getLatitudeHemisphere());
	}",No Smells
"@Test
	public void testSetIllegalLongitudeEast() {
		try {
			instance.setLongitude(180.0001);
			fail(""Did not throw exception"");
		}",No Smells
"@Test
	public void testSetIllegalLongitudeWest() {
		try {
			instance.setLongitude(-180.0001);
			fail(""Did not throw exception"");
		}",No Smells
"@Test
	public void testSetLatitudeNorth() {
		assertEquals(60.0, instance.getLatitude(), 0.0000001);
		instance.setLatitude(90.0);
		assertEquals(90.0, instance.getLatitude(), 0.0000001);
		assertEquals(CompassPoint.NORTH, instance.getLatitudeHemisphere());
	}",No Smells
"@Test
	public void testSetLongitudeEast() {
		assertEquals(25.0, instance.getLongitude(), 0.0000001);
		instance.setLongitude(180.0);
		assertEquals(180, instance.getLongitude(), 0.0000001);
		assertEquals(CompassPoint.EAST, instance.getLongitudeHemisphere());
	}",No Smells
"@Test
	public void testToWaypoint() {
		final String name = ""TEST"";
		final Waypoint wp = instance.toWaypoint(name);
		assertEquals(name, wp.getId());
		assertEquals("""", wp.getDescription());
		assertEquals(instance.getLatitude(), wp.getLatitude(), 0.00001);
		assertEquals(instance.getLongitude(), wp.getLongitude(), 0.00001);
		assertEquals(instance.getLatitudeHemisphere(), wp.getLatitudeHemisphere());
		assertEquals(instance.getLongitudeHemisphere(), wp.getLongitudeHemisphere());
		assertEquals(instance.getDatum(), wp.getDatum());
	}",No Smells
"@Test
	public void testFormatTimeWithDecimals() {
		Time t = new Time(1, 2, 3.456);
		assertEquals(""010203.456"", t.toString());
	}",No Smells
"@Test
	public void testParseTimeWithoutDecimals() {
		Time t = new Time(""010203"");
		assertEquals(1, t.getHour());
		assertEquals(2, t.getMinutes());
		assertEquals(3.0, t.getSeconds(), 0.001);
	}",No Smells
"@Test
	public void testSetInvalidSeconds() {
		try {
			time.setSeconds(60.0);
			fail(""Did not throw exception"");
		}",No Smells
"@Test
	public void testSetMinutes() {
		time.setMinutes(30);
		assertEquals(30, time.getMinutes());
	}",No Smells
"@Test
	public void testSetTime() {

		Date now = new Date();
		time.setTime(now);

		GregorianCalendar cal = new GregorianCalendar();
		cal.setTime(now);
		int hours = cal.get(Calendar.HOUR_OF_DAY);
		int minutes = cal.get(Calendar.MINUTE);
		int fullSeconds = cal.get(Calendar.SECOND);
		int milliSeconds = cal.get(Calendar.MILLISECOND);
		double seconds = fullSeconds + (milliSeconds / 1000.0);

		assertEquals(hours, time.getHour());
		assertEquals(minutes, time.getMinutes());
		assertEquals(seconds, time.getSeconds(), 0.001);
	}",No Smells
"@Test
	public void testHDGSentenceRead() {

		Sentence s = factory.createParser(HDGTest.EXAMPLE);
		assertNull(event);

		instance.sentenceRead(new SentenceEvent(this, s));
		
		assertNotNull(event);
		assertEquals(123.4, event.getHeading(), 0.1);
		assertFalse(event.isTrue());
	}",No Smells
"@Test
	public void testHDMSentenceRead() {

		Sentence s = factory.createParser(HDMTest.EXAMPLE);
		assertNull(event);

		instance.sentenceRead(new SentenceEvent(this, s));

		assertNotNull(event);
		assertEquals(90.0, event.getHeading(), 0.1);
		assertFalse(event.isTrue());
	}",No Smells
"@Test
    public void path_is_available() {
        QAbstractEntityTest_CategoryReference categoryReference = QAbstractEntityTest_CategoryReference.categoryReference;
        assertNotNull(categoryReference.category.defaultChild);
    }",No Smells
"@Test
    public void inheritance() {
        assertNotNull(entity3.entity3Ref.entity2Ref);
        assertNotNull(entity3.entity3Ref.entity3Ref);

        // super
        assertNotNull(entity3.entity3Ref._super.entity2Ref);
    }",No Smells
"@Test
    public void test() {
        QType1 type1 = QType1.type1;
        QType2 type2 = QType2.type2;
        assertEquals(type2.getType(), type1.property.getType());
        assertEquals(type2.getClass(), type1.property.getClass());
    }",No Smells
"@Test
    public void test() {
        assertEquals(Path.class, QPath.path.getType());
    }",No Smells
"@Test
    public void rooJpaActiveRecord() {
        assertNotNull(QRooEntities_MyEntity2.myEntity2);
    }",No Smells
"@Test
    public void rooJpaEntity() {
        assertNotNull(QRooEntities_MyEntity.myEntity);
    }",No Smells
"@Test
    public void skipped_field1() {
        start(QSimpleTypesTest_SimpleTypes.class, QSimpleTypesTest_SimpleTypes.simpleTypes);
        assertMissing(""skipMe"");
    }",No Smells
"@Test
    public void skipped_field2() {
        start(QSimpleTypesTest_SimpleTypes.class, QSimpleTypesTest_SimpleTypes.simpleTypes);
        assertMissing(""test"");
    }",No Smells
"@Test
    public void process() throws IOException {
        List<String> sources = Arrays.asList(
                new File(packagePath, ""IntegerExtensions.java"").getPath(),
                new File(packagePath, ""ExampleEntity2.java"").getPath());
        process(QuerydslAnnotationProcessor.class, sources, ""integerExtensions"");
                String qtypeContent = new String(Files.readAllBytes(Paths.get(""target"", ""integerExtensions"", ""com"", ""querydsl"", ""QExampleEntity2.java"")), StandardCharsets.UTF_8);
        //The superclass' id property is inherited, but can't be assigned to the custom QInteger
        assertTrue(qtypeContent.contains(""public final ext.java.lang.QInteger id = new ext.java.lang.QInteger(_super.id);""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void process_abstractClasses2() throws IOException {
        String path = new File(""src/test/java/com/querydsl/apt/domain/AbstractClasses2Test.java"").getPath();
        process(JPAAnnotationProcessor.class, Collections.singletonList(path),""abstractClasses2"");
    }",Mystery Guest + Resource Optimism
"@Test
    public void process_generic13Test() throws IOException {
        String path = new File(""src/test/java/com/querydsl/apt/domain/Generic13Test.java"").getPath();
        process(QuerydslAnnotationProcessor.class, Collections.singletonList(path),""Generic13Test"");
    }",Mystery Guest + Resource Optimism
"@Test
    public void process_inheritance2Test() throws IOException {
        String path = new File(""src/test/java/com/querydsl/apt/inheritance/Inheritance2Test.java"").getPath();
        process(QuerydslAnnotationProcessor.class, Collections.singletonList(path),""InheritanceTest2"");
    }",Mystery Guest + Resource Optimism
"@Test
    public void process_monitoredCompany() throws IOException {
        String path = new File(PACKAGE_PATH, ""MonitoredCompany.java"").getPath();
        process(QuerydslAnnotationProcessor.class, Collections.singletonList(path),""MonitoredCompany"");
    }",Mystery Guest + Resource Optimism
"@Test
    public void process_queryEmbedded4() throws IOException {
        String path = new File(""src/test/java/com/querydsl/apt/domain/QueryEmbedded4Test.java"").getPath();
        process(QuerydslAnnotationProcessor.class, Collections.singletonList(path),""QueryEmbedded4Test"");
    }",Mystery Guest + Resource Optimism
"@Test
    public void rooAnnotationProcessor() throws IOException {
        process(RooAnnotationProcessor.class, CLASSES, ""roo"");

        assertTrue(new File(""target/roo/com/querydsl/apt/domain/QRooEntities_MyEntity.java"").exists());
    }",Mystery Guest + Resource Optimism
"@Test
    public void annotated_property() throws IOException {
        Property property = new Property(type, ""entityField"", type);
        property.addAnnotation(new QueryEntityImpl());
        type.addProperty(property);

        BeanSerializer serializer = new BeanSerializer();
        serializer.serialize(type, SimpleSerializerConfig.DEFAULT, new JavaWriter(writer));
        String str = writer.toString();

        assertTrue(str.contains(""import com.querydsl.core.annotations.QueryEntity;""));
        assertTrue(str.contains(""@QueryEntity""));
    }",No Smells
"@Test
    public void annotated_property_not_serialized() throws IOException {
        Property property = new Property(type, ""entityField"", type);
        property.addAnnotation(new QueryEntityImpl());
        type.addProperty(property);

        BeanSerializer serializer = new BeanSerializer(false);
        serializer.serialize(type, SimpleSerializerConfig.DEFAULT, new JavaWriter(writer));
        String str = writer.toString();

        assertFalse(str.contains(""import com.querydsl.core.annotations.QueryEntity;""));
        assertFalse(str.contains(""@QueryEntity""));
    }",No Smells
"@Test
    public void interfaces2() throws IOException {
        BeanSerializer serializer = new BeanSerializer();
        serializer.addInterface(Serializable.class);
        serializer.serialize(type, SimpleSerializerConfig.DEFAULT, new JavaWriter(writer));
        assertTrue(writer.toString().contains(""public class DomainClass implements Serializable {""));
    }",No Smells
"@Test
    public void defaultPrefix() {
        assertEquals(""Q"", module.get(String.class, CodegenModule.PREFIX));
    }",No Smells
"@Test
    public void equals_object() {
        Delegate delegate = new Delegate(Types.STRING, Types.STRING, ""delegate"", Collections.<Parameter>emptyList(), Types.STRING);
        Delegate delegate2 = new Delegate(Types.STRING, Types.STRING, ""delegate"", Collections.<Parameter>emptyList(), Types.STRING);
        assertEquals(delegate, delegate2);
    }",No Smells
"@Test
    public void correct_superclass() throws IOException {
        SimpleType type = new SimpleType(TypeCategory.ENTITY, ""java.util.Locale"", ""java.util"", ""Locale"",false,false);
        EntityType entityType = new EntityType(type);
        typeMappings.register(entityType, queryTypeFactory.create(entityType));
        serializer.serialize(entityType, SimpleSerializerConfig.DEFAULT, new JavaWriter(writer));
        assertTrue(writer.toString().contains(""public class QLocale extends BeanPath<Locale> {""));
        CompileUtils.assertCompiles(""QLocale"", writer.toString());
    }",No Smells
"@Test
    public void no_package() throws IOException {
        SimpleType type = new SimpleType(TypeCategory.ENTITY, ""Entity"", """", ""Entity"",false,false);
        EntityType entityType = new EntityType(type);
        typeMappings.register(entityType, queryTypeFactory.create(entityType));
        serializer.serialize(entityType, SimpleSerializerConfig.DEFAULT, new JavaWriter(writer));
        assertTrue(writer.toString().contains(""public class QEntity extends BeanPath<Entity> {""));
        CompileUtils.assertCompiles(""QEntity"", writer.toString());
    }",No Smells
"@Test
    public void correct_superclass() throws IOException {
        SimpleType type = new SimpleType(TypeCategory.ENTITY, ""java.util.Locale"", ""java.util"", ""Locale"",false,false);
        EntityType entityType = new EntityType(type);
        typeMappings.register(entityType, queryTypeFactory.create(entityType));

        serializer.serialize(entityType, SimpleSerializerConfig.DEFAULT, new JavaWriter(writer));
        assertTrue(writer.toString().contains(""public class QLocale extends EntityPathBase<Locale> {""));
        CompileUtils.assertCompiles(""QLocale"", writer.toString());
    }",No Smells
"@Test
    public void different_package() throws IOException {
        queryTypeFactory = new QueryTypeFactoryImpl(""Q"", """", "".gen"");

        EntityType entityType = new EntityType(new ClassType(Entity.class));
        typeMappings.register(entityType, queryTypeFactory.create(entityType));

        serializer.serialize(entityType, SimpleSerializerConfig.DEFAULT, new JavaWriter(writer));
        assertTrue(writer.toString().contains(""public class QEntitySerializerTest_Entity "" +
                ""extends EntityPathBase<EntitySerializerTest.Entity>""));
        CompileUtils.assertCompiles(""QEntitySerializerTest_Entity"", writer.toString());
    }",No Smells
"@Test
    public void uncapSimpleName_escaped3() {
        ClassType typeModel = new ClassType(TypeCategory.ENTITY, Void.class);
        EntityType entityModel = new EntityType(typeModel);
        assertEquals(""void$"", entityModel.getModifiedSimpleName());
    }",No Smells
"@Test
    public void equals_and_hashCode() {
        Type typeModel = new SimpleType(TypeCategory.ENTITY, ""com.querydsl.DomainClass"", ""com.querydsl"", ""DomainClass"", false,false);
        EntityType type = new EntityType(typeModel);
        Property p1 = new Property(type, ""property"", type, Collections.<String>emptyList());
        Property p2 = new Property(type, ""property"", type, Collections.<String>emptyList());
        assertEquals(p1, p1);
        assertEquals(p1, p2);
        assertEquals(p1.hashCode(), p2.hashCode());
    }",No Smells
"@Test
    public void prefix_only() {
        QueryTypeFactory factory = new QueryTypeFactoryImpl(""Q"", """", """");
        assertEquals(""com.querydsl.codegen.QPoint"", factory.create(type).getFullName());
    }",No Smells
"@Test
    public void embeddableSerializer() throws Exception {
        new DefaultEmbeddableSerializer(typeMappings,Collections.<String>emptyList())
            .serialize(type, SimpleSerializerConfig.DEFAULT, new JavaWriter(writer));
    }",No Smells
"@Test
    public void blob() {
        Type blob = factory.get(Blob.class);
        assertEquals(""Blob"", blob.getSimpleName());
        assertEquals(""java.sql.Blob"", blob.getFullName());
        assertEquals(""java.sql"", blob.getPackageName());
    }",No Smells
"@Test
    public void parameters() {
        EntityType type = factory.getEntityType(Examples.Complex.class);
        assertEquals(1, type.getParameters().size());
        assertEquals(TypeExtends.class, type.getParameters().get(0).getClass());
    }",No Smells
"@Test
    public void coalesce() {
        assertEquals(""1"", CollQueryFunctions.coalesce(""1"",null));
        assertEquals(""1"", CollQueryFunctions.coalesce(null,""1"",""2""));
        assertNull(CollQueryFunctions.coalesce(null,null));
    }",No Smells
"@Test
    public void test1() {
        Predicate crit = qDoc.id.eq(3L);
        List<Document> expResult = CollQueryFactory.from(qDoc, doc1, doc2, doc3).where(crit).fetch();
        assertTrue(expResult.contains(doc3)); //ok
    }",No Smells
"@Test
    public void test2() {
        Predicate crit = qDoc.meshThesaurusTerms.any().eq(""x"");
        List<Document> expResult = CollQueryFactory.from(qDoc, doc1, doc2, doc3).where(crit).fetch();
        assertTrue(expResult.contains(doc1)); //ok
    }",No Smells
"@Test
    public void dateTime() {
        DateTimePath<DateTime> entity = Expressions.dateTimePath(DateTime.class, ""entity"");
        query.from(entity, Arrays.asList(new DateTime(), new DateTime(0L)))
             .select(entity.year(), entity.yearMonth(), entity.month(), entity.week(),
                   entity.dayOfMonth(), entity.dayOfWeek(), entity.dayOfYear(),
                   entity.hour(), entity.minute(), entity.second(), entity.milliSecond())
             .fetch();
    }",No Smells
"@Test
    public void localTime() {
        TimePath<LocalTime> entity = Expressions.timePath(LocalTime.class, ""entity"");
        query.from(entity, Arrays.asList(new LocalTime(), new LocalTime(0L)))
             .select(entity.hour(), entity.minute(), entity.second(), entity.milliSecond())
             .fetch();
    }",No Smells
"@Test
    public void two_args() {
        MappingProjection<Pair<String,String>> mapping = new MappingProjection<Pair<String,String>>(Pair.class, str1, str2) {
            @Override
            protected Pair<String, String> map(Tuple row) {
                return Pair.of(row.get(str1), row.get(str2));
            }",No Smells
"@Test
    public void leftIsNull() {
        assertEquals(-1, comparator.compare(null, new Car()));
    }",No Smells
"@Test
    public void mismatch() {
        Car car = new Car();
        car.setHorsePower(123);

        Description mismatchDescription = new StringDescription();
        hasValue($.horsePower, equalTo(321)).describeMismatch(car, mismatchDescription);
        assertEquals(""value \""car.horsePower\"" was <123>"", mismatchDescription.toString());
    }",No Smells
"@Test
    public void reusage() {
        QueryMetadata metadata = new DefaultQueryMetadata();
        metadata.addJoin(JoinType.DEFAULT, cat);
        metadata.addWhere(cat.name.startsWith(""A""));

        CollQuery<?> query = new CollQuery<Void>(metadata);
        query.bind(cat, cats);
        assertEquals(Collections.singletonList(c3), query.select(cat).fetch());
    }",No Smells
"@Test
    public void alias() {
        DomainType domainType = Alias.alias(DomainType.class);
        Alias.alias(DomainType.class, $(domainType.getCollection()).any());
    }",No Smells
"@Test
    public void basicUsage() {
        DomainType domainType = Alias.alias(DomainType.class);
        assertEquals(""lower(domainType.firstName)"", $(domainType.getFirstName()).lower().toString());
        assertEquals(""domainType.age"", $(domainType.getAge()).toString());
        assertEquals(""domainType.map.get(a)"", $(domainType.getMap().get(""a"")).toString());
        assertEquals(""domainType.list.get(0)"", $(domainType.getList().get(0)).toString());

        assertEquals(""domainType.bigDecimal"", $(domainType.getBigDecimal()).toString());
        assertEquals(""domainType.bigInteger"", $(domainType.getBigInteger()).toString());
        assertEquals(""domainType.byte"", $(domainType.getByte()).toString());
        assertEquals(""domainType.collection"", $(domainType.getCollection()).toString());
        assertEquals(""domainType.double"", $(domainType.getDouble()).toString());
        assertEquals(""domainType.float"", $(domainType.getFloat()).toString());
        assertEquals(""domainType.date"", $(domainType.getDate()).toString());
        assertEquals(""domainType.date2"", $(domainType.getDate2()).toString());
        assertEquals(""domainType.set"", $(domainType.getSet()).toString());
        assertEquals(""domainType.short"", $(domainType.getShort()).toString());
        assertEquals(""domainType.time"", $(domainType.getTime()).toString());
        assertEquals(""domainType.timestamp"", $(domainType.getTimestamp()).toString());
        assertEquals(""domainType.gender"", $(domainType.getGender()).toString());
    }",No Smells
"@Test
    public void createComparablePath() {
        Path<String> path = pathFactory.createComparablePath(String.class, metadata);
        assertNotNull(path);
    }",No Smells
"@Test
    public void createDatePath() {
        Path<Date> path = pathFactory.createDatePath(Date.class, metadata);
        assertNotNull(path);
    }",No Smells
"@Test
    public void createSetPath() {
        Path<Set<Timestamp>> path = pathFactory.createSetPath(Timestamp.class, metadata);
        assertNotNull(path);
    }",No Smells
"@Test
    public void createSimplePath() {
        Path<Object> path = pathFactory.createSimplePath(Object.class, metadata);
        assertNotNull(path);
    }",No Smells
"@Test
    public void createTimePath() {
        Path<Time> path = pathFactory.createTimePath(Time.class, metadata);
        assertNotNull(path);
    }",No Smells
"@Test
    public void and_not() {
        BooleanBuilder builder = new BooleanBuilder();
        builder.and(first).andNot(second);
        assertEquals(first.and(second.not()), builder.getValue());
    }",No Smells
"@Test
    public void and_null_supported() {
        assertEquals(first, first.and(null));
    }",No Smells
"@Test
    public void basic() {
//        new BooleanBuilder().and(first).or(second);
        assertEquals(first.or(second).toString(),
            new BooleanBuilder().and(first).or(second).toString());
    }",No Smells
"@Test
    public void booleanBuilder_equals_constant() {
        assertFalse(new BooleanBuilder(first).equals(first));
    }",No Smells
"@Test
    public void if_then_else() {
        BooleanBuilder builder = new BooleanBuilder();
        builder.and(null);
        builder.or(null);
        builder.and(second);
        assertEquals(second, builder.getValue());
    }",No Smells
"@Test
    public void and_not() {
        BooleanBuilder builder = new BooleanBuilder();
        builder.and(first).andNot(second);
        assertEquals(first.and(second.not()), builder.getValue());
    }",No Smells
"@Test
    public void toString_() {
        BooleanBuilder builder = new BooleanBuilder().and(first);
        assertEquals(""true"", builder.toString());
        builder.or(Expressions.booleanPath(""condition""));
        assertEquals(""true || condition"", builder.toString());
    }",No Smells
"@Test
    public void getGroupBy() {
        metadata.addJoin(JoinType.DEFAULT, str);
        metadata.addGroupBy(str);
        assertEquals(Collections.singletonList(str), metadata.getGroupBy());
    }",No Smells
"@Test
    public void getGroupBy() {
        metadata.addJoin(JoinType.DEFAULT, str);
        metadata.addGroupBy(str);
        assertEquals(Collections.singletonList(str), metadata.getGroupBy());
    }",No Smells
"@Test
    public void getJoins2() {
        metadata.addJoin(JoinType.DEFAULT, str);
        assertEquals(Collections.singletonList(new JoinExpression(JoinType.DEFAULT, str)), metadata.getJoins());
    }",No Smells
"@Test
    public void isDistinct() {
        assertFalse(metadata.isDistinct());
        metadata.setDistinct(true);
        assertTrue(metadata.isDistinct());
    }",No Smells
"@Test
    public void joinShouldBeCommitted() {
        DefaultQueryMetadata md = new DefaultQueryMetadata();
        md.addJoin(JoinType.DEFAULT, str);
        DefaultQueryMetadata emptyMetadata = new DefaultQueryMetadata();
        assertFalse(md.equals(emptyMetadata));
    }",No Smells
"@Test
    public void setOffset() {
        QueryModifiers modifiers = new QueryModifiers(1L,1L);
        metadata.setModifiers(modifiers);
        metadata.setOffset(2L);

        assertEquals(Long.valueOf(1L), metadata.getModifiers().getLimit());
        assertEquals(Long.valueOf(2L), metadata.getModifiers().getOffset());
    }",No Smells
"@Test
    public void group_order() {
        CloseableIterator<Group> resultsIt = BASIC_RESULTS
            .transform(groupBy(postId).iterate(postName, set(commentId)));
        List<Group> results = IteratorAdapter.asList(resultsIt);

        assertEquals(4, results.size());
    }",No Smells
"@Test
    public void array_access() {
        List<Group> results = BASIC_RESULTS.transform(
            groupBy(postId).list(postName, set(commentId), list(commentText)));

        assertEquals(4, results.size());

        Group group = results.get(1);
        Object[] array = group.toArray();
        assertEquals(toInt(1), array[0]);
        assertEquals(""post 1"", array[1]);
        assertEquals(toSet(1, 2, 3), array[2]);
        assertEquals(Arrays.asList(""comment 1"", ""comment 2"", ""comment 3""), array[3]);
    }",No Smells
"@Test
    public void map4() {
        CloseableIterator<Map<Map<Integer, String>, String>> results = MAP4_RESULTS.transform(
            groupBy(postId).iterate(map(map(postId, commentText), postName)));
        List<Map<Map<Integer, String>, String>> actual = IteratorAdapter.asList(results);

        Object commentId = null;
        Map<Map<Integer, String>, String> comments = null;
        List<Map<Map<Integer, String>, String>> expected = new LinkedList<Map<Map<Integer, String>, String>>();
        for (Iterator<Tuple> iterator = MAP4_RESULTS.iterate(); iterator.hasNext();) {
            Tuple tuple = iterator.next();
            Object[] array = tuple.toArray();

            if (comments == null || !(commentId == array[0] || commentId != null && commentId.equals(array[0]))) {
                comments = new LinkedHashMap<Map<Integer, String>, String>();
                expected.add(comments);
            }",Eager Test
"@Test
    public void oneToOneToMany_projection() {
        List<User> results = USERS_W_LATEST_POST_AND_COMMENTS.transform(
            groupBy(userName).list(Projections.constructor(User.class, userName,
                Projections.constructor(Post.class, postId, postName, set(qComment)))));

        assertEquals(2, results.size());

        User user = results.get(0);
        Post post = user.getLatestPost();
        assertEquals(toInt(2), post.getId());
        assertEquals(""post 2"", post.getName());
        assertEquals(toSet(comment(4), comment(5)), post.getComments());
    }",No Smells
"@Test
    public void array_access() {
        Map<Integer, Group> results = BASIC_RESULTS.transform(
            groupBy(postId).as(postName, set(commentId), list(commentText)));

        Group group = results.get(1);
        Object[] array = group.toArray();
        assertEquals(toInt(1), array[0]);
        assertEquals(""post 1"", array[1]);
        assertEquals(toSet(1, 2, 3), array[2]);
        assertEquals(Arrays.asList(""comment 1"", ""comment 2"", ""comment 3""), array[3]);
    }",No Smells
"@Test
    public void first_set_and_list() {
        Map<Integer, Group> results = BASIC_RESULTS.transform(
            groupBy(postId).as(postName, set(commentId), list(commentText)));

        Group group = results.get(1);
        assertEquals(toInt(1), group.getOne(postId));
        assertEquals(""post 1"", group.getOne(postName));
        assertEquals(toSet(1, 2, 3), group.getSet(commentId));
        assertEquals(Arrays.asList(""comment 1"", ""comment 2"", ""comment 3""), group.getList(commentText));
    }",No Smells
"@Test
    public void group_by_null() {
        Map<Integer, Group> results = BASIC_RESULTS.transform(
            groupBy(postId).as(postName, set(commentId), list(commentText)));

        Group group = results.get(null);
        assertNull(group.getOne(postId));
        assertEquals(""null post"", group.getOne(postName));
        assertEquals(toSet(7, 8), group.getSet(commentId));
        assertEquals(Arrays.asList(""comment 7"", ""comment 8""), group.getList(commentText));

    }",No Smells
"@Test
    public void map3() {
        Map<Integer, Map<Integer, Map<Integer, String>>> actual = MAP3_RESULTS.transform(
            groupBy(postId).as(map(postId, map(commentId, commentText))));

        Map<Integer, Map<Integer, Map<Integer, String>>> expected = new LinkedHashMap<Integer, Map<Integer, Map<Integer, String>>>();
        for (Iterator<Tuple> iterator = MAP3_RESULTS.iterate(); iterator.hasNext();) {
            Tuple tuple = iterator.next();
            Object[] array = tuple.toArray();

            Map<Integer, Map<Integer, String>> posts = expected.get(array[0]);
            if (posts == null) {
                posts = new LinkedHashMap<Integer, Map<Integer,String>>();
                expected.put((Integer) array[0], posts);
            }",Eager Test
"@Test
    public void map_sorted_reverse() {
        Map<Integer, Group> results = MAP_RESULTS.transform(
                groupBy(postId).as(postName, sortedMap(commentId, commentText, Comparator.reverseOrder())));

        Group group = results.get(1);

        Iterator<Map.Entry<Integer, String>> it = group.getMap(commentId, commentText).entrySet().iterator();
        assertEquals(3, it.next().getKey().intValue());
        assertEquals(2, it.next().getKey().intValue());
        assertEquals(1, it.next().getKey().intValue());
    }",No Smells
"@Test
    public void hashCode_() {
        QueryModifiers modifiers1 = new QueryModifiers(null, null);
        QueryModifiers modifiers2 = new QueryModifiers(1L, null);
        QueryModifiers modifiers3 = new QueryModifiers(null, 1L);

        assertEquals(modifiers1.hashCode(), QueryModifiers.EMPTY.hashCode());
        assertEquals(modifiers2.hashCode(), QueryModifiers.limit(1L).hashCode());
        assertEquals(modifiers3.hashCode(), QueryModifiers.offset(1L).hashCode());
    }",No Smells
"@Test
    public void limit() {
        QueryModifiers modifiers = QueryModifiers.limit(12L);
        assertEquals(Long.valueOf(12), modifiers.getLimit());
        assertNull(modifiers.getOffset());
        assertTrue(modifiers.isRestricting());
    }",No Smells
"@Test
    public void test() {
        DummySerializer serializer = new DummySerializer(new JavaTemplates());
        StringPath strPath = Expressions.stringPath(""str"");
        // path
        serializer.handle(strPath);
        // operation
        serializer.handle(strPath.isNotNull());
        // long path
        serializer.handle(new PathBuilder<Object>(Object.class,""p"").getList(""l"",Map.class).get(0));
        // constant
        serializer.handle(ConstantImpl.create(""""));
        //  custom
        serializer.handle(ExpressionUtils.template(Object.class, ""xxx"", ConstantImpl.create("""")));
    }",No Smells
"@Test
    public void test() {
        assertEquals(""abc"", expr(""ab"").append(""c"").toString());
        assertEquals(""abc"", expr(""bc"").prepend(""a"").toString());
        assertEquals(""abc"", expr(""ABC"").lower().toString());
        assertEquals(""ABC"", expr(""abc"").upper().toString());
        assertEquals(""ab"",  expr(""abc"").substring(0,2).toString());
    }",No Smells
"@Test
    public void longer_path() {
        assertEquals(""cat_kittens_0.name"", serialize(cat.kittens.any().name));
    }",No Smells
"@Test
    public void simple_booleanOperation() {
        Predicate predicate = cat.kittens.any().name.eq(""Ruth123"");
        assertEquals(""cat_kittens_0.name = Ruth123"", serialize(predicate));
    }",No Smells
"@Test
    public void addJoin() {
        List<JoinExpression> joins = new ArrayList<JoinExpression>();
        joins.add(new JoinExpression(JoinType.DEFAULT, x));
        joins.add(new JoinExpression(JoinType.DEFAULT, y));
        joins.add(new JoinExpression(JoinType.INNERJOIN, y));
        joins.add(new JoinExpression(JoinType.INNERJOIN, x_a));
        joins.add(new JoinExpression(JoinType.INNERJOIN, x_a_a));
        joins.add(new JoinExpression(JoinType.INNERJOIN, x_a_b));
        joins.add(new JoinExpression(JoinType.INNERJOIN, x_b));
        joins.add(new JoinExpression(JoinType.INNERJOIN, y_a));
        joins.add(new JoinExpression(JoinType.INNERJOIN, y_b));

        for (JoinExpression join1 : joins) {
            for (JoinExpression join2 : joins) {
                QueryMetadata md = new OrderedQueryMetadata();
                addJoin(md, join1);
                addJoin(md, join2);
                validate(md.getJoins());

                for (JoinExpression join3 : joins) {
                    md = new OrderedQueryMetadata();
                    addJoin(md, join1);
                    addJoin(md, join2);
                    addJoin(md, join3);
                    validate(md.getJoins());

                    for (JoinExpression join4 : joins) {
                        md = new OrderedQueryMetadata();
                        addJoin(md, join1);
                        addJoin(md, join2);
                        addJoin(md, join3);
                        addJoin(md, join4);
                        validate(md.getJoins());
                    }",Eager Test
"@Test
    public void getJoins_with_condition() {
        mixin.innerJoin(entity);
        mixin.on(entity.version.isNull(), entity.version.isNotNull());

        assertEquals(1, mixin.getMetadata().getJoins().size());
        JoinExpression je = mixin.getMetadata().getJoins().get(0);
        assertEquals(entity, je.getTarget());
        assertEquals(Expressions.allOf(entity.version.isNull(), entity.version.isNotNull()), je.getCondition());
    }",No Smells
"@Test
    public void leftJoin() {
        DummyEntity e = Alias.alias(DummyEntity.class);
        DummyEntity e2 = Alias.alias(DummyEntity.class, ""e2"");
        DummyEntity e3 = Alias.alias(DummyEntity.class, ""e3"");
        DummyEntity e4 = Alias.alias(DummyEntity.class, ""e4"");

        // left join
        mixin.leftJoin($(e));
        mixin.leftJoin($(e.getOther()),$(e2));
        mixin.leftJoin($(e.getList()),$(e3));
        mixin.leftJoin($(e.getList()));
        mixin.leftJoin($(e.getMap()),$(e4));
        mixin.leftJoin($(e.getMap()));

        assertEquals(6, mixin.getMetadata().getJoins().size());
    }",No Smells
"@Test
    public void create3() {
        assertNotNull(Projections.constructor(ProjectionExample.class).newInstance());
    }",No Smells
"@Test
    public void as_class_with_inits_cached() {
        beanPath = new BeanPath<BeanPathTest>(BeanPathTest.class,
                PathMetadataFactory.forVariable(""p""), PathInits.DEFAULT);
        MyBeanPath otherPath = beanPath.as(MyBeanPath.class);
//        assertEquals(beanPath, otherPath);
        assertTrue(otherPath == beanPath.as(MyBeanPath.class));
    }",No Smells
"@Test
    public void andAnyOf() {
        assertEquals(a.and(b.or(c)), a.andAnyOf(b, c));
    }",No Smells
"@Test
    public void isFalse() {
        assertEquals(a.eq(false), a.isFalse());
    }",No Smells
"@Test
    public void orAllOf() {
        assertEquals(a.or(b.and(c)), a.orAllOf(b, c));
    }",No Smells
"@Test
    public void enumTyped() {
        Customer c = alias(Customer.class, ""customer"");
        EnumExpression<Gender> cases = new CaseBuilder()
            .when($(c.getAnnualSpending()).gt(10000)).then(Gender.MALE)
            .otherwise(Gender.FEMALE);

        assertEquals(
                ""case "" +
                ""when customer.annualSpending > 10000 then MALE "" +
                ""else FEMALE "" +
                ""end"", cases.toString());
    }",No Smells
"@Test
    public void numberTyped() {
        Customer c = alias(Customer.class, ""customer"");
        NumberExpression<Integer> cases = new CaseBuilder()
            .when($(c.getAnnualSpending()).gt(10000)).then(1)
            .when($(c.getAnnualSpending()).gt(5000)).then(2)
            .when($(c.getAnnualSpending()).gt(2000)).then(3)
            .otherwise(4);

        assertEquals(
                ""case "" +
                ""when customer.annualSpending > 10000 then 1 "" +
                ""when customer.annualSpending > 5000 then 2 "" +
                ""when customer.annualSpending > 2000 then 3 "" +
                ""else 4 "" +
                ""end"", cases.toString());
    }",No Smells
"@Test
    public void stringTyped() {
//        CASE
//          WHEN c.annualSpending > 10000 THEN 'Premier'
//          WHEN c.annualSpending >  5000 THEN 'Gold'
//          WHEN c.annualSpending >  2000 THEN 'Silver'
//          ELSE 'Bronze'
//        END

        Customer c = alias(Customer.class, ""customer"");
        StringExpression cases = new CaseBuilder()
            .when($(c.getAnnualSpending()).gt(10000)).then(""Premier"")
            .when($(c.getAnnualSpending()).gt(5000)).then(""Gold"")
            .when($(c.getAnnualSpending()).gt(2000)).then(""Silver"")
            .otherwise(""Bronze"");

        // NOTE : this is just a test serialization, not the real one
        assertEquals(
           ""case "" +
           ""when customer.annualSpending > 10000 then Premier "" +
           ""when customer.annualSpending > 5000 then Gold "" +
           ""when customer.annualSpending > 2000 then Silver "" +
           ""else Bronze "" +
           ""end"", cases.toString());

    }",No Smells
"@Test
    public void dateType() {
        Customer c = alias(Customer.class, ""customer"");

        DateExpression<java.sql.Date> cases = $(c.getAnnualSpending())
                .when(1000L).then(new java.sql.Date(0))
                .otherwise(new java.sql.Date(0));

        assertNotNull(cases);
    }",No Smells
"@Test
    public void dateTimeType() {
        Customer c = alias(Customer.class, ""customer"");

        DateTimeExpression<java.util.Date> cases = $(c.getAnnualSpending())
                .when(1000L).then(new java.util.Date(0))
                .otherwise(new java.util.Date(0));

        assertNotNull(cases);
    }",No Smells
"@Test
    public void between_end_given() {
        assertEquals(strPath.loe(""Z""), strPath.between(null, ""Z""));
    }",No Smells
"@Test
    public void allOf() {
        assertEquals(""a && b"", Expressions.allOf(a, b).toString());
    }",No Smells
"@Test
    public void asBoolean_returns_a_corresponding_BooleanExpression_for_a_given_Expression() {
        assertEquals(""true = true"", Expressions.asBoolean(Expressions.constant(true)).isTrue().toString());
    }",No Smells
"@Test
    public void asComparable_returns_a_corresponding_ComparableExpression_for_a_given_Constant() {
        assertEquals(""1 = 1"", Expressions.asComparable(1L).eq(1L).toString());
    }",No Smells
"@Test
    public void asDate_returns_a_corresponding_DateExpression_for_a_given_Expression() {
        assertEquals(""year(Thu Jan 01 00:00:00 UTC 1970)"",
                Expressions.asDate(Expressions.constant(new Date(1L))).year().toString());
    }",No Smells
"@Test
    public void asDateTime_returns_a_corresponding_DateTimeExpression_for_a_given_Constant() {
        assertEquals(""min(Thu Jan 01 00:00:00 UTC 1970)"", Expressions.asDateTime(new Date(1L)).min().toString());
    }",No Smells
"@Test
    public void asEnum_returns_a_corresponding_EnumExpression_for_a_given_Expression() {
        assertEquals(""ordinal(TEST)"", Expressions.asEnum(Expressions.constant(testEnum.TEST)).ordinal().toString());
    }",No Smells
"@Test
    public void dateTimePathClassOfTString() {
        assertEquals(""variable"", Expressions.dateTimePath(Date.class, ""variable"").toString());
    }",No Smells
"@Test
    public void pathClassOfTString() {
        assertEquals(""variable"", Expressions.path(String.class, ""variable"").toString());
    }",No Smells
"@Test
    public void  Signature() throws NoSuchMethodException {
        List<String> types = Arrays.asList(""boolean"", ""comparable"", ""date"", ""dsl"", ""dateTime"",
                ""enum"", ""number"", ""simple"", ""string"", ""time"");
        for (String type : types) {
            if (type.equals(""boolean"") || type.equals(""string"")) {
                assertReturnType(Expressions.class.getMethod(type + ""Path"", String.class));
                assertReturnType(Expressions.class.getMethod(type + ""Path"", Path.class, String.class));
                assertReturnType(Expressions.class.getMethod(type + ""Path"", PathMetadata.class));
                assertReturnType(Expressions.class.getMethod(type + ""Operation"", Operator.class, Expression[].class));
                assertReturnType(Expressions.class.getMethod(type + ""Template"", String.class, Object[].class));
                assertReturnType(Expressions.class.getMethod(type + ""Template"", String.class, List.class));
                assertReturnType(Expressions.class.getMethod(type + ""Template"", Template.class, Object[].class));
                assertReturnType(Expressions.class.getMethod(type + ""Template"", Template.class, List.class));
            }",Eager Test
"@Test
    public void stringPathPathOfQString() {
        assertEquals(""variable.property"",
                Expressions.stringPath(Expressions.path(Object.class, ""variable""), ""property"").toString());
    }",No Smells
"@Test
    public void dateTimePathClassOfTPathOfQString() {
        assertEquals(""variable.property"", Expressions.dateTimePath(Date.class,
                Expressions.path(Object.class, ""variable""), ""property"").toString());
    }",No Smells
"@Test
    public void dateTimePathClassOfTString() {
        assertEquals(""variable"", Expressions.dateTimePath(Date.class, ""variable"").toString());
    }",No Smells
"@Test
    public void getElementType() {
        assertEquals(String.class, stringPath.getElementType());
    }",No Smells
"@Test
    public void get() {
        assertNotNull(mapPath.get(""X""));
        assertNotNull(mapPath.get(ConstantImpl.create(""X"")));
    }",No Smells
"@Test
    public void getParameter() {
        assertEquals(String.class, mapPath.getParameter(0));
        assertEquals(String.class, mapPath.getParameter(1));
    }",No Smells
"@Test
    public void getValueType() {
        assertEquals(String.class, mapPath.getValueType());
    }",No Smells
"@Test
    public void between_start_given() {
        assertEquals(intPath.goe(1L), intPath.between(1L, null));
    }",No Smells
"@Test
    public void bytePath_in() {
        Operation<?> operation = (Operation<?>) bytePath.in(1, 2, 3);
        Constant<List<Byte>> rightArg = (Constant<List<Byte>>) operation.getArg(1);
        List<Byte> numbers = rightArg.getConstant();
        assertEquals(Byte.valueOf((byte) 1), numbers.get(0));
        assertEquals(Byte.valueOf((byte) 2), numbers.get(1));
        assertEquals(Byte.valueOf((byte) 3), numbers.get(2));
    }",No Smells
"@Test
    public void create_withSuffix() {
        PathBuilderFactory factory = new PathBuilderFactory(""_"");
        PathBuilder<Object> pathBuilder = factory.create(Object.class);
        assertEquals(""object_"", pathBuilder.toString());
        assertEquals(Object.class, pathBuilder.getType());

        pathBuilder.get(""prop"", Object.class);
        pathBuilder.get(""prop"", String.class);
        pathBuilder.get(""prop"", Object.class);
    }",No Smells
"@Test
    public void getEnum() {
        PathBuilder<User> entityPath = new PathBuilder<User>(User.class, ""entity"");
        EnumPath<Gender> enumPath = entityPath.getEnum(""gender"", Gender.class);
        assertNotNull(enumPath.ordinal());
        assertEquals(enumPath, entityPath.get(enumPath));
    }",No Smells
"@Test
    public void defaultInits() {
        assertFalse(PathInits.DEFAULT.isInitialized(""""));
    }",No Smells
"@Test
    public void getElementType() {
        assertEquals(String.class, stringPath.getElementType());
    }",No Smells
"@Test
    public void as_usage() {
        SimpleExpression<String> str = new StringPath(""str"");
        assertEquals(""str as alias"", str.as(""alias"").toString());
        assertEquals(""str as alias"", str.as(new StringPath(""alias"")).toString());
    }",No Smells
"@Test
    public void case_() {
        SimpleExpression<String> str = new StringPath(""str"");
        // nullif(str, 'xxx')
        str.when(""xxx"").thenNull().otherwise(str);
    }",No Smells
"@Test
    public void constructors() {
        Templates templates = new JavaTemplates();
        Template template = TemplateFactory.DEFAULT.create(""{0}",No Smells
"@Test
    public void factoryMethods() {
        String template = """";
        Expression<Boolean> arg = ConstantImpl.create(true);

        Expressions.booleanTemplate(template, arg);
        Expressions.comparableTemplate(String.class, template, arg);
        Expressions.dateTemplate(Date.class, template, arg);
        Expressions.dateTimeTemplate(Date.class, template, arg);
        Expressions.enumTemplate(PropertyType.class, template, arg);
        Expressions.numberTemplate(Integer.class, template, arg);
        Expressions.template(Object.class, template, arg);
        Expressions.stringTemplate(template, arg);
        Expressions.timeTemplate(Time.class, template, arg);
    }",No Smells
"@Test
    public void factoryMethods2() {
        Template template = TemplateFactory.DEFAULT.create("""");
        Expression<Boolean> arg = ConstantImpl.create(true);

        Expressions.booleanTemplate(template, arg);
        Expressions.comparableTemplate(String.class, template, arg);
        Expressions.dateTemplate(Date.class, template, arg);
        Expressions.dateTimeTemplate(Date.class, template, arg);
        Expressions.enumTemplate(PropertyType.class, template, arg);
        Expressions.numberTemplate(Integer.class, template, arg);
        Expressions.template(Object.class, template, arg);
        Expressions.stringTemplate(template, arg);
        Expressions.timeTemplate(Time.class, template, arg);
    }",No Smells
"@Test
    public void isNotNull() {
        assertEquals(""str is not null"", ExpressionUtils.isNotNull(str).toString());
    }",No Smells
"@Test
    public void in_subQuery() {
        String s = ExpressionUtils.in(str, new SubQueryExpressionImpl<String>(String.class, new DefaultQueryMetadata())).toString();
        assertTrue(s.startsWith(""str in com.querydsl.core.DefaultQueryMetadata@c""));
    }",No Smells
"@Test
    public void notIn_subQuery() {
        String s = ExpressionUtils.notIn(str, new SubQueryExpressionImpl<String>(String.class, new DefaultQueryMetadata())).toString();
        assertTrue(s.startsWith(""str not in com.querydsl.core.DefaultQueryMetadata@c""));
    }",No Smells
"@Test
    public void regexToLike() {
        assertEquals(""%"", like(ConstantImpl.create("".*"")));
        assertEquals(""_"",  like(ConstantImpl.create(""."")));
        assertEquals(""."", like(ConstantImpl.create(""\\."")));

        StringPath path = Expressions.stringPath(""path"");
        assertEquals(""path + %"", like(path.append("".*"")));
        assertEquals(""% + path"", like(path.prepend("".*"")));
        assertEquals(""path + _"", like(path.append(""."")));
        assertEquals(""_ + path"", like(path.prepend(""."")));
    }",No Smells
"@Test
    public void generic_precedence() {
        TemplatesTestUtils.testPrecedence(JavaTemplates.DEFAULT);
    }",No Smells
"@Test
    public void precedence() {
        // postfix    expr++ expr--
        // unary    ++expr --expr +expr -expr ~ !
        // multiplicative    * / %
        // additive    + -
        // shift    << >> >>>
        // relational    < > <= >= instanceof
        // equality    == !=
        // bitwise AND    &
        // bitwise exclusive OR    ^
        // bitwise inclusive OR    |
        // logical AND    &&
        // logical OR    ||
        // ternary    ? :
        // assignment    = += -= *= /= %= &= ^= |= <<= >>= >>>=

        int p1 = getPrecedence(Ops.NOT);
        int p2 = getPrecedence(Ops.MULT, Ops.DIV, Ops.MOD);
        int p3 = getPrecedence(Ops.ADD, Ops.SUB);
        int p4 = getPrecedence(Ops.LT, Ops.GT, Ops.GOE, Ops.LOE, Ops.BETWEEN, Ops.INSTANCE_OF);
        int p5 = getPrecedence(Ops.EQ, Ops.NE);
        int p6 = getPrecedence(Ops.AND);
        int p7 = getPrecedence(Ops.OR);

        assertTrue(p1 < p2);
        assertTrue(p2 < p3);
        assertTrue(p3 < p4);
        assertTrue(p4 < p5);
        assertTrue(p5 < p6);
        assertTrue(p6 < p7);
    }",No Smells
"@Test
    public void distinct_expressions() {
        MappingProjection<Pair<String,String>> mapping = new MappingProjection<Pair<String,String>>(Pair.class, str1, str1) {
            @Override
            protected Pair<String, String> map(Tuple row) {
                return Pair.of(row.get(str1), row.get(str1));
            }",No Smells
"@Test
    public void single_arg() {
        MappingProjection<String> mapping = new MappingProjection<String>(String.class, str1) {
            @Override
            protected String map(Tuple row) {
                return row.get(str1);
            }",No Smells
"@Test
    public void array() {
        FactoryExpression<String[]> expr = Projections.array(String[].class,
                ExpressionUtils.path(String.class, ""p1""), ExpressionUtils.path(String.class, ""p2""));
        assertEquals(String[].class, expr.newInstance(""1"", ""2"").getClass());
    }",No Smells
"@Test
    public void constructor() {
        Expression<Long> longVal = ConstantImpl.create(1L);
        Expression<String> stringVal = ConstantImpl.create("""");
        assertEquals(ProjectionExample.class, Projections.constructor(ProjectionExample.class, longVal, stringVal)
                .newInstance(0L, """").getClass());
    }",No Smells
"@Test
    public void nestedSkipNulls() {
        StringPath str1 = Expressions.stringPath(""str1"");
        StringPath str2 = Expressions.stringPath(""str2"");
        StringPath str3 = Expressions.stringPath(""str3"");
        FactoryExpression<Entity1> entity = Projections.constructor(Entity1.class, str1, str2).skipNulls();
        FactoryExpression<Entity2> wrapper = Projections.constructor(Entity2.class, str3, entity);
        FactoryExpression<Entity2> wrapped = FactoryExpressionUtils.wrap(wrapper);

        Entity2 w = wrapped.newInstance(""a"", ""b"", ""c"");
        assertEquals(""a"", w.arg1);
        assertEquals(""b"", w.entity.arg1);
        assertEquals(""c"", w.entity.arg2);

        w = wrapped.newInstance(""a"", null, null);
        assertEquals(""a"", w.arg1);
        assertNull(w.entity);

        w = wrapped.newInstance(null, null, null);
        assertNull(w.entity);
    }",No Smells
"@Test
    public void newInstance() {
        QList qList = new QList(Expressions.stringPath(""a""), Expressions.stringPath(""b""));
        List<?> list = qList.newInstance(""a"", null);
        assertEquals(2, list.size());
        assertEquals(""a"", list.get(0));
        assertNull(list.get(1));
    }",No Smells
"@Test
    public void nestedProjection_newInstance() {
        QMap expr = new QMap(concat);
        assertEquals(""1234"", FactoryExpressionUtils.wrap(expr).newInstance(""12"", ""34"").get(concat));
    }",No Smells
"@Test
    public void twoExpressions_getArgs() {
        assertEquals(Arrays.asList(str1, str2), new QMap(str1, str2).getArgs());
    }",No Smells
"@Test
    public void expressions() throws Exception {
        Map<Class<?>, Object> args = new HashMap<>();
        args.put(Object.class, ""obj"");
        args.put(BeanPath.class, new EntityPathBase<Object>(Object.class, ""obj""));
        args.put(Class.class, Integer.class);
        args.put(Class[].class, new Class<?>[]{Object.class, Object.class}",Eager Test
"@Test
    public void visitConstantOfQVoid() {
        validator.visit(ConstantImpl.create(""XXX""), known);
    }",No Smells
"@Test
    public void test() {
        Object[] array = ArrayUtils.combine(5, new Object[]{""a"",""b""}",No Smells
"@Test
    public void size() {
        assertEquals(4, beanMap.size());
    }",No Smells
"@Test
    public void clone_() throws CloneNotSupportedException {
        assertEquals(beanMap, beanMap.clone());
    }",No Smells
"@Test
    public void toString_() {
        assertEquals(""BeanMap<null>"", new BeanMap().toString());
    }",No Smells
"@Test
    public void uncapitalize() {
        assertEquals(""x"",    BeanUtils.uncapitalize(""X""));
        assertEquals(""prop"", BeanUtils.uncapitalize(""Prop""));
        assertEquals(""URL"",  BeanUtils.uncapitalize(""URL""));
        assertEquals(""cId"",  BeanUtils.uncapitalize(""cId""));
        assertEquals(""sEPOrder"",  BeanUtils.capitalize(""sEPOrder""));
    }",No Smells
"@Test
    public void getDefaultConstructor() {
        Class<?>[] args = {}",No Smells
"@Test
    public void cast_returns_argument_as_is_when_compatible() {
        checkSame(BigDecimal.ONE, BigDecimal.class);
        checkSame(BigInteger.ONE, BigInteger.class);
        checkSame((double) 1, Double.class);
        checkSame((float) 1, Float.class);
        checkSame(1, Integer.class);
        checkSame((long) 1, Long.class);
        checkSame((short) 1, Short.class);
        checkSame((byte) 1, Byte.class);
    }",No Smells
"@Test
    public void oneLevel() {
        it = new MultiIterator(Collections.singletonList(list1));
        assertIteratorEquals(Arrays.asList(row(1), row(2)).iterator(), it);
    }",No Smells
"@Test
    public void delete() {
        Customer customer = customerDao.findById(1);
        customerDao.delete(customer);
        assertNull(customerDao.findById(1));
    }",No Smells
"@Test
    public void findById() {
        assertNotNull(orderDao.findById(1));
    }",No Smells
"@Test
    public void update() {
        Order order = orderDao.findById(1);
        orderDao.save(order);
    }",No Smells
"@Test
    public void findAll() {
        List<Person> persons = personDao.findAll();
        assertFalse(persons.isEmpty());
    }",No Smells
"@Test
    public void update() {
        Person person = personDao.findById(1);
        personDao.save(person);
    }",No Smells
"@Test
    public void delete() {
        Product product = new Product();
        product.setSupplier(supplierDao.findById(1));
        product.setName(""ProductX"");
        product.setLocalizations(Collections.singleton(new ProductL10n()));
        productDao.save(product);
        assertNotNull(productDao.findById(product.getId()));
        productDao.delete(product);
        assertNull(productDao.findById(product.getId()));
    }",No Smells
"@Test
    public void findAll() {
        List<Supplier> suppliers = supplierDao.findAll();
        assertFalse(suppliers.isEmpty());
    }",No Smells
"@Test
    public void findById() {
        assertNotNull(supplierDao.findById(1));
    }",No Smells
"@Test
    public void get_all() {
        User user = new User();
        user.setUsername(""jimmy"");
        repository.save(user);
        assertTrue(repository.all().size() == 1);
    }",No Smells
"@Test
    public void save_and_get_by_id() {
        String username = ""jackie"";
        User user = new User();
        user.setUsername(username);
        Long id = repository.save(user);
        assertEquals(username, repository.findById(id).getUsername());
    }",No Smells
"@Test
    public void get_connection() {
        assertNotNull(context.getConnection(true));
        assertNotNull(context.getConnection());
        context.removeConnection();
        assertNull(context.getConnection());
    }",No Smells
"@Test
    public void get_all_with_tweet_count() {
        User user = new User();
        user.setUsername(""jimmy"");
        Long posterId = repository.save(user);

        Tweet tw3 = new Tweet();
        tw3.setPosterId(posterId);
        tw3.setContent(""#EpicFail"");
        tweetRepository.save(tw3);

        List<UserInfo> infos = repository.allWithTweetCount();
        assertFalse(infos.isEmpty());
        for (UserInfo info : infos) {
            assertNotNull(info.getUsername());
        }",Eager Test
"@Test
    public void save_and_get_by_id() {
        String username = ""jackie"";
        User user = new User();
        user.setUsername(username);
        Long id = repository.save(user);
        assertEquals(username, repository.findById(id).getUsername());
    }",No Smells
"@Test
    public void exists() {
        assertTrue(query().where(user.emailAddress.eq(""bob@example.com"")).fetchCount() > 0);
        assertFalse(query().where(user.emailAddress.eq(""bobby@example.com"")).fetchCount() > 0);
    }",No Smells
"@Test
    public void listResults() {
        BooleanExpression filter = user.middleName.eq(""X"");
        QueryResults<User> users = query().where(filter).orderBy(
                user.firstName.asc()).limit(2).fetchResults();
        List<String> asc = getFirstNames(users.getResults());
        assertEquals(Arrays.asList(""Anton"", ""Barbara""), asc);
        assertEquals(4, users.getTotal());
    }",No Smells
"@Test
    public void having() {
        assertEquals(3, query().from(product)
                .groupBy(product.description).having(product.description.ne(""XXX""))
                .select(product.description).fetch().size());
        assertEquals(3, query().from(product)
                .groupBy(product.price).having(product.price.gt(0))
                .select(product.price).fetch().size());
    }",No Smells
"@Test
    public void generic_precedence() {
        TemplatesTestUtils.testPrecedence(JDOQLTemplates.DEFAULT);
    }",No Smells
"@Test
    public void from() {
        assertNotNull(queryFactory.from(QProduct.product));
    }",No Smells
"@Test
    public void count() {
        assertEquals(30L, sql().from(product).fetchCount());
    }",No Smells
"@Test
    public void verify_package() throws Exception {
        String version = System.getProperty(""version"");
        verify(new File(""target/querydsl-jdo-"" + version + ""-apt-one-jar.jar""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void groupBy() {
        assertEquals(3, query().from(product).groupBy(product.description).select(product.description).fetch().size());
        assertEquals(3, query().from(product).groupBy(product.price).select(product.price).fetch().size());
    }",No Smells
"@Test
    public void scrollTuple() throws IOException {
        CloseableIterator<Tuple> rows = new ScrollableResultsIterator<Tuple>(query()
                .from(cat)
                .select(cat.name, cat.birthdate).createQuery().scroll());
        assertTrue(rows.hasNext());
        while (rows.hasNext()) {
            Tuple row = rows.next();
            assertEquals(2, row.size());
        }",Eager Test
"@Test
    public void with_comment() {
        query().from(cat).setComment(""my comment"").select(cat).fetch();
    }",No Smells
"@Test
    public void from() {
        assertNotNull(queryFactory.from(QAnimal.animal));
    }",No Smells
"@Test
    public void limit1_uniqueResult() {
        assertNotNull(query().from(cat).limit(1).select(cat).fetchOne());
    }",No Smells
"@Test
    public void queryExposure() {
        //save(new Cat(20));
        List<Cat> results = query().from(cat).select(cat).createQuery().getResultList();
        assertNotNull(results);
        assertFalse(results.isEmpty());
    }",No Smells
"@Test
    public void simple_booleanOperation_elementCollection() {
        QEmployee employee = QEmployee.employee;
        Predicate predicate = employee.jobFunctions.any().stringValue().eq(""CODER"");
        assertEquals(""exists (select 1\n"" +
                ""from Employee employee_1463394548\n"" +
                ""  inner join employee_1463394548.jobFunctions as employee_jobFunctions_0\n"" +
                ""where employee_1463394548 = employee and str(employee_jobFunctions_0) = ?1)"", serialize(predicate));
    }",No Smells
"@Test
    public void hibernate() {
        factory = Persistence.createEntityManagerFactory(""h2"");
        em = factory.createEntityManager();
        System.out.println(em.getDelegate().getClass());
        assertEquals(Hibernate5Templates.DEFAULT, JPAProvider.getTemplates(em));
    }",No Smells
"@Test
    public void hibernate_for_proxy() {
        factory = Persistence.createEntityManagerFactory(""h2"");
        em = factory.createEntityManager();
        InvocationHandler handler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                return method.invoke(em, args);
            }",No Smells
"@Test
    public void delete() {
        assertNotNull(queryFactory.delete(QAnimal.animal));
    }",No Smells
"@Test
    public void query2() {
        queryFactory2.query().from(QAnimal.animal);
    }",No Smells
"@Test
    public void query2() {
        queryFactory2.query().from(QAnimal.animal);
    }",No Smells
"@Test
    public void query3() {
        EasyMock.expect(mock.getEntityManagerFactory()).andReturn(factoryMock);
        EasyMock.expect(factoryMock.getProperties()).andReturn(properties);
        EasyMock.expect(mock.unwrap(EasyMock.anyObject(Class.class))).andReturn(mock).atLeastOnce();

        EasyMock.replay(mock, factoryMock);

        queryFactory3.query().from(QAnimal.animal);

        EasyMock.verify(mock, factoryMock);
    }",No Smells
"@Test
    public void update() {
        assertNotNull(queryFactory.update(QAnimal.animal));
    }",No Smells
"@Test
    public void orderBy_any() {
        QCat cat = QCat.cat;
        QCat catKittens = new QCat(""cat_kittens"");
        mixin.from(cat);
        mixin.orderBy(cat.kittens.any().name.asc());

        QueryMetadata md = mixin.getMetadata();
        assertEquals(Arrays.asList(
                new JoinExpression(JoinType.DEFAULT, cat),
                new JoinExpression(JoinType.LEFTJOIN, cat.kittens.as(catKittens))),
                md.getJoins());
        assertEquals(Collections.singletonList(catKittens.name.asc()),
                md.getOrderBy());
    }",No Smells
"@Test
    public void where_null() {
        mixin.where((Predicate) null);
    }",No Smells
"@Test
    public void case1_hibernate() {
        QCat cat = QCat.cat;
        JPQLSerializer serializer = new JPQLSerializer(HQLTemplates.DEFAULT);
        Expression<?> expr = Expressions.cases().when(cat.toes.eq(2)).then(2)
                .when(cat.toes.eq(3)).then(3)
                .otherwise(4);
        serializer.handle(expr);
        assertEquals(""case when (cat.toes = ?1) then ?2 when (cat.toes = ?3) then ?4 else 4 end"", serializer.toString());
    }",No Smells
"@Test
    public void count() {
        QCat cat = QCat.cat;
        QueryMetadata md = new DefaultQueryMetadata();
        md.addJoin(JoinType.DEFAULT, cat);
        md.setProjection(cat.mate.countDistinct());
        JPQLSerializer serializer1 = new JPQLSerializer(HQLTemplates.DEFAULT);
        serializer1.serialize(md, true, null);
        assertEquals(""select count(count(distinct cat.mate))\n"" +
                ""from Cat cat"",  serializer1.toString());

        JPQLSerializer serializer2 = new JPQLSerializer(HQLTemplates.DEFAULT);
        serializer2.serialize(md, false, null);
        assertEquals(""select count(distinct cat.mate)\n"" +
                ""from Cat cat"", serializer2.toString());
    }",No Smells
"@Test
    public void fromWithCustomEntityName() {
        JPQLSerializer serializer = new JPQLSerializer(HQLTemplates.DEFAULT);
        EntityPath<Location> entityPath = new EntityPathBase<Location>(Location.class, ""entity"");
        QueryMetadata md = new DefaultQueryMetadata();
        md.addJoin(JoinType.DEFAULT, entityPath);
        serializer.serialize(md, false, null);
        assertEquals(""select entity\nfrom Location2 entity"", serializer.toString());
    }",No Smells
"@Test
    public void like() {
        JPQLSerializer serializer = new JPQLSerializer(HQLTemplates.DEFAULT);
        serializer.handle(Expressions.stringPath(""str"").contains(""abc!""));
        assertEquals(""str like ?1 escape '!'"", serializer.toString());
        assertEquals(""%abc!!%"", serializer.getConstants().get(0).toString());
    }",No Smells
"@Test
    public void nullsFirst() {
        QCat cat = QCat.cat;
        JPQLSerializer serializer = new JPQLSerializer(HQLTemplates.DEFAULT);
        QueryMetadata md = new DefaultQueryMetadata();
        md.addJoin(JoinType.DEFAULT, cat);
        md.addOrderBy(cat.name.asc().nullsFirst());
        serializer.serialize(md, false, null);
        assertEquals(""select cat\n"" +
                 ""from Cat cat\n"" +
                 ""order by cat.name asc nulls first"", serializer.toString());
    }",No Smells
"@Test
    public void in() {
        Configuration conf = new Configuration(new MySQLTemplates());
        NativeSQLSerializer serializer = new NativeSQLSerializer(conf, true);
        DefaultQueryMetadata md = new DefaultQueryMetadata();
        SAnimal cat = SAnimal.animal_;
        md.addJoin(JoinType.DEFAULT, cat);
        md.addWhere(cat.name.in(""X"", ""Y""));
        md.setProjection(cat.id);
        serializer.serialize(md, false);
        assertEquals(""select animal_.id\n"" +
            ""from animal_ animal_\n"" +
            ""where animal_.name in (?1, ?2)"", serializer.toString());
    }",No Smells
"@Test
    public void functionCall() {
        //select tab.col from Table tab join TableValuedFunction('parameter') func on tab.col not like func.col

        QSurvey table = new QSurvey(""SURVEY"");
        RelationalFunctionCall<String> func = SQLExpressions.relationalFunctionCall(String.class, ""TableValuedFunction"", ""parameter"");
        PathBuilder<String> funcAlias = new PathBuilder<String>(String.class, ""tokFunc"");
        SubQueryExpression<?> expr = select(table.name).from(table)
            .join(func, funcAlias).on(table.name.like(funcAlias.getString(""prop"")).not());

        Configuration conf = new Configuration(new SQLServerTemplates());
        SQLSerializer serializer = new NativeSQLSerializer(conf, true);
        serializer.serialize(expr.getMetadata(), false);
        assertEquals(""select SURVEY.NAME\n"" +
                ""from SURVEY SURVEY\n"" +
                ""join TableValuedFunction(?1) as tokFunc\n"" +
                ""on not (SURVEY.NAME like tokFunc.prop escape '\\')"", serializer.toString());

    }",No Smells
"@Test
    public void all_by_excluding_where() {
        assertEquals(4, query.fetch().size());
    }",No Smells
"@Test
    public void list_distinct_property() {
        assertEquals(4, query.fetch().size());
        assertEquals(3, query.distinct(year).fetch().size());
    }",No Smells
"@Test
    public void list_not_sorted_limit_2() {
        query.where(year.between(1800, 2000));
        query.limit(2);
        final List<Document> documents = query.fetch();
        assertFalse(documents.isEmpty());
        assertEquals(2, documents.size());
    }",No Smells
"@Test
    public void list_not_sorted_offset_2() {
        query.where(year.between(1800, 2000));
        query.offset(2);
        final List<Document> documents = query.fetch();
        assertFalse(documents.isEmpty());
        assertEquals(2, documents.size());
    }",No Smells
"@Test
    public void list_sorted_by_year_limit_1() {
        query.where(year.between(1800, 2000));
        query.limit(1);
        query.orderBy(year.asc());
        final List<Document> documents = query.fetch();
        assertFalse(documents.isEmpty());
        assertEquals(1, documents.size());
    }",No Smells
"@Test
    public void load_singleResult_fieldSelector() {
        Document document = query.where(title.ne("""")).load(Collections.singleton(""title"")).fetchFirst();
        assertNotNull(document.get(""title""));
        assertNull(document.get(""year""));
    }",No Smells
"@Test
    public void list_not_sorted_offset_2() {
        query.where(year.between(1800, 2000));
        query.offset(2);
        final List<Document> documents = query.fetch();
        assertFalse(documents.isEmpty());
        assertEquals(2, documents.size());
    }",No Smells
"@Test
    public void single_result_considers_offset() {
        assertEquals(""Introduction to Algorithms"", query.where(title.ne("""")).offset(3).fetchFirst().get(""title""));
    }",No Smells
"@Test
    public void single_result_takes_limit() {
        assertEquals(""Jurassic Park"", query
                                        .where(title.ne(""""))
                                        .limit(1)
                                        .fetchFirst().get(""title""));
    }",No Smells
"@Test
    public void unique_result_considers_limit_and_offset() {
        assertEquals(""The Lord of the Rings"", query.where(title.ne("""")).limit(1).offset(2).fetchOne().get(""title""));
    }",No Smells
"@Test
    public void uniqueResult_finds_no_results() {
        query.where(year.eq(2200));
        assertNull(query.fetchOne());
    }",No Smells
"@Test
    public void between_does_not_find_results() throws Exception {
        testQuery(title.between(""Indiana"", ""Jurassib""), ""title:[indiana TO jurassib]"", 0);
    }",No Smells
"@Test
    public void between_numeric_integer() throws Exception {
        testQuery(year.between(1980, 2000), ""year:[1980 TO 2000]"", 1);
    }",No Smells
"@Test
    public void booleanBuilder() throws Exception {
        testQuery(new BooleanBuilder(gross.goe(900.10)), ""gross:[900.1 TO *]"", 0);
    }",No Smells
"@Test
    public void contains() throws Exception {
        testQuery(title.contains(""rassi""), ""title:*rassi*"", 1);
    }",No Smells
"@Test
    public void contains_user_inputted_wildcards_dont_work() throws Exception {
        testQuery(title.contains(""r*i""), ""title:*r\\*i*"", 0);
    }",No Smells
"@Test
    public void ends_with_empty_string() throws Exception {
        testQuery(title.endsWith(""""), ""title:*"", 1);
    }",No Smells
"@Test
    public void endsWith() throws Exception {
        testQuery(title.endsWith(""ark""), ""title:*ark"", 1);
    }",No Smells
"@Test
    public void eq_or_eq_and_eq_does_not_find_results() throws Exception {
        testQuery(title.eq(""jeeves"").or(rating.eq(""superb"")).and(author.eq(""michael crichton"")), ""+(title:jeeves rating:superb) +author:\""michael crichton\"""", 0);
    }",No Smells
"@Test
    public void eq_phrase() throws Exception {
        testQuery(title.eq(""Jurassic Park""), ""title:\""jurassic park\"""", 1);
    }",No Smells
"@Test
    public void eq_phrase_does_not_find_results_because_word_in_middle() throws Exception {
        testQuery(title.eq(""Jurassic Amusement Park""), ""title:\""jurassic amusement park\"""", 0);
    }",No Smells
"@Test
    public void equals_empty_string() throws Exception {
        testQuery(title.eq(""""), ""title:"", 0);
    }",No Smells
"@Test
    public void fuzzyLike() throws Exception {
        testQuery(LuceneExpressions.fuzzyLike(rating, ""Good""), ""rating:Good~2"", 1);
    }",No Smells
"@Test
    public void goe_numeric_double() throws Exception {
        testQuery(gross.goe(320.50), ""gross:[320.5 TO *]"", 1);
    }",No Smells
"@Test
    public void goe_numeric_integer_equal() throws Exception {
        testQuery(year.goe(1990), ""year:[1990 TO *]"", 1);
    }",No Smells
"@Test
    public void goe_numeric_integer_not_found() throws Exception {
        testQuery(year.goe(1991), ""year:[1991 TO *]"", 0);
    }",No Smells
"@Test
    public void gt_not_in_range_because_equal() throws Exception {
        testQuery(rating.gt(""Good""), ""rating:{good TO *}",No Smells
"@Test
    public void like_custom_wildcard_single_character() throws Exception {
        testQuery(author.like(""Mi?hael""), ""author:mi?hael"", 1);
    }",No Smells
"@Test
    public void queryElement() throws Exception {
        Query query1 = serializer.toQuery(author.like(""Michael""), metadata);
        Query query2 = serializer.toQuery(text.like(""Text""), metadata);

        BooleanExpression query = Expressions.anyOf(
                new QueryElement(query1),
                new QueryElement(query2)
        );
        testQuery(query, ""author:michael text:text"", 1);
    }",No Smells
"@Test
    public void like_custom_wildcard_multiple_character() throws Exception {
        testQuery(text.like(""*U*X*""), ""text:*u*x*"", 1);
    }",No Smells
"@Test
    public void like_not_does_not_find_results() throws Exception {
        testQuery(title.like(""*H*e*"").not(), ""-title:*h*e* +*:*"", 1);
    }",No Smells
"@Test
    public void loe() throws Exception {
        testQuery(rating.loe(""Superb""), ""rating:[* TO superb]"", 1);
    }",No Smells
"@Test
    public void loe_equal() throws Exception {
        testQuery(rating.loe(""Good""), ""rating:[* TO good]"", 1);
    }",No Smells
"@Test
    public void loe_not_found() throws Exception {
        testQuery(rating.loe(""Bad""), ""rating:[* TO bad]"", 0);
    }",No Smells
"@Test
    public void loe_numeric_double_not_found() throws Exception {
        testQuery(gross.loe(899.9), ""gross:[* TO 899.9]"", 0);
    }",No Smells
"@Test
    public void lt_not_in_range_because_equal() throws Exception {
        testQuery(rating.lt(""Good""), ""rating:{* TO good}",No Smells
"@Test
    public void lt_numeric_double() throws Exception {
        testQuery(gross.lt(10000.0), ""gross:{* TO 10000.0}",No Smells
"@Test
    public void ne_and_eq() throws Exception {
        testQuery(title.ne(""house"").and(rating.eq(""good"")), ""+(-title:house +*:*) +rating:good"", 1);
    }",No Smells
"@Test
    public void queryElement() throws Exception {
        Query query1 = serializer.toQuery(author.like(""Michael""), metadata);
        Query query2 = serializer.toQuery(text.like(""Text""), metadata);

        BooleanExpression query = Expressions.anyOf(
                new QueryElement(query1),
                new QueryElement(query2)
        );
        testQuery(query, ""author:michael text:text"", 1);
    }",No Smells
"@Test
    public void queryElement() throws Exception {
        Query query1 = serializer.toQuery(author.like(""Michael""), metadata);
        Query query2 = serializer.toQuery(text.like(""Text""), metadata);

        BooleanExpression query = Expressions.anyOf(
                new QueryElement(query1),
                new QueryElement(query2)
        );
        testQuery(query, ""author:michael text:text"", 1);
    }",No Smells
"@Test
    public void various() throws Exception {
        MatchingFiltersFactory filters = new MatchingFiltersFactory(QuerydslModule.LUCENE, Target.LUCENE);
        for (Predicate filter : filters.string(title, StringConstant.create(""jurassic park""))) {
            if (unsupportedOperation(filter)) {
                continue;
            }",Eager Test
"@Test
    public void hashCode_() {
        PhraseElement el1 = new PhraseElement(""x""), el2 = new PhraseElement(""x"");
        assertEquals(el1.hashCode(), el2.hashCode());
    }",No Smells
"@Test
    public void testEqualsAndHashCode() {
    TermElement el1 = new TermElement(""x""), el2 = new TermElement(""x""), el3 = new TermElement(""y"");
        assertEquals(el1, el2);
        assertFalse(el1.equals(el3));
        assertEquals(el1.hashCode(), el2.hashCode());
    }",No Smells
"@Test
    public void empty_index_should_return_empty_list() throws Exception {
        idx = new RAMDirectory();

        writer = createWriter(idx);
        writer.close();
        IndexReader reader = IndexReader.open(idx);
        searcher = new IndexSearcher(reader);
        query = new LuceneQuery(new LuceneSerializer(true, true), searcher);
        assertTrue(query.fetch().isEmpty());
    }",No Smells
"@Test
    public void exists() {
        assertTrue(query.where(title.eq(""Jurassic Park"")).fetchCount() > 0);
        assertFalse(query.where(title.eq(""Jurassic Park X"")).fetchCount() > 0);
    }",No Smells
"@Test
    public void in_toString() {
        assertEquals(""year:`____F year:`____H"", query.where(year.in(1990, 1864)).toString());
    }",No Smells
"@Test
    public void list_all() {
        final List<Document> results = query.where(title.like(""*"")).orderBy(
                title.asc(), year.desc()).fetch();
        assertEquals(4, results.size());
    }",No Smells
"@Test
    public void list_not_sorted_offset_0() {
        query.where(year.between(1800, 2000));
        query.offset(0);
        final List<Document> documents = query.fetch();
        assertFalse(documents.isEmpty());
        assertEquals(4, documents.size());
    }",No Smells
"@Test
    public void list_sorted_ascending_by_year_offset_2() {
        query.where(year.between(1800, 2000));
        query.offset(2);
        query.orderBy(year.asc());
        final List<Document> documents = query.fetch();
        assertFalse(documents.isEmpty());
        assertEquals(2, documents.size());
        assertEquals(""1990"", documents.get(0).get(""year""));
        assertEquals(""1990"", documents.get(1).get(""year""));
    }",No Smells
"@Test
    public void list_sorted_by_year_ascending() {
        query.where(year.between(1800, 2000));
        query.orderBy(year.asc());
        final List<Document> documents = query.fetch();
        assertFalse(documents.isEmpty());
        assertEquals(4, documents.size());
    }",No Smells
"@Test
    public void load_list_fieldSelector() {
        Document document = query.where(title.ne("""")).load(Collections.singleton(""title"")).fetch().get(0);
        assertNotNull(document.get(""title""));
        assertNull(document.get(""year""));
    }",No Smells
"@Test
    public void notExists() {
        assertFalse(query.where(title.eq(""Jurassic Park"")).fetchCount() == 0);
        assertTrue(query.where(title.eq(""Jurassic Park X"")).fetchCount() == 0);
    }",No Smells
"@Test
    public void single_result_considers_limit_and_actual_result_size() {
        query.where(title.startsWith(""Nummi""));
        final Document document = query.limit(3).fetchFirst();
        assertEquals(""Nummisuutarit"", document.get(""title""));
    }",No Smells
"@Test
    public void single_result_considers_offset() {
        assertEquals(""Introduction to Algorithms"", query.where(title.ne("""")).offset(3).fetchFirst().get(""title""));
    }",No Smells
"@Test
    public void single_result_takes_limit() {
        assertEquals(""Jurassic Park"", query
                                        .where(title.ne(""""))
                                        .limit(1)
                                        .fetchFirst().get(""title""));
    }",No Smells
"@Test
    public void load_singleResult() {
        Document document = query.where(title.ne("""")).load(title).fetchFirst();
        assertNotNull(document.get(""title""));
        assertNull(document.get(""year""));
    }",No Smells
"@Test
    public void between_empty_strings() throws Exception {
        testQuery(title.between("""", """"), ""title:[ TO ]"", 0);
    }",No Smells
"@Test
    public void endsWith() throws Exception {
        testQuery(title.endsWith(""ark""), ""title:*ark"", 1);
    }",No Smells
"@Test
    public void eq() throws Exception {
        testQuery(rating.eq(""good""), ""rating:good"", 1);
    }",No Smells
"@Test
    public void eq_and_eq_not_does_not_find_results_because_second_expression_finds_nothing() throws Exception {
        testQuery(rating.eq(""superb"").and(title.eq(""house"").not()), ""+rating:superb +(-title:house +*:*)"", 0);
    }",No Smells
"@Test
    public void eq_phrase_does_not_find_results_because_word_in_middle() throws Exception {
        testQuery(title.eq(""Jurassic Amusement Park""), ""title:\""jurassic amusement park\"""", 0);
    }",No Smells
"@Test
    public void eq_phrase_should_not_find_results_but_luceNe_semantics_differs_from_querydsls() throws Exception {
        testQuery(text.eq(""UNIX System""), ""text:\""unix system\"""", 1);
    }",No Smells
"@Test
    public void fuzzyLike() throws Exception {
        testQuery(LuceneExpressions.fuzzyLike(rating, ""Good""), ""rating:Good~2"", 1);
    }",No Smells
"@Test
    public void fuzzyLike_with_similarity_and_prefix() throws Exception {
        testQuery(LuceneExpressions.fuzzyLike(rating, ""Good"", 2, 0), ""rating:Good~2"", 1);
    }",No Smells
"@Test
    public void goe_equal() throws Exception {
        testQuery(rating.goe(""Good""), ""rating:[good TO *]"", 1);
    }",No Smells
"@Test
    public void queryElement() throws Exception {
        Query query1 = serializer.toQuery(author.like(""Michael""), metadata);
        Query query2 = serializer.toQuery(text.like(""Text""), metadata);

        BooleanExpression query = Expressions.anyOf(
                new QueryElement(query1),
                new QueryElement(query2)
        );
        testQuery(query, ""author:michael text:text"", 1);
    }",No Smells
"@Test
    public void like_custom_wildcard_multiple_character() throws Exception {
        testQuery(text.like(""*U*X*""), ""text:*u*x*"", 1);
    }",No Smells
"@Test
    public void loe_not_found() throws Exception {
        testQuery(rating.loe(""Bad""), ""rating:[* TO bad]"", 0);
    }",No Smells
"@Test
    public void loe_numeric_double() throws Exception {
        testQuery(gross.loe(903.0), ""gross:[* TO 903.0]"", 1);
    }",No Smells
"@Test
    public void lt_numeric_double() throws Exception {
        testQuery(gross.lt(10000.0), ""gross:{* TO 10000.0}",No Smells
"@Test
    public void lt_numeric_integer() throws Exception {
        testQuery(year.lt(1991), ""year:{* TO 1991}",No Smells
"@Test
    public void lt_numeric_integer_not_in_range_because_equal() throws Exception {
        testQuery(year.lt(1990), ""year:{* TO 1990}",No Smells
"@Test
    public void not_equals_finds_none() throws Exception {
        testQuery(title.ne(""Jurassic Park""), ""-title:\""jurassic park\"" +*:*"", 0);
    }",No Smells
"@Test
    public void various() throws Exception {
        MatchingFiltersFactory filters = new MatchingFiltersFactory(QuerydslModule.LUCENE, Target.LUCENE);
        for (Predicate filter : filters.string(title, StringConstant.create(""jurassic park""))) {
            if (unsupportedOperation(filter)) {
                continue;
            }",No Smells
"@Test
    public void various() throws Exception {
        MatchingFiltersFactory filters = new MatchingFiltersFactory(QuerydslModule.LUCENE, Target.LUCENE);
        for (Predicate filter : filters.string(title, StringConstant.create(""jurassic park""))) {
            if (unsupportedOperation(filter)) {
                continue;
            }",Eager Test
"@Test
    public void test() {
        StringPath title = Expressions.stringPath(""title"");
        LuceneSerializer serializer = new LuceneSerializer(false,true);
        QueryMetadata metadata = new DefaultQueryMetadata();
        assertEquals(""title:\""Hello World\"""", serializer.toQuery(title.eq(""Hello World""), metadata).toString());
        assertEquals(""title:Hello World"", serializer.toQuery(title.eq(new TermElement(""Hello World"")), metadata).toString());
    }",No Smells
"@Test
    public void between() {
        assertEquals(3, query.where(year.between(1950, 1990)).fetchCount());
    }",No Smells
"@Test
    public void between() {
        assertEquals(3, query.where(year.between(1950, 1990)).fetchCount());
    }",No Smells
"@Test
    public void list_sorted_ascending_by_year_offset_2() {
        query.where(year.between(1800, 2000));
        query.offset(2);
        query.orderBy(year.asc());
        final List<Document> documents = query.fetch();
        assertFalse(documents.isEmpty());
        assertEquals(2, documents.size());
        assertEquals(""1990"", documents.get(0).get(""year""));
        assertEquals(""1990"", documents.get(1).get(""year""));
    }",No Smells
"@Test
    public void list_sorted_ascending_offset_0() {
        query.where(year.between(1800, 2000));
        query.offset(0);
        query.orderBy(year.asc());
        final List<Document> documents = query.fetch();
        assertFalse(documents.isEmpty());
        assertEquals(4, documents.size());
    }",No Smells
"@Test
    public void list_with_filter() {
        Filter filter = new DuplicateFilter(""year"");
        assertEquals(4, query.fetch().size());
        assertEquals(3, query.filter(filter).fetch().size());
    }",No Smells
"@Test
    public void load_list() {
        Document document = query.where(title.ne("""")).load(title).fetch().get(0);
        assertNotNull(document.get(""title""));
        assertNull(document.get(""year""));
    }",No Smells
"@Test
    public void load_list_fieldSelector() {
        Document document = query.where(title.ne("""")).load(Collections.singleton(""title"")).fetch().get(0);
        assertNotNull(document.get(""title""));
        assertNull(document.get(""year""));
    }",No Smells
"@Test
    public void load_singleResult() {
        Document document = query.where(title.ne("""")).load(title).fetchFirst();
        assertNotNull(document.get(""title""));
        assertNull(document.get(""year""));
    }",No Smells
"@Test
    public void single_result_considers_limit_and_offset() {
        assertEquals(""The Lord of the Rings"", query.where(title.ne("""")).limit(1).offset(2).fetchFirst().get(""title""));
    }",No Smells
"@Test
    public void single_result_considers_offset() {
        assertEquals(""Introduction to Algorithms"", query.where(title.ne("""")).offset(3).fetchFirst().get(""title""));
    }",No Smells
"@Test
    public void single_result_returns_null_if_nothing_is_in_range() {
        query.where(title.startsWith(""Nummi""));
        assertNull(query.offset(10).fetchFirst());
    }",No Smells
"@Test
    public void unique_result_considers_limit_and_offset() {
        assertEquals(""The Lord of the Rings"", query.where(title.ne("""")).limit(1).offset(2).fetchOne().get(""title""));
    }",No Smells
"@Test
    public void unique_result_considers_offset() {
        assertEquals(""Introduction to Algorithms"", query.where(title.ne("""")).offset(3).fetchOne().get(""title""));
    }",No Smells
"@Test
    public void uniqueResult_with_param() {
        final Param<String> param = new Param<String>(String.class, ""title"");
        query.set(param, ""Nummi"");
        query.where(title.startsWith(param));
        final Document document = query.fetchOne();
        assertEquals(""Nummisuutarit"", document.get(""title""));
    }",No Smells
"@Test
    public void between_empty_strings() throws Exception {
        testQuery(title.between("""", """"), ""title:[ TO ]"", 0);
    }",No Smells
"@Test
    public void between_is_inclusive_from_start() throws Exception {
        testQuery(title.between(""Jurassic"", ""Kundun""), ""title:[jurassic TO kundun]"", 1);
    }",No Smells
"@Test
    public void between_is_inclusive_to_end() throws Exception {
        testQuery(title.between(""Indiana"", ""Jurassic""), ""title:[indiana TO jurassic]"", 1);
    }",No Smells
"@Test
    public void between_numeric_integer() throws Exception {
        testQuery(year.between(1980, 2000), ""year:[1980 TO 2000]"", 1);
    }",No Smells
"@Test
    public void contains_empty_string() throws Exception {
        testQuery(title.contains(""""), ""title:**"", 1);
    }",No Smells
"@Test
    public void endsWith() throws Exception {
        testQuery(title.endsWith(""ark""), ""title:*ark"", 1);
    }",No Smells
"@Test
    public void eq() throws Exception {
        testQuery(rating.eq(""good""), ""rating:good"", 1);
    }",No Smells
"@Test
    public void eq_with_deep_path() throws Exception {
        StringPath deepPath = entityPath.get(""property1"", Object.class).getString(""property2"");
        testQuery(deepPath.eq(""good""), ""property1.property2:good"", 0);
    }",No Smells
"@Test
    public void equals_empty_string() throws Exception {
        testQuery(title.eq(""""), ""title:"", 0);
    }",No Smells
"@Test
    public void equals_ignores_case() throws Exception {
        testQuery(title.eq(""Jurassic""), ""title:jurassic"", 1);
    }",No Smells
"@Test
    public void fuzzyLike_with_similarity_and_prefix() throws Exception {
        testQuery(LuceneExpressions.fuzzyLike(rating, ""Good"", 2, 0), ""rating:Good~2"", 1);
    }",No Smells
"@Test
    public void goe_numeric_integer_equal() throws Exception {
        testQuery(year.goe(1990), ""year:[1990 TO *]"", 1);
    }",No Smells
"@Test
    public void goe_numeric_integer_not_found() throws Exception {
        testQuery(year.goe(1991), ""year:[1991 TO *]"", 0);
    }",No Smells
"@Test
    public void gt_not_in_range_because_equal() throws Exception {
        testQuery(rating.gt(""Good""), ""rating:{good TO *}",No Smells
"@Test
    public void gt_numeric_double() throws Exception {
        testQuery(gross.gt(100.00), ""gross:{100.0 TO *}",No Smells
"@Test
    public void gt_numeric_double_not_in_range_because_equal() throws Exception {
        testQuery(gross.gt(900.00), ""gross:{900.0 TO *}",No Smells
"@Test
    public void like_custom_wildcard_single_character() throws Exception {
        testQuery(author.like(""Mi?hael""), ""author:mi?hael"", 1);
    }",No Smells
"@Test
    public void like_custom_wildcard_multiple_character() throws Exception {
        testQuery(text.like(""*U*X*""), ""text:*u*x*"", 1);
    }",No Smells
"@Test
    public void like_not_does_not_find_results() throws Exception {
        testQuery(title.like(""*H*e*"").not(), ""-title:*h*e* +*:*"", 1);
    }",No Smells
"@Test
    public void not_equals_finds_one() throws Exception {
        testQuery(title.ne(""house""), ""-title:house +*:*"", 1);
    }",No Smells
"@Test
    public void pathAny() throws Exception {
        testQuery(titles.any().eq(""Jurassic""), ""title:jurassic"", 1);
    }",No Smells
"@Test
    public void startsWith_phrase() throws Exception {
        testQuery(title.startsWith(""jurassic par""), ""+title:jurassic* +title:*par*"", 1);
    }",No Smells
"@Test
    public void test() {
        StringPath title = Expressions.stringPath(""title"");
        LuceneSerializer serializer = new LuceneSerializer(false,true);
        QueryMetadata metadata = new DefaultQueryMetadata();
        assertEquals(""title:\""Hello World\"""", serializer.toQuery(title.eq(""Hello World""), metadata).toString());
        assertEquals(""title:Hello World"", serializer.toQuery(title.eq(new TermElement(""Hello World"")), metadata).toString());
    }",No Smells
"@Test
    public void testEqualsAndHashCode() {
    TermElement el1 = new TermElement(""x""), el2 = new TermElement(""x""), el3 = new TermElement(""y"");
        assertEquals(el1, el2);
        assertFalse(el1.equals(el3));
        assertEquals(el1.hashCode(), el2.hashCode());
    }",No Smells
"@Test
    public void executeWithNamingStrategy() throws Exception {
        mojo.setTargetFolder(""target/export8"");
        mojo.setNamingStrategyClass(OriginalNamingStrategy.class.getName());
        mojo.execute();

        assertTrue(new File(""target/export8"").exists());
    }",Mystery Guest
"@Test
    public void executeWithNumericMappings() throws Exception {
        mojo.setTargetFolder(""target/export5"");
        NumericMapping mapping = new NumericMapping();
        mapping.setTotal(1);
        mapping.setDecimal(1);
        mapping.setJavaType(Number.class.getName());
        mojo.setNumericMappings(new NumericMapping[]{mapping}",Mystery Guest
"@Test
    public void executeWithRenames() throws Exception {
        RenameMapping mapping = new RenameMapping();
        mapping.setFromSchema(""ABC"");
        mapping.setToSchema(""DEF"");

        mojo.setTargetFolder(""target/export13"");
        mojo.setRenameMappings(new RenameMapping[]{mapping}",Mystery Guest
"@Test
    public void friend() {
        User friend = new User();
        friend.setId(ObjectId.createFromLegacyFormat(1,2,3));

        User user = new User();
        user.setFriend(friend);

        assertNotNull(morphia.toDBObject(user));
    }",No Smells
"@Test
    public void friends() {
        User friend = new User();
        friend.setId(ObjectId.createFromLegacyFormat(1,2,3));

        User user = new User();
        user.addFriend(friend);

        assertNotNull(morphia.toDBObject(user));
    }",No Smells
"@Test
    public void collectionAny() {
        QUser user = QUser.user;
        assertQuery(user.addresses.any().street.eq(""Aakatu""), dbo(""addresses.street"", ""Aakatu""));
    }",No Smells
"@Test
    public void paths() {
        QUser user = QUser.user;
        assertEquals(""user"", serializer.visit(user, null));
        assertEquals(""addresses"", serializer.visit(user.addresses, null));
        assertEquals(""addresses"", serializer.visit(user.addresses.any(), null));
        assertEquals(""addresses.street"", serializer.visit(user.addresses.any().street, null));
        assertEquals(""firstName"", serializer.visit(user.firstName, null));
    }",No Smells
"@Test
    public void indexedAccess() {
        QUser user = QUser.user;
        assertEquals(""addresses.0.street"", serializer.visit(user.addresses.get(0).street, null));
    }",No Smells
"@Test
    public void indexedAccess() {
        QUser user = QUser.user;
        assertEquals(""addresses.0.street"", serializer.visit(user.addresses.get(0).street, null));
    }",No Smells
"@Test
    public void propertyAnnotation() {
        QDummyEntity entity = QDummyEntity.dummyEntity;
        assertEquals(""prop"", serializer.visit(entity.property, null));
    }",No Smells
"@Test
    public void notEq() {
        assertQuery(title.ne(""A""), dbo(""title"", dbo(""$ne"", ""A"")));
    }",No Smells
"@Test
    public void orderBy() {
        DBObject orderBy = serializer.toSort(sortList(year.asc()));
        assertEquals(dbo(""year"", 1), orderBy);

        orderBy = serializer.toSort(sortList(year.desc()));
        assertEquals(dbo(""year"", -1), orderBy);

        orderBy = serializer.toSort(sortList(year.desc(), title.asc()));
        assertEquals(dbo(""year"", -1).append(""title"", 1), orderBy);
    }",No Smells
"@Test
    public void verify_package() throws Exception {
        String version = System.getProperty(""version"");
        verify(new File(""target/querydsl-jdo-"" + version + ""-apt-one-jar.jar""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void allMapped() {
        Map<Operator, String> mapping = HibernateSpatialSupport.getSpatialOps();
        for (Operator operator : SpatialOps.values()) {
            assertTrue(operator + "" missing"", mapping.containsKey(operator));
        }",Eager Test
"@Test
    public void execute_with_beans() {
        AntMetaDataExporter exporter = new AntMetaDataExporter();
        exporter.setJdbcDriver(""org.h2.Driver"");
        exporter.setJdbcUser(""sa"");
        exporter.setJdbcUrl(url);
        exporter.setPackageName(""test"");
        exporter.setTargetFolder(""target/AntMetaDataExporterTest2"");
        exporter.setExportBeans(true);
        exporter.setNamePrefix(""Q"");
        exporter.setNameSuffix("""");
        exporter.setBeanPrefix("""");
        exporter.setBeanSuffix(""Bean"");
        exporter.execute();

        assertTrue(new File(""target/AntMetaDataExporterTest2"").exists());
        assertTrue(new File(""target/AntMetaDataExporterTest2/test/QTest.java"").exists());
        assertTrue(new File(""target/AntMetaDataExporterTest2/test/TestBean.java"").exists());
    }",Mystery Guest
"@Test
    public void getPropertyNameForInverseForeignKey() {
        assertEquals(""_superiorFk"", namingStrategy.getPropertyNameForInverseForeignKey(""fk_superior"", entityModel));
        // fk_order_rows
        assertEquals(""rows"", namingStrategy.getPropertyNameForInverseForeignKey(""fk_order_rows"", entityModel));
        // fk_category_events
        assertEquals(""events"", namingStrategy.getPropertyNameForInverseForeignKey(""fk_category_events"", entityModel));
    }",No Smells
"@Test
    public void getPropertyName() {
        assertEquals(""while_col"", namingStrategy.getPropertyName(""while"", entityModel));
        assertEquals(""name"", namingStrategy.getPropertyName(""name"", entityModel));
        assertEquals(""user_id"", namingStrategy.getPropertyName(""user_id"", entityModel));
        assertEquals(""accountEvent_id"", namingStrategy.getPropertyName(""accountEvent_id"", entityModel));

        assertEquals(""_123abc"", namingStrategy.getPropertyName(""123abc"", entityModel));
        assertEquals(""_123_abc"", namingStrategy.getPropertyName(""123 abc"", entityModel));

        assertEquals(""_123_abc_def"", namingStrategy.getPropertyName(""#123#abc#def"", entityModel));

        assertEquals(""new_line"", namingStrategy.getPropertyName(""new line"", entityModel));
    }",Mystery Guest
"@Test
    public void tableToTable() {
        mapping.setFromTable(""TABLE1"");
        mapping.setToTable(""TABLE2"");
        mapping.apply(configuration);

        assertEquals(
                new SchemaAndTable(""DEF"", ""TABLE2""),
                configuration.getOverride(new SchemaAndTable(""DEF"", ""TABLE1"")));
        assertEquals(
                new SchemaAndTable(""DEF"", ""TABLE3""),
                configuration.getOverride(new SchemaAndTable(""DEF"", ""TABLE3"")));
    }",Mystery Guest
"@Test
    public void custom_type() {
        Configuration configuration = new Configuration(new H2Templates());
//        configuration.setJavaType(Types.BLOB, InputStream.class);
        configuration.register(new InputStreamType());
        assertEquals(InputStream.class, configuration.getJavaType(Types.BLOB, null, 0,0,"""", """"));
    }",Mystery Guest
"@Test
    public void get_schema() {
        Configuration configuration = new Configuration(new H2Templates());
        configuration.registerSchemaOverride(""public"", ""pub"");
        configuration.registerTableOverride(""employee"", ""emp"");
        configuration.registerTableOverride(""public"", ""employee"", ""employees"");

        assertEquals(""pub"", configuration.getOverride(new SchemaAndTable(""public"", """")).getSchema());
        assertEquals(""emp"", configuration.getOverride(new SchemaAndTable("""", ""employee"")).getTable());
        assertEquals(""employees"", configuration.getOverride(new SchemaAndTable(""public"", ""employee"")).getTable());

        configuration.setDynamicNameMapping(new PreConfiguredNameMapping());
        SchemaAndTable notOverriddenSchemaAndTable = new SchemaAndTable(""notoverridden"", ""notoverridden"");
        assertEquals(notOverriddenSchemaAndTable, configuration.getOverride(notOverriddenSchemaAndTable));

        configuration.setDynamicNameMapping(new ChangeLetterCaseNameMapping(LetterCase.UPPER, Locale.ENGLISH));
        String notDirectOverriden = ""notDirectOverriden"";
        assertEquals(notDirectOverriden.toUpperCase(Locale.ENGLISH),
                configuration.getOverride(new SchemaAndTable(""public"", notDirectOverriden)).getTable());

    }",Mystery Guest
"@Test
    public void batch() throws SQLException {
        insert(survey).values(2, ""A"",""B"").execute();
        insert(survey).values(3, ""B"",""C"").execute();

        SQLDeleteClause delete = delete(survey);
        delete.where(survey.name.eq(""A"")).addBatch();
        assertEquals(1, delete.getBatchCount());
        delete.where(survey.name.eq(""B"")).addBatch();
        assertEquals(2, delete.getBatchCount());
        assertEquals(2, delete.execute());
    }",Mystery Guest
"@Test
    public void nextVal() {
        Operation<String> nextval = ExpressionUtils.operation(String.class, SQLOps.NEXTVAL, ConstantImpl.create(""myseq""));
        assertEquals(""next value for myseq"", new SQLSerializer(new Configuration(new DerbyTemplates())).handle(nextval).toString());
    }",Mystery Guest
"@Test
    public void precedence() {
        // unary + and -
        int p1 = getPrecedence(Ops.NEGATE);
        // *, /, || (concatenation)
        int p2 = getPrecedence(Ops.MULT, Ops.DIV);
        // binary + and -
        int p3 = getPrecedence(Ops.ADD, Ops.SUB);
        // comparisons, quantified comparisons, EXISTS, IN, IS NULL, LIKE, BETWEEN, IS
        int p4 = getPrecedence(Ops.EQ, Ops.NE, Ops.LT, Ops.GT, Ops.LOE, Ops.GOE, Ops.EXISTS,
                Ops.IN, Ops.IS_NULL, Ops.LIKE, Ops.BETWEEN, Ops.IS_NOT_NULL);
        // NOT
        int p5 = getPrecedence(Ops.NOT);
        // AND
        int p6 = getPrecedence(Ops.AND);
        // OR
        int p7 = getPrecedence(Ops.OR);

        assertTrue(p1 < p2);
        assertTrue(p2 < p3);
        assertTrue(p3 < p4);
        assertTrue(p4 < p5);
        assertTrue(p5 < p6);
        assertTrue(p6 < p7);
    }",Mystery Guest
"@Test
    public void extract2() {
        Map<Path<?>, Object> values = AnnotationMapper.DEFAULT.createMap(emp, new EmployeeX());
        assertTrue(values.isEmpty());
    }",Mystery Guest
"@Test
    public void extract_failure() {
        Map<Path<?>, Object> values = AnnotationMapper.DEFAULT.createMap(emp, employee);
        assertTrue(values.isEmpty());
    }",Mystery Guest
"@Test
    public void getSQL() {
        QEmployee emp1 = new QEmployee(""emp1"");
        SQLDeleteClause delete = new SQLDeleteClause(null, SQLTemplates.DEFAULT, emp1);
        delete.where(emp1.id.eq(1));

        SQLBindings sql = delete.getSQL().get(0);
        assertEquals(""delete from EMPLOYEE\nwhere EMPLOYEE.ID = ?"", sql.getSQL());
        assertEquals(Collections.singletonList(1), sql.getNullFriendlyBindings());
    }",Mystery Guest
"@Test
    public void getSQLWithPreservedColumnOrder() {
        com.querydsl.sql.domain.QEmployee emp1 = new com.querydsl.sql.domain.QEmployee(""emp1"");
        SQLInsertClause insert = new SQLInsertClause(null, SQLTemplates.DEFAULT, emp1);
        insert.populate(emp1);

        SQLBindings sql = insert.getSQL().get(0);
        assertEquals(""The order of columns in generated sql should be predictable"",
                ""insert into EMPLOYEE (ID, FIRSTNAME, LASTNAME, SALARY, DATEFIELD, TIMEFIELD, SUPERIOR_ID)\n"" +
                ""values (EMPLOYEE.ID, EMPLOYEE.FIRSTNAME, EMPLOYEE.LASTNAME, EMPLOYEE.SALARY, EMPLOYEE.DATEFIELD, EMPLOYEE.TIMEFIELD, EMPLOYEE.SUPERIOR_ID)"", sql.getSQL());
    }",Mystery Guest
"@Test
    public void intertable2() {
        QEmployee emp1 = new QEmployee(""emp1"");
        QEmployee emp2 = new QEmployee(""emp2"");
        SQLUpdateClause update = new SQLUpdateClause(null, SQLTemplates.DEFAULT, emp1);
        update.set(emp1.id, select(emp2.id).from(emp2)
              .where(emp2.superiorId.isNotNull()));

        SQLBindings sql = update.getSQL().get(0);
        assertEquals(""update EMPLOYEE\n"" +
                ""set ID = (select emp2.ID\n"" +
                ""from EMPLOYEE emp2\n"" +
                ""where emp2.SUPERIOR_ID is not null)"", sql.getSQL());
    }",Mystery Guest
"@Test
    public void on() {
        QEmployee employee = new QEmployee(""employee"");
        QEmployee employee2 = new QEmployee(""employee2"");

        ForeignKey<Employee> foreignKey = new ForeignKey<Employee>(employee, employee.superiorId, ""ID"");
        assertEquals(""employee.superiorId = employee2.ID"", foreignKey.on(employee2).toString());

        foreignKey = new ForeignKey<Employee>(employee,
                Arrays.asList(employee.superiorId, employee.firstname),
                Arrays.asList(""ID"", ""FN""));
        assertEquals(""employee.superiorId = employee2.ID && employee.firstname = employee2.FN"", foreignKey.on(employee2).toString());
    }",Mystery Guest
"@Test
    public void builder() {
        SQLTemplates templates = H2Templates.builder().quote()
            .newLineToSingleSpace()
            .build();

        assertNotNull(templates);
    }",Mystery Guest
"@Test
    public void precedence() {
        // unary
        // *, /, %
        // +, -
        // ||
        // comparison
        // NOT
        // AND
        // OR

        int p1 = getPrecedence(Ops.NEGATE);
        int p2 = getPrecedence(Ops.MULT, Ops.DIV, Ops.MOD);
        int p3 = getPrecedence(Ops.ADD, Ops.SUB);
        int p4 = getPrecedence(Ops.CONCAT);
        int p5 = getPrecedence(Ops.EQ, Ops.NE, Ops.LT, Ops.GT); // ...
        int p6 = getPrecedence(Ops.NOT);
        int p7 = getPrecedence(Ops.AND);
        int p8 = getPrecedence(Ops.OR);

        assertTrue(p1 < p2);
        assertTrue(p2 < p3);
        assertTrue(p3 < p4);
        assertTrue(p4 < p5);
        assertTrue(p5 < p6);
        assertTrue(p6 < p7);
        assertTrue(p7 < p8);
    }",Mystery Guest
"@Test
    public void precedence() {
        // Evaluation from left to right. Parentheses group operations.
        // Multiplication and division take precedence over addition and subtraction.
        // AND takes precedence over OR.
        // NOT applies to the immediate term.
        // LIKE applies to the result of any string concatenation to the right.
        // Comparison ops are not combined without logical ops so there is no precedence issue.

        //int p1 = getPrecedence(Ops.NEGATE);
        int p2 = getPrecedence(Ops.MULT, Ops.DIV, Ops.CONCAT);
        int p3 = getPrecedence(Ops.ADD, Ops.SUB);
        int p4 = getPrecedence(Ops.NOT);
        int p5 = getPrecedence(Ops.EQ, Ops.NE, Ops.LT, Ops.GT, Ops.LOE, Ops.GOE);
        int p6 = getPrecedence(Ops.IS_NULL, Ops.IS_NOT_NULL, Ops.LIKE, Ops.LIKE_ESCAPE, Ops.BETWEEN, Ops.IN, Ops.NOT_IN, Ops.EXISTS);
        int p7 = getPrecedence(Ops.AND);
        int p8 = getPrecedence(Ops.OR);

        //assertTrue(p1 < p2);
        assertTrue(p2 < p3);
        assertTrue(p3 < p4);
        assertTrue(p4 < p5);
        assertTrue(p5 < p6);
        assertTrue(p6 < p7);
        assertTrue(p7 < p8);
    }",Mystery Guest
"@Test
    public void complex1() {
        // related to #584795
        QSurvey survey = new QSurvey(""survey"");
        QEmployee emp1 = new QEmployee(""emp1"");
        QEmployee emp2 = new QEmployee(""emp2"");
        SQLInsertClause insert = insert(survey);
        insert.columns(survey.id, survey.name);
        insert.select(select(survey.id, emp2.firstname).from(survey)
          .innerJoin(emp1)
           .on(survey.id.eq(emp1.id))
          .innerJoin(emp2)
           .on(emp1.superiorId.eq(emp2.superiorId), emp1.firstname.eq(emp2.firstname)));

        assertEquals(0, insert.execute());
    }",Mystery Guest
"@Test
    public void insert_alternative_syntax() {
        // with columns
        assertEquals(1, insert(survey)
            .set(survey.id, 3)
            .set(survey.name, ""Hello"")
            .execute());
    }",Mystery Guest
"@Test
    public void insert_batch_to_bulk() {
        SQLInsertClause insert = insert(survey);
        insert.setBatchToBulk(true);

        insert.set(survey.id, 5)
                .set(survey.name, ""55"")
                .addBatch();

        assertEquals(1, insert.getBatchCount());

        insert.set(survey.id, 6)
                .set(survey.name, ""66"")
                .addBatch();

        assertEquals(2, insert.getBatchCount());
        assertEquals(2, insert.execute());

        assertEquals(1L, query().from(survey).where(survey.name.eq(""55"")).fetchCount());
        assertEquals(1L, query().from(survey).where(survey.name.eq(""66"")).fetchCount());
    }",Mystery Guest
"@Test
    public void getType_for_object() {
        assertEquals(ObjectType.class, typeMapping.getType(Object.class).getClass());
    }",No Smells
"@Test
    public void bytesTypes() {
        assertEquals(byte[].class, typeMapping.get(Types.BINARY,0,0));
        assertEquals(byte[].class, typeMapping.get(Types.VARBINARY,0,0));
        assertEquals(byte[].class, typeMapping.get(Types.LONGVARBINARY,0,0));
    }",No Smells
"@Test
    public void like_with_escape() {
        assertEquals(1, query().from(survey).where(survey.name.like(""a!%"", '!')).fetchCount());
        assertEquals(1, query().from(survey).where(survey.name.like(""a!_"", '!')).fetchCount());
        assertEquals(3, query().from(survey).where(survey.name.like(""a%"", '!')).fetchCount());
        assertEquals(2, query().from(survey).where(survey.name.like(""a_"", '!')).fetchCount());
    }",Mystery Guest
"@Test
    public void merge_listener() {
        final AtomicInteger calls = new AtomicInteger(0);
        SQLListener listener = new SQLBaseListener() {
            @Override
            public void end(SQLListenerContext context) {
                if (context.getData(AbstractSQLQuery.PARENT_CONTEXT) == null) {
                    calls.incrementAndGet();
                }",Mystery Guest
"@Test
    public void merge_with_keys_columns_and_values_using_null() {
        // keys + columns + values
        assertEquals(1, merge(survey).keys(survey.id)
            .set(survey.id, 5)
            .set(survey.name, (String) null).execute());
    }",Mystery Guest
"@Test
    public void tableHints_multiple() {
        SQLServerQuery<?> query = new SQLServerQuery<Void>(null, new SQLServerTemplates());
        query.from(survey).tableHints(SQLServerTableHints.NOWAIT, SQLServerTableHints.NOLOCK).where(survey.name.isNull());
        assertEquals(""from SURVEY SURVEY with (NOWAIT, NOLOCK)\nwhere SURVEY.NAME is null"", query.toString());
    }",Mystery Guest
"@Test
    public void tableHints_multiple2() {
        QSurvey survey2 = new QSurvey(""survey2"");
        SQLServerQuery<?> query = new SQLServerQuery<Void>(null, new SQLServerTemplates());
        query.from(survey).tableHints(SQLServerTableHints.NOWAIT)
             .from(survey2).tableHints(SQLServerTableHints.NOLOCK)
             .where(survey.name.isNull());
        assertEquals(""from SURVEY SURVEY with (NOWAIT), SURVEY survey2 with (NOLOCK)\nwhere SURVEY.NAME is null"", query.toString());
    }",Mystery Guest
"@Test
    public void hashCode_() {
        int hashCode = multiKey1.hashCode();
        multiKey1.setId(1);
        assertEquals(hashCode, multiKey1.hashCode());

        multiKey1.setId2(""2"");
        multiKey1.setId3(3);

        multiKey2.setId(1);
        multiKey2.setId2(""2"");
        multiKey2.setId3(3);

        assertEquals(multiKey1.hashCode(), multiKey2.hashCode());
    }",No Smells
"@Test
    public void toString_() {
        assertEquals(""Multikey#null;null;null"", multiKey1.toString());

        multiKey1.setId(1);
        multiKey1.setId2(""2"");
        multiKey1.setId3(3);
        assertEquals(""Multikey#1;2;3"", multiKey1.toString());
    }",No Smells
"@Test
    public void insert() {
        assertNotNull(queryFactory.insert(QSurvey.survey));
    }",No Smells
"@Test
    public void insertOnDuplicateKeyUpdate_multiple() {
        SQLInsertClause clause = queryFactory.insertOnDuplicateKeyUpdate(QSurvey.survey,
                SQLExpressions.set(QSurvey.survey.id, 2),
                SQLExpressions.set(QSurvey.survey.name, ""B""));
        assertEquals(""insert into SURVEY\n"" +
                ""values () on duplicate key update SURVEY.ID = ?, SURVEY.NAME = ?"", clause.toString());
    }",No Smells
"@Test
    public void insertOnDuplicateKeyUpdate_null() {
        SQLInsertClause clause = queryFactory.insertOnDuplicateKeyUpdate(QSurvey.survey,
                SQLExpressions.set(QSurvey.survey.name, (String) null));
        assertEquals(""insert into SURVEY\n"" +
                ""values () on duplicate key update SURVEY.NAME = null"", clause.toString());
    }",No Smells
"@Test
    public void forUpdate_with_limit() {
        query.forUpdate();
        query.limit(2);
        assertEquals(""select survey.NAME from SURVEY survey order by survey.NAME asc limit ? for update"",
                toString(query));
    }",Mystery Guest
"@Test
    public void ignoreIndex() {
        query = new MySQLQuery<Void>(null, MySQLTemplates.builder().newLineToSingleSpace().build());
        query.from(survey);
        query.ignoreIndex(""col1_index"");
        query.orderBy(survey.name.asc());
        query.getMetadata().setProjection(survey.name);

        assertEquals(""select survey.NAME from SURVEY survey ignore index (col1_index) "" +
                     ""order by survey.NAME asc"", toString(query));
    }",Mystery Guest
"@Test
    public void intoString() {
        query.into(""var1"");
        assertEquals(""select survey.NAME from SURVEY survey "" +
                     ""order by survey.NAME asc into var1"", toString(query));
    }",Mystery Guest
"@Test
    public void syntax() {
//        SELECT
//        [ALL | DISTINCT | DISTINCTROW ]
//          [HIGH_PRIORITY]
        query.highPriority();
//          [STRAIGHT_JOIN]
        query.straightJoin();
//          [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
        query.smallResult();
        query.bigResult();
        query.bufferResult();
//          [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
        query.cache();
        query.noCache();
        query.calcFoundRows();
//        select_expr [, select_expr ...]
//        [FROM table_references
        query.from(new QSurvey(""survey2""));
//        [WHERE where_condition]
        query.where(survey.id.isNotNull());
//        [GROUP BY {col_name | expr | position}",Mystery Guest
"@Test
    public void precedence() {
        // INTERVAL
        // BINARY, COLLATE
        // !
        // - (unary minus), ~ (unary bit inversion)
        int p0 = getPrecedence(Ops.NEGATE);
        // ^
        // *, /, DIV, %, MOD
        int p1 = getPrecedence(Ops.MULT, Ops.DIV, Ops.MOD);
        // -, +
        int p2 = getPrecedence(Ops.SUB, Ops.ADD);
        // <<, >>
        // &
        // |
        // = (comparison), <=>, >=, >, <=, <, <>, !=, IS, LIKE, REGEXP, IN
        int p3 = getPrecedence(Ops.EQ, Ops.GOE, Ops.GT, Ops.LT, Ops.NE, Ops.IS_NULL, Ops.IS_NOT_NULL, Ops.MATCHES, Ops.IN, Ops.LIKE, Ops.LIKE_ESCAPE);
        // BETWEEN, CASE, WHEN, THEN, ELSE
        int p4 = getPrecedence(Ops.BETWEEN, Ops.CASE, Ops.CASE_ELSE);
        // NOT
        int p5 = getPrecedence(Ops.NOT);
        // &&, AND
        int p6 = getPrecedence(Ops.AND);
        // XOR
        int p7 = getPrecedence(Ops.XOR, Ops.XNOR);
        // ||, OR
        int p8 = getPrecedence(Ops.OR);
        // = (assignment), :=

        assertTrue(p0 < p1);
        assertTrue(p1 < p2);
        assertTrue(p2 < p3);
        assertTrue(p3 < p4);
        assertTrue(p4 < p5);
        assertTrue(p5 < p6);
        assertTrue(p6 < p7);
        assertTrue(p7 < p8);
    }",No Smells
"@Test
    public void test() {
        SQLTemplates templates = MySQLTemplates.builder()
                .printSchema()
                .build();
        Configuration conf = new Configuration(templates);
        System.out.println(new SQLQuery(conf).from(survey1).toString());
    }",Mystery Guest
"@Test
    public void delete() {
        assertNotNull(queryFactory.delete(QSurvey.survey));
    }",No Smells
"@Test
    public void insert() {
        assertNotNull(queryFactory.insert(QSurvey.survey));
    }",No Smells
"@Test
    public void merge() {
        assertNotNull(queryFactory.merge(QSurvey.survey));
    }",No Smells
"@Test
    public void update() {
        assertNotNull(queryFactory.update(QSurvey.survey));
    }",No Smells
"@Test
    public void connectByNocyclePrior() {
        query.connectByNocyclePrior(survey.name.isNull());
        assertEquals(""from SURVEY survey connect by nocycle prior survey.NAME is null order by survey.NAME asc"",
                toString(query));
    }",No Smells
"@Test
    public void connectByPrior() {
        query.connectByPrior(survey.name.isNull());
        assertEquals(""from SURVEY survey connect by prior survey.NAME is null order by survey.NAME asc"",
                toString(query));
    }",No Smells
"@Test
    public void modifiers() {
        query.from(survey1).limit(5).offset(3);
        query.getMetadata().setProjection(survey1.id);
        assertEquals(""select * from (  "" +
                ""select a.*, rownum rn from (   "" +
                ""select survey1.ID from SURVEY survey1  ) "" +
                ""a) "" +
                ""where rn > 3 and rownum <= 5"", query.toString());
    }",No Smells
"@Test
    public void modifiers2() {
        query.from(survey1).limit(5).offset(3);
        query.getMetadata().setProjection(survey1.id);
        query.getMetadata().addFlag(new QueryFlag(QueryFlag.Position.AFTER_PROJECTION, "", count(*) over() ""));

        assertEquals(""select * from (  "" +
            ""select a.*, rownum rn from (   "" +
            ""select survey1.ID, count(*) over()  from SURVEY survey1  ) "" +
            ""a) "" +
            ""where rn > 3 and rownum <= 5"", query.toString());
    }",No Smells
"@Test
    public void precedence() {
        // +, - (as unary operators), PRIOR, CONNECT_BY_ROOT  identity, negation, location in hierarchy
        int p1 = getPrecedence(Ops.NEGATE);
        // *, / multiplication, division
        int p2 = getPrecedence(Ops.MULT, Ops.DIV);
        // +, - (as binary operators), || addition, subtraction, concatenation
        int p3 = getPrecedence(Ops.ADD, Ops.SUB, Ops.CONCAT);
        // =, !=, <, >, <=, >=, comparison
        int p4 = getPrecedence(Ops.EQ, Ops.NE, Ops.LT, Ops.GT, Ops.LOE, Ops.GOE);
        // IS [NOT] NULL, LIKE, [NOT] BETWEEN, [NOT] IN, EXISTS, IS OF type comparison
        int p5 = getPrecedence(Ops.IS_NULL, Ops.IS_NOT_NULL, Ops.LIKE, Ops.LIKE_ESCAPE, Ops.BETWEEN, Ops.IN, Ops.NOT_IN, Ops.EXISTS);
        // NOT exponentiation, logical negation
        int p6 = getPrecedence(Ops.NOT);
        // AND conjunction
        int p7 = getPrecedence(Ops.AND);
        // OR disjunction
        int p8 = getPrecedence(Ops.OR);

        assertTrue(p1 < p2);
        assertTrue(p2 < p3);
        assertTrue(p3 < p4);
        assertTrue(p4 < p5);
        assertTrue(p5 < p6);
        assertTrue(p6 < p7);
        assertTrue(p7 < p8);
    }",No Smells
"@Test
    public void delete() {
        assertNotNull(queryFactory.delete(QSurvey.survey));
    }",No Smells
"@Test
    public void from() {
        assertNotNull(queryFactory.from(QSurvey.survey));
    }",No Smells
"@Test
    public void forShare() {
        query.from(survey).forShare();
        assertEquals(""from SURVEY survey for share"", toString(query));
    }",No Smells
"@Test
    public void noFrom() {
        query.getMetadata().setProjection(Expressions.ONE);
        assertEquals(""select 1"", query.toString());
    }",No Smells
"@Test
    public void union() {
        NumberExpression<Integer> one = Expressions.ONE;
        NumberExpression<Integer> two = Expressions.TWO;
        NumberExpression<Integer> three = Expressions.THREE;
        Path<Integer> col1 = Expressions.path(Integer.class,""col1"");
        Union union = query.union(
                select(one.as(col1)),
                select(two),
                select(three));
        assertEquals(
                ""(select 1 as col1)\n"" +
                ""union\n"" +
                ""(select 2)\n"" +
                ""union\n"" +
                ""(select 3)"", union.toString());
    }",No Smells
"@Test
    public void alias_to_managed_type() {
        FactoryExpression<Employee> expr = Projections.bean(Employee.class, e.superiorId.as(""id""));
        Employee e = expr.newInstance(3);
        assertEquals(3, e.getId().intValue());
    }",No Smells
"@Test
    public void aggregate_uniqueResult() {
        int min = 30000, avg = 65000, max = 160000;
        // fetchOne
        assertEquals(min, query().from(employee).select(employee.salary.min()).fetchOne().intValue());
        assertEquals(avg, query().from(employee).select(employee.salary.avg()).fetchOne().intValue());
        assertEquals(max, query().from(employee).select(employee.salary.max()).fetchOne().intValue());
    }",Mystery Guest
"@Test
    public void all() {
        for (Expression<?> expr : survey.all()) {
            Path<?> path = (Path<?>) expr;
            assertEquals(survey, path.getMetadata().getParent());
        }",Mystery Guest
"@Test
    public void array_projection() {
        List<String[]> results = query().from(employee).select(
                new ArrayConstructorExpression<String>(String[].class, employee.firstname)).fetch();
        assertFalse(results.isEmpty());
        for (String[] result : results) {
            assertNotNull(result[0]);
        }",Mystery Guest
"@Test
    public void array_projection() {
        List<String[]> results = query().from(employee).select(
                new ArrayConstructorExpression<String>(String[].class, employee.firstname)).fetch();
        assertFalse(results.isEmpty());
        for (String[] result : results) {
            assertNotNull(result[0]);
        }",Eager Test + Mystery Guest
"@Test
    public void between() {
        // 11-13
        assertEquals(Arrays.asList(11, 12, 13),
                query().from(employee).where(employee.id.between(11, 13)).orderBy(employee.id.asc())
                       .select(employee.id).fetch());
    }",Mystery Guest
"@Test
    public void casts() throws SQLException {
        NumberExpression<?> num = employee.id;
        List<Expression<?>> exprs = new ArrayList<>();

        add(exprs, num.byteValue(), MYSQL);
        add(exprs, num.doubleValue());
        add(exprs, num.floatValue());
        add(exprs, num.intValue());
        add(exprs, num.longValue(), MYSQL);
        add(exprs, num.shortValue(), MYSQL);
        add(exprs, num.stringValue(), DERBY);

        for (Expression<?> expr : exprs) {
            for (Object o : query().from(employee).select(expr).fetch()) {
                assertEquals(expr.getType(), o.getClass());
            }",Eager Test + Mystery Guest
"@Test
    public void coalesce() {
        Coalesce<String> c = new Coalesce<String>(employee.firstname, employee.lastname).add(""xxx"");
        assertEquals(Collections.emptyList(),
                query().from(employee).where(c.getValue().eq(""xxx"")).select(employee.id).fetch());
    }",Mystery Guest
"@Test
    public void count2() {
        assertEquals(10, query().from(employee).select(employee.count()).fetchFirst().intValue());
    }",Mystery Guest
"@Test
    public void count_distinct2() {
        query().from(employee).select(employee.countDistinct()).fetchFirst();
    }",Mystery Guest
"@Test
    public void count_distinct_with_pK() {
        assertEquals(10, query().from(employee).distinct().fetchCount());
    }",Mystery Guest
"@Test
    public void dateTime() {
        SQLQuery<?> query = query().from(employee).orderBy(employee.id.asc());
        assertEquals(Integer.valueOf(10),     query.select(employee.datefield.dayOfMonth()).fetchFirst());
        assertEquals(Integer.valueOf(2),      query.select(employee.datefield.month()).fetchFirst());
        assertEquals(Integer.valueOf(2000),   query.select(employee.datefield.year()).fetchFirst());
        assertEquals(Integer.valueOf(200002), query.select(employee.datefield.yearMonth()).fetchFirst());
    }",Mystery Guest
"@Test
    public void select_concat() throws SQLException {
        for (Tuple row : query().from(survey).select(survey.name, survey.name.append(""Hello World"")).fetch()) {
            assertEquals(
                    row.get(survey.name) + ""Hello World"",
                    row.get(survey.name.append(""Hello World"")));
        }",Mystery Guest
"@Test
    public void factoryExpression_in_groupBy() {
        Expression<Employee> empBean = Projections.bean(Employee.class, employee.id, employee.superiorId);
        assertTrue(query().from(employee).groupBy(empBean).select(empBean).fetchFirst() != null);
    }",Mystery Guest
"@Test
    public void aggregate_list() {
        int min = 30000, avg = 65000, max = 160000;
        // fetch
        assertEquals(min, query().from(employee).select(employee.salary.min()).fetch().get(0).intValue());
        assertEquals(avg, query().from(employee).select(employee.salary.avg()).fetch().get(0).intValue());
        assertEquals(max, query().from(employee).select(employee.salary.max()).fetch().get(0).intValue());
    }",Mystery Guest
"@Test
    public void in_empty() {
        assertEquals(0, query().from(employee).where(employee.id.in(Collections.emptyList())).fetchCount());
    }",Mystery Guest
"@Test
    public void inner_join() throws SQLException {
        assertEquals(8, query().from(employee).innerJoin(employee2)
            .on(employee.superiorIdKey.on(employee2))
            .select(employee.id, employee2.id).fetch().size());
    }",Mystery Guest
"@Test
    public void inner_join_2Conditions() {
        assertEquals(8, query().from(employee).innerJoin(employee2)
            .on(employee.superiorIdKey.on(employee2))
            .on(employee2.firstname.isNotNull())
            .select(employee.id, employee2.id).fetch().size());
    }",Mystery Guest
"@Test
    public void compact_join() {
        // verbose
        assertEquals(8, query().from(employee)
            .innerJoin(employee2)
            .on(employee.superiorId.eq(employee2.id))
            .select(employee.id, employee2.id).fetch().size());

        // compact
        assertEquals(8, query().from(employee)
            .innerJoin(employee.superiorIdKey, employee2)
            .select(employee.id, employee2.id).fetch().size());

    }",Eager Test + Mystery Guest
"@Test
    public void joins() throws SQLException {
        for (Tuple row : query().from(employee).innerJoin(employee2)
                .on(employee.superiorId.eq(employee2.superiorId))
                .where(employee2.id.eq(10))
                .select(employee.id, employee2.id).fetch()) {
            assertNotNull(row.get(employee.id));
            assertNotNull(row.get(employee2.id));
        }",Eager Test + Mystery Guest
"@Test
    public void like_ignore_case() {
        assertEquals(3, query().from(employee).where(employee.firstname.likeIgnoreCase(""%m%"")).fetchCount());
    }",Mystery Guest
"@Test
    public void limit_and_offset() throws SQLException {
        assertEquals(Arrays.asList(20, 13, 10, 2),
            query().from(employee)
                   .orderBy(employee.firstname.asc())
                   .limit(4).offset(3)
                   .select(employee.id).fetch());
    }",Mystery Guest
"@Test
    public void listResults() {
        QueryResults<Integer> results = query().from(employee)
                .limit(10).offset(1).orderBy(employee.id.asc())
                .select(employee.id).fetchResults();
        assertEquals(10, results.getTotal());
    }",Mystery Guest
"@Test
    public void listResults2() {
        QueryResults<Integer> results = query().from(employee)
                .limit(2).offset(10).orderBy(employee.id.asc())
                .select(employee.id).fetchResults();
        assertEquals(10, results.getTotal());
    }",Mystery Guest
"@Test
    public void listResults_factoryExpression() {
        QueryResults<Employee> results = query().from(employee)
                .limit(10).offset(1).orderBy(employee.id.asc())
                .select(employee).fetchResults();
        assertEquals(10, results.getTotal());
    }",Mystery Guest
"@Test
    public void literals_literals() {
        if (configuration.getUseLiterals()) {
            literals();
        }",Mystery Guest
"@Test
    public void random() {
        firstResult(MathExpressions.random());
    }",Mystery Guest
"@Test
    public void nested_tuple_projection() {
        Concatenation concat = new Concatenation(employee.firstname, employee.lastname);
        List<Tuple> tuples = query().from(employee)
                .select(employee.firstname, employee.lastname, concat).fetch();
        assertFalse(tuples.isEmpty());
        for (Tuple tuple : tuples) {
            String firstName = tuple.get(employee.firstname);
            String lastName = tuple.get(employee.lastname);
            assertEquals(firstName + lastName, tuple.get(concat));
        }",Eager Test + Mystery Guest
"@Test
    public void num_cast() {
        query().from(employee).select(employee.id.castToNum(Long.class)).fetch();
        query().from(employee).select(employee.id.castToNum(Float.class)).fetch();
        query().from(employee).select(employee.id.castToNum(Double.class)).fetch();
    }",Mystery Guest
"@Test
    public void number_as_boolean_Null() {
        QNumberTest numberTest = QNumberTest.numberTest;
        delete(numberTest).execute();
        insert(numberTest).setNull(numberTest.col1Boolean).execute();
        insert(numberTest).setNull(numberTest.col1Number).execute();
        assertEquals(2, query().from(numberTest).select(numberTest.col1Boolean).fetch().size());
        assertEquals(2, query().from(numberTest).select(numberTest.col1Number).fetch().size());
    }",Mystery Guest
"@Test
    public void offset_only() {
        assertEquals(Arrays.asList(20, 13, 10, 2, 1, 11, 12), query().from(employee)
            .orderBy(employee.firstname.asc())
            .offset(3)
            .select(employee.id).fetch());
    }",Mystery Guest
"@Test
    public void order_nullsLast() {
        assertEquals(Collections.singletonList(""Hello World""), query().from(survey)
            .orderBy(survey.name.asc().nullsLast())
            .select(survey.name).fetch());
    }",Mystery Guest
"@Test
    public void statementOptions() {
        StatementOptions options = StatementOptions.builder().setFetchSize(15).setMaxRows(150).build();
        SQLQuery<?> query = query().from(employee).orderBy(employee.id.asc());
        query.setStatementOptions(options);
        query.addListener(new SQLBaseListener() {
            public void preExecute(SQLListenerContext context) {
                try {
                    assertEquals(15, context.getPreparedStatement().getFetchSize());
                    assertEquals(150, context.getPreparedStatement().getMaxRows());
                }",Mystery Guest
"@Test
    public void array_projection() {
        List<String[]> results = query().from(employee).select(
                new ArrayConstructorExpression<String>(String[].class, employee.firstname)).fetch();
        assertFalse(results.isEmpty());
        for (String[] result : results) {
            assertNotNull(result[0]);
        }",Eager Test + Mystery Guest
"@Test
    public void constructor_projection2() {
        List<SimpleProjection> projections = query().from(employee).select(
                Projections.constructor(SimpleProjection.class,
                        employee.firstname, employee.lastname)).fetch();
        assertFalse(projections.isEmpty());
        for (SimpleProjection projection : projections) {
            assertNotNull(projection);
        }",Eager Test + Mystery Guest
"@Test
    public void query_with_constant() throws Exception {
        for (Tuple row : query().from(survey)
                .where(survey.id.eq(1))
                .select(survey.id, survey.name).fetch()) {
            assertNotNull(row.get(survey.id));
            assertNotNull(row.get(survey.name));
        }",Eager Test + Mystery Guest
"@Test
    public void relationalPath_eq() {
        assertEquals(10, query().from(employee, employee2)
                .where(employee.eq(employee2))
                .select(employee.id, employee2.id).fetch().size());
    }",Mystery Guest
"@Test
    public void relationalPath_eq2() {
        assertEquals(1, query().from(survey, survey2)
                .where(survey.eq(survey2))
                .select(survey.id, survey2.id).fetch().size());
    }",Mystery Guest
"@Test
    public void select_for_share() {
        if (configuration.getTemplates().isForShareSupported()) {
            assertEquals(1, query().from(survey).forShare().where(survey.id.isNotNull()).select(survey.id).fetch().size());
        }",Mystery Guest
"@Test
    public void serialization2() throws Exception {
        List<Tuple> rows = query().from(survey).select(survey.id, survey.name).fetch();
        serialize(rows);
    }",Mystery Guest
"@Test
    public void serialization2() throws Exception {
        List<Tuple> rows = query().from(survey).select(survey.id, survey.name).fetch();
        serialize(rows);
    }",Mystery Guest
"@Test
    public void statementOptions() {
        StatementOptions options = StatementOptions.builder().setFetchSize(15).setMaxRows(150).build();
        SQLQuery<?> query = query().from(employee).orderBy(employee.id.asc());
        query.setStatementOptions(options);
        query.addListener(new SQLBaseListener() {
            public void preExecute(SQLListenerContext context) {
                try {
                    assertEquals(15, context.getPreparedStatement().getFetchSize());
                    assertEquals(150, context.getPreparedStatement().getMaxRows());
                }",Mystery Guest
"@Test
    public void array_projection() {
        List<String[]> results = query().from(employee).select(
                new ArrayConstructorExpression<String>(String[].class, employee.firstname)).fetch();
        assertFalse(results.isEmpty());
        for (String[] result : results) {
            assertNotNull(result[0]);
        }",Mystery Guest
"@Test
    public void stringFunctions2() throws SQLException {
        for (BooleanExpression where : Arrays.asList(
                employee.firstname.startsWith(""a""),
                employee.firstname.startsWithIgnoreCase(""a""),
                employee.firstname.endsWith(""a""),
                employee.firstname.endsWithIgnoreCase(""a""))) {
            query().from(employee).where(where).select(employee.firstname).fetch();
        }",Mystery Guest
"@Test
    public void syntax_for_employee() throws SQLException {
        assertEquals(3, query().from(employee).groupBy(employee.superiorId)
            .orderBy(employee.superiorId.asc())
            .select(employee.salary.avg(), employee.id.max()).fetch().size());

        assertEquals(2, query().from(employee).groupBy(employee.superiorId)
            .having(employee.id.max().gt(5))
            .orderBy(employee.superiorId.asc())
            .select(employee.salary.avg(), employee.id.max()).fetch().size());

        assertEquals(2, query().from(employee).groupBy(employee.superiorId)
            .having(employee.superiorId.isNotNull())
            .orderBy(employee.superiorId.asc())
            .select(employee.salary.avg(), employee.id.max()).fetch().size());
    }",Mystery Guest
"@Test
    public void nested_tuple_projection() {
        Concatenation concat = new Concatenation(employee.firstname, employee.lastname);
        List<Tuple> tuples = query().from(employee)
                .select(employee.firstname, employee.lastname, concat).fetch();
        assertFalse(tuples.isEmpty());
        for (Tuple tuple : tuples) {
            String firstName = tuple.get(employee.firstname);
            String lastName = tuple.get(employee.lastname);
            assertEquals(firstName + lastName, tuple.get(concat));
        }",Eager Test + Mystery Guest
"@Test
    public void unique_wildcard() {
        // unique wildcard
        Tuple row = query().from(survey).limit(1).select(survey.all()).fetchFirst();
        assertNotNull(row);
        assertEquals(3, row.size());
        assertNotNull(row.get(0, Object.class));
        assertNotNull(row.get(0, Object.class) + "" is not null"", row.get(1, Object.class));
    }",Eager Test + Mystery Guest
"@Test
    public void where_exists() throws SQLException {
        SQLQuery<Integer> sq1 = query().from(employee).select(employee.id.max());
        assertEquals(10, query().from(employee).where(sq1.exists()).fetchCount());
    }",Mystery Guest
"@Test
    public void wildcard_all2() {
        assertEquals(10, query().from(new RelationalPathBase<Object>(Object.class, ""employee"", ""public"", ""EMPLOYEE""))
                .select(Wildcard.all).fetch().size());
    }",Mystery Guest
"@Test
    public void windowFunctions_manual_paging() {
        Expression<Long> rowNumber = SQLExpressions.rowNumber().over().orderBy(employee.lastname.asc()).as(""rn"");
        Expression<Object[]> all = Wildcard.all;

        // simple
        System.out.println(""#1"");
        for (Tuple row : query().from(employee).select(employee.firstname, employee.lastname, rowNumber).fetch()) {
            System.out.println(row);
        }",Eager Test + Mystery Guest
"@Test
    public void test() {
        // insert into SHAPES values (1, GeomFromText('POINT(2 2)'))
        SQLTemplates templates = new MySQLSpatialTemplates();
        //assertEquals(""GeomFromText('POINT(2 2)')"", templates.asLiteral(Wkt.fromWkt(""Point(2 2)"")));
    }",No Smells
"@Test
    public void lineString_instances() {
        List<Geometry> results = withLineStrings().select(shapes.geometry).fetch();
        assertFalse(results.isEmpty());
        for (Geometry row : results) {
            assertNotNull(row);
            assertTrue(row instanceof LineString);
        }",Eager Test + Mystery Guest
"@Test
    public void multiLineString_instances() {
        List<Geometry> results = withMultiLineStrings().select(shapes.geometry).fetch();
        assertFalse(results.isEmpty());
        for (Geometry row : results) {
            assertNotNull(row);
            assertTrue(row instanceof MultiLineString);
        }",Eager Test + Mystery Guest
"@Test
    public void multiPoint_methods() {
        MultiPointPath<MultiPoint> multipoint = shapes.geometry.asMultiPoint();

        List<Expression<?>> expressions = new ArrayList<>();
        add(expressions, multipoint.asBinary(), H2);
        add(expressions, multipoint.asText());
        add(expressions, multipoint.boundary(), H2, MYSQL);
        add(expressions, multipoint.convexHull(), H2, MYSQL);
        add(expressions, multipoint.dimension());
        add(expressions, multipoint.envelope(), H2);
        add(expressions, multipoint.geometryType(), H2);
        add(expressions, multipoint.isEmpty());
        add(expressions, multipoint.isSimple());
        // multipoint specific
        add(expressions, multipoint.numGeometries(), H2);
        add(expressions, multipoint.geometryN(1), H2);

        for (Expression<?> expr : expressions) {
            boolean logged = false;
            for (Object row : withMultipoints().select(expr).fetch()) {
                if (row == null && !logged) {
                    System.err.println(expr.toString());
                    logged = true;
                }",Eager Test + Mystery Guest
"@Test
    public void multiPolygon_instances() {
        List<Geometry> results = withMultiPolygons().select(shapes.geometry).fetch();
        assertFalse(results.isEmpty());
        for (Geometry row : results) {
            assertNotNull(row);
            assertTrue(row instanceof MultiPolygon);
        }",Eager Test + Mystery Guest
"@Test
    public void test() {
        // insert into SHAPES values (1, 'Point(2 2)')
        SQLTemplates templates = new TeradataSpatialTemplates();
        //assertEquals(""'POINT(2 2)'"", templates.asLiteral(Wkt.fromWkt(""Point(2 2)"")));
    }",No Smells
"@Test
    public void params() {
        Param<String> name = new Param<String>(String.class, ""name"");
        query.from(survey).where(survey.name.eq(name), survey.name2.eq(""A"")).select(survey.id);
        query.set(name, ""Bob"");
        SQLBindings bindings = query.getSQL();
        assertEquals(""select SURVEY.ID\nfrom SURVEY SURVEY\nwhere SURVEY.NAME = ? and SURVEY.NAME2 = ?"", bindings.getSQL());
        assertEquals(Arrays.asList(""Bob"", ""A""), bindings.getNullFriendlyBindings());
    }",Mystery Guest
"@Test
    public void iterate() {
        try (CloseableIterator<Employee> it = query.iterate()) {
            while (it.hasNext()) {
                it.next();
            }",Eager Test + Mystery Guest
"@Test
    public void precedence() {
        // ||
        // *    /    %
        int p1 = getPrecedence(Ops.MULT, Ops.DIV, Ops.MOD);
        // +    -
        int p2 = getPrecedence(Ops.ADD, Ops.SUB);
        // <<   >>   &    |
        // <    <=   >    >=
        int p3 = getPrecedence(Ops.LT, Ops.GT, Ops.LOE, Ops.GOE);
        // =    ==   !=   <>   IS   IS NOT   IN   LIKE   GLOB   MATCH   REGEXP
        int p4 = getPrecedence(Ops.EQ, Ops.EQ_IGNORE_CASE, Ops.IS_NULL, Ops.IS_NOT_NULL,
                Ops.IN, Ops.LIKE, Ops.LIKE_ESCAPE, Ops.MATCHES);
        // AND
        int p5 = getPrecedence(Ops.AND);
        //  OR
        int p6 = getPrecedence(Ops.OR);

        assertTrue(p1 < p2);
        assertTrue(p2 < p3);
        assertTrue(p3 < p4);
        assertTrue(p4 < p5);
        assertTrue(p5 < p6);
    }",No Smells
"@Test
    public void notifyQuery_detailedListener_contexSetting() {
        SQLListenerContext sqlListenerContext = new SQLListenerContextImpl(new DefaultQueryMetadata());
        SQLDetailedListener listenerParent = new AssertingDetailedListener(""keyParent"", ""valueParent"");
        SQLDetailedListener listener1 = new AssertingDetailedListener(""key1"", ""value1"");
        SQLDetailedListener listener2 = new AssertingDetailedListener(""key1"", ""value1"");

        SQLListeners listeners = new SQLListeners(listenerParent);
        listeners.add(listener1);
        listeners.add(listener2);

        listeners.start(sqlListenerContext);
        listeners.preRender(sqlListenerContext);
        listeners.rendered(sqlListenerContext);
        listeners.prePrepare(sqlListenerContext);
        listeners.prepared(sqlListenerContext);
        listeners.preExecute(sqlListenerContext);
        listeners.preExecute(sqlListenerContext);
    }",No Smells
"@Test
    public void notifyQuery_parent() {
        SQLListener listener = createMock(SQLListener.class);
        SQLListeners listeners = new SQLListeners(listener);

        QueryMetadata md = new DefaultQueryMetadata();
        listener.notifyQuery(md);
        replay(listener);

        listeners.notifyQuery(md);
        verify(listener);
    }",No Smells
"@Test
    public void delete() {
        assertNotNull(queryFactory.delete(QSurvey.survey));
    }",No Smells
"@Test
    public void merge() {
        assertNotNull(queryFactory.merge(QSurvey.survey));
    }",No Smells
"@Test
    public void query() {
        assertNotNull(queryFactory.query());
    }",No Smells
"@Test
    public void boolean_() {
        QSurvey s = new QSurvey(""s"");
        BooleanBuilder bb1 = new BooleanBuilder();
        bb1.and(s.name.eq(s.name));

        BooleanBuilder bb2 = new BooleanBuilder();
        bb2.or(s.name.eq(s.name));
        bb2.or(s.name.eq(s.name));

        String str = new SQLSerializer(Configuration.DEFAULT).handle(bb1.and(bb2)).toString();
        assertEquals(""s.NAME = s.NAME and (s.NAME = s.NAME or s.NAME = s.NAME)"", str);
    }",No Smells
"@Test
    public void complex_subQuery() {
        // create sub queries
        List<SubQueryExpression<Tuple>> sq = new ArrayList<SubQueryExpression<Tuple>>();
        String[] strs = new String[]{""a"",""b"",""c""}",Eager Test
"@Test
    public void list_in_query() {
        Expression<?> expr = Expressions.list(survey.id, survey.name).in(select(survey.id, survey.name).from(survey));

        String str = new SQLSerializer(Configuration.DEFAULT).handle(expr).toString();
        assertEquals(""(SURVEY.ID, SURVEY.NAME) in (select SURVEY.ID, SURVEY.NAME\nfrom SURVEY SURVEY)"", str);
    }",No Smells
"@Test
    public void withRecursive2() {
        /*with sub (id, firstname, superior_id) as (
            select id, firstname, superior_id from employee where firstname like 'Mike'
            union all
            select employee.id, employee.firstname, employee.superior_id from sub, employee
            where employee.superior_id = sub.id)
        select * from sub;*/

        QEmployee e = QEmployee.employee;
        PathBuilder<Tuple> sub = new PathBuilder<Tuple>(Tuple.class, ""sub"");
        SQLQuery<?> query = new SQLQuery<Void>(SQLTemplates.DEFAULT);
        query.withRecursive(sub, sub.get(e.id), sub.get(e.firstname), sub.get(e.superiorId)).as(
                unionAll(
                        select(e.id, e.firstname, e.superiorId).from(e).where(e.firstname.eq(""Mike"")),
                        select(e.id, e.firstname, e.superiorId).from(e, sub).where(e.superiorId.eq(sub.get(e.id)))))
             .from(sub);

        QueryMetadata md = query.getMetadata();
        md.setProjection(Wildcard.all);
        SQLSerializer serializer = new SQLSerializer(Configuration.DEFAULT);
        serializer.serialize(md, false);
        assertEquals(""with recursive sub (ID, FIRSTNAME, SUPERIOR_ID) as ((select EMPLOYEE.ID, EMPLOYEE.FIRSTNAME, EMPLOYEE.SUPERIOR_ID\n"" +
                ""from EMPLOYEE EMPLOYEE\n"" +
                ""where EMPLOYEE.FIRSTNAME = ?)\n"" +
                ""union all\n"" +
                ""(select EMPLOYEE.ID, EMPLOYEE.FIRSTNAME, EMPLOYEE.SUPERIOR_ID\n"" +
                ""from EMPLOYEE EMPLOYEE, sub\n"" +
                ""where EMPLOYEE.SUPERIOR_ID = sub.ID))\n"" +
                ""select *\n"" +
                ""from sub"", serializer.toString());

    }",No Smells
"@Test
    public void limit() {
        query.from(survey1).limit(5);
        query.getMetadata().setProjection(survey1.id);
        assertEquals(""select top (?) survey1.ID from SURVEY survey1"", query.toString());
    }",No Smells
"@Test
    public void noFrom() {
        query.getMetadata().setProjection(Expressions.ONE);
        assertEquals(""select 1"", query.toString());
    }",No Smells
"@Test
    public void delete_limit() {
        SQLDeleteClause clause = new SQLDeleteClause(null, createTemplates(), survey1);
        clause.where(survey1.name.eq(""Bob""));
        clause.limit(5);
        assertEquals(""delete top 5 from SURVEY\n"" +
                ""where SURVEY.NAME = ?"", clause.toString());
    }",No Smells
"@Test
    public void limitOffset() {
        query.from(survey1).limit(5).offset(5);
        query.getMetadata().setProjection(survey1.id);
        assertEquals(""select survey1.ID from SURVEY survey1 "" +
                ""order by 1 asc "" +
                ""offset ? rows fetch next ? rows only"", query.toString());
    }",No Smells
"@Test
    public void nextVal() {
        Operation<String> nextval = ExpressionUtils.operation(String.class, SQLOps.NEXTVAL, ConstantImpl.create(""myseq""));
        assertSerialized(nextval, ""next value for myseq"");
    }",No Smells
"@Test
    public void update_limit() {
        SQLUpdateClause clause = new SQLUpdateClause(null, createTemplates(), survey1);
        clause.set(survey1.name, ""Bob"");
        clause.limit(5);
        assertEquals(""update top 5 SURVEY\n"" +
                ""set NAME = ?"", clause.toString());
    }",No Smells
"@Test
    public void numeric_operations() {
        NumberPath<Integer> intPath = Expressions.numberPath(Integer.class, ""intPath"");
        NumberPath<Integer> intPath2 = Expressions.numberPath(Integer.class, ""intPath2"");
        SQLSerializer serializer = new SQLSerializer(new Configuration(SQLTemplates.DEFAULT));
        serializer.handle(intPath.subtract(intPath2.add(2)));
        assertEquals(""intPath - (intPath2 + ?)"", serializer.toString());
    }",No Smells
"@Test
    public void test() {
        Template template = TemplateFactory.DEFAULT.create(""fetch first {0s}",No Smells
"@Test
    public void subQuery_alias() {
        query().from(query().from(employee).select(employee.all()).as(employee2)).select(employee2.all()).fetch();
    }",Mystery Guest
"@Test
    public void subQuery_leftJoin() {
        SubQueryExpression<Integer> sq = query().from(employee2).select(employee2.id);
        QEmployee sqEmp = new QEmployee(""sq"");
        query().from(employee).leftJoin(sq, sqEmp).on(sqEmp.id.eq(employee.id)).select(employee.id).fetch();

    }",Mystery Guest
"@Test
    public void toDate() {
        StringExpression str = Expressions.stringPath(""str"");
        assertEquals(""to_date(str,'DD-MON-YYYY')"", to_date(str, ""DD-MON-YYYY"").toString());
    }",No Smells
"@Test
    public void lang() {
        Locale l = new Locale(""en"");
        assertEquals(l, LocaleType.toLocale(l.toString()));
    }",No Smells
"@Test
    public void union_single_column_projections_iterate() throws IOException {
        SubQueryExpression<Integer> sq1 = query().from(employee).select(employee.id.max());
        SubQueryExpression<Integer> sq2 = query().from(employee).select(employee.id.min());

        try (CloseableIterator<Integer> iterator = query().union(sq1, sq2).iterate()) {
            assertTrue(iterator.hasNext());
            assertTrue(iterator.next() != null);
            assertTrue(iterator.next() != null);
            assertFalse(iterator.hasNext());
        }",Mystery Guest
"@Test
    public void setNull2() {
        long count = query().from(survey).fetchCount();
        assertEquals(count, update(survey).set(survey.name, (String) null).execute());
    }",Mystery Guest
"@Test
    public void update() throws SQLException {
        // original state
        long count = query().from(survey).fetchCount();
        assertEquals(0, query().from(survey).where(survey.name.eq(""S"")).fetchCount());

        // update call with 0 update count
        assertEquals(0, update(survey).where(survey.name.eq(""XXX"")).set(survey.name, ""S"").execute());
        assertEquals(0, query().from(survey).where(survey.name.eq(""S"")).fetchCount());

        // update call with full update count
        assertEquals(count, update(survey).set(survey.name, ""S"").execute());
        assertEquals(count, query().from(survey).where(survey.name.eq(""S"")).fetchCount());
    }",Mystery Guest
"@Test
    public void update2() throws SQLException {
        List<Path<?>> paths = Collections.<Path<?>>singletonList(survey.name);
        List<?> values = Collections.singletonList(""S"");

        // original state
        long count = query().from(survey).fetchCount();
        assertEquals(0, query().from(survey).where(survey.name.eq(""S"")).fetchCount());

        // update call with 0 update count
        assertEquals(0, update(survey).where(survey.name.eq(""XXX"")).set(paths, values).execute());
        assertEquals(0, query().from(survey).where(survey.name.eq(""S"")).fetchCount());

        // update call with full update count
        assertEquals(count, update(survey).set(paths, values).execute());
        assertEquals(count, query().from(survey).where(survey.name.eq(""S"")).fetchCount());

    }",Mystery Guest
"@Test
    public void update_with_subQuery_exists() {
        QSurvey survey1 = new QSurvey(""s1"");
        QEmployee employee = new QEmployee(""e"");
        SQLUpdateClause update = update(survey1);
        update.set(survey1.name, ""AA"");
        update.where(selectOne().from(employee).where(survey1.id.eq(employee.id)).exists());
        assertEquals(1, update.execute());
    }",Mystery Guest
"@Test
    public void update_with_subQuery_exists2() {
        QSurvey survey1 = new QSurvey(""s1"");
        QEmployee employee = new QEmployee(""e"");
        SQLUpdateClause update = update(survey1);
        update.set(survey1.name, ""AA"");
        update.where(selectOne().from(employee).where(survey1.name.eq(employee.lastname)).exists());
        assertEquals(0, update.execute());
    }",Mystery Guest
"@Test
    public void update_with_subQuery_exists_Params() {
        QSurvey survey1 = new QSurvey(""s1"");
        QEmployee employee = new QEmployee(""e"");

        Param<Integer> param = new Param<Integer>(Integer.class, ""param"");
        SQLQuery<?> sq = query().from(employee).where(employee.id.eq(param));
        sq.set(param, -12478923);

        SQLUpdateClause update = update(survey1);
        update.set(survey1.name, ""AA"");
        update.where(sq.exists());
        assertEquals(0, update.execute());
    }",Mystery Guest
"@Test
    public void update_with_subQuery_notExists() {
        QSurvey survey1 = new QSurvey(""s1"");
        QEmployee employee = new QEmployee(""e"");
        SQLUpdateClause update = update(survey1);
        update.set(survey1.name, ""AA"");
        update.where(query().from(employee).where(survey1.id.eq(employee.id)).notExists());
        assertEquals(0, update.execute());
    }",Mystery Guest
"@Test
  public void testDefault() {
    RescorerProvider noop = new NullProvider1();
    assertNull(noop.getMostActiveUsersRescorer(null));
    assertNull(noop.getMostPopularItemsRescorer(null));
    assertNull(noop.getMostSimilarItemsRescorer(null));
    assertNull(noop.getRecommendRescorer(null, null));
    assertNull(noop.getRecommendToAnonymousRescorer(null, null));
  }",No Smells
"@Test
  public void testConcurrent() throws Exception {
    FeatureVectorsPartition fv = new FeatureVectorsPartition();
    AtomicInteger counter = new AtomicInteger();
    int numWorkers = 16;
    int numIterations = 10000;
    ExecUtils.doInParallel(numWorkers, i -> {
      for (int j = 0; j < numIterations; j++) {
        int c = counter.getAndIncrement();
        fv.setVector(Integer.toString(c), new float[] { c }",Eager Test
"@Test
  public void testToString() {
    FeatureVectors vectors = new FeatureVectorsPartition();
    vectors.setVector(""A"", new float[]{1.0f, 3.0f, 6.0f}",No Smells
"@Test
  public void testMultiMostSimilarItemsRescorer() {
    RescorerProvider multi = MultiRescorerProvider.of(
        new SimpleModRescorerProvider(2), new SimpleModRescorerProvider(3));
    Rescorer provider = multi.getMostSimilarItemsRescorer(null);
    assertNotNull(provider);
    assertInstanceOf(provider, MultiRescorer.class);
    assertIsFiltered(provider, ""ABC"");
    assertIsFiltered(provider, ""ABCDE"");
    assertNotFiltered(provider, ""ABCDEFABCDEF"");
  }",No Smells
"@Test
  public void testOf() {
    MultiRescorer multi = (MultiRescorer) MultiRescorer.of(new SimpleModRescorer(1), new SimpleModRescorer(2));
    assertEquals(2, multi.getRescorers().length);
    MultiRescorer multi2 = (MultiRescorer) MultiRescorer.of(multi, new SimpleModRescorer(3));
    assertEquals(3, multi2.getRescorers().length);
  }",No Smells
"@Test
  public void testToString() {
    PartitionedFeatureVectors partitioned = new PartitionedFeatureVectors(2, getExecutor());
    partitioned.setVector(""A"", new float[] { 1.0f, 3.0f, 6.0f }",No Smells
"@Test
  public void testVTV() {
    PartitionedFeatureVectors fv = new PartitionedFeatureVectors(NUM_PARTITIONS,  getExecutor());
    fv.setVector(""foo"", new float[] { 1.0f, 2.0f, 4.0f }",No Smells
"@Test
  public void testDecay() {
    Rating rating = new Rating(1, 2, 3.0);
    long timestamp = 10_000_000L;

    Rating noDecay = ALSUpdate.decayRating(rating, timestamp, timestamp, 0.5);
    assertEquals(1, noDecay.user());
    assertEquals(2, noDecay.product());
    assertEquals(3.0, noDecay.rating());

    Rating dayDecay = ALSUpdate.decayRating(rating, timestamp, timestamp + 86_400_000L, 0.5);
    assertEquals(1, dayDecay.user());
    assertEquals(2, dayDecay.product());
    assertEquals(1.5, dayDecay.rating());
  }",No Smells
"@Test
  public void testDaviesBouldinIndexForClustering() {
    List<ClusterInfo> clusters = getClusters();
    DaviesBouldinIndex daviesBouldinIndex = new DaviesBouldinIndex(clusters);
    double eval = daviesBouldinIndex.evaluate(getRddOfVectors());
    log.info(""Davies Bouldin Index for {}",No Smells
"@Test
  public void testKMeans() throws Exception {
    Path tempDir = getTempDir();
    Path dataDir = tempDir.resolve(""data"");
    Path modelDir = tempDir.resolve(""model"");

    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", KMeansUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", dataDir);
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", modelDir);
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", GEN_INTERVAL_SEC);
    overlayConfig.put(""oryx.kmeans.hyperparams.k"", ""[2,100]"");
    overlayConfig.put(""oryx.kmeans.iterations"", 20);
    overlayConfig.put(""oryx.input-schema.num-features"", NUM_FEATURES);
    overlayConfig.put(""oryx.input-schema.categorical-features"", ""[]"");
    overlayConfig.put(""oryx.ml.eval.candidates"", 3);
    overlayConfig.put(""oryx.ml.eval.parallelism"", 2);
    overlayConfig.put(""oryx.kmeans.evaluation-strategy"", EVALUATION_STRATEGY);

    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    startServerProduceConsumeTopics(
        config,
        new RandomKMeansDataGenerator(NUM_FEATURES),
        DATA_TO_WRITE,
        WRITE_INTERVAL_MSEC);

    List<Path> modelInstanceDirs = IOUtils.listFiles(modelDir, ""*"");

    checkIntervals(modelInstanceDirs.size(), DATA_TO_WRITE, WRITE_INTERVAL_MSEC, GEN_INTERVAL_SEC);

    Path latestModelDir = modelInstanceDirs.get(modelInstanceDirs.size() - 1);
    Path modelFile = latestModelDir.resolve(MLUpdate.MODEL_FILE_NAME);
    assertTrue(""No such model file: "" + modelFile, Files.exists(modelFile));

    PMML pmml = PMMLUtils.read(modelFile);
    Model rootModel = pmml.getModels().get(0);
    ClusteringModel clusteringModel = (ClusteringModel) rootModel;

    // Should have picked highest k
    assertEquals(100, clusteringModel.getNumberOfClusters().intValue());
  }",No Smells
"@Test
  public void testRDF() throws Exception {
    Path tempDir = getTempDir();
    Path dataDir = tempDir.resolve(""data"");
    Path modelDir = tempDir.resolve(""model"");

    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", RDFUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", dataDir);
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", modelDir);
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", GEN_INTERVAL_SEC);
    overlayConfig.put(""oryx.rdf.num-trees"", 10);
    // Low values like 1 are deliberately bad, won't work
    overlayConfig.put(""oryx.rdf.hyperparams.max-depth"", ""[1,"" + MAX_DEPTH + ""]"");
    overlayConfig.put(""oryx.rdf.hyperparams.max-split-candidates"", MAX_SPLIT_CANDIDATES);
    overlayConfig.put(""oryx.input-schema.num-features"", 5);
    overlayConfig.put(""oryx.input-schema.categorical-features"", ""[\""4\""]"");
    overlayConfig.put(""oryx.input-schema.id-features"", ""[\""0\""]"");
    overlayConfig.put(""oryx.input-schema.target-feature"", ""\""4\"""");
    overlayConfig.put(""oryx.ml.eval.candidates"", 2);
    overlayConfig.put(""oryx.ml.eval.parallelism"", 2);
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    startServerProduceConsumeTopics(
        config,
        new RandomCategoricalRDFDataGenerator(3),
        DATA_TO_WRITE,
        WRITE_INTERVAL_MSEC);

    List<Path> modelInstanceDirs = IOUtils.listFiles(modelDir, ""*"");

    checkIntervals(modelInstanceDirs.size(), DATA_TO_WRITE, WRITE_INTERVAL_MSEC, GEN_INTERVAL_SEC);

    Path latestModelDir = modelInstanceDirs.get(modelInstanceDirs.size() - 1);
    Path modelFile = latestModelDir.resolve(MLUpdate.MODEL_FILE_NAME);
    assertTrue(""No such model file: "" + modelFile, Files.exists(modelFile));

    PMML pmml = PMMLUtils.read(modelFile);

    assertEquals(3, pmml.getExtensions().size());
    Map<String,Object> expected = new HashMap<>();
    expected.put(""maxSplitCandidates"", MAX_SPLIT_CANDIDATES);
    expected.put(""maxDepth"", MAX_DEPTH);
    expected.put(""impurity"", IMPURITY);
    checkExtensions(pmml, expected);

    Pair<DecisionForest,CategoricalValueEncodings> forestEncoding = RDFPMMLUtils.read(pmml);
    DecisionForest forest = forestEncoding.getFirst();
    CategoricalValueEncodings encoding = forestEncoding.getSecond();
    Map<String,Integer> targetEncoding = encoding.getValueEncodingMap(4);

    int[] zeroOne = { 0, 1 }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testFeature() {
    NumericFeature f = NumericFeature.forValue(1.5);
    assertEquals(FeatureType.NUMERIC, f.getFeatureType());
    assertEquals(1.5, f.getValue());
    assertEquals(f, NumericFeature.forValue(1.5));
    assertNotEquals(f, NumericFeature.forValue(Double.NaN));
  }",No Smells
"@Test
  public void testConstruct() {
    int[] counts = { 0, 1, 3, 0, 4, 0 }",No Smells
"@Test
  public void testConstructFromProbability() {
    double[] probability = {0.0, 0.125, 0.375, 0.0, 0.5, 0.0 }",No Smells
"@Test
  public void testHashCode() {
    int[] counts = { 0, 1, 3, 0, 4, 0 }",No Smells
"@Test
  public void testUpdate2() {
    int[] counts = { 0, 1, 3, 0, 4, 0 }",No Smells
"@Test
  public void testEquals() {
    NumericPrediction prediction = new NumericPrediction(1.5, 1);
    NumericPrediction prediction1 = new NumericPrediction(1.5, 2);
    assertEquals(prediction, prediction1);
    prediction1.update(2.0, 2);
    assertNotEquals(prediction, prediction1);
    prediction1.update(1.5, 4);
    assertNotEquals(prediction, prediction1);
  }",No Smells
"@Test
  public void testNumericVoteWeighted() {
    List<NumericPrediction> predictions = Arrays.asList(
        new NumericPrediction(1.0, 1),
        new NumericPrediction(3.0, 2),
        new NumericPrediction(6.0, 3)
    );
    double[] weights = {3.0, 2.0, 1.0}",No Smells
"@Test
  public void testSumWithNaN() throws Exception {
    OryxTest.assertEquals(1.0, MLFunctions.SUM_WITH_NAN.call(Arrays.asList(1.0)).doubleValue());
    OryxTest.assertEquals(6.0, MLFunctions.SUM_WITH_NAN.call(Arrays.asList(1.0, 2.0, 3.0)).doubleValue());
    OryxTest.assertEquals(3.0, MLFunctions.SUM_WITH_NAN.call(Arrays.asList(1.0, Double.NaN, 3.0)).doubleValue());
    assertNaN(MLFunctions.SUM_WITH_NAN.call(Arrays.asList(1.0, 2.0, Double.NaN)));
    assertNaN(MLFunctions.SUM_WITH_NAN.call(Arrays.asList(Double.NaN)));
  }",No Smells
"@Test
  public void testToTimestamp() throws Exception {
    assertEquals(123L, MLFunctions.TO_TIMESTAMP_FN.call(""a,b,c,123"").longValue());
    assertEquals(123L, MLFunctions.TO_TIMESTAMP_FN.call(""a,b,c,123,"").longValue());
    assertEquals(123L, MLFunctions.TO_TIMESTAMP_FN.call(""[\""a\"",\""b\"",\""c\"",123]"").longValue());
    assertEquals(123L, MLFunctions.TO_TIMESTAMP_FN.call(""[\""a\"",\""b\"",\""c\"",123,\""d\""]"").longValue());
  }",No Smells
"@Test
  public void testClosestCluster() {
    List<ClusterInfo> clusters = Arrays.asList(
        new ClusterInfo(2, new double[] { 1.0,  2.0 }",No Smells
"@Test
  public void testFeaturesFromTokens() {
    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.input-schema.num-features"", 4);
    overlayConfig.put(""oryx.input-schema.categorical-features"", ""[]"");
    overlayConfig.put(""oryx.input-schema.ignored-features"", ""[0,2]"");
    Config config = ConfigUtils.overlayOn(overlayConfig, ConfigUtils.getDefault());
    InputSchema inputSchema = new InputSchema(config);
    double[] features = KMeansUtils.featuresFromTokens(new String[] { ""1.0"", ""2.0"", ""0.0"", ""-3.5"" }",No Smells
"@Test
  public void testListFeaturesMS() {
    MiningSchema miningSchema = AppPMMLUtils.buildMiningSchema(buildTestSchema());
    List<String> featureNames = AppPMMLUtils.getFeatureNames(miningSchema);
    assertEquals(Arrays.asList(""foo"", ""bar"", ""baz"", ""bing""), featureNames);
  }",No Smells
"@Test
  public void testReadPMMLFromMessage() throws Exception {
    PMML pmml = PMMLUtils.buildSkeletonPMML();
    String pmmlString = PMMLUtils.toString(pmml);
    assertEquals(PMMLUtils.VERSION, AppPMMLUtils.readPMMLFromUpdateKeyMessage(
        ""MODEL"", pmmlString, null).getVersion());

    Path pmmlPath = getTempDir().resolve(""out.pmml"");
    Files.write(pmmlPath, Collections.singleton(pmmlString));
    assertEquals(PMMLUtils.VERSION, AppPMMLUtils.readPMMLFromUpdateKeyMessage(
        ""MODEL-REF"", pmmlPath.toAbsolutePath().toString(), null).getVersion());

    assertNull(AppPMMLUtils.readPMMLFromUpdateKeyMessage(""MODEL-REF"", ""no-such-path"", null));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testEqualsHashCode() {
    BitSet activeCategories = new BitSet(10);
    activeCategories.set(5);
    CategoricalDecision a = new CategoricalDecision(0, activeCategories, true);
    CategoricalDecision b = new CategoricalDecision(0, activeCategories, true);
    CategoricalDecision c = new CategoricalDecision(1, activeCategories, true);
    assertEquals(a, b);
    assertNotEquals(a, c);
    assertEquals(a.hashCode(), b.hashCode());
    assertNotEquals(a.hashCode(), c.hashCode());
  }",No Smells
"@Test
  public void testToString() {
    BitSet activeCategories = new BitSet(10);
    activeCategories.set(2);
    activeCategories.set(5);
    CategoricalDecision decision = new CategoricalDecision(0, activeCategories, true);
    assertEquals(""(#0  [2,5])"", decision.toString());
  }",No Smells
"@Test
  public void testEqualsHashCode() {
    NumericDecision a = new NumericDecision(0, 0.5, true);
    NumericDecision b = new NumericDecision(0, 0.5, true);
    NumericDecision c = new NumericDecision(1, 0.5, true);
    assertEquals(a, b);
    assertNotEquals(a, c);
    assertEquals(a.hashCode(), b.hashCode());
    assertNotEquals(a.hashCode(), c.hashCode());
  }",No Smells
"@Test
  public void testNode() {
    Prediction prediction = new NumericPrediction(1.2, 3);
    TerminalNode node = new TerminalNode(""1"", prediction);
    assertTrue(node.isTerminal());
    assertSame(prediction, node.getPrediction());
    assertEquals(3, node.getCount());
  }",No Smells
"@Test
  public void testOrder() {
    List<TreePath> paths = new ArrayList<>(Arrays.asList(LRL, R, LR, LRR));
    Collections.sort(paths);
    assertEquals(Arrays.asList(LRL, LR, LRR, R), paths);
  }",No Smells
"@Test
  public void testToString() {
    assertEquals("""", TreePath.EMPTY.toString());
    assertEquals(""010"", LRL.toString());
    assertEquals(""011"", LRR.toString());
  }",No Smells
"@Test
  public void testCounts() {
    CategoricalValueEncodings encodings = makeTestValues();
    assertEquals(3, encodings.getValueCount(0));
    assertEquals(4, encodings.getValueCount(2));
    assertEquals(1, encodings.getValueCount(3));
    Map<Integer,Integer> counts = encodings.getCategoryCounts();
    assertEquals(3, counts.get(0).intValue());
    assertEquals(4, counts.get(2).intValue());
    assertEquals(1, counts.get(3).intValue());
  }",No Smells
"@Test
  public void testAllItemIDs() {
    List<String> users = target(""/user/allIDs"").request()
        .accept(MediaType.APPLICATION_JSON_TYPE).get(LIST_STRING_TYPE);
    Assert.assertEquals(7, users.size());
    for (int user = 0; user < 7; user++) {
      OryxTest.assertContains(users, ""U"" + user);
    }",Mystery Guest + Resource Optimism
"@Test
  public void testEmptyItems() {
    List<String> items = target(""/knownItems/X1"").request()
        .accept(MediaType.APPLICATION_JSON_TYPE).get(LIST_STRING_TYPE);
    Assert.assertEquals(0, items.size());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testKnownItems() {
    ALSServingModel model = new ALSServingModel(2, true, 1.0, null);
    populateKnownItems(model);
    assertContainsSame(Arrays.asList(""I0"", ""I1""), model.getKnownItems(""U0""));
    assertContainsSame(Arrays.asList(""I0"", ""I1"", ""I2""), model.getKnownItems(""U1""));
    assertContainsSame(Arrays.asList(""I8"", ""I9""), model.getKnownItems(""U9""));
    Map<String,Integer> userCounts = model.getUserCounts();
    assertEquals(2, userCounts.get(""U0"").intValue());
    assertEquals(3, userCounts.get(""U1"").intValue());
    assertEquals(2, userCounts.get(""U9"").intValue());
    Map<String,Integer> itemCounts = model.getItemCounts();
    assertEquals(2, itemCounts.get(""I0"").intValue());
    assertEquals(3, itemCounts.get(""I1"").intValue());
    assertEquals(2, itemCounts.get(""I9"").intValue());
  }",No Smells
"@Test
  public void testLSHEffect() {
    RandomGenerator random = RandomManager.getRandom();
    PoissonDistribution itemPerUserDist = new PoissonDistribution(
        random,
        20,
        PoissonDistribution.DEFAULT_EPSILON,
        PoissonDistribution.DEFAULT_MAX_ITERATIONS);
    int features = 20;
    ALSServingModel mainModel = new ALSServingModel(features, true, 1.0, null);
    ALSServingModel lshModel = new ALSServingModel(features, true, 0.5, null);

    int userItemCount = 20000;
    for (int user = 0; user < userItemCount; user++) {
      String userID = ""U"" + user;
      float[] vec = VectorMath.randomVectorF(features, random);
      mainModel.setUserVector(userID, vec);
      lshModel.setUserVector(userID, vec);
      int itemsPerUser = itemPerUserDist.sample();
      Collection<String> knownIDs = new ArrayList<>(itemsPerUser);
      for (int i = 0; i < itemsPerUser; i++) {
        knownIDs.add(""I"" + random.nextInt(userItemCount));
      }",Eager Test
"@Test
  public void testManyCores() {
    // But 3 cores should allow 1 bit difference if 3/4 is to be evaluated
    doTestHashesBits(0.75, 3, 2, 1);
    // 2 cores, evaluate half: 2 hashes split in 1/4, but can only keep 1 core busy at 0 bits differing
    // Allow 1 bit differing even though means evaluating 3 partitions, but then that evaluates 3/4 = 0.75 of
    // candidates which is too much. Ends up needing 3 hashes.
    doTestHashesBits(0.5, 3, 3, 1);
    // Ends up needing 7 hashes, 1 bit differing (1+7=8 partitions to try) to achieve 8 / 2^7 <= 0.1 sampling
    doTestHashesBits(0.1, 8, 7, 1);
    doTestHashesBits(0.01, 8, 11, 1);
    doTestHashesBits(0.001, 8, 14, 1);
    // Near max hashes:
    doTestHashesBits(0.0001, 8, 16, 1);
    // Maxes out at 16 hashes
    doTestHashesBits(0.00001, 8, LocalitySensitiveHash.MAX_HASHES, 1);
  }",Eager Test
"@Test
  public void testOneCore() {
    // 1 core, evaluate all: no hashes necessary at all
    doTestHashesBits(1.0, 1, 0, 0);
    // 1 core, evaluate half: 1 hash to split in half, evaluate only half (0 bits differ)
    doTestHashesBits(0.5, 1, 1, 0);
    // 1 core, evaluate <= 0.1: need 4 hashes to split in 1/16, then evaluate 1/16th (0 bits differ)
    doTestHashesBits(0.1, 1, 4, 0);
  }",Eager Test
"@Test
  public void testRescorer() {
    List<IDCount> top = target(""/mostPopularItems"").queryParam(""rescorerParams"", ""foo"").request()
        .accept(MediaType.APPLICATION_JSON_TYPE).get(LIST_ID_COUNT_TYPE);
    Assert.assertEquals(4, top.size());
    Assert.assertEquals(6, top.get(0).getCount());
    Assert.assertEquals(5, top.get(1).getCount());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testDelete() {
    Response response = target(""/pref/U1/I2"").request().delete();
    checkResponse(response, ""U1"", ""I2"", """");
  }",Mystery Guest + Resource Optimism
"@Test
  public void testPostWithBadItemValue() {
    try (Response response = target(""/pref/U2/I2"").request().post(Entity.text(""aBc!""))) {
      Assert.assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
    }",Mystery Guest + Resource Optimism
"@Test
  public void testRecommendToAnonymous() {
    List<IDValue> recs = target(""/recommendToAnonymous/I4=1.0/I5=2.0"").request()
        .accept(MediaType.APPLICATION_JSON_TYPE).get(LIST_ID_VALUE_TYPE);
    testTopByValue(7, recs, false);
    Assert.assertEquals(""I7"", recs.get(0).getID());
    Assert.assertEquals(0.35964763f, recs.get(0).getValue(), FLOAT_EPSILON);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testRescorer() {
    List<IDValue> recs = target(""/recommendToAnonymous/I4=1.0/I5=2.0"")
        .queryParam(""rescorerParams"", ""foo"").request()
        .accept(MediaType.APPLICATION_JSON_TYPE).get(LIST_ID_VALUE_TYPE);
    testTopByValue(3, recs, false);
    Assert.assertEquals(""I7"", recs.get(0).getID());
    Assert.assertEquals(2.0f * 0.35964763f, recs.get(0).getValue(), FLOAT_EPSILON);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testHowMany() {
    testHowMany(""/recommendWithContext/U5/"", 10, 2);
    testHowMany(""/recommendWithContext/U5/"", 2, 2);
    testHowMany(""/recommendWithContext/U5/"", 1, 1);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testRecommendWithContextWithUnknown() {
    String response = target(""/recommendWithContext/U0/foo/I4=1.0/I5=2.0"").request().get(String.class);
    testCSVTopByScore(5, response);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testRescorer() {
    List<IDValue> recs = target(""similarity/I0/I4/I6"")
        .queryParam(""rescorerParams"", ""foo"").request()
        .accept(MediaType.APPLICATION_JSON_TYPE).get(LIST_ID_VALUE_TYPE);
    testTopByValue(4, recs, false);
    Assert.assertEquals(""I5"", recs.get(1).getID());
    Assert.assertEquals(2.0 * 0.9125432970065859, recs.get(2).getValue(), DOUBLE_EPSILON);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testSimilarityCSV() {
    String response = target(""/similarity/I0/I4/I6"").request().get(String.class);
    testCSVTopByScore(6, response);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testZeroSimilarityToItem() {
    List<Double> items = target(""/similarityToItem/I1/I10"").request()
        .accept(MediaType.APPLICATION_JSON_TYPE).get(LIST_DOUBLE_TYPE);
    Assert.assertEquals(1, items.size());
    Assert.assertEquals(0.0f, items.get(0), FLOAT_EPSILON);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testAssign2() {
    String prediction = target(""/assign/10,-1.0"").request().get(String.class);
    Assert.assertEquals(3, Integer.parseInt(prediction));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testConsole() {
    String html;
    try (Response response = target(""/index.html"").request().accept(MediaType.TEXT_HTML).get()) {
      Assert.assertEquals(""public"", response.getHeaderString(""Cache-Control""));
      Assert.assertEquals(""SAMEORIGIN"", response.getHeaderString(""X-Frame-Options""));
      html = response.readEntity(String.class);
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testGet() {
    try (Response response = target(""/ready"").request().get()) {
      Assert.assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());
    }",Mystery Guest + Resource Optimism
"@Test
  public void testDistribution() {
    List<IDValue> recs = target(""/classificationDistribution/B,0,"").request()
        .accept(MediaType.APPLICATION_JSON_TYPE).get(LIST_ID_VALUE_TYPE);
    Assert.assertEquals(""X"", recs.get(0).getID());
    Assert.assertEquals((10.0 / 90.0 + 2 * (1000.0 / 111000.0)) / 3,
                        recs.get(0).getValue(),
                        OryxTest.DOUBLE_EPSILON);
    Assert.assertEquals(""Y"", recs.get(1).getID());
    Assert.assertEquals((30.0 / 90.0 + 2 * (10000.0 / 111000.0)) / 3,
                        recs.get(1).getValue(),
                        OryxTest.DOUBLE_EPSILON);
    Assert.assertEquals(""Z"", recs.get(2).getID());
    Assert.assertEquals((50.0 / 90.0 + 2 * (100000.0 / 111000.0)) / 3,
                        recs.get(2).getValue(),
                        OryxTest.DOUBLE_EPSILON);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testConsole() {
    String html;
    try (Response response = target(""/index.html"").request().accept(MediaType.TEXT_HTML).get()) {
      Assert.assertEquals(""public"", response.getHeaderString(""Cache-Control""));
      Assert.assertEquals(""SAMEORIGIN"", response.getHeaderString(""X-Frame-Options""));
      html = response.readEntity(String.class);
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testFormPredict() throws Exception {
    checkResponse(getFormPostResponse(PREDICT_DATA, ""/predict"", null, null));
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testALSSpeed() throws Exception {
    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.speed.model-manager-class"", ALSSpeedModelManager.class.getName());
    overlayConfig.put(""oryx.speed.streaming.generation-interval-sec"", 5);
    overlayConfig.put(""oryx.als.hyperparams.features"", 2);
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    List<KeyMessage<String,String>> updates =
        startServerProduceConsumeTopics(config,
                                        new MockALSInputGenerator(),
                                        new MockALSModelUpdateGenerator(),
                                        10, 10);

    if (log.isDebugEnabled()) {
      updates.forEach(update -> log.debug(""{}",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testToString() {
    String modelToString = new ALSSpeedModel(2, true, true, 0.01).toString();
    assertContains(modelToString, ""ALSSpeedModel"");
    assertContains(modelToString, ""features:2"");
    assertContains(modelToString, ""implicit:true"");
    assertContains(modelToString, ""logStrength:true"");
    assertContains(modelToString, ""epsilon:0.01"");
  }",No Smells
"@Test
  public void testUserItemVector() {
    ALSSpeedModel model = new ALSSpeedModel(2, true, false, Double.NaN);
    assertEquals(2, model.getFeatures());
    model.setUserVector(""U1"", new float[] { 1.5f, -2.5f }",No Smells
"@Test
  public void testRDFSpeedRegression() throws Exception {
    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.speed.model-manager-class"", RDFSpeedModelManager.class.getName());
    overlayConfig.put(""oryx.speed.streaming.generation-interval-sec"", 10);
    overlayConfig.put(""oryx.input-schema.feature-names"", ""[\""foo\"",\""bar\""]"");
    overlayConfig.put(""oryx.input-schema.categorical-features"", ""[]"");
    overlayConfig.put(""oryx.input-schema.target-feature"", ""bar"");
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    List<KeyMessage<String,String>> updates =
        startServerProduceConsumeTopics(config,
                                        new MockRDFRegressionInputGenerator(),
                                        new MockRDFRegressionModelGenerator(),
                                        NUM_INPUT,
                                        1);

    if (log.isDebugEnabled()) {
      updates.forEach(update -> log.debug(""{}",Eager Test
"@Test
  public void testDeleteRecursively() throws IOException {
    Path testDir = createTestDirs();
    IOUtils.deleteRecursively(testDir);
    assertFalse(Files.exists(testDir));
    assertFalse(Files.exists(testDir.resolve(""subFile1"")));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testListSubdirs2() throws IOException {
    Path testDir = createTestDirs();
    List<Path> files = IOUtils.listFiles(testDir, ""*/subFile*"");
    assertEquals(1, files.size());
    assertContains(files, testDir.resolve(""subDir1"").resolve(""subFile2""));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testAutoClose() {
    ReentrantLock lock = new ReentrantLock();
    assertFalse(lock.isHeldByCurrentThread());
    AutoLock al = new AutoLock(lock);
    try (AutoLock al2 = al.autoLock()) {
      assertTrue(lock.isHeldByCurrentThread());
    }",No Smells
"@Test
  public void testNoContextCL() {
    Thread current = Thread.currentThread();
    ClassLoader savedCL = current.getContextClassLoader();
    current.setContextClassLoader(null);
    try {
      assertTrue(ClassUtils.classExists(ClassUtilsTest.class.getName()));
    }",No Smells
"@Test
  public void testRunHook() {
    OryxShutdownHook hook = new OryxShutdownHook();
    AtomicInteger a = new AtomicInteger();
    hook.addCloseable(() -> a.set(3));
    hook.run();
    assertEquals(3, a.get());
  }",No Smells
"@Test
  public void testShutdownHook() {
    // Can't really test this except to verify that no exception is thrown now or at shutdown
    JVMUtils.closeAtShutdown(() -> {}",No Smells
"@Test
  public void testComplex() {
    DoubleWeightedMean mean = new DoubleWeightedMean();
    for (int i = 1; i <= 5; i++) {
      mean.increment(1.0 / (i + 1), i);
    }",Eager Test
"@Test
  public void testNone() {
    DoubleWeightedMean mean = new DoubleWeightedMean();
    assertEquals(0, mean.getN());
    assertNaN(mean.getResult());
  }",No Smells
"@Test
  public void testSolveDToD() {
    double[][] a = {
        {1.3, -2.0, 3.0}",No Smells
"@Test
  public void testSolveDToDPacked() {
    double[] a = {1.3, -2.0, 2.0, 3.0, 5.0, 1.5}",No Smells
"@Test
  public void testNullTranspose() {
    assertNull(VectorMath.transposeTimesSelf(null));
    assertNull(VectorMath.transposeTimesSelf(Collections.emptyList()));
  }",No Smells
"@Test
  public void testParseVector() {
    assertArrayEquals(
        new double[] {-1.0, 2.01, 3.5}",No Smells
"@Test
  public void testSmall() {
    float[] a = { 1.0e-24f }",No Smells
"@Test
  public void testReadWrite() throws Exception {
    Path tempModelFile = Files.createTempFile(getTempDir(), ""model"", "".pmml"");
    PMML model = buildDummyModel();
    PMMLUtils.write(model, tempModelFile);
    assertTrue(Files.exists(tempModelFile));
    PMML model2 = PMMLUtils.read(tempModelFile);
    List<Model> models = model2.getModels();
    assertEquals(1, models.size());
    assertInstanceOf(models.get(0), TreeModel.class);
    TreeModel treeModel = (TreeModel) models.get(0);
    assertEquals(123.0, treeModel.getNode().getRecordCount().doubleValue());
    assertEquals(MiningFunction.CLASSIFICATION, treeModel.getMiningFunction());
  }",No Smells
"@Test
  public void testSkeleton() {
    PMML pmml = PMMLUtils.buildSkeletonPMML();
    assertEquals(""Oryx"", pmml.getHeader().getApplication().getName());
    assertNotNull(pmml.getHeader().getTimestamp());
  }",No Smells
"@Test
  public void testUnseededRandomState() {
    RandomGenerator generator = RandomManager.getUnseededRandom();
    assertNotEquals(1553355631, generator.nextInt());
  }",No Smells
"@Test
  public void testOptionalString() {
    Config config = ConfigUtils.overlayOn(Collections.singletonMap(""nonexistent"", ""null""),
                                          ConfigUtils.getDefault());
    assertNull(ConfigUtils.getOptionalString(config, ""nonexistent""));
  }",No Smells
"@Test
  public void testSerialize() {
    String serialized = ConfigUtils.serialize(ConfigUtils.getDefault());
    assertContains(serialized, ""update-class"");
    Config deserialized = ConfigUtils.deserialize(serialized);
    assertEquals(
        ConfigUtils.getDefault().getString(""oryx.serving.api.port""),
        deserialized.getString(""oryx.serving.api.port""));
  }",No Smells
"@Test
  public void tetKeyValuesToProperties() {
    assertEquals(new Properties(), ConfigUtils.keyValueToProperties());
    Properties expected = new Properties();
    expected.setProperty(""foo"", ""1"");
    expected.setProperty(""2.0"", ""bing"");
    assertEquals(expected, ConfigUtils.keyValueToProperties(
       ""foo"", 1,
       2.0, ""bing""
    ));
  }",No Smells
"@Test
  public void testConvertViaJSON() {
    assertEquals(3, TextUtils.convertViaJSON(""3"", Long.class).longValue());
    assertArrayEquals(new float[] { 1.0f, 2.0f }",No Smells
"@Test
  public void testJoinPMMLDelimited() {
    assertEquals(""ab \""a b\"" \""with \\\""quotes\\\"" \"""",
                 TextUtils.joinPMMLDelimited(Arrays.asList(""ab"", ""a b"", ""with \""quotes\"" "")));
    assertEquals(""1 22 3"",
                 TextUtils.joinPMMLDelimited(Arrays.asList(""1"", ""22"", ""3"")));
    assertEquals(""\"" c\\\"" d \\\""e \"" \"" c\\\"" d \\\""e \"""",
                 TextUtils.joinPMMLDelimited(Arrays.asList("" c\"" d \""e "", "" c\"" d \""e "")));
  }",No Smells
"@Test
  public void testParseDelimited() throws Exception {
    assertArrayEquals(new String[] {""a"", ""1"", ""foo""}",No Smells
"@Test
  public void testReadJSON() {
    assertEquals(3, TextUtils.readJSON(""3"", Integer.class).intValue());
    assertEquals(Arrays.asList(""foo"", ""bar""), TextUtils.readJSON(""[\""foo\"", \""bar\""]"", List.class));
    assertArrayEquals(new float[] { 1.0f, 2.0f }",No Smells
"@Test
  public void testDeleteOldData() throws Exception {
    Path tempDir = getTempDir();
    Path dataDir = tempDir.resolve(""data"");
    Path modelDir = tempDir.resolve(""model"");
    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", MockBatchUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", dataDir);
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", modelDir);
    overlayConfig.put(""oryx.batch.storage.max-age-data-hours"", 0);
    overlayConfig.put(""oryx.batch.storage.max-age-model-hours"", 0);
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", GEN_INTERVAL_SEC);
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();
    startServerProduceConsumeTopics(config, DATA_TO_WRITE, WRITE_INTERVAL_MSEC);
    assertEquals(0, IOUtils.listFiles(dataDir, ""*"").size());
    assertEquals(0, IOUtils.listFiles(modelDir, ""*"").size());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testFunction() {
    WritableToValueFunction<String,String> function =
        new WritableToValueFunction<>(String.class, String.class, Text.class, Text.class);
    Tuple2<Writable,Writable> in = new Tuple2<>(new Text(""bizz""), new Text(""buzz""));
    Tuple2<String,String> out = function.call(in);
    assertEquals(""bizz"", out._1());
    assertEquals(""buzz"", out._2());
  }",No Smells
"@Test
  public void testWrite() throws Exception {
    CSVMessageBodyWriter writer = new CSVMessageBodyWriter();

    HasCSV foo = () -> ""foo"";
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    writer.writeTo(foo, HasCSV.class, null, null, TEXT_CSV_TYPE, null, out);
    out.close();
    assertEquals(""foo\n"", new String(out.toByteArray(), StandardCharsets.UTF_8));

    HasCSV bar = () -> ""bar"";
    ByteArrayOutputStream multiOut = new ByteArrayOutputStream();
    writer.writeTo(Arrays.asList(foo, bar), Iterable.class, null, null, TEXT_CSV_TYPE, null, multiOut);
    multiOut.close();
    assertEquals(""foo\nbar\n"", new String(multiOut.toByteArray(), StandardCharsets.UTF_8));
  }",No Smells
"@Test
  public void testListener() throws Exception {
    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.serving.model-manager-class"", MockServingModelManager.class.getName());
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());
    String serializedConfig = ConfigUtils.serialize(config);

    MockServletContext mockContext = new MockServletContext();
    mockContext.addInitParameter(ConfigUtils.class.getName() + "".serialized"", serializedConfig);

    startMessaging();

    try (ModelManagerListener<?,?,?> listener = new ModelManagerListener<>()) {
      listener.init(mockContext);
      try {
        listener.contextInitialized(new ServletContextEvent(mockContext));
        ServingModelManager<?> manager =
            (ServingModelManager<?>) mockContext.getAttribute(ModelManagerListener.MANAGER_KEY);
        assertNotNull(manager);
        assertFalse(manager.isReadOnly());
        assertNotNull(manager.getConfig());
      }",No Smells
"@Test
  public void testMap() {
    OryxExceptionMapper mapper = new OryxExceptionMapper();
    OryxServingException ex = new OryxServingException(Response.Status.BAD_REQUEST, ""Bad request"");
    Response response = mapper.toResponse(ex);
    assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
    assertEquals(""Bad request"", response.getEntity().toString());
  }",No Smells
"@Test
  public void testUserPassword() throws Exception {
    startServer(buildUserPasswordConfig());

    Authenticator.setDefault(new Authenticator() {
      @Override
      protected PasswordAuthentication getPasswordAuthentication() {
        return new PasswordAuthentication(""oryx"", ""pass"".toCharArray());
      }",Mystery Guest + Resource Optimism
"@Test
  public void testCombos() {
    List<HyperParamValues<?>> hyperParams = new ArrayList<>();
    hyperParams.add(HyperParams.fixed(1.0));
    hyperParams.add(HyperParams.range(2, 10));
    hyperParams.add(HyperParams.around(5.0, 0.5));
    List<List<?>> combos = GridSearch.chooseHyperParameterCombos(hyperParams, 4);
    assertEquals(4, combos.size());
    assertContains(combos, Arrays.<Number>asList(1.0, 2, 4.75));
    assertContains(combos, Arrays.<Number>asList(1.0, 10, 4.75));
    assertContains(combos, Arrays.<Number>asList(1.0, 2, 5.25));
    assertContains(combos, Arrays.<Number>asList(1.0, 10, 5.25));
  }",No Smells
"@Test
  public void testMLUpdate() throws Exception {
    Path tempDir = getTempDir();
    Path dataDir = tempDir.resolve(""data"");
    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", MockMLUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", dataDir);
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", tempDir.resolve(""model""));
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", GEN_INTERVAL_SEC);
    overlayConfig.put(""oryx.ml.eval.test-fraction"", TEST_FRACTION);
    overlayConfig.put(""oryx.ml.eval.threshold"", DATA_TO_WRITE / 2); // Should easily pass threshold
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    List<Integer> trainCounts = MockMLUpdate.getResetTrainCounts();
    List<Integer> testCounts = MockMLUpdate.getResetTestCounts();

    startServerProduceConsumeTopics(config, DATA_TO_WRITE, WRITE_INTERVAL_MSEC);

    // If lists are unequal at this point, there must have been an empty test set
    // which yielded no call to evaluate(). Fill in the blank
    while (trainCounts.size() > testCounts.size()) {
      testCounts.add(0);
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testToJson() {
    final String json = adminMessage.toJson();
    assertNotNull(adminMessage);
    assertEquals(adminMessage, BroadcastMessageImpl.fromJson(json));
  }",No Smells
"@Test
  public void testHistoryMode() throws Exception {
    // Test setup
    Set<Long> tagIds = new HashSet<>();
    tagIds.add(1L);
    tagIds.add(2L);
    Collection<TagUpdate> serverUpdates = new ArrayList<>(tagIds.size());
    for (Long tagId : tagIds) {
      serverUpdates.add(createValidTransferTag(tagId));
      prepareClientDataTagCreateMock(tagId);
    }",Eager Test
"@Test
  public void testNoHealthNotification() throws InterruptedException {
    wrapper.setNotificationTimeBeforeWarning(1000); //allow up to 1s
    mocksControl.reset();
    mocksControl.replay();
    int i = 0;
    while (i < 2) {
      wrapper.onMessage(mockMessage);
      Thread.sleep(300);
      i++;
    }",Eager Test
"@Test
  public void testUpdateWithEquipmentDown() throws RuleFormatException {
    Long equipmentId = 777L;
    
    TagController tagController = new TagController(TAG_ID);
    
    TestTagUpdate tagUpdate1 = TestTagUpdate.create();
    tagUpdate1.setServerTimestamp(CURRENT_TIME);
    tagUpdate1.setDaqTimestamp(CURRENT_TIME);
    tagUpdate1.setSourceTimestamp(CURRENT_TIME);
    tagUpdate1.setEquipmentIds(Arrays.asList(equipmentId));
    tagUpdate1.getDataTagQuality().removeInvalidStatus(TagQualityStatus.UNINITIALISED);
    
    tagController.update(tagUpdate1);
    
    assertTrue(""The data tag should be valid"", tagController.getTagImpl().getDataTagQuality().isValid());
    
    SupervisionEvent processDownEvent = new SupervisionEventImpl(
        SupervisionConstants.SupervisionEntity.EQUIPMENT,
        equipmentId,
        """",
        SupervisionConstants.SupervisionStatus.DOWN,
        CURRENT_TIME,
        ""Equipment down!"");
    
    tagController.onSupervisionUpdate(processDownEvent);
    assertFalse(""The data tag should be invalid"", tagController.getTagImpl().getDataTagQuality().isValid());
  }",No Smells
"@Test
  public void retrieveTopicName() {
    TagController tagController = new TagController(1234L);
    tagController.onUpdate(createValidTransferTag(1234L));
    tagController.getTagImpl().setTopicName(""test"");

    assertTrue(tagController.getTagImpl().getTopicName().equals(""test""));
  }",No Smells
"@Test
    public void testAddSourceCommandTagNoSuccess() {
        CommandTagAdd commandTagAdd = new CommandTagAdd(25L, TEST_EQUIPMENT_ID, new SourceCommandTag(
                TEST_COMMAND_TAG_ID, ""none""));
        ChangeReport report = configurationController.onCommandTagAdd(commandTagAdd);
        IEquipmentConfiguration equipmentConfiguration = processConfiguration.getEquipmentConfigurations().get(
                TEST_EQUIPMENT_ID);
        assertTrue(equipmentConfiguration.getSourceCommandTags().size() == 1);
        assertFalse(report.isSuccess());
    }",No Smells
"@Test
	public void testAddSubEquipmentUnitSuccess() throws ConfigurationException {
		String xml = ""<SubEquipmentUnit  id=\"""" + TEST_SUB_EQUIPMENT_ID + ""\"" name=\""E_TEST\"">""
				+ ""<commfault-tag-id>201498</commfault-tag-id>"" + ""<commfault-tag-value>false</commfault-tag-value>""
				+ ""</SubEquipmentUnit>"";

		ChangeReport report = configurationController
				.onSubEquipmentUnitAdd(new SubEquipmentUnitAdd(100L, TEST_SUB_EQUIPMENT_ID, TEST_EQUIPMENT_ID, xml));
		assertFalse(report.isFail());
	}",No Smells
"@Test
    public void testFindDataTagFailure() {
        ISourceDataTag dataTag = configurationController.findDataTag(TEST_NOT_EXIST_ID);
        assertNull(dataTag);
    }",No Smells
"@Test
    public void testNoCommandTagChangerForImplementationLayer() {
        // remove default changer
        configurationController.putImplementationCommandTagChanger(TEST_EQUIPMENT_ID, null);

        CommandTagRemove commandTagRemove = new CommandTagRemove(3434L, TEST_COMMAND_TAG_ID, TEST_EQUIPMENT_ID);
        IEquipmentConfiguration equipmentConfiguration = processConfiguration.getEquipmentConfigurations().get(
                TEST_EQUIPMENT_ID);
        assertTrue(equipmentConfiguration.hasSourceCommandTag(TEST_COMMAND_TAG_ID));
        ChangeReport report = configurationController.onCommandTagRemove(commandTagRemove);
        assertFalse(equipmentConfiguration.hasSourceCommandTag(TEST_COMMAND_TAG_ID));
        assertTrue(report.getState() == CHANGE_STATE.REBOOT);
        assertNotNull(report.getErrorMessage());
    }",No Smells
"@Test
    public void testNoExistantEquipment() {
        CommandTagRemove commandTagRemove = new CommandTagRemove(3434L, TEST_COMMAND_TAG_ID, TEST_NOT_EXIST_ID);
        ChangeReport report = configurationController.onCommandTagRemove(commandTagRemove);
        assertEquals(CHANGE_STATE.FAIL, report.getState());
        assertNotNull(report.getErrorMessage());
        assertTrue(report.getErrorMessage().contains(Long.toString(TEST_NOT_EXIST_ID)));
    }",No Smells
"@Test
    public void testRemoveNonExistentSourceDataTag() {
        DataTagRemove dataTagRemove = new DataTagRemove(3434L, TEST_NOT_EXIST_ID, TEST_EQUIPMENT_ID);
        IEquipmentConfiguration equipmentConfiguration = processConfiguration.getEquipmentConfigurations().get(
                TEST_EQUIPMENT_ID);
        assertFalse(equipmentConfiguration.hasSourceDataTag(TEST_NOT_EXIST_ID));
        ChangeReport report = configurationController.onDataTagRemove(dataTagRemove);
        assertFalse(equipmentConfiguration.hasSourceDataTag(TEST_NOT_EXIST_ID));
        assertTrue(report.isSuccess());
        assertNotNull(report.getWarnMessage());
    }",No Smells
"@Test
    public void testUpdateDataTagSuccess() {
        DataTagUpdate dataTagUpdate = new DataTagUpdate(435L, TEST_DATA_TAG_ID, TEST_EQUIPMENT_ID);
        String newName = ""newName"";
        dataTagUpdate.setName(newName);
        DataTagAddressUpdate dataTagAddressUpdate = new DataTagAddressUpdate();
        dataTagAddressUpdate.setGuaranteedDelivery(true);
        dataTagUpdate.setDataTagAddressUpdate(dataTagAddressUpdate);
        EquipmentConfiguration equipmentConfiguration = processConfiguration.getEquipmentConfigurations().get(
                TEST_EQUIPMENT_ID);
        SourceDataTag sourceDataTag = equipmentConfiguration.getDataTags().get(TEST_DATA_TAG_ID);
        assertTrue(sourceDataTag.getName().equals(DEFAULT_NAME));
        ChangeReport report = configurationController.onDataTagUpdate(dataTagUpdate);
        assertTrue(sourceDataTag.getName().equals(newName));
        assertTrue(report.isSuccess());
    }",No Smells
"@Test
  public void testOnAddDataTag() {
    SourceDataTag sdtLow = createSourceDataTag(5324L, """", ""Float"", ValueDeadbandType.NONE, JmsMessagePriority.PRIORITY_LOW, false);
    SourceDataTag sdtMed = createSourceDataTag(5325L, """", ""Float"", ValueDeadbandType.NONE, JmsMessagePriority.PRIORITY_MEDIUM, false);
    SourceDataTag sdtHigh = createSourceDataTag(5326L, """", ""Float"", ValueDeadbandType.NONE, JmsMessagePriority.PRIORITY_HIGH, false);

    dynamicTimeDeadbandFilterActivatorMock.addDataTag(sdtHigh);
    dynamicTimeDeadbandFilterActivatorMock.addDataTag(sdtLow);
    dynamicTimeDeadbandFilterActivatorMock.addDataTag(sdtMed);

    replay(dynamicTimeDeadbandFilterActivatorMock);

    equipmentMessageSender.onAddDataTag(sdtHigh, new ChangeReport(1L));
    equipmentMessageSender.onAddDataTag(sdtLow, new ChangeReport(2L));
    equipmentMessageSender.onAddDataTag(sdtMed, new ChangeReport(3L));

    verify(dynamicTimeDeadbandFilterActivatorMock);
  }",No Smells
"@Test
  public void testOnRemoveDataTag() {
    SourceDataTag sdt1Clone = sdt1.clone();
    SourceDataTag sdt2Clone = sdt2.clone();
    SourceDataTag sdt3Clone = sdt3.clone();
    sdt3Clone.getAddress().setStaticTimedeadband(true);
    
    sdt1.setDataType(""Float"");
    sdt2.getAddress().setPriority(JmsMessagePriority.PRIORITY_LOW);
    sdt2.getAddress().setStaticTimedeadband(true);
    sdt3.getAddress().setPriority(JmsMessagePriority.PRIORITY_HIGH);
    sdt3.getAddress().setStaticTimedeadband(false);

    dynamicTimeDeadbandFilterActivatorMock.removeDataTag(sdt2);
    dynamicTimeDeadbandFilterActivatorMock.removeDataTag(sdt3);
    dynamicTimeDeadbandFilterActivatorMock.addDataTag(sdt3);

    replay(dynamicTimeDeadbandFilterActivatorMock);

    equipmentMessageSender.onUpdateDataTag(sdt1, sdt1Clone, new ChangeReport(1L));
    equipmentMessageSender.onUpdateDataTag(sdt2, sdt2Clone, new ChangeReport(1L));
    equipmentMessageSender.onUpdateDataTag(sdt3, sdt3Clone, new ChangeReport(1L));

    verify(dynamicTimeDeadbandFilterActivatorMock);
  }",No Smells
"@Test
  public void testOnUpdateDataTag() {
    dynamicTimeDeadbandFilterActivatorMock.removeDataTag(sdt1);

    replay(dynamicTimeDeadbandFilterActivatorMock);

    equipmentMessageSender.onRemoveDataTag(sdt1, new ChangeReport(1L));

    verify(dynamicTimeDeadbandFilterActivatorMock);
  }",No Smells
"@Test
  public void testSendInvalidTagFutureSourceTS() throws InterruptedException {
    // Add value to the SourceDatTag
    this.sdt1.update(new ValueUpdate(false));

    // One value is added
    this.processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    expectLastCall().times(1);
    // One value is filtered out
    this.filterMessageSenderMock.addValue(isA(FilteredDataTagValue.class));
    expectLastCall().times(1);

    replay(this.processMessageSenderMock, this.filterMessageSenderMock);

    SourceDataTagValue sourceDTValue = this.sdt1.getCurrentValue();
    // Get the source data quality from the quality code and description
    SourceDataTagQuality newSDQuality = new SourceDataTagQuality(SourceDataTagQualityCode.FUTURE_SOURCE_TIMESTAMP, sourceDTValue.getQuality().getDescription());

    // It has:
    // - same currentSDValue and new value (false)
    // - same Value Description
    // - different Quality Code (OK vs FUTURE_SOURCE_TIMESTAMP)
    // - same Quality Description
    //
    // Should not be filtered
    this.equipmentMessageSender.update(this.sdt1.getId(), new ValueUpdate(sourceDTValue.getValue(), sourceDTValue.getValueDescription(), System.currentTimeMillis() + 1L), newSDQuality);

    assertEquals(SourceDataTagQualityCode.FUTURE_SOURCE_TIMESTAMP, this.sdt1.getCurrentValue().getQuality().getQualityCode());

    // It has:
    // - same currentSDValue and new value (false)
    // - same Value Description
    // - same Quality Code (FUTURE_SOURCE_TIMESTAMP)
    // - same Quality Description
    //
    // Should be filtered
    this.equipmentMessageSender.update(this.sdt1.getId(), new ValueUpdate(sourceDTValue.getValue(), sourceDTValue.getValueDescription(), System.currentTimeMillis() + 2L), newSDQuality);

    verify(this.processMessageSenderMock, this.filterMessageSenderMock);
  }",No Smells
"@Test
  public void testSendInvalidTagWithValueConversionBoolean2Float() throws InterruptedException {
    // Add value to the SourceDatTag
    this.sdt2.update(new ValueUpdate(Float.valueOf(0f)));

    // One value is added
    this.processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    expectLastCall().times(1);

    replay(this.processMessageSenderMock, this.filterMessageSenderMock);

    SourceDataTagValue sourceDTValue = this.sdt2.getCurrentValue();
    // Get the source data quality from the quality code and description
    SourceDataTagQuality newSDQuality = new SourceDataTagQuality(SourceDataTagQualityCode.DATA_UNAVAILABLE, sourceDTValue.getQuality().getDescription());

    // It has:
    // - different currentSDValue and new value (true vs false)
    // - same Value Description
    // - different Quality Code (OK vs DATA_UNAVAILABLE)
    // - same Quality Description
    //
    // Should not be filtered
    this.equipmentMessageSender.update(this.sdt2.getId(), new ValueUpdate(true, sourceDTValue.getValueDescription(), System.currentTimeMillis() + 1L), newSDQuality);

    // The Value has changed
    assertEquals(Float.valueOf(1f), this.sdt2.getCurrentValue().getValue());
    assertTrue(this.sdt2.getCurrentValue().getValue().getClass() == Float.class);
    // The Quality Code has changed
    assertEquals(SourceDataTagQualityCode.DATA_UNAVAILABLE, this.sdt2.getCurrentValue().getQuality().getQualityCode());

    verify(this.processMessageSenderMock, this.filterMessageSenderMock);
  }",No Smells
"@Test
  public void testSendInvalidTagWithValueConversionFloat2Boolean() throws InterruptedException {
    // Add value to the SourceDatTag
    this.sdt1.update(new ValueUpdate(true));

    // One value is added
    this.processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    expectLastCall().times(1);

    replay(this.processMessageSenderMock, this.filterMessageSenderMock);

    SourceDataTagValue sourceDTValue = this.sdt1.getCurrentValue();
    // Get the source data quality from the quality code and description
    SourceDataTagQuality newSDQuality = new SourceDataTagQuality(SourceDataTagQualityCode.DATA_UNAVAILABLE, sourceDTValue.getQuality().getDescription());

    // It has:
    // - different currentSDValue and new value (true vs false)
    // - same Value Description
    // - different Quality Code (OK vs DATA_UNAVAILABLE)
    // - same Quality Description
    //
    // Should not be filtered
    this.equipmentMessageSender.update(this.sdt1.getId(), new ValueUpdate(Float.valueOf(0f),  sourceDTValue.getValueDescription(), System.currentTimeMillis() + 1L), newSDQuality);

    // The Value has changed
    assertEquals(false, this.sdt1.getCurrentValue().getValue());
    assertTrue(this.sdt1.getCurrentValue().getValue().getClass() == Boolean.class);
    // The Quality Code has changed
    assertEquals(SourceDataTagQualityCode.DATA_UNAVAILABLE, this.sdt1.getCurrentValue().getQuality().getQualityCode());

    verify(this.processMessageSenderMock, this.filterMessageSenderMock);
  }",No Smells
"@Test
  public void testSendTagFilteredInvalidTimestamp() throws Exception {
    this.dynamicTimeDeadbandFilterActivatorMock.newTagValueSent(sdt1.getId());
    expectLastCall().times(2);

    this.processMessageSenderMock.addValue(isA(SourceDataTagValue.class));

    // even though we try to send twice the tag, it should only be invalidated
    // once, since the quality code does not
    // change and it is FUTURE_SOURCE_TIMESTAMP
    expectLastCall().times(2);

    // One value is filtered out
    this.filterMessageSenderMock.addValue(isA(FilteredDataTagValue.class));
    expectLastCall().times(1);

    replay(this.dynamicTimeDeadbandFilterActivatorMock, this.processMessageSenderMock, this.filterMessageSenderMock);

    long futureTimestamp = System.currentTimeMillis() + 600000L;

    long futureTimestamp2 = futureTimestamp + 2000;

    long futureTimestamp3 = futureTimestamp + 4000;

    // Should not be filtered
    this.equipmentMessageSender.update(this.sdt1.getId(), new ValueUpdate(false, futureTimestamp));

    // Quality has change to FUTURE_SOURCE_TIMESTAMP
    assertEquals(SourceDataTagQualityCode.FUTURE_SOURCE_TIMESTAMP, this.sdt1.getCurrentValue().getQuality().getQualityCode());

    // String qualityDesc = String
    // .format(""value: false received with source timestamp: [%s] in the future!
    // No further updates will be processed and the tag's value will stay
    // unchanged until this problem is fixed"",
    // new Timestamp(futureTimestamp));
    //
    // // Problema con test ""Value received with source timestamp in the future!
    // Time on server was: "" + new Timestamp(System.currentTimeMillis()));
    //
    // assertEquals(qualityDesc,
    // sdt1.getCurrentValue().getQuality().getDescription());
    //
    // Thread.sleep(200);

    // Should be filtered (FUTURE_SOURCE_TIMESTAMP)
    this.equipmentMessageSender.update(this.sdt1.getId(), new ValueUpdate(false, futureTimestamp2));

    // Quality did not change
    assertEquals(SourceDataTagQualityCode.FUTURE_SOURCE_TIMESTAMP, sdt1.getCurrentValue().getQuality().getQualityCode());

    // Should not be filtered
    this.equipmentMessageSender.update(this.sdt1.getId(), new ValueUpdate(true, futureTimestamp3));

    // Another value update should be sent with invalid quality
    // FUTURE_SOURCE_TIMESTAMP
    assertEquals(SourceDataTagQualityCode.FUTURE_SOURCE_TIMESTAMP, sdt1.getCurrentValue().getQuality().getQualityCode());
    assertEquals(true, sdt1.getCurrentValue().getValue());
    assertEquals(futureTimestamp3, sdt1.getCurrentValue().getTimestamp().getTime());

    verify(this.dynamicTimeDeadbandFilterActivatorMock, this.processMessageSenderMock, this.filterMessageSenderMock);
  }",No Smells
"@Test
  public void testSendTagFilteredNotConvertable() throws InterruptedException {
    dynamicTimeDeadbandFilterActivatorMock.newTagValueSent(sdt2.getId());
    processMessageSenderMock.addValue(isA(SourceDataTagValue.class));

    replay(dynamicTimeDeadbandFilterActivatorMock, processMessageSenderMock);

    equipmentMessageSender.update(sdt2.getId(), new ValueUpdate(""asdasdasd"", System.currentTimeMillis() + 1L));

    assertEquals(SourceDataTagQualityCode.CONVERSION_ERROR, sdt2.getCurrentValue().getQuality().getQualityCode());

    verify(dynamicTimeDeadbandFilterActivatorMock, processMessageSenderMock);
  }",No Smells
"@Test
  public void testSendTagFilteredOldUpdateSent() throws InterruptedException {
    // update the value
    this.sdt1.update(new ValueUpdate(false));
    // Timestamps to use
    long sourceTS = System.currentTimeMillis() + 1000;
    long sourceTS_2 = sourceTS + 2000;
    long sourceTS_3 = sourceTS + 3000;

    SourceDataTagQuality newSDBadQuality = new SourceDataTagQuality(SourceDataTagQualityCode.DATA_UNAVAILABLE, """");

    this.processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    expectLastCall().times(4);
    this.filterMessageSenderMock.addValue(isA(FilteredDataTagValue.class));
    expectLastCall().times(1);

    replay(this.processMessageSenderMock, this.filterMessageSenderMock);

    // The first one: the run method sends it to the server with NO_FILTERING
    this.equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(true, sourceTS));
    assertEquals(true, this.sdt1.getCurrentValue().getValue());

    // This one should NOT be filtered out. New TS > Current TS
    this.equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(false, sourceTS_2));
    assertEquals(false, this.sdt1.getCurrentValue().getValue());

    // This one should be filtered out. New TS <= Current TS + Current Good
    // Quality
    this.equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(true, sourceTS));
    assertEquals(false, this.sdt1.getCurrentValue().getValue());

    // Changing quality to BAD. Not filtering
    this.equipmentMessageSender.update(this.sdt1.getId(), new ValueUpdate(false, sourceTS_3), newSDBadQuality);
    assertEquals(false, this.sdt1.getCurrentValue().getValue());
    assertEquals(SourceDataTagQualityCode.DATA_UNAVAILABLE, this.sdt1.getCurrentValue().getQuality().getQualityCode());

    // This one should NOT be filtered out. New TS <= Current TS + New Good
    // Quality + Current Bad Quality
    this.equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(true, sourceTS));
    assertEquals(true, this.sdt1.getCurrentValue().getValue());

    verify(this.processMessageSenderMock, this.filterMessageSenderMock);
  }",No Smells
"@Test
  public void testSendTagFilteredTwiceSameValuesButDiffValueDesc() throws Exception {
    processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    expectLastCall().times(2);

    replay(processMessageSenderMock);

    // Send to the server
    equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(true, ""test description A"", System.currentTimeMillis()));
    // Send to the server. Equal Value but dif Value Description
    equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(true, ""test description B"", System.currentTimeMillis() + 2L));

    verify(processMessageSenderMock);
  }",No Smells
"@Test
  public void testSendTagFilteredWithArbitraryObjectWithCurrentValue() throws InterruptedException {

    processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    dynamicTimeDeadbandFilterActivatorMock.newTagValueSent(sdt5.getId());

    replay(dynamicTimeDeadbandFilterActivatorMock, processMessageSenderMock);

    // setUp current SourceDataTagValue:
    Object currentArbitraryObject = ArbitraryObject.builder().field1(""TestCurrent"").field2(9.87f).build();
    sdt5.getAddress().setTimeDeadband(0);
    sdt5.update(new ValueUpdate(currentArbitraryObject));

    Object arbitraryObject = ArbitraryObject.builder().field1(""Test"").field2(1.3f).build();
    equipmentMessageSender.update(sdt5.getId(), new ValueUpdate(arbitraryObject, System.currentTimeMillis() + 1L));

    assertEquals(SourceDataTagQualityCode.OK, sdt5.getCurrentValue().getQuality().getQualityCode());

    verify(dynamicTimeDeadbandFilterActivatorMock, processMessageSenderMock);
  }",No Smells
"@Test
  public void testSendTagFilteredWithIntArray() throws InterruptedException {
    processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    dynamicTimeDeadbandFilterActivatorMock.newTagValueSent(sdt4.getId());

    replay(dynamicTimeDeadbandFilterActivatorMock, processMessageSenderMock);
    sdt4.getAddress().setTimeDeadband(0);
    equipmentMessageSender.update(sdt4.getId(), new ValueUpdate(new int[] { 1, 2, 3, 4, 5 }",No Smells
"@Test
  public void testSendTagFilteredWithValueConversionShort2Boolean() throws InterruptedException {
    // update the value
    this.sdt1.update(new ValueUpdate(false));

    this.processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    expectLastCall().times(1);

    replay(this.processMessageSenderMock, this.filterMessageSenderMock);

    // Should be filtered out since the value is the same as the one just
    // updated
    this.equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(1.0f, System.currentTimeMillis() + 1L));
    assertEquals(true, this.sdt1.getCurrentValue().getValue());
    assertTrue(this.sdt1.getCurrentValue().getValue().getClass() == Boolean.class);

    verify(this.processMessageSenderMock, this.filterMessageSenderMock);
  }",No Smells
"@Test
  public void testSendTagFilteredWithValueConversionShort2Float() throws InterruptedException {
    // update the value
    this.sdt2.update(new ValueUpdate(Float.valueOf(10f)));

    this.processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    expectLastCall().times(1);

    replay(this.processMessageSenderMock, this.filterMessageSenderMock);

    // Should be filtered out since the value is the same as the one just
    // updated
    this.equipmentMessageSender.update(sdt2.getId(), new ValueUpdate((short) 100, System.currentTimeMillis() + 1L));
    assertEquals(Float.valueOf(100), this.sdt2.getCurrentValue().getValue());
    assertTrue(this.sdt2.getCurrentValue().getValue().getClass() == Float.class);

    verify(this.processMessageSenderMock, this.filterMessageSenderMock);
  }",No Smells
"@Test
  public void testSendValidInvalidTagTimeDeadbandEnabled() throws Exception {
    dynamicTimeDeadbandFilterActivatorMock.newTagValueSent(sdt1.getId());
    expectLastCall().times(3);
    processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    expectLastCall().times(3);

    this.sdt1.getAddress().setTimeDeadband(1);
    this.sdt1.update(new ValueUpdate(true));

    replay(this.dynamicTimeDeadbandFilterActivatorMock, this.processMessageSenderMock);

    // The first one: the run method sends it to the server with NO_FILTERING
    // (first time running the schedule)
    this.equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(false, System.currentTimeMillis() + 1L));
    Thread.sleep(300);
    assertEquals(false, this.sdt1.getCurrentValue().getValue());

    // The second one is also sent to the server since the value is different
    this.equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(true, System.currentTimeMillis() + 2L));
    Thread.sleep(300);
    assertEquals(true, this.sdt1.getCurrentValue().getValue());

    SourceDataTagQuality quality = new SourceDataTagQuality(SourceDataTagQualityCode.DATA_UNAVAILABLE);

    // The third one is invalid so it flush and cancel. It run the run() for the
    // first time so the second value is sent to the server
    this.equipmentMessageSender.update(sdt1.getId(), quality, System.currentTimeMillis() + 3L);
    Thread.sleep(300);
    assertEquals(SourceDataTagQualityCode.DATA_UNAVAILABLE, this.sdt1.getCurrentValue().getQuality().getQualityCode());

    verify(this.dynamicTimeDeadbandFilterActivatorMock, this.processMessageSenderMock);
  }",No Smells
"@Test
  public void testSendValidTagTimeDeadbandEnabled() throws Exception {
    // 3 of the values will be recorded and the other one send to the filter
    dynamicTimeDeadbandFilterActivatorMock.newTagValueSent(sdt1.getId());
    expectLastCall().times(3);

    processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    expectLastCall().times(3);
    filterMessageSenderMock.addValue(isA(FilteredDataTagValue.class));
    expectLastCall().times(1);

    // Lets figure out the Time Deadband is enabled (in this case would be the
    // Dynamic)
    this.sdt1.getAddress().setTimeDeadband(1);
    this.sdt1.update(new ValueUpdate(true));

    replay(this.dynamicTimeDeadbandFilterActivatorMock, this.processMessageSenderMock, this.filterMessageSenderMock);

    // The first one: the run method sends it to the server with NO_FILTERING
    // (first time running the schedule)
    this.equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(false, ""test"", System.currentTimeMillis() + 1L));
    assertEquals(false, this.sdt1.getCurrentValue().getValue());
    Thread.sleep(300);

    // The second one is also sent to the server since the value is different
    this.equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(true, ""test"", System.currentTimeMillis() + 2L));
    assertEquals(true, this.sdt1.getCurrentValue().getValue());
    Thread.sleep(300);

    // The third one is filtered with REPEATED_VALUE because the value and value
    // description are the same
    this.equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(true, ""test"", System.currentTimeMillis() + 3L));
    assertEquals(true, this.sdt1.getCurrentValue().getValue());
    Thread.sleep(300);

    // The fourth one is also sent to the server since the value is different
    this.equipmentMessageSender.update(sdt1.getId(), new ValueUpdate(false, System.currentTimeMillis() + 4L));
    assertEquals(false, this.sdt1.getCurrentValue().getValue());
    Thread.sleep(300);

    verify(this.dynamicTimeDeadbandFilterActivatorMock, this.processMessageSenderMock, this.filterMessageSenderMock);
  }",No Smells
"@Test
  public void testScheduleFilterRepeatedValue() throws Exception {

    // Tag update
    this.tag.update(new ValueUpdate(true, ""test"", System.currentTimeMillis()));

    EasyMock.expect(this.configurationControllerMock.getProcessConfiguration()).andReturn(this.processConfigurationMock);
    EasyMock.expect(this.processConfigurationMock.getProcessName()).andReturn(""TEST_PROCESS_NAME"");

    // No Dymanic Time Deadband
    EasyMock.expect(this.dynamicTimeDeadbandFiltererMock.isDynamicTimeDeadband(tag)).andReturn(false).times(2);

    // This message will be sent since it is the first one
    this.processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    // This message will be filtered with filter type REPEATED_VALUE
    this.filterMessageSenderMock.addValue(isA(FilteredDataTagValue.class));

    replay(this.processMessageSenderMock, this.filterMessageSenderMock, this.configurationControllerMock, this.processConfigurationMock,
        this.dynamicTimeDeadbandFiltererMock);

    this.equipmentMessageSender.init(this.conf);

    this.dataTagValueFilter = new DataTagValueFilter();

    // Filter module
    this.equipmentSenderFilterModule = new EquipmentSenderFilterModule(this.filterMessageSenderMock);

//     EquipmentLogger equipmentLogger = new EquipmentLogger(""asd"", ""asd"", ""asd"");
    this.scheduler = new SDTTimeDeadbandScheduler(tag, this.processMessageSenderMock, this.equipmentSenderFilterModule, new Timer(true), this
        .dataTagValueFilter, this.dynamicTimeDeadbandFiltererMock);

    this.scheduler.scheduleValueForSending();
    this.scheduler.run();

    // Repeated value
    this.scheduler.scheduleValueForSending();
    this.scheduler.run();

    verify(this.processMessageSenderMock, this.filterMessageSenderMock);

    if (this.exception != null) throw new Exception(this.exception);
  }",No Smells
"@Test
  public void testScheduleNoFiltering() throws Exception {
    // Tag update
    this.tag.update(new ValueUpdate(true, ""test"", System.currentTimeMillis()));

    EasyMock.expect(this.configurationControllerMock.getProcessConfiguration()).andReturn(this.processConfigurationMock);
    EasyMock.expect(this.processConfigurationMock.getProcessName()).andReturn(""TEST_PROCESS_NAME"");

    // No Dymanic Time Deadband
    EasyMock.expect(this.dynamicTimeDeadbandFiltererMock.isDynamicTimeDeadband(tag)).andReturn(false).times(2);

    // This message will be sent since it is the first one
    this.processMessageSenderMock.addValue(isA(SourceDataTagValue.class));
    expectLastCall().times(2);

    replay(this.processMessageSenderMock, this.configurationControllerMock, this.processConfigurationMock, this
        .dynamicTimeDeadbandFiltererMock);

    this.equipmentMessageSender.init(this.conf);

    this.dataTagValueFilter = new DataTagValueFilter();

    // Filter module
    this.equipmentSenderFilterModule = new EquipmentSenderFilterModule(this.filterMessageSenderMock);

    //        EquipmentLogger equipmentLogger = new EquipmentLogger(""asd"", ""asd"", ""asd"");
    this.scheduler = new SDTTimeDeadbandScheduler(tag, this.processMessageSenderMock, this.equipmentSenderFilterModule, new Timer(true), this
        .dataTagValueFilter, this.dynamicTimeDeadbandFiltererMock);

    this.scheduler.scheduleValueForSending();
    this.scheduler.run();

    // New value
    this.tag.update(new ValueUpdate(false, ""test"", System.currentTimeMillis()));
    scheduler.scheduleValueForSending();
    this.scheduler.run();

    verify(this.processMessageSenderMock);

    if (this.exception != null) throw new Exception(this.exception);
  }",No Smells
"@Test
    public void testApplyChange() {
        RequestController requestController = new RequestController(configurationControllerMock);
        List<Change> changes = new ArrayList<>();
        /*
         *  Values in this case don't matter.
         *  Just add to the configuration controller and check
         *  if the MessageHandler does the right thing.
         */
        DataTagAdd dataTagAdd = new DataTagAdd();
        changes.add(dataTagAdd);
        configurationControllerMock.onDataTagAdd(dataTagAdd);
        expectLastCall().andReturn(new ChangeReport(1L));

        DataTagRemove dataTagRemove = new DataTagRemove();
        changes.add(dataTagRemove);
        configurationControllerMock.onDataTagRemove(dataTagRemove);
        expectLastCall().andReturn(new ChangeReport(1L));

        DataTagUpdate dataTagUpdate = new DataTagUpdate();
        changes.add(dataTagUpdate);
        configurationControllerMock.onDataTagUpdate(dataTagUpdate);
        expectLastCall().andReturn(new ChangeReport(1L));

        CommandTagAdd commandTagAdd = new CommandTagAdd();
        changes.add(commandTagAdd);
        configurationControllerMock.onCommandTagAdd(commandTagAdd);
        expectLastCall().andReturn(new ChangeReport(1L));

        CommandTagRemove commandTagremove = new CommandTagRemove();
        changes.add(commandTagremove);
        configurationControllerMock.onCommandTagRemove(commandTagremove);
        expectLastCall().andReturn(new ChangeReport(1L));

        CommandTagUpdate commandTagUpdate = new CommandTagUpdate();
        changes.add(commandTagUpdate);
        configurationControllerMock.onCommandTagUpdate(commandTagUpdate);
        expectLastCall().andReturn(new ChangeReport(1L));

        EquipmentConfigurationUpdate equipmentConfigurationUpdate = new EquipmentConfigurationUpdate();
        changes.add(equipmentConfigurationUpdate);
        configurationControllerMock.onEquipmentConfigurationUpdate(equipmentConfigurationUpdate);
        expectLastCall().andReturn(new ChangeReport(1L));

        ProcessConfigurationUpdate processConfigurationUpdate = new ProcessConfigurationUpdate();
        changes.add(processConfigurationUpdate);
        configurationControllerMock.onProcessConfigurationUpdate(processConfigurationUpdate);
        expectLastCall().andReturn(new ChangeReport(1L));

        replay(configurationControllerMock);
        for (Change change : changes) {
            requestController.applyChange(change);
        }",Eager Test
"@Test
    public void testOnSourceDataTagValueUpdateRequestEquipment() {
        ConfigurationController configurationController = getBasicConfigurationController();

        RequestController handler = new RequestController(configurationController);
        SourceDataTagValueRequest valueRequest =
            new SourceDataTagValueRequest(EQUIPMENT, 2L);

        SourceDataTagValueResponse response =
            handler.onSourceDataTagValueUpdateRequest(valueRequest);

        assertTrue(response.getAllDataTagValueObjects().size() == 2);
    }",No Smells
"@Test
  public void testCallNoResponse() throws InterruptedException {
    SourceCommandExecutor executor = new SourceCommandExecutor(
        new ICommandRunner() {
          @Override
          public String runCommand(SourceCommandTagValue sourceCommandTagValue) throws EqCommandTagException {
            try {
              Thread.sleep(1000000000L);
            }",No Smells
"@Test
  public void isInRangeLong() {
    SourceDataTag sourceDataTag = new SourceDataTag(100L, ""testTag"", false);
    sourceDataTag.setMaxValue(Long.MAX_VALUE - 1L);
    sourceDataTag.setMinValue(0L);
    sourceDataTag.setDataType(Long.class.getName());

    assertTrue(valueValidator.isInRange(sourceDataTag, Long.MAX_VALUE - 2L));
    assertFalse(valueValidator.isInRange(sourceDataTag, Long.MAX_VALUE));
    assertTrue(valueValidator.isInRange(sourceDataTag, 0L));
    assertFalse(valueValidator.isInRange(sourceDataTag, -1L));
  }",No Smells
"@Test
    public void testAverage() {
        int counterSwitches = 5;
        int numberOfCounts = 50;
        for (int i = 0; i < counterSwitches; i++) {
            for (int j = 0; j < numberOfCounts; j++) {
                counterMovingAverage.increaseCurrentCounter();
            }",Eager Test
"@Test
    public void testOnOff() throws InterruptedException {
        for (int i = 0; i < 100; i++) {
            getActivator().newTagValueSent(getTestKey());
        }",Eager Test
"@Test
  public void testIsAbsoluteValueDeadband() {
    // Most basic sanity test
    assertTrue(""Lossless precision float values should be filtered"", dvf.isAbsoluteValueDeadband(0f, 1f, 1.1f));
    assertTrue(""Lossless precision int values should be filtered"", dvf.isAbsoluteValueDeadband(0, 1, 2.0f));
    assertFalse(""Lossless precision int values should not be filtered"", dvf.isAbsoluteValueDeadband(0, 1, 1.0f));
    assertTrue(""Lossless precision byte values should be filtered"", dvf.isAbsoluteValueDeadband((byte) 0, (byte) 1, 1.1f));
    assertTrue(""Lossless precision long values should be filtered"", dvf.isAbsoluteValueDeadband(0l, 1l, 1.1f));
    assertTrue(""Lossless precision double values should be filtered"", dvf.isAbsoluteValueDeadband(0.0, 1.0, 1.1f));

    // A few sanity tests
    assertFalse(""Lossless precision float values should not be filtered"", dvf.isAbsoluteValueDeadband(88888f, 88889f, 1f));
    assertFalse(""Lossless precision float values should not be filtered"", dvf.isAbsoluteValueDeadband(0f, 1f, 1f));
    assertFalse(""Lossless precision float values should not be filtered"", dvf.isAbsoluteValueDeadband(88888.68f, 88889.68f, 1f));

    // Checking that any float value that might cause integer precision loss is not
    // evaluated for deadband filtering
    assertFalse(""Integer values expressed over the max float precision float "", dvf.isAbsoluteValueDeadband(167772119f, 167772120f, 1.1f));

    // Checking that any long value that might cause double precision loss is not
    // evaluated for deadband filtering
    assertFalse(""Long values expressed over the max  double precision should not be filtered in any case"",
        dvf.isAbsoluteValueDeadband(Long.MAX_VALUE - 1, Long.MAX_VALUE, 1.1f));

  }",No Smells
"@Test
  public void testIsRelativeValueDeadband() {
    assertTrue(""Integer value 167772119 should be flagged as causing a loss of precision"", DataTagValueFilter.willCausePrecisionLoss(167772119));

    // Most basic sanity test
    assertFalse(""Incoming zero value should never get evaluated"", dvf.isRelativeValueDeadband(0f, 1f, 110));
    assertTrue(""Lossless precision float values should be filtered"", dvf.isRelativeValueDeadband(1f, 2f, 110));
    assertTrue(""Lossless precision int values should be filtered"", dvf.isRelativeValueDeadband(1, 2, 200));
    assertFalse(""Lossless precision int values should not be filtered"", dvf.isRelativeValueDeadband(1, 2, 100));
    assertTrue(""Lossless precision byte values should be filtered"", dvf.isRelativeValueDeadband((byte) 1, (byte) 2, 110));
    assertTrue(""Lossless precision long values should be filtered"", dvf.isRelativeValueDeadband(1l, 2l, 110));
    assertTrue(""Lossless precision double values should be filtered"", dvf.isRelativeValueDeadband(1.0, 2.0, 110));

    // A few sanity tests
    assertFalse(""Lossless precision float values should not be filtered"", dvf.isRelativeValueDeadband(100f, 200f, 100));
    assertFalse(""Lossless precision float values should not be filtered"", dvf.isRelativeValueDeadband(1f, 2f, 100));

    // Checking that any float value that might cause integer precision loss is not
    // evaluated for deadband filtering
    assertFalse(""Integer values expressed over the max float precision float should not be filtered in any case"",
        dvf.isRelativeValueDeadband(167772119, 167772120, 10000));

    // Checking that any long value that might cause double precision loss is not
    // evaluated for deadband filtering
    assertFalse(""Long values expressed over the max  double precision should not be filtered in any case"",
        dvf.isRelativeValueDeadband(Long.MAX_VALUE - 1, Long.MAX_VALUE, 110));

  }",No Smells
"@Test
  public void testGetAlarmsByCodeAndFamily() {
    AlarmQueryFilter query = AlarmQueryFilter.builder().faultFamily(""TEST_*"").faultCode(20).build();
    Collection<Long> result = alarmCache.findAlarm(query);
    assertNotNull(result);
    assertEquals(""Search result != 4"", 4, result.size());
  }",No Smells
"@Test
  public void testUpdateTimestampIsSetToTagCacheTimestamp() {
    Timestamp tagTime = new Timestamp(System.currentTimeMillis() - 1000);

    DataTagCacheObject tag = CacheObjectCreation.createTestDataTag();
    AlarmCacheObject currentAlarmState = CacheObjectCreation.createTestAlarm2();
    Timestamp origTime = new Timestamp(System.currentTimeMillis() - 50000);
    currentAlarmState.setTimestamp(origTime);
    tag.setSourceTimestamp(tagTime);
    //check set as expected
    assertEquals(true, currentAlarmState.isActive());
    assertEquals(false, currentAlarmState.getCondition().evaluateState(tag.getValue()));
    assertTrue(tag.isValid());

    // Recording Mock calls
    alarmCache.acquireWriteLockOnKey(currentAlarmState.getId());
    EasyMock.expect(alarmCache.getCopy(currentAlarmState.getId())).andReturn(currentAlarmState);
    alarmCache.put(currentAlarmState.getId(), currentAlarmState);
    alarmCache.releaseWriteLockOnKey(currentAlarmState.getId());
    EasyMock.replay(alarmCache, tagLocationService);

    //(1) test update works
    AlarmCacheObject newAlarm = (AlarmCacheObject) alarmFacadeImpl.update(currentAlarmState.getId(), tag);
    EasyMock.verify(alarmCache, tagLocationService);

    assertEquals(false, newAlarm.isActive());
    assertTrue(newAlarm.getSourceTimestamp().equals(tag.getTimestamp()));
    assertEquals(false, currentAlarmState.isActive()); //also update alarm parameter object (usually in cache)
    assertTrue(currentAlarmState.getSourceTimestamp().equals(tag.getTimestamp()));
  }",No Smells
"@Test
  public void testCacheLoading() {
    assertNotNull(dataTagCache);
    
    List<DataTag> dataTagList = dataTagMapper.getAll();
    
    //test the cache was loaded correctly
    assertEquals(dataTagList.size(), dataTagCache.getCache().getKeys().size());
    //compare all the objects from the cache and buffer
    Iterator<DataTag> it = dataTagList.iterator();
    while (it.hasNext()) {
      DataTag currentTag = (DataTag) it.next();
      //equality of DataTagCacheObjects => currently only compares names (do not change when DAQs are running on same DB)
      assertEquals(currentTag.getName(), ((DataTagCacheObject) dataTagCache.getCopy(currentTag.getId())).getName());
    }",Eager Test
"@Test
  public void testCreateCacheObjectForSubEquipment() throws IllegalAccessException {
    Properties properties = new Properties();
    properties.put(""minValue"", 1);
    properties.put(""maxValue"", 20);
    properties.put(""name"", ""tag_name"");
    properties.put(""dataType"", ""String"");
    properties.put(""mode"", 0);
    properties.put(""subEquipmentId"", ""30"");
    properties.put(""address"", ""<DataTagAddress><HardwareAddress class=\""cern.c2mon.shared.common.datatag.address.impl"" +
        "".JAPCHardwareAddressImpl\""><protocol>yami</protocol><service>yami</service><device-name>TEST.CLIC"" +
        "".DIAMON.1</device-name><property-name>Acquisition</property-name><data-field-name>sys.mem"" +
        "".inactpct</data-field-name><column-index>-1</column-index><row-index>-1</row-index></HardwareAddress><time-to-live>3600000</time-to-live><priority>2"" +
        ""</priority><guaranteed-delivery>false</guaranteed-delivery></DataTagAddress>"");

    dataTagCache.acquireReadLockOnKey(11L);
    dataTagCache.acquireWriteLockOnKey(11L);
    EasyMock.expect(subEquipmentFacade.getProcessIdForAbstractEquipment(30L)).andReturn(2L);
    dataTagCache.releaseReadLockOnKey(11L);
    dataTagCache.releaseWriteLockOnKey(11L);

    EasyMock.replay(subEquipmentFacade);

    DataTag tag = dataTagFacade.createCacheObject(11L, properties);
    EasyMock.verify(subEquipmentFacade);
  }",No Smells
"@Test
  public void testGetAll() {
    int tableSize = alarmMapper.getNumberItems();
    int alarmsRetrieved = alarmMapper.getAll().size();
    assertEquals(tableSize, alarmsRetrieved);
  }",No Smells
"@Test
  public void testRetrieveProcessAlive() {
//    Process process = CacheObjectCreation.createTestProcess1();
//    ControlTag aliveTag = CacheObjectCreation.createTestProcessAlive();
//    Equipment equipment = CacheObjectCreation.createTestEquipment();
    //id in control tag cache is the same as in alivetimer cache
    AliveTimerCacheObject retrievedCacheObject = (AliveTimerCacheObject) aliveTimerMapper.getItem(1221L);
//    assertEquals(aliveTag.getId(), retrievedCacheObject.getId());
    assertTrue(60000L == retrievedCacheObject.getAliveInterval());
    assertEquals(""PROC"", retrievedCacheObject.getAliveType());
    assertTrue(50L == retrievedCacheObject.getRelatedId());
    assertEquals(""P_TESTHANDLER03"", retrievedCacheObject.getRelatedName());
    assertTrue(1220L == retrievedCacheObject.getRelatedStateTagId());
    assertTrue(retrievedCacheObject.getDependentAliveTimerIds().size() == 1); //2 dependent alive timers (eq and subeq)
    assertTrue(retrievedCacheObject.getDependentAliveTimerIds().contains(1224L));
    //assertTrue(retrievedCacheObject.getDependentAliveTimerIds().contains(testDataHelper.getSubEquipment().getAliveTagId())); only contains equipment alives!
  }",No Smells
"@Test
  public void testGetCommandTag() {
    //construct fake DataTagCacheObject, setting all fields
    CommandTagCacheObject cacheObject = new CommandTagCacheObject(200_000L);
    cacheObject.setName(""Junit_test_command_tag""); //non null
    cacheObject.setDescription(""test description"");
    cacheObject.setMode(DataTagConstants.MODE_TEST); //non null
    cacheObject.setDataType(""Integer""); // non null
    cacheObject.setHardwareAddress(new SimpleHardwareAddressImpl(""test hardware address""));
    cacheObject.setEquipmentId(150L); //need test equipment inserted - use EquipmentMapperTest
    cacheObject.setMaximum(23);
    cacheObject.setMinimum(10);
    Metadata metadata = new Metadata();
    metadata.addMetadata(""String"", 11);
    cacheObject.setMetadata(metadata);
    cacheObject.setProcessId(50L); //need test process also (P_JAPC01)
    cacheObject.setSourceTimeout(10);
    cacheObject.setSourceRetries(2);
    cacheObject.setExecTimeout(10);
    cacheObject.setClientTimeout(3);
    RbacAuthorizationDetails rbac = new RbacAuthorizationDetails();
    rbac.setRbacProperty(""property"");
    rbac.setRbacDevice(""device"");
    rbac.setRbacClass(""class"");
    cacheObject.setAuthorizationDetails(rbac);
    //put in database
    commandTagMapper.insertCommandTag(cacheObject);

    //retrieve and check successful
    CommandTagCacheObject retrievedCommand = (CommandTagCacheObject) commandTagMapper.getItem(cacheObject.getId());
    assertNotNull(retrievedCommand);
    CacheObjectComparison.equals(cacheObject, retrievedCommand);
  }",No Smells
"@Test
  public void testUpdate() {
    CommandTagCacheObject modifiedCommand = new CommandTagCacheObject(commandTag);
    //below: must all be different then values set in create method above
    modifiedCommand.setName(""new name"");
    modifiedCommand.setDescription(""new description"");
    modifiedCommand.setDataType(""Integer"");
    modifiedCommand.setMode(DataTagConstants.MODE_TEST);
    modifiedCommand.setEquipmentId(160L);
    //must change process manually here for assertions work...
    modifiedCommand.setProcessId(50L);
    try {
      modifiedCommand.setHardwareAddress(new OPCHardwareAddressImpl(""newAddress""));
    }",No Smells
"@Test
  public void testIsInDB() {
    assertTrue(controlTagMapper.isInDb(1230L));
  }",No Smells
"@Test
  public void testUpdateControlTag() {
    ControlTagCacheObject cacheObject = CacheObjectCreation.createTestControlTag();
    controlTagMapper.insertControlTag(cacheObject);

    assertTrue(cacheObject.getDataType().equals(""Float""));
    cacheObject.setValue(Float.valueOf(1999f));
    cacheObject.setCacheTimestamp(new Timestamp(System.currentTimeMillis()));
    cacheObject.setSourceTimestamp(new Timestamp(System.currentTimeMillis()));
    cacheObject.setValueDescription(""new control value"");
    cacheObject.setDataTagQuality(new DataTagQualityImpl(TagQualityStatus.PROCESS_DOWN, ""Process down.""));
    cacheObject.setSimulated(false);

    controlTagMapper.updateCacheable(cacheObject);

    ControlTagCacheObject retrievedObject = (ControlTagCacheObject) controlTagMapper.getItem(cacheObject.getId());

    assertEquals(cacheObject.getValue(), retrievedObject.getValue());
    assertEquals(Float.class, retrievedObject.getValue().getClass());
    assertEquals(cacheObject.getValueDescription(), retrievedObject.getValueDescription());
    assertEquals(cacheObject.getDataTagQuality(), retrievedObject.getDataTagQuality());//quality compare code and string
    assertEquals(cacheObject.getTimestamp(), retrievedObject.getTimestamp());
    assertEquals(cacheObject.getSourceTimestamp(), retrievedObject.getSourceTimestamp());
    assertEquals(cacheObject.isSimulated(), retrievedObject.isSimulated());

  }",No Smells
"@Test
  public void testUpdateDataTag() {
    // construct fake DataTagCacheObject
    DataTagCacheObject cacheObject = new DataTagCacheObject();
    cacheObject.setId(150000L); // must be non null in DB
    cacheObject.setName(""Junit_test_tag""); // non null
    cacheObject.setMode(DataTagConstants.MODE_TEST); // non null
    cacheObject.setDataType(""Boolean""); // non null
    cacheObject.setEquipmentId(150L); // need test equipment inserted
    Metadata metadata = new Metadata();
    metadata.addMetadata(""metadata"", 11);
    cacheObject.setMetadata(metadata);

    dataTagMapper.insertDataTag(cacheObject);

    cacheObject.setValue(Boolean.TRUE);
    cacheObject.setValueDescription(""test value description"");
    cacheObject.setSimulated(false); // null allowed
    cacheObject.setDataTagQuality(new DataTagQualityImpl(TagQualityStatus.UNDEFINED_VALUE, ""undefined value""));
    cacheObject.setCacheTimestamp(new Timestamp(System.currentTimeMillis()));
    cacheObject.setSourceTimestamp(new Timestamp(System.currentTimeMillis()));
    metadata = new Metadata();
    metadata.addMetadata(""metadata_boolean"", true);
    cacheObject.setMetadata(metadata);

    dataTagMapper.updateCacheable(cacheObject);

    DataTagCacheObject retrievedObject = (DataTagCacheObject) dataTagMapper.getItem(new Long(150000));

    // updated values are changed
    assertEquals(cacheObject.getValue(), retrievedObject.getValue());
    assertEquals(cacheObject.getValueDescription(), retrievedObject.getValueDescription());
    assertEquals(cacheObject.isSimulated(), retrievedObject.isSimulated());
    assertEquals(cacheObject.getDataTagQuality(), retrievedObject.getDataTagQuality());
    assertEquals(cacheObject.getTimestamp(), retrievedObject.getTimestamp());
    assertEquals(cacheObject.getSourceTimestamp(), retrievedObject.getSourceTimestamp());
    metadata = new Metadata();
    metadata.addMetadata(""metadata"", 11);
    assertEquals(metadata, retrievedObject.getMetadata());

    // other values should be the same or ...
    assertEquals(cacheObject.getId(), retrievedObject.getId());
    assertEquals(cacheObject.getName(), retrievedObject.getName());
    assertEquals(cacheObject.getMode(), retrievedObject.getMode());
    assertEquals(cacheObject.getDataType(), retrievedObject.getDataType());

    // ... null/default
    assertNull(retrievedObject.getDescription());
    assertEquals(false, retrievedObject.isLogged()); // default boolean
    assertNull(retrievedObject.getUnit());
    assertNull(retrievedObject.getDipAddress());
    assertNull(retrievedObject.getJapcAddress());
    assertNull(retrievedObject.getMinValue());
    assertNull(retrievedObject.getMaxValue());
    assertNull(retrievedObject.getAddress());

    dataTagMapper.deleteDataTag(cacheObject.getId());
  }",Eager Test
"@Test
  public void testGetAll() {
    List<DeviceClass> deviceClasses = deviceClassMapper.getAll();
    Assert.assertNotNull(deviceClasses);
    Assert.assertTrue(deviceClasses.size() == 2);

    for (DeviceClass deviceClass : deviceClasses) {
      Assert.assertFalse(deviceClass.getProperties().size() == 0);
    }",Eager Test
"@Test
  public void testInsertDeviceClass() throws ClassNotFoundException {
    DeviceClassCacheObject deviceClass = new DeviceClassCacheObject(402L, ""TEST_DEVICE_CLASS_3"", ""Description of TEST_DEVICE_CLASS_3"");

    List<Property> properties = new ArrayList<>();

    properties.add(new Property(10L, ""TEST_PROPERTY_1"", ""Test property 1""));
    properties.add(new Property(11L, ""TEST_PROPERTY_2"", ""Test property 2""));

    List<Property> fields = new ArrayList<>();
    fields.add(new Property(12L, ""TEST_FIELD_1"", null));
    fields.add(new Property(13L, ""TEST_FIELD_2"", null));

    properties.add(new Property(14L, ""TEST_PROPERTY_WITH_FIELDS"", ""Test property with fields"", fields));

    deviceClass.setProperties(properties);

    deviceClass.setCommands(Arrays.asList(new Command(10L, ""TEST_COMMAND_1"", ""Test command 1""), new Command(11L, ""TEST_COMMAND_2"", ""Test command 2"")));

    deviceClassMapper.insertDeviceClass(deviceClass);
    for (Property property : ((DeviceClassCacheObject) deviceClass).getProperties()) {
      deviceClassMapper.insertDeviceClassProperty(deviceClass.getId(), property);

      if (property.getFields() != null) {
        for (Property field : property.getFields()) {
          deviceClassMapper.insertDeviceClassField(property.getId(), field);
        }",Eager Test
"@Test
  public void testGetAll() {
    List<Device> devices = deviceMapper.getAll();
    Assert.assertNotNull(devices);
    Assert.assertTrue(devices.size() == 4);
  }",No Smells
"@Test
  public void testIsInDb() {
    Assert.assertTrue(deviceMapper.isInDb(300L));
    Assert.assertTrue(deviceMapper.isInDb(301L));
  }",No Smells
"@Test
  public void getByName() {
    Long retrievedId = equipmentMapper.getIdByName(""E_TESTHANDLER_TESTHANDLER03"");
    assertTrue(retrievedId == 150L);
  }",No Smells
"@Test
  public void testInsertAndRetrieve() {
//      EquipmentCacheObject equipmentCacheObject = createTestEquipment();
//      equipmentMapper.insertEquipment(equipmentCacheObject);
//      SubEquipmentCacheObject subEquipmentCacheObject = createTestSubEquipment();
//      subEquipmentMapper.insertSubEquipment(subEquipmentCacheObject);
//      DataTagCacheObject dataTagCacheObject = DataTagMapperTest.createTestDataTag();
//      dataTagMapper.insertDataTag(dataTagCacheObject);
    EquipmentCacheObject retrievedObject = (EquipmentCacheObject) equipmentMapper.getItem(equipmentCacheObject.getId());
    assertEquals(equipmentCacheObject.getId(), retrievedObject.getId());
    assertEquals(equipmentCacheObject.getName(), retrievedObject.getName());
    assertEquals(equipmentCacheObject.getAddress(), retrievedObject.getAddress());
    assertEquals(equipmentCacheObject.getAliveInterval(), retrievedObject.getAliveInterval());
    assertEquals(equipmentCacheObject.getAliveTagId(), retrievedObject.getAliveTagId());
    assertEquals(equipmentCacheObject.getStatusDescription(), retrievedObject.getStatusDescription());
    assertEquals(equipmentCacheObject.getStatusTime(), retrievedObject.getStatusTime());
    assertEquals(equipmentCacheObject.getSupervisionStatus(), retrievedObject.getSupervisionStatus());
    assertEquals(equipmentCacheObject.getCommFaultTagId(), retrievedObject.getCommFaultTagId());
    assertEquals(equipmentCacheObject.getProcessId(), retrievedObject.getProcessId());
    assertEquals(equipmentCacheObject.getStateTagId(), retrievedObject.getStateTagId());
    assertEquals(equipmentCacheObject.getHandlerClassName(), retrievedObject.getHandlerClassName());
    assertEquals(equipmentCacheObject.getDescription(), retrievedObject.getDescription());

    List<Long> subEquipmentIds = new LinkedList<Long>();
    subEquipmentIds.add(subEquipmentCacheObject.getId());
//    subEquipmentIds.add(subEquipmentCacheObject2.getId());
    assertEquals(subEquipmentIds, retrievedObject.getSubEquipmentIds());
    assertTrue(retrievedObject.getCommandTagIds().contains(commandTag.getId())); //check it contains the commandtag

    //assertEquals(dataTagCacheObject.getId(), retrievedObject.getDataTagIds().iterator().next()); //TODO just one in array so far
  }",No Smells
"@Test
  public void testUpdateConfig() {
    assertEquals(new Long(1224), equipmentCacheObject.getAliveTagId());
    equipmentCacheObject.setAliveTagId(1251L);
    equipmentCacheObject.setCommFaultTagId(1252L);
    equipmentCacheObject.setStateTagId(1250L);
    equipmentMapper.updateEquipmentConfig(equipmentCacheObject);
    Equipment updatedEquipment = equipmentMapper.getItem(equipmentCacheObject.getId());
    assertEquals(new Long(1251), updatedEquipment.getAliveTagId());
    assertEquals(new Long(1252), updatedEquipment.getCommFaultTagId());
    assertEquals(new Long(1250), updatedEquipment.getStateTagId());
  }",No Smells
"@Test
  public void testGetAll() {
    List<Cacheable> returnList = processMapper.getAll();
    assertTrue(returnList.size() > 0);
  }",No Smells
"@Test
  public void testIsInDB() {
    assertTrue(processMapper.isInDb(50L));
  }",No Smells
"@Test
  public void testNotInDB() {
    assertFalse(processMapper.isInDb(150L));
  }",No Smells
"@Test
  public void testGetNumberItems() {
    assertTrue(ruleTagMapper.getNumberItems() > 5);
  }",No Smells
"@Test
  public void testNotInDB() {
    assertFalse(ruleTagMapper.isInDb(200000L));
  }",No Smells
"@Test
  public void testUpdateRuleTag() {
    RuleTagCacheObject ruleTag = CacheObjectCreation.createTestRuleTag();
    ruleTagMapper.insertRuleTag(ruleTag);

    ruleTag.setValue(new Integer(2000));
    ruleTag.setCacheTimestamp(new Timestamp(System.currentTimeMillis()));
    ruleTag.setValueDescription(""new control value"");
    ruleTag.setDataTagQuality(new DataTagQualityImpl(TagQualityStatus.UNKNOWN_REASON, ""test quality unknown reason""));
    ruleTag.setSimulated(false);

    ruleTagMapper.updateCacheable(ruleTag);

    RuleTagCacheObject retrievedObject = (RuleTagCacheObject) ruleTagMapper.getItem(ruleTag.getId());

    assertEquals(ruleTag.getValue(), retrievedObject.getValue());
    assertEquals(ruleTag.getValueDescription(), retrievedObject.getValueDescription());
    assertEquals(ruleTag.getDataTagQuality(), retrievedObject.getDataTagQuality());
    assertEquals(ruleTag.getTimestamp(), retrievedObject.getTimestamp());
    assertEquals(ruleTag.isSimulated(), retrievedObject.isSimulated());
  }",No Smells
"@Test
  public void testRetrieve() {
//    EquipmentCacheObject equipmentCacheObject = EquipmentMapperTest.createTestEquipment();
//    equipmentMapper.insertEquipment(equipmentCacheObject);
//    SubEquipmentCacheObject subEquipmentCacheObject = EquipmentMapperTest.createTestSubEquipment();
//    subEquipmentMapper.insertSubEquipment(subEquipmentCacheObject);
    SubEquipmentCacheObject retrievedObject = (SubEquipmentCacheObject) subEquipmentMapper.getItem(subEquipmentCacheObject.getId());
    assertEquals(subEquipmentCacheObject.getId(), retrievedObject.getId());
    assertEquals(subEquipmentCacheObject.getName(), retrievedObject.getName());
    assertEquals(subEquipmentCacheObject.getAliveInterval(), retrievedObject.getAliveInterval());
    assertEquals(subEquipmentCacheObject.getAliveTagId(), retrievedObject.getAliveTagId());
    assertEquals(subEquipmentCacheObject.getCommFaultTagId(), retrievedObject.getCommFaultTagId());
    assertEquals(subEquipmentCacheObject.getStateTagId(), retrievedObject.getStateTagId());
    assertEquals(subEquipmentCacheObject.getHandlerClassName(), retrievedObject.getHandlerClassName());
    assertEquals(subEquipmentCacheObject.getDescription(), retrievedObject.getDescription());
    assertEquals(subEquipmentCacheObject.getParentId(), retrievedObject.getParentId());
    assertEquals(subEquipmentCacheObject.getStatusDescription(), retrievedObject.getStatusDescription());
    assertEquals(subEquipmentCacheObject.getStatusTime(), retrievedObject.getStatusTime());
    assertEquals(subEquipmentCacheObject.getSupervisionStatus(), retrievedObject.getSupervisionStatus());
  }",No Smells
"@Test
  public void testSelectSubEquipmentsByEquipment() {
    List<SubEquipment> subEquipmentList = subEquipmentMapper.selectSubEquipmentsByEquipment(subEquipmentCacheObject.getParentId());
    assertEquals(1, subEquipmentList.size());
  }",No Smells
"@Test
  public void testUpdateConfig() {
    assertEquals(new Long(1231), subEquipmentCacheObject.getAliveTagId());
    subEquipmentCacheObject.setAliveTagId(1251L);
    subEquipmentCacheObject.setCommFaultTagId(1252L);
    subEquipmentCacheObject.setStateTagId(1250L);
    subEquipmentMapper.updateSubEquipmentConfig(subEquipmentCacheObject);
    SubEquipment updatedEquipment = subEquipmentMapper.getItem(subEquipmentCacheObject.getId());
    assertEquals(new Long(1251), updatedEquipment.getAliveTagId());
    assertEquals(new Long(1252), updatedEquipment.getCommFaultTagId());
    assertEquals(new Long(1250), updatedEquipment.getStateTagId());
  }",No Smells
"@Test
  public void testGetDevices() {
    // Reset the mock
    EasyMock.reset(deviceCacheMock, deviceClassCacheMock);

    String deviceClassName = ""test_device_class_name"";
    DeviceClassCacheObject deviceClassReturn = new DeviceClassCacheObject(1L, ""test_device_class_name_1"", ""Test description"");

    List<Long> deviceIds = new ArrayList<>();
    deviceIds.add(1000L);
    deviceIds.add(2000L);
    deviceClassReturn.setDeviceIds(deviceIds);

    DeviceCacheObject device1 = new DeviceCacheObject(1000L, ""test_device_1"", 1L);
    device1.setDeviceProperties(new ArrayList<>(Arrays.asList(new DeviceProperty(10L, ""test_property"", ""10"", ""tagId"", null))));
    device1.setDeviceCommands(new ArrayList<>(Arrays.asList(new DeviceCommand(10L, ""test_command"", ""20"", ""commandTagId"", null))));
    Device device2 = new DeviceCacheObject(2000L, ""test_device_2"", 1L);

    List<Device> deviceReturn = new ArrayList<>();
    deviceReturn.add(device1);
    deviceReturn.add(device2);

    // Expect the facade to get the device class object
    EasyMock.expect(deviceClassCacheMock.getDeviceClassIdByName(deviceClassName)).andReturn(deviceClassReturn.getId());
    EasyMock.expect(deviceCacheMock.getByDeviceClassId(deviceClassReturn.getId())).andReturn(deviceReturn);

    // Setup is finished, need to activate the mock
    EasyMock.replay(deviceCacheMock, deviceClassCacheMock);

    List<Device> devices = deviceFacade.getDevices(deviceClassName);
    Assert.assertTrue(devices.get(0).getId() == device1.getId());
    Assert.assertTrue(devices.get(1).getId() == device2.getId());
    Assert.assertTrue(devices.get(0).getDeviceClassId() == device1.getDeviceClassId());
    Assert.assertTrue(devices.get(1).getDeviceClassId() == device2.getDeviceClassId());

    // Verify that everything happened as expected
    EasyMock.verify(deviceCacheMock, deviceClassCacheMock);
  }",No Smells
"@Test
  public void testGetAll() {
    assertNotNull(controlTagLoaderDAO.getAllAsMap());
    assertTrue(controlTagLoaderDAO.getAllAsMap().size() > 10);
  }",No Smells
"@Test
  public void testGetItem() {
    assertNotNull(controlTagLoaderDAO.getItem(1260L));
  }",No Smells
"@Test
  public void testCacheLoading() {
    assertNotNull(ruleTagCache);

    List<RuleTag> ruleList = ruleTagMapper.getAll(); //IN FACT: GIVES TIME FOR CACHE TO FINISH LOADING ASYNCH BEFORE COMPARISON BELOW...

    //test the cache is the same size as in DB
    assertEquals(ruleList.size(), ruleTagCache.getCache().getKeys().size());
    //compare all the objects from the cache and buffer
    Iterator<RuleTag> it = ruleList.iterator();
    while (it.hasNext()) {
      RuleTagCacheObject currentRule = (RuleTagCacheObject) it.next();
      //only compares one field so far (name, which does not change when server is running!)
      assertEquals(currentRule.getName(), (((RuleTag) ruleTagCache.getCopy(currentRule.getId())).getName()));
    }",Eager Test
"@Test
  public void testGetCopy() {
    RuleTagCacheObject cacheObject = (RuleTagCacheObject) ruleTagCache.getCopy(60002L);
    RuleTagCacheObject objectInDb = (RuleTagCacheObject) ruleTagMapper.getItem(60002L);
    //Servertimestamp is always set when creating the object, so the second call above should have a t.s. that is later (first
    // is set when loading cache from DB)
    assertTrue(objectInDb.getTimestamp().after(cacheObject.getTimestamp()));
    //reset t.s. for comparison method to succeed
    objectInDb.setCacheTimestamp(cacheObject.getCacheTimestamp());
    CacheObjectComparison.equalsTag(cacheObject, objectInDb);
  }",No Smells
"@Test
  public void testGetTagByName() {
    Assert.assertNull(ruleTagCache.get(""does not exist""));
    
    Tag tag = ruleTagCache.get(""DIAMON_clic_CS-CCR-DEV3"");
    Assert.assertNotNull(tag);
    Assert.assertEquals(Long.valueOf(60000L), tag.getId());
    Assert.assertEquals(""Integer"", tag.getDataType());
    
    tag = ruleTagCache.get(""RULE_WITH_MuLtIpLe_PARENTS"");
    Assert.assertNotNull(tag);
    Assert.assertEquals(Long.valueOf(60011L), tag.getId());
    Assert.assertEquals(""Integer"", tag.getDataType()); 
  }",No Smells
"@Test
  public void testParentIdLoading() {
   // first remove the object from the cache
   ruleTagCache.remove(60011L);

   //load from DB & check parent ids
   RuleTag rule = ruleTagCache.loadFromDb(60011L);
   assertNotNull(rule);
   assertEquals(2, rule.getProcessIds().size());
   assertEquals(2, rule.getEquipmentIds().size());
   assertTrue(rule.getProcessIds().contains(50L));
   assertTrue(rule.getProcessIds().contains(51L));
   assertTrue(rule.getEquipmentIds().contains(150L));
   assertTrue(rule.getEquipmentIds().contains(170L));
  }",No Smells
"@Test
  public void testAddSupervisionQuality() {
    RuleTagCacheObject tag = new RuleTagCacheObject(1L);
    SupervisionEvent event = new SupervisionEventImpl(SupervisionEntity.PROCESS, 10L, ""P_TEST"", SupervisionStatus.DOWN, new Timestamp(System.currentTimeMillis()), ""test message"");

    mockControl.replay();

    supervisionAppender.addSupervisionQuality(tag, event);

    mockControl.verify();

    assertTrue(!tag.isValid());
    assertTrue(tag.getDataTagQuality().isInvalidStatusSet(TagQualityStatus.PROCESS_DOWN));
    assertTrue(!tag.getDataTagQuality().isInvalidStatusSet(TagQualityStatus.EQUIPMENT_DOWN));
    assertTrue(tag.getDataTagQuality().getDescription().equals(""test message""));
  }",No Smells
"@Test
  public void testEmptyClientMetadata(){
    Metadata currentMetadata = new Metadata();
    currentMetadata.addMetadata(""key"", ""value"");
    Properties properties = new Properties();
    properties.put(""metadata"","""");

    Metadata result = MetadataUtils.parseMetadataConfiguration(properties, currentMetadata);

    assertEquals(currentMetadata, result);
  }",No Smells
"@Test
  public void testUpdateWithNullMetadataProperty(){
    Metadata currentMetadata = new Metadata();
    String currentKey = ""currentKey"";
    currentMetadata.addMetadata(currentKey, null);
    cern.c2mon.shared.client.metadata.Metadata clientMetadata = new cern.c2mon.shared.client.metadata.Metadata();
    clientMetadata.setUpdate(true);
    Properties properties = new Properties();
    properties.put(""metadata"",  cern.c2mon.shared.client.metadata.Metadata.toJSON(clientMetadata));

    Metadata result = MetadataUtils.parseMetadataConfiguration(properties, currentMetadata);

    assertEquals(1, result.getMetadata().size());
    assertTrue(result.getMetadata().containsKey(currentKey));
    assertEquals(currentMetadata.getMetadata().get(currentKey), result.getMetadata().get(currentKey));
  }",No Smells
"@Test
  public void testListenerNotified() throws InterruptedException {
    HeartbeatListener mockListener = EasyMock.createMock(HeartbeatListener.class);
    CountDownLatch latch = new CountDownLatch(3);

    mockListener.notifyHeartbeat(EasyMock.isA(Heartbeat.class));
    EasyMock.expectLastCall().andAnswer(() -> { latch.countDown(); return null; }",No Smells
"@Test
  public void testAlarmValueMessageConversion() {
    JsonRequest<AlarmValue> request = new ClientRequestImpl<AlarmValue>(AlarmValue.class);

    TextMessage message = new ActiveMQTextMessage();
    try {
      message.setText(request.toJson());
      ClientRequest receivedRequest = ClientRequestMessageConverter.fromMessage(message);

      assertTrue(receivedRequest.getRequestType() == ClientRequest.RequestType.ALARM_REQUEST);
      assertTrue(receivedRequest.getResultType() == ClientRequest.ResultType.TRANSFER_ALARM_LIST);
    }",No Smells
"@Test
  public void testConfigurationReportMessageConversion() {
    JsonRequest<ConfigurationReport> request = new ClientRequestImpl<ConfigurationReport>(ConfigurationReport.class);

    TextMessage message = new ActiveMQTextMessage();
    try {
      message.setText(request.toJson());
      ClientRequest receivedRequest = ClientRequestMessageConverter.fromMessage(message);

      assertTrue(receivedRequest.getRequestType() == ClientRequest.RequestType.APPLY_CONFIGURATION_REQUEST);
      assertTrue(receivedRequest.getResultType() == ClientRequest.ResultType.TRANSFER_CONFIGURATION_REPORT);
    }",No Smells
"@Test
  public void testProcessNamesMessageConversion() {

    ClientRequestImpl<ProcessNameResponse> request = new ClientRequestImpl<ProcessNameResponse>(ProcessNameResponse.class);

    TextMessage message = new ActiveMQTextMessage();
    try {
      message.setText(request.toJson());
      ClientRequest receivedRequest = ClientRequestMessageConverter.fromMessage(message);

      assertTrue(receivedRequest.getRequestType() == ClientRequest.RequestType.PROCESS_NAMES_REQUEST);
      assertTrue(receivedRequest.getResultType() == ClientRequest.ResultType.TRANSFER_PROCESS_NAMES);
    }",No Smells
"@Test
  public void testTagConfigMessageConversion() {
    JsonRequest<TagConfig> request = new ClientRequestImpl<TagConfig>(TagConfig.class);

    TextMessage message = new ActiveMQTextMessage();
    try {
      message.setText(request.toJson());
      ClientRequest receivedRequest = ClientRequestMessageConverter.fromMessage(message);

      assertTrue(receivedRequest.getRequestType() == ClientRequest.RequestType.TAG_CONFIGURATION_REQUEST);
      assertTrue(receivedRequest.getResultType() == ClientRequest.ResultType.TRANSFER_TAG_CONFIGURATION_LIST);
    }",No Smells
"@Test
  public void testTransferTagValueMessageConversion() {
    JsonRequest<TagValueUpdate> request = new ClientRequestImpl<TagValueUpdate>(TagValueUpdate.class);

    TextMessage message = new ActiveMQTextMessage();
    try {
      message.setText(request.toJson());
      ClientRequest receivedRequest = ClientRequestMessageConverter.fromMessage(message);

      assertTrue(receivedRequest.getRequestType() == ClientRequest.RequestType.TAG_REQUEST);
      assertTrue(receivedRequest.getResultType() == ClientRequest.ResultType.TRANSFER_TAG_VALUE_LIST);
    }",No Smells
"@Test
  public void testFailToPublish() throws InterruptedException {
    republisher.start();

    Object publishedObject1 = new Object();
    Object publishedObject2 = new Object();
    Object publishedObject3 = new Object();

    publisher.publish(publishedObject1); //failure
    EasyMock.expectLastCall().andThrow(new UncategorizedJmsException("""")).anyTimes();
    publisher.publish(publishedObject2); //failure
    EasyMock.expectLastCall().andThrow(new UncategorizedJmsException("""")).anyTimes();
    publisher.publish(publishedObject3); //failure
    EasyMock.expectLastCall().andThrow(new UncategorizedJmsException("""")).anyTimes();

    control.replay();

    republisher.publicationFailed(publishedObject1);
    republisher.publicationFailed(publishedObject2);
    republisher.publicationFailed(publishedObject3);

    Thread.sleep(1000);

    assertTrue(republisher.getNumberFailedPublications() > 0);
    assertEquals(3, republisher.getSizeUnpublishedList());

    control.verify();
  }",No Smells
"@Test
  public void testMultipleRepublication() throws InterruptedException {
    republisher.start();

    Object publishedObject1 = new Object();
    Object publishedObject2 = new Object();
    Object publishedObject3 = new Object();

    //republication succeeds
    publisher.publish(publishedObject1);
    publisher.publish(publishedObject2);
    publisher.publish(publishedObject3);

    control.replay();

    republisher.publicationFailed(publishedObject1);
    republisher.publicationFailed(publishedObject2);
    republisher.publicationFailed(publishedObject3);

    Thread.sleep(500);

    assertEquals(3, republisher.getNumberFailedPublications()); //the manual publicationFailed calls
    assertEquals(0, republisher.getSizeUnpublishedList());

    control.verify();
  }",No Smells
"@Test
  public void testProcessListConverter() {
    ProcessListConverter converter = new ProcessListConverter();

    String list = ""[P_TEST01, P_TEST02]"";
    Set<String> processList = converter.convert(list);
    assertTrue(processList.size() == 2);
    assertTrue(processList.contains(""P_TEST01""));
    assertTrue(processList.contains(""P_TEST02""));

    list = ""[P_TEST01]"";
    processList = converter.convert(list);
    assertTrue(processList.size() == 1);
    assertTrue(processList.contains(""P_TEST01""));

    list = ""[]"";
    processList = converter.convert(list);
    assertTrue(processList.size() == 0);
  }",No Smells
"@Test

  public void testRemoveDeviceClass() {
    DeviceClass deviceClass = deviceClassCache.get(400L);
    assertNotNull(deviceClass);
    assertTrue(deviceClassCache.hasKey(400L));
    assertNotNull(deviceClassMapper.getItem(400L));

    replay(mockManager);

    ConfigurationReport report = configurationLoader.applyConfiguration(33);

    assertFalse(report.toXML().contains(Status.FAILURE.toString()));

    deviceClass = deviceClassCache.get(400L);
    assertTrue(((DeviceClassCacheObject) deviceClass).getDeviceIds().size() == 3);

    Device device = deviceCache.get(20L);
    assertNotNull(device);

    report = configurationLoader.applyConfiguration(32);

    assertFalse(report.toXML().contains(Status.FAILURE.toString()));
    assertFalse(deviceClassCache.hasKey(400L));
    DeviceClass cacheObject = deviceClassMapper.getItem(400L);
    assertNull(cacheObject);

    verify(mockManager);
  }",No Smells
"@Test
  public void testNotEmptyUpdateDataTag() throws IllegalAccessException {
    control.reset();

    DataTagCacheObject dataTag = CacheObjectCreation.createTestDataTag();
    // mimic the actions of the datatag facade
    DataTagUpdate update = new DataTagUpdate();
    update.setDataTagId(dataTag.getId());
    update.setEquipmentId(dataTag.getEquipmentId());
    dataTagCache.acquireWriteLockOnKey(dataTag.getId());
    EasyMock.expect(dataTagCache.getCopy(dataTag.getId())).andReturn(dataTag);
    dataTagCache.put(dataTag.getId(), dataTag);
    EasyMock.expectLastCall();
    EasyMock.expect(dataTagFacade.updateConfig(dataTag, new Properties())).andReturn(update);
    dataTagLoaderDAO.updateConfig(dataTag);
    dataTagCache.releaseWriteLockOnKey(dataTag.getId());

    control.replay();

    ProcessChange change = dataTagConfigTransacted.doUpdateDataTag(dataTag.getId(), new Properties());
    assertFalse(change.processActionRequired());
    assertEquals(null, change.getProcessId());

    control.verify();
  }",No Smells
"@Test
  public void testUpdateDAQRelatedPropertiesOfDataTag() throws IllegalAccessException {
    control.reset();

    DataTagCacheObject dataTag = CacheObjectCreation.createTestDataTag();

    DataTagUpdate update = new DataTagUpdate();
    update.setDataTagId(dataTag.getId());
    update.setEquipmentId(dataTag.getEquipmentId());
    update.setDataTagAddressUpdate(new DataTagAddressUpdate());

    Properties properties = new Properties();
    properties.put(""address"", ""new address"");
    properties.put(""dataType"", ""new data type"");
    properties.put(""minValue"", ""new min val"");
    properties.put(""maxValue"", ""new max val"");

    dataTagCache.acquireWriteLockOnKey(dataTag.getId());

    EasyMock.expect(dataTagCache.getCopy(dataTag.getId())).andReturn(dataTag);
    dataTagCache.put(dataTag.getId(), dataTag);
    EasyMock.expectLastCall();
    EasyMock.expect(dataTagFacade.updateConfig(dataTag, properties)).andReturn(update);
    EasyMock.expect(equipmentFacade.getProcessIdForAbstractEquipment(dataTag.getEquipmentId())).andReturn(50L);

    dataTagLoaderDAO.updateConfig(dataTag);
    dataTagCache.releaseWriteLockOnKey(dataTag.getId());

    control.replay();

    ProcessChange change = dataTagConfigTransacted.doUpdateDataTag(dataTag.getId(), properties);
    assertTrue(change.processActionRequired());
    assertEquals(Long.valueOf(50), change.getProcessId());

    control.verify();
  }",No Smells
"@Test
  public void testUpdateNonDAQRelatedPropertiesOfDataTag() throws IllegalAccessException {
    control.reset();
    DataTagCacheObject dataTag = CacheObjectCreation.createTestDataTag();

    DataTagUpdate update = new DataTagUpdate();
    update.setDataTagId(dataTag.getId());
    update.setEquipmentId(dataTag.getEquipmentId());

    // Update all properties that do not require DAQ reconfiguration
    Properties properties = new Properties();
    properties.put(""id"", dataTag.getId());
    properties.put(""description"", ""new description"");
    properties.put(""mode"", ""new mode"");
    properties.put(""isLogged"", ""new logged"");
    properties.put(""unit"", ""new unit"");
    properties.put(""equipmentId"", dataTag.getEquipmentId());
    properties.put(""valueDictionary"", ""new dict"");
    properties.put(""japcAddress"", ""new japc address"");
    properties.put(""dipAddress"", ""new dip address"");

    dataTagCache.acquireWriteLockOnKey(dataTag.getId());

    EasyMock.expect(dataTagCache.getCopy(dataTag.getId())).andReturn(dataTag);
    dataTagCache.put(dataTag.getId(), dataTag);
    EasyMock.expectLastCall();
    EasyMock.expect(dataTagFacade.updateConfig(dataTag, properties)).andReturn(update);

    dataTagLoaderDAO.updateConfig(dataTag);
    dataTagCache.releaseWriteLockOnKey(dataTag.getId());

    control.replay();

    ProcessChange change = dataTagConfigTransacted.doUpdateDataTag(dataTag.getId(), properties);
    assertFalse(change.processActionRequired());

    control.verify();
  }",No Smells
"@Test
  public void testGetConfigName() {
    assertEquals(""create subequipment"", configurationDAO.getConfigName(19));
  }",No Smells
"@Test
  public void parseCrudConfiguration() {

    Configuration insertConfig = Configuration.builder().name(""Default configuration"").confId(-1L).application(""No application defined"").build();

    Process createProcess = Process.create(""P_TEST"").statusTag(StatusTag.create(""Status_P"").build()).build();
    Equipment createEquipment = Equipment.create(""E_TEST"", ""handlerClassName"").id(33L).build();
    createEquipment.setParentProcessName(""P_TEST"");
    DataTag updateTag = DataTag.update(""The DataTag"").maxValue(10).description(""dataTagUpdate"").build();

    List<ConfigurationEntity> configList = new ArrayList<>();
    configList.add(createProcess);
    configList.add(createEquipment);
    configList.add(updateTag);

    insertConfig.setEntities(configList);

    Configuration readConfig = serializeDeserializeConfiguration(insertConfig);

    assertEquals(insertConfig, readConfig);
  }",No Smells
"@Test
  public void parseTagWithDBHardwareAddress(){

    HardwareAddress address = new DBHardwareAddressImpl(""itemName"");
    HardwareAddress readAddress = serializeDeserializeAddress(address);

    assertEquals(address, readAddress);
  }",No Smells
"@Test
  public void parseTagWithDIPHardwareAddress(){

    HardwareAddress address = new DIPHardwareAddressImpl(""itemName"", ""fieldName"", 1);
    HardwareAddress readAddress = serializeDeserializeAddress(address);

    assertEquals(address, readAddress);

  }",No Smells
"@Test
  public void parseTagWithOPCHardwareAddress(){

    HardwareAddress address = new OPCHardwareAddressImpl(""pItemName"", 100);
    HardwareAddress readAddress = serializeDeserializeAddress(address);

    assertEquals(address, readAddress);

  }",No Smells
"@Test
  public void parseTagWithSimpleHardwareAddress(){

    HardwareAddress address = new SimpleHardwareAddressImpl(""simpleName"");
    HardwareAddress readAddress = serializeDeserializeAddress(address);

    assertEquals(address, readAddress);

  }",No Smells
"@Test
  public void testConfigurationRequest() throws Exception {
    //fake DAQ responding to request
    final JmsTemplate daqTemplate = new JmsTemplate(connectionFactory);
    new Thread(new Runnable() {

      @Override
      public void run() {
        try {
          daqTemplate.execute(new SessionCallback<Object>() {
            String reportString = MessageConverter.responseToJson(new ConfigurationChangeEventReport());
            @Override
            public Object doInJms(Session session) throws JMSException {
              Process process = processCache.get(50L);
              String jmsDaqQueue = ""c2mon.process"" + "".command."" + process.getCurrentHost() + ""."" + process.getName() + ""."" + process.getProcessPIK();
              MessageConsumer consumer = session.createConsumer(new ActiveMQQueue(jmsDaqQueue));
              Message incomingMessage = consumer.receive(1000);
              MessageProducer messageProducer = session.createProducer(incomingMessage.getJMSReplyTo());
              TextMessage replyMessage = session.createTextMessage();
              replyMessage.setText(reportString);
              messageProducer.send(replyMessage);
              return null;
            }",Eager Test
"@Test
  public void testIncomingDataInvalidTagWithNullValue() throws InterruptedException {
    dataTagCache.put(dataTag.getId(), dataTag);

    //create a source update for this tag
    Timestamp timestamp = new Timestamp(System.currentTimeMillis() - 20);
    Timestamp daqTimestamp = new Timestamp(System.currentTimeMillis() - 10);
    //check datatag is set to value TRUE
//    assertEquals(Boolean.TRUE, dataTag.getValue());

    //set source update with value
    SourceDataTagValue sourceDataTagValue = SourceDataTagValue.builder()
        .id(dataTag.getId())
        .name(dataTag.getName())
        .controlTag(false)
        .value(1)
        .quality(new SourceDataTagQuality(SourceDataTagQualityCode.DATA_UNAVAILABLE))
        .timestamp(timestamp)
        .daqTimestamp(new Timestamp(System.currentTimeMillis()))
        .priority(JmsMessagePriority.PRIORITY_LOW.getPriority())
        .valueDescription(""test description"")
        .timeToLive(DataTagConstants.TTL_FOREVER)
        .build();
    sourceDataTagValue.setDaqTimestamp(daqTimestamp);
    ArrayList<SourceDataTagValue> tagList = new ArrayList<SourceDataTagValue>();
    tagList.add(sourceDataTagValue);
    DataTagValueUpdate dataTagValueUpdate = new DataTagValueUpdate(90L, tagList);
    sourceUpdateManager.processUpdates(dataTagValueUpdate);

    //check update is both in cache and DB
    DataTag cacheObject = (DataTag) dataTagCache.get(dataTag.getId());
    assertEquals(sourceDataTagValue.getValue(), cacheObject.getValue());
    assertEquals(sourceDataTagValue.getTimestamp(), cacheObject.getTimestamp());
    assertEquals(sourceDataTagValue.getDaqTimestamp(), cacheObject.getDaqTimestamp());
    assertEquals(sourceDataTagValue.getTimestamp(), cacheObject.getSourceTimestamp());
    assertTrue(cacheObject.getDataTagQuality().getInvalidQualityStates().containsKey(TagQualityStatus.INACCESSIBLE));
  }",No Smells
"@Test
  public void testCommandLogging() {
    CommandTag commandTag = CacheObjectCreation.createTestCommandTag();
    CommandReport report = new CommandReportImpl(commandTag.getId(), CommandExecutionStatus.STATUS_AUTHORISATION_FAILED,
        ""report text"", new Timestamp(System.currentTimeMillis()), new Short((short) 2));
    commandRecordListener.log(commandTag, report);

    List<CommandRecord> retrievedLogList = commandTagMapper.getCommandTagLog(commandTag.getId());

    assertNotNull(retrievedLogList);
    assertEquals(1, retrievedLogList.size());

    CommandRecord retrievedLog = retrievedLogList.get(0);

    assertEquals(commandTag.getId(), retrievedLog.getTagId());
    assertEquals(commandTag.getId().toString(), retrievedLog.getId());
    assertEquals(commandTag.getName(), retrievedLog.getName());
    assertEquals(commandTag.getDataType(), retrievedLog.getDataType());
    assertEquals(commandTag.getCommandExecutionDetails().getValue().toString(), retrievedLog.getValue());
    //assertEquals(commandTag.getHost(), retrievedLog.getHost());
    assertEquals(Short.valueOf(commandTag.getMode()), retrievedLog.getMode());
    //assertEquals(commandTag.getUser(), retrievedLog.getUser());
    assertEquals(report.getStatus(), retrievedLog.getReportStatus());
    assertEquals(report.getReportText(), retrievedLog.getReportDescription());

    //check time is logged in UTC format to DB
    int offset = TimeZone.getDefault().getOffset(commandTag.getCommandExecutionDetails().getExecutionStartTime().getTime());
    assertEquals(commandTag.getCommandExecutionDetails().getExecutionStartTime().getTime(), retrievedLog.getExecutionTime().getTime() + offset);

    //check time is logged in UTC format to DB
    int offset2 = TimeZone.getDefault().getOffset(report.getTimestamp().getTime());
    assertEquals(report.getTimestamp().getTime(), retrievedLog.getReportTime().getTime() + offset2);
  }",No Smells
"@Test
  public void testLogCommand() {
    CommandRecord commandLog = new CommandRecord();
    commandLog.setId(COMMAND_ID);
    commandLog.setName(""command name"");
    commandLog.setDataType(""datatype"");
    commandLog.setMode(Short.valueOf((short) 2));
    commandLog.setExecutionTime(new Timestamp(System.currentTimeMillis()));
    commandLog.setValue(""value"");
    commandLog.setHost(""host"");
    commandLog.setUser(""user"");
    commandLog.setReportStatus(CommandExecutionStatus.STATUS_CMD_UNKNOWN);
    commandLog.setReportTime(new Timestamp(System.currentTimeMillis() + 1000));
    commandLog.setReportDescription(""report text"");

    commandRecordMapper.insertLog(commandLog);

    List<CommandRecord> retrievedLogList = commandRecordMapper.getCommandTagLog(COMMAND_ID);

    assertNotNull(retrievedLogList);
    assertEquals(1, retrievedLogList.size());

    CommandRecord retrievedLog = retrievedLogList.get(0);

    assertEquals(commandLog.getId(), retrievedLog.getId());
    assertEquals(commandLog.getName(), retrievedLog.getName());
    assertEquals(commandLog.getDataType(), retrievedLog.getDataType());
    assertEquals(commandLog.getValue(), retrievedLog.getValue());
    assertEquals(commandLog.getHost(), retrievedLog.getHost());
    assertEquals(commandLog.getMode(), retrievedLog.getMode());
    assertEquals(commandLog.getUser(), retrievedLog.getUser());
    assertEquals(commandLog.getReportStatus(), retrievedLog.getReportStatus());
    assertEquals(commandLog.getReportDescription(), retrievedLog.getReportDescription());

    //check time is logged in UTC format to DB
    int offset = TimeZone.getDefault().getOffset(commandLog.getReportTime().getTime());
    assertEquals(commandLog.getReportTime().getTime(), retrievedLog.getReportTime().getTime() + offset);

  //check time is logged in UTC format to DB
    int offset2 = TimeZone.getDefault().getOffset(commandLog.getExecutionTime().getTime());
    assertEquals(commandLog.getExecutionTime().getTime(), retrievedLog.getExecutionTime().getTime() + offset2);

  }",No Smells
"@Test
  public void testLogSingleEvent() {
    serverLifecycleEventMapper.logEvent(testEvent);

    List<ServerLifecycleEvent> retrievedEvents = serverLifecycleEventMapper.getEventsForServer(testEvent.getServerName());

    assertNotNull(retrievedEvents);
    assertEquals(1, retrievedEvents.size());
    assertSameEvent(testEvent, retrievedEvents.get(0));
  }",No Smells
"@Test
  public void testLogSupervision() {
    SupervisionEvent event = new SupervisionEventImpl(ENTITY, ID, NAME, STATUS, DATE, MESSAGE);
    supervisionEventMapper.logSupervisionEvent(event);

    //check event was properly saved
    List<SupervisionEvent> eventList = supervisionEventMapper.getEntitySupervision(ID);

    assertNotNull(eventList);
    assertEquals(1, eventList.size());

    SupervisionEvent retrievedEvent = eventList.get(0);
    assertEquals(event.getEntityId(), retrievedEvent.getEntityId());
    assertEquals(event.getEntity(), retrievedEvent.getEntity());
    assertEquals(event.getStatus(), retrievedEvent.getStatus());

    //check time is logged in UTC format to DB
    int offset = TimeZone.getDefault().getOffset(event.getEventTime().getTime());
    assertEquals(event.getEventTime().getTime(), retrievedEvent.getEventTime().getTime() + offset);

    assertEquals(event.getMessage(), retrievedEvent.getMessage());
  }",No Smells
"@Test
  public void testAlarmLogConverter() {
    AlarmRecordConverter converter = new AlarmRecordConverter();

    Alarm alarm = EasyMock.createMock(Alarm.class);
    EasyMock.expect(alarm.getId()).andReturn(10L).times(2);
    EasyMock.expect(alarm.getFaultCode()).andReturn(2);
    EasyMock.expect(alarm.getFaultFamily()).andReturn(""FF"");
    EasyMock.expect(alarm.getFaultMember()).andReturn(""FM"");
    EasyMock.expect(alarm.getTagId()).andReturn(1L);
    EasyMock.expect(alarm.getInfo()).andReturn("""");
    EasyMock.expect(alarm.getTimestamp()).andReturn(new Timestamp(System.currentTimeMillis()));
    EasyMock.expect(alarm.getSourceTimestamp()).andReturn(new Timestamp(System.currentTimeMillis()));
    EasyMock.expect(alarm.isActive()).andReturn(true);
    EasyMock.expect(alarm.isOscillating()).andReturn(false);
    EasyMock.replay(alarm);

    AlarmRecord l = (AlarmRecord) converter.convertToLogged(alarm);
    Long.valueOf(l.getId()).equals(alarm.getId());

    EasyMock.verify(alarm);
  }",No Smells
"@Test
  public void testStringEncoding() throws DataFallbackException {

    AlarmRecord al = getAlarmLog();
    al.setActive(true);
    al.setAlarmId(1234L);
    al.setServerTimestamp(new Timestamp(System.currentTimeMillis()));
    al.setSourceTimestamp(new Timestamp(System.currentTimeMillis()));
    al.setInfo(""!@#$%^&*(}",No Smells
"@Test
  public void testEncodingWithNullDaqTimestamp() throws DataFallbackException {
    TagRecord tag = getTag();
    tag.setDaqTimestamp(null);
    String encoded = tag.toString();
    TagRecord retrievedLog = (TagRecord) tag.getObject(encoded);
    assertSameLog(tag, retrievedLog);
    //log date is set when logging to file
    assertNotNull(retrievedLog.getLogDate());
  }",No Smells
"@Test
  public void testEncodingWithNullValue() throws DataFallbackException {
    TagRecord tag = getTag();
    tag.setTagValue(null);
    String encoded = tag.toString();
    TagRecord retrievedLog = (TagRecord) tag.getObject(encoded);
    assertSameLog(tag, retrievedLog);
    //log date is set when logging to file
    assertNotNull(retrievedLog.getLogDate());
  }",No Smells
"@Test
  public void testProcessAliveTag() throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(6);
    supervisionListener.notifySupervisionEvent(EasyMock.isA(SupervisionEvent.class));
    cacheSupervisionListener.onSupervisionChange(EasyMock.isA(Tag.class));
    EasyMock.expectLastCall().andAnswer(() -> { latch.countDown(); return null; }",Eager Test
"@Test
  public void testActiveAlarmJsonMessageSerialization() {

    ClientRequestImpl<AlarmValue> alarmsRequest =
      new ClientRequestImpl<>(
          ClientRequest.ResultType.TRANSFER_ALARM_LIST,
          ClientRequest.RequestType.ACTIVE_ALARMS_REQUEST,
          10000
      );

    String json = alarmsRequest.toJson();
    ClientRequest receivedRequest = ClientRequestImpl.fromJson(json);

    assertEquals(ClientRequest.RequestType.ACTIVE_ALARMS_REQUEST, receivedRequest.getRequestType());
    assertEquals(ClientRequest.ResultType.TRANSFER_ALARM_LIST, receivedRequest.getResultType());
  }",No Smells
"@Test
  public void testConfigurationReportJsonMessageSerialization() {
    ClientRequestImpl<ConfigurationReport> tagRequest =
      new ClientRequestImpl<>(ConfigurationReport.class);
    tagRequest.addTagIds(Arrays.asList(123L, 4324L, 4535L, 123L));

    String json = tagRequest.toJson();
    ClientRequest receivedRequest = ClientRequestImpl.fromJson(json);
    assertEquals(ClientRequest.RequestType.APPLY_CONFIGURATION_REQUEST, receivedRequest.getRequestType());
    assertEquals(tagRequest.getTagIds().size(), receivedRequest.getTagIds().size());
    Collection<Long> receivedTags = receivedRequest.getTagIds();
    for (Long tagId : receivedTags) {
      assertFalse(tagRequest.addTagId(tagId));
    }",Eager Test
"@Test
  public void testConfigurationReportJsonResponseDeserialization() {
    ClientRequestImpl<ConfigurationReport> tagRequest =
      new ClientRequestImpl<>(ConfigurationReport.class);
    tagRequest.addTagIds(Arrays.asList(123L, 4324L, 4535L, 123L));

    ConfigurationReport originalConfigurationReport = createConfigurationReport(123L) ;

    Float responseTagValue = Float.valueOf(2342.456546f); // not used
    String serverResponse = mockTagValueResponse(tagRequest.toJson(), responseTagValue);
    Collection<ConfigurationReport> responseList = tagRequest.fromJsonResponse(serverResponse);

    assertEquals(tagRequest.getTagIds().size(), responseList.size());
    for (ConfigurationReport receivedReport : responseList) {
      assertTrue(tagRequest.getTagIds().contains(receivedReport.getId()));

      assertTrue(originalConfigurationReport.getName() .equals(receivedReport.getName()));
      assertTrue(originalConfigurationReport.getStatus() .equals(receivedReport.getStatus()));
      assertTrue(originalConfigurationReport.getStatusDescription() .equals(receivedReport.getStatusDescription()));

      assertTrue(originalConfigurationReport.getUser() .equals(receivedReport.getUser()));
      assertTrue(originalConfigurationReport.getElementReports() .equals(receivedReport.getElementReports()));
    }",Eager Test
"@Test
  public void testResult() {
    DummyClientRequestReport report = new DummyClientRequestReport();
    assertTrue(report.isResult());
    assertTrue(!report.isErrorReport());
    assertTrue(!report.isProgressReport());
  }",No Smells
"@Test
  public void testByteJsonMsg() {
    String jacksonString = toJson(createTagForValue(Byte.valueOf((byte) 0x000A)));
    TagUpdate receivedTag = fromJson(jacksonString, TransferTagImpl.class);
    assertTrue(receivedTag.getValue() instanceof Byte);
  }",No Smells
"@Test
  public void testPublicationsTransfer() {
    TransferTagImpl originalTransferTag = createTagForValue(Long.valueOf(444L));
    String jacksonString = toJson(originalTransferTag);
    TagUpdate receivedTag = fromJson(jacksonString, TransferTagImpl.class);
    assertTrue(receivedTag.getValue() instanceof Long);
  }",No Smells
"@Test
  public void testRuleIdsTransfer() {
    TransferTagImpl originalTransferTag = createTagForValue(Long.valueOf(234533246L));
    String jacksonString = toJson(originalTransferTag);
    TagUpdate receivedTag = fromJson(jacksonString, TransferTagImpl.class);
    assertTrue(receivedTag.getValue() instanceof Long);
  }",No Smells
"@Test
  public void testFloatJsonMsg() {
    Float value = Float.valueOf(3.34535f);
    String jacksonString = TransferTagSerializer.toJson(createTagForValue(value));
    TagValueUpdate receivedTag = TransferTagSerializer.fromJson(jacksonString, TransferTagValueImpl.class);
    assertTrue(receivedTag.getValue() instanceof Float);
    assertEquals(value, receivedTag.getValue());
  }",No Smells
"@Test
  public void parseBasicHardwareAddressToXml() {
    // initialize test data:
    HashMap<String, String> testData = new HashMap<>();
    testData.put(""key1"", ""1"");
    testData.put(""key2"", ""test"");
    testData.put(""key3"", ""true"");

    DataTagAddress testAddress = new DataTagAddress(testData);

    String compareString = ""      <DataTagAddress>\n"" +
        ""            <address-parameters class=\""java.util.HashMap\""><entry key=\""key1\""><![CDATA[1]]></entry><entry key=\""key2\""><![CDATA[test]]></entry><entry key=\""key3\""><![CDATA[true]]></entry></address-parameters>\n"" +
        ""        <priority>2</priority>\n"" +
        ""        <guaranteed-delivery>false</guaranteed-delivery>\n"" +
        ""      </DataTagAddress>\n"";

    // test run:
    String resultXml = testAddress.toConfigXML();

    // check results:
    assertEquals(resultXml, compareString);

  }",No Smells
"@Test
    public void testGetCallMethod() throws Exception {
        JMXHardwareAddress addr1 = new JMXHardwareAddressImpl(""java.lang:type=Runtime"", ""java.vm.version"", ""method1"",
                ""notification"");
        JMXHardwareAddress addr2 = new JMXHardwareAddressImpl(""java.lang:type=Runtime"", ""java.vm.version"");
        assertEquals(""method1"", addr1.getCallMethod());
        assertTrue(addr1.hasCallMethod());
        assertTrue(addr1.hasAttribute());
        assertEquals(null, addr2.getCallMethod());
    }",No Smells
"@Test
  public void testDefaultConstructor() {
    DataTagQuality tagQuality = new DataTagQualityImpl();
    assertFalse(tagQuality.isInitialised());
    assertEquals(1, tagQuality.getInvalidQualityStates().size());
  }",No Smells
"@Test
  public void testEqualsMethod() {
    String description = ""Equipment is down!"";
    DataTagQuality invalidTagQuality1 = new DataTagQualityImpl(TagQualityStatus.EQUIPMENT_DOWN, description);
    DataTagQuality invalidTagQuality2 = new DataTagQualityImpl(TagQualityStatus.EQUIPMENT_DOWN, description);
    DataTagQuality validTagQuality = new DataTagQualityImpl();
    validTagQuality.validate();
    
    assertTrue(invalidTagQuality1.equals(invalidTagQuality2));
    assertTrue(invalidTagQuality2.equals(invalidTagQuality1));
    assertFalse(validTagQuality.equals(invalidTagQuality1));
    
    invalidTagQuality2.setInvalidStatus(TagQualityStatus.EQUIPMENT_DOWN, ""Some other reason"");
    assertFalse(invalidTagQuality1.equals(invalidTagQuality2));
    assertFalse(invalidTagQuality2.equals(invalidTagQuality1));
  }",No Smells
"@Test
  public void testGetDescription() {
    DataTagQuality tagQuality = new DataTagQualityImpl();
    assertEquals("""", tagQuality.getDescription());
    
    tagQuality.validate();
    assertEquals(VALID_DESCR, tagQuality.getDescription());
    
    // Setting the status shall overwrite the others
    
    String undefined = ""Tag is not defined"";
    assertTrue(tagQuality.setInvalidStatus(TagQualityStatus.UNDEFINED_TAG, undefined));
    assertEquals(undefined, tagQuality.getDescription());
    
    String subEquipmentDown = ""Sub-equipment is down"";
    assertTrue(tagQuality.setInvalidStatus(TagQualityStatus.SUBEQUIPMENT_DOWN, subEquipmentDown));
    assertEquals(subEquipmentDown, tagQuality.getDescription());
    
    String equipmentDown = ""Equipment is down"";
    assertTrue(tagQuality.setInvalidStatus(TagQualityStatus.EQUIPMENT_DOWN, equipmentDown));
    assertEquals(equipmentDown, tagQuality.getDescription());
    
    String processDown = ""DAQ process is down"";
    assertTrue(tagQuality.setInvalidStatus(TagQualityStatus.PROCESS_DOWN, processDown));
    assertEquals(processDown, tagQuality.getDescription());
    
    // Adding the status shall return the description of the highest severity
    assertTrue(tagQuality.addInvalidStatus(TagQualityStatus.EQUIPMENT_DOWN, equipmentDown));
    assertEquals(processDown, tagQuality.getDescription());
    
    assertTrue(tagQuality.addInvalidStatus(TagQualityStatus.SUBEQUIPMENT_DOWN, subEquipmentDown));
    assertEquals(processDown, tagQuality.getDescription());
    
    assertTrue(tagQuality.addInvalidStatus(TagQualityStatus.UNDEFINED_TAG, undefined));
    assertEquals(undefined, tagQuality.getDescription());
    
    tagQuality.removeInvalidStatus(TagQualityStatus.PROCESS_DOWN);
    assertEquals(undefined, tagQuality.getDescription());
    
    tagQuality.removeInvalidStatus(TagQualityStatus.UNDEFINED_TAG);
    assertEquals(equipmentDown, tagQuality.getDescription());
    
    tagQuality.removeInvalidStatus(TagQualityStatus.EQUIPMENT_DOWN);
    assertEquals(subEquipmentDown, tagQuality.getDescription());
    
    tagQuality.removeInvalidStatus(TagQualityStatus.SUBEQUIPMENT_DOWN);
    assertEquals(VALID_DESCR, tagQuality.getDescription());
    
    // test concatenation of error messages with same severity
    final String separator = ""; ""; 
    String outOfBounds = ""Value is out of bounds"";
    assertTrue(tagQuality.addInvalidStatus(TagQualityStatus.VALUE_OUT_OF_BOUNDS, outOfBounds));
    assertEquals(outOfBounds, tagQuality.getDescription());
    
    String unknownReason = ""Unknown"";
    assertTrue(tagQuality.addInvalidStatus(TagQualityStatus.UNKNOWN_REASON, unknownReason));
    if ((outOfBounds + separator + unknownReason).equalsIgnoreCase(tagQuality.getDescription())) {
      assertTrue(true);
    }",Eager Test
"@Test
  public void testIsValid() {
    DataTagQuality validTagQuality = new DataTagQualityImpl();
    validTagQuality.validate();
    assertTrue(validTagQuality.isValid());
    assertEquals(VALID_DESCR, validTagQuality.getDescription());
    
    validTagQuality.addInvalidStatus(TagQualityStatus.UNKNOWN_REASON);
    assertFalse(validTagQuality.isValid());
  }",No Smells
"@Test
  public void testQualityStatusWithDescriptionConstructor() {
    String description = ""The DAQ process is down"";
    DataTagQuality tagQuality = new DataTagQualityImpl(TagQualityStatus.PROCESS_DOWN, description);
    assertFalse(tagQuality.isAccessible());
    assertEquals(1, tagQuality.getInvalidQualityStates().size());
    assertEquals(description, tagQuality.getDescription());
    
    // Test null pointer initialization
    tagQuality = new DataTagQualityImpl((TagQualityStatus) null, null);
    assertFalse(tagQuality.isInitialised());
  }",No Smells
"@Test
  public void testStatusAndDescriptionComparisonTrue2() {
    DataTagQuality quality = new DataTagQualityImpl(TagQualityStatus.EQUIPMENT_DOWN, """");
    assertTrue(quality.isInvalidStatusSetWithSameDescription(TagQualityStatus.EQUIPMENT_DOWN, null));    
  }",No Smells
"@Test
  public void testToString() {
    DataTagQuality tagQuality = new DataTagQualityImpl();
    tagQuality.validate();
    assertEquals(VALID_DESCR, tagQuality.toString());
    
    String separator = ""+"";
    String equipmentDown = ""EQUIPMENT_DOWN"";
    tagQuality.addInvalidStatus(TagQualityStatus.EQUIPMENT_DOWN);
    assertEquals(equipmentDown, tagQuality.toString());
    
    String valueExpired = ""VALUE_EXPIRED"";
    tagQuality.addInvalidStatus(TagQualityStatus.VALUE_EXPIRED);
    if ((valueExpired + separator + equipmentDown).equalsIgnoreCase(tagQuality.toString())) {
      assertTrue(true);
    }",No Smells
"@Test
  public void testBooleanStringToLongCast() {
    assertEquals(Long.valueOf(0l), TypeConverter.castToType(""false"", Long.class));
    assertEquals(Long.valueOf(1l), TypeConverter.castToType(""true"", Long.class));
    assertEquals(true, TypeConverter.isConvertible(""false"", Long.class));
    assertEquals(true, TypeConverter.isConvertible(""true"", Long.class));
    assertEquals(true, TypeConverter.isConvertible(""false"", ""Long""));
    assertEquals(true, TypeConverter.isConvertible(""true"", ""Long""));
    assertEquals(true, TypeConverter.isConvertible(""false"", ""java.lang.Long""));
    assertEquals(true, TypeConverter.isConvertible(""true"", ""java.lang.Long""));
  }",No Smells
"@Test
  public void testByteArrayCast() {
    castTest(new Boolean[]{Boolean.TRUE, Boolean.FALSE}",No Smells
"@Test
    public void testDoubleCast() {
      castTest(Boolean.TRUE, Double.class, new Double(1));
      castTest(Boolean.FALSE, Double.class, new Double(0));
      castTest(new Double(0), Double.class, new Double(0));
      castTest(new Double(1), Double.class, new Double(1));
      castTest(new Double(25.5), Double.class, new Double(25.5));
      castTest(new Float(0), Double.class, new Double(0));
      castTest(new Float(1), Double.class, new Double(1));
      castTest(new Float(25.5), Double.class, new Double(25.5));
      castTest(new Short((short) 0), Double.class, new Double(0));
      castTest(new Short((short) 1), Double.class, new Double(1));
      castTest(new Short((short) 25), Double.class, new Double(25));
      castTest(new Long(0), Double.class, new Double(0));
      castTest(new Long(1), Double.class, new Double(1));
      castTest(new Long(2123190123125l), Double.class, new Double(2123190123125l));
      castTest(new Integer(0), Double.class, new Double(0));
      castTest(new Integer(1), Double.class, new Double(1));
      castTest(new Integer(25), Double.class, new Double(25));
      castTest(""0"", Double.class, new Double(0));
      castTest(""25.5"", Double.class, new Double(25.5));
      castTest(""RUNNING"", SupervisionStatus.class, SupervisionStatus.RUNNING);
      castTest(""DOWN"", SupervisionStatus.class, SupervisionStatus.DOWN);

      castTest(Boolean.TRUE, Double.class.getName(), new Double(1));
      castTest(Boolean.FALSE, Double.class.getName(), new Double(0));
      castTest(new Double(0), Double.class.getName(), new Double(0));
      castTest(new Double(1), Double.class.getName(), new Double(1));
      castTest(new Double(25.5), Double.class.getName(), new Double(25.5));
      castTest(new Float(0), Double.class.getName(), new Double(0));
      castTest(new Float(1), Double.class.getName(), new Double(1));
      castTest(new Float(25.5), Double.class.getName(), new Double(25.5));
      castTest(new Short((short) 0), Double.class.getName(), new Double(0));
      castTest(new Short((short) 1), Double.class.getName(), new Double(1));
      castTest(new Short((short) 25), Double.class.getName(), new Double(25));
      castTest(new Long(0), Double.class.getName(), new Double(0));
      castTest(new Long(1), Double.class.getName(), new Double(1));
      castTest(new Long(2123190123125l), Double.class.getName(), new Double(2123190123125l));
      castTest(new Integer(0), Double.class.getName(), new Double(0));
      castTest(new Integer(1), Double.class.getName(), new Double(1));
      castTest(new Integer(25), Double.class.getName(), new Double(25));
      castTest(""0"", Double.class.getName(), new Double(0));
      castTest(""25.5"", Double.class.getName(), new Double(25.5));
      castTest(""RUNNING"", SupervisionStatus.class, SupervisionStatus.RUNNING);
      castTest(""DOWN"", SupervisionStatus.class, SupervisionStatus.DOWN);

      castTest(Boolean.TRUE, ""Double"", new Double(1));
      castTest(Boolean.FALSE, ""Double"", new Double(0));
      castTest(new Double(0), ""Double"", new Double(0));
      castTest(new Double(1), ""Double"", new Double(1));
      castTest(new Double(25.5), ""Double"", new Double(25.5));
      castTest(new Float(0), ""Double"", new Double(0));
      castTest(new Float(1), ""Double"", new Double(1));
      castTest(new Float(25.5), ""Double"", new Double(25.5));
      castTest(new Short((short) 0), ""Double"", new Double(0));
      castTest(new Short((short) 1), ""Double"", new Double(1));
      castTest(new Short((short) 25), ""Double"", new Double(25));
      castTest(new Long(0), ""Double"", new Double(0));
      castTest(new Long(1), ""Double"", new Double(1));
      castTest(new Long(2123190123125l), ""Double"", new Double(2123190123125l));
      castTest(new Integer(0), ""Double"", new Double(0));
      castTest(new Integer(1), ""Double"", new Double(1));
      castTest(new Integer(25), ""Double"", new Double(25));
      castTest(""0"", ""Double"", new Double(0));
      castTest(""25.5"", ""Double"", new Double(25.5));
      castTest(""RUNNING"", SupervisionStatus.class, SupervisionStatus.RUNNING);
      castTest(""DOWN"", SupervisionStatus.class, SupervisionStatus.DOWN);
    }",Eager Test
"@Test
    public void testShortCast() {
      castTest(Boolean.TRUE, Short.class, new Short((short) 1));
      castTest(Boolean.FALSE, Short.class, new Short((short) 0));
      castTest(new Double(0), Short.class, new Short((short) 0));
      castTest(new Double(1), Short.class, new Short((short) 1));
      castTest(new Double(25.5), Short.class, new Short((short) 26));
      castTest(new Float(0), Short.class, new Short((short) 0));
      castTest(new Float(1), Short.class, new Short((short) 1));
      castTest(new Float(25.5), Short.class, new Short((short) 26));
      castTest(new Short((short) 0), Short.class, new Short((short) 0));
      castTest(new Short((short) 1), Short.class, new Short((short) 1));
      castTest(new Short((short) 25), Short.class, new Short((short) 25));
      castTest(new Long(0), Short.class, new Short((short) 0));
      castTest(new Long(1), Short.class, new Short((short) 1));
      castTest(new Integer(0), Short.class, new Short((short) 0));
      castTest(new Integer(1), Short.class, new Short((short) 1));
      castTest(new Integer(25), Short.class, new Short((short) 25));
      castTest(""0"", Short.class, new Short((short) 0));
      castTest(""25.5"", Short.class, Short.valueOf((short) 26));

      castTest(Boolean.TRUE, Short.class.getName(), new Short((short) 1));
      castTest(Boolean.FALSE, Short.class.getName(), new Short((short) 0));
      castTest(new Double(0), Short.class.getName(), new Short((short) 0));
      castTest(new Double(1), Short.class.getName(), new Short((short) 1));
      castTest(new Double(25.5), Short.class.getName(), new Short((short) 26));
      castTest(new Float(0), Short.class.getName(), new Short((short) 0));
      castTest(new Float(1), Short.class.getName(), new Short((short) 1));
      castTest(new Float(25.5), Short.class.getName(), new Short((short) 26));
      castTest(new Short((short) 0), Short.class.getName(), new Short((short) 0));
      castTest(new Short((short) 1), Short.class.getName(), new Short((short) 1));
      castTest(new Short((short) 25), Short.class.getName(), new Short((short) 25));
      castTest(new Long(0), Short.class.getName(), new Short((short) 0));
      castTest(new Long(1), Short.class.getName(), new Short((short) 1));
      castTest(new Integer(0), Short.class.getName(), new Short((short) 0));
      castTest(new Integer(1), Short.class.getName(), new Short((short) 1));
      castTest(new Integer(25), Short.class.getName(), new Short((short) 25));
      castTest(""0"", Short.class.getName(), new Short((short) 0));
      castTest(""25.5"", Short.class.getName(), Short.valueOf((short) 26));

      castTest(Boolean.TRUE, ""Short"", new Short((short) 1));
      castTest(Boolean.FALSE, ""Short"", new Short((short) 0));
      castTest(new Double(0), ""Short"", new Short((short) 0));
      castTest(new Double(1), ""Short"", new Short((short) 1));
      castTest(new Double(25.5), ""Short"", new Short((short) 26));
      castTest(new Float(0), ""Short"", new Short((short) 0));
      castTest(new Float(1), ""Short"", new Short((short) 1));
      castTest(new Float(25.5), ""Short"", new Short((short) 26));
      castTest(new Short((short) 0), ""Short"", new Short((short) 0));
      castTest(new Short((short) 1), ""Short"", new Short((short) 1));
      castTest(new Short((short) 25), ""Short"", new Short((short) 25));
      castTest(new Long(0), ""Short"", new Short((short) 0));
      castTest(new Long(1), ""Short"", new Short((short) 1));
      castTest(new Integer(0), ""Short"", new Short((short) 0));
      castTest(new Integer(1), ""Short"", new Short((short) 1));
      castTest(new Integer(25), ""Short"", new Short((short) 25));
      castTest(""0"", ""Short"", new Short((short) 0));
      castTest(""25.5"", ""Short"", Short.valueOf((short) 26));
    }",Eager Test
"@Test
  public void testStringArrayCast() {
    // String
    castTest(new Boolean[]{Boolean.TRUE, Boolean.FALSE}",No Smells
"@Test
  public void testFromXMLWithEmptyMessage() throws ParserConfigurationException {
    SimpleXMLParser parser = new SimpleXMLParser();
    String xmlString = ""<DataTagValueUpdate process-id=\""4077\""><DataTag id=\""126329\"" name=\""FW.L08.FDED-00072_8.1_VMA8211/1:DEF_TPS_FERM\"" control=\""false\""><quality><code>4</code><desc><![CDATA[]]></desc></quality><timestamp>1350761384924</timestamp><daq-timestamp>1350761384924</daq-timestamp></DataTag></DataTagValueUpdate>"";

    DataTagValueUpdate update = DataTagValueUpdate.fromXML(parser.parse(xmlString).getDocumentElement());
    Assert.assertNotNull(update);

    for (SourceDataTagValue sdt : update.getValues()) {
      Assert.assertNotNull(sdt.getQuality().getDescription());
      Assert.assertEquals("""", sdt.getQuality().getDescription());
      Assert.assertEquals(4, sdt.getQuality().getQualityCode().getQualityCode());
    }",No Smells
"@Test 
  public void feedIncorrectParameters() {
    //incorrect array for the method
    parameterArray = new Object[] {""test"", Long.valueOf(0), 1}",No Smells
"@Test
    public void testBasicBenchmarking() throws IOException {

        List<InputDocument> docs = ImmutableList.of(
                InputDocument.builder(""doc1"").addField(""f"", ""some text about the world"", STANDARD).build(),
                InputDocument.builder(""doc2"").addField(""f"", ""some text about cheese"", STANDARD).build()
        );

        BenchmarkResults<QueryMatch> results = Benchmark.run(monitor, docs, 1, SimpleMatcher.FACTORY);

        assertThat(results.getTimer().getCount()).isEqualTo(2);

    }",No Smells
"@Test
    public void testPresearcherBenchmarking() throws IOException {

        List<InputDocument> docs = ImmutableList.of(
                InputDocument.builder(""doc1"").addField(""f"", ""some text about the world"", STANDARD).build(),
                InputDocument.builder(""doc2"").addField(""f"", ""some text about cheese"", STANDARD).build()
        );

        BenchmarkResults<PresearcherMatch> results = Benchmark.timePresearcher(monitor, 2, docs);

        assertThat(results.getTimer().getCount()).isEqualTo(1);
        assertThat(results.getTimer().getMeanRate()).isGreaterThan(0);

    }",No Smells
"@Test
    public void testDisjunctionWithUnorderedNearSpans() throws Exception {

        final Query bq = new BooleanQuery.Builder()
                .add(new TermQuery(new Term(textfield, ""a"")), BooleanClause.Occur.SHOULD)
                .add(SpanNearQuery.newUnorderedNearQuery(textfield)
                        .addClause(new SpanTermQuery(new Term(textfield, ""b"")))
                        .addClause(new SpanTermQuery(new Term(textfield, ""c"")))
                        .setSlop(1)
                        .build(), BooleanClause.Occur.SHOULD)
                .build();
        final Query parent = new BooleanQuery.Builder()
                .add(new TermQuery(new Term(textfield, ""a"")), BooleanClause.Occur.MUST)
                .add(bq, BooleanClause.Occur.MUST)
                .build();

        monitor = new Monitor((queryString, metadata) -> parent, new MatchAllPresearcher());
        monitor.update(new MonitorQuery(""1"", """"));

        InputDocument doc = buildDoc(""1"", ""a b x x x x c"");
        Matches<HighlightsMatch> matches = monitor.match(doc, HighlightingMatcher.FACTORY);

        assertThat(matches).matchesQuery(""1"", ""1"").withHitCount(1);

    }",No Smells
"@Test
    public void testIdenticalMatches() throws Exception {

        final BooleanQuery bq = new BooleanQuery.Builder()
                .add(new TermQuery(new Term(textfield, ""term1"")), BooleanClause.Occur.MUST)
                .add(new TermQuery(new Term(textfield, ""term1"")), BooleanClause.Occur.SHOULD)
                .build();

        monitor = new Monitor((queryString, metadata) -> bq, new MatchAllPresearcher());

        monitor.update(new MonitorQuery(""1"", """"));
        Matches<HighlightsMatch> matches = monitor.match(buildDoc(""1"", ""term1 term2""), HighlightingMatcher.FACTORY);

        assertThat(matches).matchesQuery(""1"", ""1"").withHitCount(1);
    }",No Smells
"@Test
    public void testMinShouldMatchQuery() throws Exception {

        final Query minq = new BooleanQuery.Builder()
                .add(new TermQuery(new Term(textfield, ""x"")), BooleanClause.Occur.SHOULD)
                .add(new TermQuery(new Term(textfield, ""y"")), BooleanClause.Occur.SHOULD)
                .add(new TermQuery(new Term(textfield, ""z"")), BooleanClause.Occur.SHOULD)
                .setMinimumNumberShouldMatch(2)
                .build();

        final Query bq = new BooleanQuery.Builder()
                .add(new TermQuery(new Term(textfield, ""a"")), BooleanClause.Occur.MUST)
                .add(new TermQuery(new Term(textfield, ""b"")), BooleanClause.Occur.MUST)
                .add(minq, BooleanClause.Occur.SHOULD)
                .build();

        monitor = new Monitor((queryString, metadata) -> bq, new MatchAllPresearcher());
        monitor.update(new MonitorQuery(""1"", """"));

        InputDocument doc = buildDoc(""1"", ""a b x"");
        Matches<HighlightsMatch> matches = monitor.match(doc, HighlightingMatcher.FACTORY);

        assertThat(matches).matchesQuery(""1"", ""1"")
            .withHitCount(2)
            .inField(textfield)
                .withHit(new HighlightsMatch.Hit(0, 0, 0, 1))
                .withHit(new HighlightsMatch.Hit(1, 2, 1, 3));
    }",No Smells
"@Test
    public void testWildcardBooleanRewrites() throws Exception {

        final Query wc = new PrefixQuery(new Term(textfield, ""term1""));

        final Query wrapper = new BooleanQuery.Builder()
                .add(wc, BooleanClause.Occur.MUST)
                .build();

        final Query wrapper2  = new BooleanQuery.Builder()
                .add(wrapper, BooleanClause.Occur.MUST)
                .build();

        final BooleanQuery bq = new BooleanQuery.Builder()
                .add(new PrefixQuery(new Term(textfield, ""term2"")), BooleanClause.Occur.MUST)
                .add(wrapper2, BooleanClause.Occur.MUST_NOT)
                .build();

        monitor = new Monitor((queryString, metadata) -> bq, new MatchAllPresearcher());

        monitor.update(new MonitorQuery(""1"", """"));
        Matches<HighlightsMatch> matches = monitor.match(buildDoc(""1"", ""term2 term""), HighlightingMatcher.FACTORY);
        assertThat(matches).matchesQuery(""1"", ""1"").withHitCount(1);

        matches = monitor.match(buildDoc(""1"", ""term2 term""), HighlightingMatcher.FACTORY);
        assertThat(matches).matchesQuery(""1"", ""1"").withHitCount(1);
    }",No Smells
"@Test
    public void testDisjunctionsWithAnyClausesOnlyReturnANYTOKEN() throws Exception {

        // disjunction containing a pure negative - we can't narrow this down
        Query q = ParserUtils.parse(""hello goodbye (*:* -term)"");

        assertThat(analyzer.collectTerms(q, WEIGHTOR))
                .extracting(""type"")
                .containsOnly(QueryTerm.Type.ANY);

    }",No Smells
"@Test
    public void testNestedConjunctions() throws Exception {

        Query q = ParserUtils.parse(""+(+(+(+aaaa +cc) +(+d +bbb)))"");
        QueryTree tree = analyzer.buildTree(q, WEIGHTOR);

        assertThat(analyzer.collectTerms(tree))
                .containsOnly(new QueryTerm(""field"", ""aaaa"", QueryTerm.Type.EXACT));
        assertThat(tree.advancePhase(0))
                .isTrue();

        assertThat(analyzer.collectTerms(tree))
                .containsOnly(new QueryTerm(""field"", ""bbb"", QueryTerm.Type.EXACT));
        assertThat(tree.advancePhase(0))
                .isTrue();

        assertThat(analyzer.collectTerms(tree))
                .containsOnly(new QueryTerm(""field"", ""cc"", QueryTerm.Type.EXACT));
        assertThat(tree.advancePhase(0))
                .isTrue();

        assertThat(analyzer.collectTerms(tree))
                .containsOnly(new QueryTerm(""field"", ""d"", QueryTerm.Type.EXACT));
        assertThat(tree.advancePhase(0))
                .isFalse();

    }",No Smells
"@Test
    public void testErrorHandling() throws Exception {

        try (Monitor monitor = new Monitor(new LuceneQueryParser(""f""), new MatchAllPresearcher())) {
            List<QueryError> errors = new ArrayList<>();
            try (ConcurrentQueryLoader loader = new ConcurrentQueryLoader(monitor, errors)) {
                for (int i = 0; i < 2000; i++) {
                    String query = ""test"" + i;
                    if (i % 200 == 0)
                        query += "" ["";
                    loader.add(new MonitorQuery(Integer.toString(i), query));
                }",No Smells
"@Test
    public void testLoading() throws Exception {

        try (Monitor monitor = new Monitor(new LuceneQueryParser(""f""), new MatchAllPresearcher())) {
            List<QueryError> errors = new ArrayList<>();
            try (ConcurrentQueryLoader loader = new ConcurrentQueryLoader(monitor, errors)) {
                for (int i = 0; i < 2000; i++) {
                    loader.add(new MonitorQuery(Integer.toString(i), ""\""test "" + i + ""\""""));
                }",No Smells
"@Test
    public void testCannotAddReservedFieldName() {
        expected.expect(IllegalArgumentException.class);
        expected.expectMessage(""reserved"");

        InputDocument.builder(""id"").addField(InputDocument.ID_FIELD, ""test"", new StandardAnalyzer()).build();
    }",No Smells
"@Test
    public void testSimpleDisjunctions() throws Exception {
        Query q = ParserUtils.parse(""hello world"");
        assertThat(decomposer.decompose(q))
                .hasSize(2)
                .containsExactly(q(""hello""), q(""world""));
    }",No Smells
"@Test
    public void testSingleValuedConjunctions() throws Exception {
        assertThat(decomposer.decompose(q(""+(hello world)"")))
                .containsExactly(q(""hello""), q(""world""));
    }",No Smells
"@Test
    public void testSingleValuedConjunctWithExclusions() throws Exception {
        assertThat(decomposer.decompose(q(""+(hello world) -goodbye"")))
                .containsExactly(q(""+hello -goodbye""), q(""+world -goodbye""));
    }",No Smells
"@Test
    public void testRewrite() throws IOException {

        try (Directory dir = new RAMDirectory();
             IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(new StandardAnalyzer()))) {

            Document doc = new Document();
            doc.add(new TextField(""field"", ""term1 term2 term3 term4"", Field.Store.NO));
            iw.addDocument(doc);
            iw.commit();

            IndexReader reader = DirectoryReader.open(dir);

            PrefixQuery pq = new PrefixQuery(new Term(""field"", ""term""));
            ForceNoBulkScoringQuery q = new ForceNoBulkScoringQuery(pq);

            assertThat(q.getWrappedQuery()).isEqualTo(pq);

            Query rewritten = q.rewrite(reader);
            assertThat(rewritten).isInstanceOf(ForceNoBulkScoringQuery.class);

            Query inner = ((ForceNoBulkScoringQuery) rewritten).getWrappedQuery();
            assertThat(inner).isNotEqualTo(pq);


        }",No Smells
"@Test
    public void testMultiTermQueryEquals() throws Exception {

        WildcardQuery wq = new WildcardQuery(new Term(""field"", ""term""));
        Query q1 = new SpanRewriter().rewrite(wq, null);
        Query q2 = new SpanRewriter().rewrite(wq, null);

        assertThat(q1).isEqualTo(q2);
    }",No Smells
"@Test
    public void testPhraseQuery() throws Exception {

        PhraseQuery pq = new PhraseQuery(1, ""field1"", ""term1"", ""term2"");

        Query q = new SpanRewriter().rewrite(pq, null);
        assertThat(q).isInstanceOf(SpanOffsetReportingQuery.class);

        SpanOffsetReportingQuery or = (SpanOffsetReportingQuery) q;
        assertThat(or.getWrappedQuery()).isInstanceOf(SpanNearQuery.class);
        SpanNearQuery sq = (SpanNearQuery) or.getWrappedQuery();
        assertThat(sq.getClauses()).contains(new SpanTermQuery(new Term(""field1"", ""term1"")),
                new SpanTermQuery(new Term(""field1"", ""term2"")));
        assertThat(sq.getSlop()).isEqualTo(1);
    }",No Smells
"@Test
    public void when_permission_revoked_the_resource_is_saved() throws Exception {
        service.revokePermission(resourceSecured, resourceSaver, Subject.APPLICATION);
        verify(resourceSaver).save(resourceSecured);
    }",No Smells
"@Test
    public void deleteCurrentBranch() throws Exception {
        FileUtil.delete(localGitPath);
        RepositoryManager.create(localGitPath, null);
        RepositoryManager.checkoutExistingBranchOrCreateOrphan(localGitPath, true, null, null, ""newBranch"");

        // as the current branch is ""newBranch"" the deletion will go to tmp branch
        RepositoryManager.deleteBranch(localGitPath, ""newBranch"", false);

        assertThat(RepositoryManager.isOnBranch(localGitPath, ""tmp"")).isTrue();
    }",Mystery Guest + Resource Optimism
"@Test
    public void check_an_update_override_everything() throws Exception {
        Map<String, String> patch = new HashMap<String, String>() {{
            put(""d"", ""4"");
        }",No Smells
"@Test
    public void testLdapUserImport() throws NamingException {
        Mockito.when(ldapTemplate.getContextSource()).thenReturn(Mockito.mock(ContextSource.class));
        int userCount = 10;
        List<User> users = prepareGetAllUserMock(userCount);

        // for each user we should check if it exists in the user repository and only if not then we add it.
        for (int i = 0; i < users.size(); i++) {
            User user = users.get(i);
            if (i % 2 == 0) {
                user.setLastName(""test"");
                Mockito.when(alienUserDao.find(user.getUsername())).thenReturn(user);
            }",Eager Test
"@Test
    public void invalidBooleanEqualsShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createEqualDefinition(ToscaTypes.BOOLEAN.toString(), ""true"", ""false""),
                ToscaSequence.class);
        Assert.assertEquals(1, violations.size());
    }",No Smells
"@Test
    public void invalidFloatEqualsShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createEqualDefinition(ToscaTypes.FLOAT.toString(), ""10.56"", ""40.56""),
                ToscaSequence.class);
        Assert.assertEquals(1, violations.size());
    }",No Smells
"@Test
    public void invalidFloatGreaterThanShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createGreaterThanDefinition(ToscaTypes.FLOAT.toString(), 10.56d, ""5.56""),
                ToscaSequence.class);
        Assert.assertEquals(1, violations.size());

        violations = validator.validate(createGreaterThanDefinition(ToscaTypes.FLOAT.toString(), 10.56d, ""10.56""), ToscaSequence.class);
        Assert.assertEquals(1, violations.size());
    }",No Smells
"@Test
    public void invalidIntegerEqualsShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createEqualDefinition(ToscaTypes.INTEGER.toString(), ""10"", ""40""),
                ToscaSequence.class);
        Assert.assertEquals(1, violations.size());
    }",No Smells
"@Test
    public void validFloatEqualsShouldNotCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createEqualDefinition(ToscaTypes.FLOAT.toString(), ""10.56"", ""10.56""),
                ToscaSequence.class);
        Assert.assertEquals(0, violations.size());
    }",No Smells
"@Test
    public void validFloatGreaterOrEqualShouldNotCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(
                createGreaterOrEqualDefinition(ToscaTypes.FLOAT.toString(), 10.56d, ""10.56""), ToscaSequence.class);
        Assert.assertEquals(0, violations.size());

        violations = validator.validate(createGreaterOrEqualDefinition(ToscaTypes.FLOAT.toString(), 10.56d, ""20.56""), ToscaSequence.class);
        Assert.assertEquals(0, violations.size());
    }",No Smells
"@Test
    public void validIntegerGreaterOrEqualShouldNotCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createGreaterOrEqualDefinition(ToscaTypes.INTEGER.toString(), 10l, ""10""),
                ToscaSequence.class);
        Assert.assertEquals(0, violations.size());

        violations = validator.validate(createGreaterOrEqualDefinition(ToscaTypes.INTEGER.toString(), 10l, ""20""), ToscaSequence.class);
        Assert.assertEquals(0, violations.size());
    }",No Smells
"@Test
    public void validIntegerGreaterThanShouldNotCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createGreaterThanDefinition(ToscaTypes.INTEGER.toString(), 10l, ""20""),
                ToscaSequence.class);
        Assert.assertEquals(0, violations.size());
    }",No Smells
"@Test
    public void validStringEqualsShouldNotCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(
                createEqualDefinition(ToscaTypes.STRING.toString(), ""constrainted value"", ""constrainted value""), ToscaSequence.class);
        Assert.assertEquals(0, violations.size());
    }",No Smells
"@Test
    public void invalidBooleanDefaultShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createDefinitions(ToscaTypes.BOOLEAN, ""not a boolean""));
        Assert.assertEquals(1, violations.size());
    }",No Smells
"@Test
    public void invalidVersionDefaultShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createDefinitions(ToscaTypes.VERSION, ""not a version""));
        Assert.assertEquals(1, violations.size());
    }",No Smells
"@Test
    public void validBooleanDefaultShouldNotCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createDefinitions(ToscaTypes.BOOLEAN, ""true""));
        Assert.assertEquals(0, violations.size());
    }",No Smells
"@Test
    public void validNoTimezoneTimestampDefaultShouldNotCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator
                .validate(createDefinitions(ToscaTypes.TIMESTAMP, ""2001-12-15 2:59:43.10""));
        Assert.assertEquals(0, violations.size());
    }",No Smells
"@Test
    public void validVersionDefaultShouldNotCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createDefinitions(ToscaTypes.VERSION, ""1.3.15""));
        Assert.assertEquals(0, violations.size());
    }",No Smells
"@Test
    public void referenceToMissingTypeShouldFail() {
        ReferencedParser referencedParser = new ReferencedParser(""missingParser"");
        ParsingContextExecution contextExecution = new ParsingContextExecution();
        try {
            contextExecution.init();
            contextExecution.setRegistry(Maps.newHashMap());
            Node node = Mockito.mock(Node.class);
            Mockito.when(node.getStartMark()).thenReturn(new Mark(""name"", 0, 10, 10, """", 0));
            Mockito.when(node.getEndMark()).thenReturn(new Mark(""name"", 0, 10, 10, """", 0));
            referencedParser.parse(node, contextExecution);
            assertEquals(ParsingErrorLevel.ERROR, contextExecution.getParsingErrors().get(0).getErrorLevel());
            assertEquals(ErrorCode.ALIEN_MAPPING_ERROR, contextExecution.getParsingErrors().get(0).getErrorCode());
        }",No Smells
"@Test
    public void testMapIsNotEmptyAndContainsNotnullValues() {
        Assert.assertFalse(utils.mapIsNotEmptyAndContainsNotnullValues(null));
        Assert.assertFalse(utils.mapIsNotEmptyAndContainsNotnullValues(Maps.newHashMap()));
        Map<String, Object> map = Maps.newHashMap();
        map.put(""key1"", null);
        Assert.assertFalse(utils.mapIsNotEmptyAndContainsNotnullValues(map));
        map.put(""key2"", ""something"");
        Assert.assertTrue(utils.mapIsNotEmptyAndContainsNotnullValues(map));

        // inner collection
        Map<String, Set<String>> mapOfSet = Maps.newHashMap();
        Set<String> set = Sets.newHashSet();
        mapOfSet.put(""key1"", set);
        // the set is empty
        Assert.assertFalse(utils.mapIsNotEmptyAndContainsNotnullValues(mapOfSet));
        Set<String> filledSet = Sets.newHashSet(""something"");
        mapOfSet.put(""key2"", filledSet);
        // the second set contains something
        Assert.assertTrue(utils.mapIsNotEmptyAndContainsNotnullValues(mapOfSet));

        // inner map
        Map<String, Map<String, Set<String>>> mapOfmap = Maps.newHashMap();
        Map<String, Set<String>> innerMap = Maps.newHashMap();
        mapOfmap.put(""key1"", innerMap);
        // the inner map is empty
        Assert.assertFalse(utils.mapIsNotEmptyAndContainsNotnullValues(mapOfmap));
        Map<String, Set<String>> innerMap2 = Maps.newHashMap();
        Set<String> emptySet = Sets.newHashSet();
        innerMap2.put(""key21"", emptySet);
        mapOfmap.put(""key2"", innerMap2);
        // the inner set is empty
        Assert.assertFalse(utils.mapIsNotEmptyAndContainsNotnullValues(mapOfmap));
        filledSet = Sets.newHashSet(""something"");
        innerMap2.put(""key22"", filledSet);
        Assert.assertTrue(utils.mapIsNotEmptyAndContainsNotnullValues(mapOfmap));

        // ScalarPropertyValue
        ScalarPropertyValue spv = new ScalarPropertyValue();
        Map<String, AbstractPropertyValue> apvMap = new HashMap<String, AbstractPropertyValue>();
        apvMap.put(""key1"", spv);
        Assert.assertFalse(utils.mapIsNotEmptyAndContainsNotnullValues(apvMap));
        spv.setValue(""value"");
        Assert.assertTrue(utils.mapIsNotEmptyAndContainsNotnullValues(apvMap));
    }",No Smells
"@Test
    public void testRenderDescription() throws IOException {
        Assert.assertEquals(""\""a single line description\"""", utils.renderDescription(""a single line description"", ""  ""));
        Assert.assertEquals(""|\n  a multi line \n  description"", utils.renderDescription(""a multi line \ndescription"", ""  ""));
    }",No Smells
"@Test
    public void deserializationWithDefaultContext() throws IOException {
        TestObject testObject = new TestObject();
        testObject.map.put(""key1"", new InnerObject(""innerStr1"", 1));
        ObjectMapper mapper = new ObjectMapper();
        String str = mapper.writeValueAsString(testObject);
        TestObject readObject = mapper.readValue(str, TestObject.class);

        Assert.assertEquals(testObject, readObject);
    }",No Smells
"@Test
    public void serializationWithMapContextShouldSerializeToArray() throws JsonProcessingException {
        TestObject testObject = new TestObject();
        testObject.map.put(""key1"", new InnerObject(""innerStr1"", 1));
        MapRestMapper mapper = new MapRestMapper();
        String str = mapper.writeValueAsString(testObject);
        Assert.assertEquals(""{\""map\"":[{\""key\"":\""key1\"",\""value\"":{\""str\"":\""innerStr1\"",\""integer\"":1}",No Smells
"@Test
    public void validateApplicationIdTest() {
        NameValidationUtils.validateApplicationId(""app"");
        NameValidationUtils.validateApplicationId(""app_2"");

        List<String> invalids = Lists.newArrayList(""app"", ""App-2"", ""App.unix"", ""App 2"");
        invalids.forEach(invalid -> {
            expectException(new Callable() {
                @Override
                public Object call() throws Exception {
                    NameValidationUtils.validateApplicationId(invalid);
                    return null;
                }",Eager Test
"@Test
    public void testValidBooleanProperty() throws Exception {
        PropertyDefinition propertyDefinition = new PropertyDefinition();
        propertyDefinition.setType(ToscaTypes.BOOLEAN);
        ConstraintPropertyService.checkPropertyConstraint(""test"", ""true"", propertyDefinition);
        ConstraintPropertyService.checkPropertyConstraint(""test"", ""false"", propertyDefinition);
        ConstraintPropertyService.checkPropertyConstraint(""test"", ""1"", propertyDefinition);
        ConstraintPropertyService.checkPropertyConstraint(""test"", ""0"", propertyDefinition);
        ConstraintPropertyService.checkPropertyConstraint(""test"", ""TRUE"", propertyDefinition);
        ConstraintPropertyService.checkPropertyConstraint(""test"", ""FALSE"", propertyDefinition);
        // in fact anything can be used for boolean
        ConstraintPropertyService.checkPropertyConstraint(""test"", ""anything"", propertyDefinition);
    }",No Smells
"@Test
    public void testValidIntegerProperty() throws Exception {
        PropertyDefinition propertyDefinition = new PropertyDefinition();
        propertyDefinition.setType(ToscaTypes.INTEGER);
        ConstraintPropertyService.checkPropertyConstraint(""test"", ""128"", propertyDefinition);
    }",No Smells
"@Test
    public void testValidStringConstraintProperty() throws Exception {
        PropertyDefinition propertyDefinition = new PropertyDefinition();
        propertyDefinition.setType(ToscaTypes.STRING);
        propertyDefinition.setConstraints(new ArrayList<PropertyConstraint>());
        LengthConstraint lengthConstraint = new LengthConstraint();
        lengthConstraint.setLength(3);
        propertyDefinition.getConstraints().add(lengthConstraint);

        ConstraintPropertyService.checkPropertyConstraint(""test"", ""val"", propertyDefinition);
    }",No Smells
"@Test
    public void testValidVersionProperty() throws Exception {
        PropertyDefinition propertyDefinition = new PropertyDefinition();
        propertyDefinition.setType(ToscaTypes.VERSION);
        ConstraintPropertyService.checkPropertyConstraint(""test"", ""2.0"", propertyDefinition);
        ConstraintPropertyService.checkPropertyConstraint(""test"", ""1.0.0-SNAPSHOT"", propertyDefinition);
    }",No Smells
"@Test
    public void testEqualsNullSafe() {
        assertFalse(newArtifactVersion(""1"").equals(null));
    }",No Smells
"@Test
    public void testVersionComparing() {
        assertVersionEqual(""1"", ""1"");
        assertVersionOlder(""1"", ""2"");
        assertVersionOlder(""1.5"", ""2"");
        assertVersionOlder(""1"", ""2.5"");
        assertVersionEqual(""1"", ""1.0"");
        assertVersionEqual(""1"", ""1.0.0"");
        assertVersionOlder(""1.0"", ""1.1"");
        assertVersionOlder(""1.1"", ""1.2"");
        assertVersionOlder(""1.0.0"", ""1.1"");
        assertVersionOlder(""1.7.3.0"", ""1.7.3.1"");
        assertVersionOlder(""1.1"", ""1.2.0"");

        assertVersionOlder(""1.1.2.alpha1"", ""1.1.2"");
        assertVersionOlder(""1.1.2.alpha1"", ""1.1.2.beta1"");
        assertVersionOlder(""1.1.2.beta1"", ""1.2"");

        assertVersionOlder(""1.0-alpha-1"", ""1.0"");
        assertVersionOlder(""1.0-alpha-1"", ""1.0-alpha-2"");
        assertVersionOlder(""1.0-alpha-2"", ""1.0-alpha-15"");
        assertVersionOlder(""1.0-alpha-1"", ""1.0-beta-1"");

        assertVersionOlder(""1.0-beta-1"", ""1.0-SNAPSHOT"");
        assertVersionOlder(""1.0-SNAPSHOT"", ""1.0"");
        assertVersionOlder(""1.0-alpha-1-SNAPSHOT"", ""1.0-alpha-1"");

        assertVersionOlder(""1.0"", ""1.0-1"");
        assertVersionOlder(""1.0-1"", ""1.0-2"");
        assertVersionEqual(""2.0-0"", ""2.0"");
        assertVersionOlder(""2.0"", ""2.0-1"");
        assertVersionOlder(""2.0.0"", ""2.0-1"");
        assertVersionOlder(""2.0-1"", ""2.0.1"");

        assertVersionOlder(""2.0.1-klm"", ""2.0.1-lmn"");
        assertVersionOlder(""2.0.1"", ""2.0.1-xyz"");
        assertVersionOlder(""2.0.1-xyz-1"", ""2.0.1-1-xyz"");

        assertVersionOlder(""2.0.1"", ""2.0.1-123"");
        assertVersionOlder(""2.0.1-xyz"", ""2.0.1-123"");

        assertVersionOlder(""1.2.3-10000000000"", ""1.2.3-10000000001"");
        assertVersionOlder(""1.2.3-1"", ""1.2.3-10000000001"");
        assertVersionOlder(""2.3.0-v200706262000"", ""2.3.0-v200706262130""); // org.eclipse:emf:2.3.0-v200706262000
        // org.eclipse.wst.common_core.feature_2.0.0.v200706041905-7C78EK9E_EkMNfNOd2d8qq
        assertVersionOlder(""2.0.0.v200706041905-7C78EK9E_EkMNfNOd2d8qq"", ""2.0.0.v200706041906-7C78EK9E_EkMNfNOd2d8qq"");
    }",Eager Test
"@Test
    public void testVersionParsing() {
        checkVersionParsing(""1"", 1, 0, 0, 0, null);
        checkVersionParsing(""1.2"", 1, 2, 0, 0, null);
        checkVersionParsing(""1.2.3"", 1, 2, 3, 0, null);
        checkVersionParsing(""1.2.3-1"", 1, 2, 3, 1, null);
        checkVersionParsing(""1.2.3-alpha-1"", 1, 2, 3, 0, ""alpha-1"");
        checkVersionParsing(""1.2-alpha-1"", 1, 2, 0, 0, ""alpha-1"");
        checkVersionParsing(""1.2-alpha-1-20050205.060708-1"", 1, 2, 0, 0, ""alpha-1-20050205.060708-1"");
        checkVersionParsing(""RELEASE"", 0, 0, 0, 0, ""RELEASE"");
        checkVersionParsing(""2.0-1"", 2, 0, 0, 1, null);

        // 0 at the beginning of a number has a special handling
        checkVersionParsing(""02"", 0, 0, 0, 0, ""02"");
        checkVersionParsing(""0.09"", 0, 0, 0, 0, ""0.09"");
        checkVersionParsing(""0.2.09"", 0, 0, 0, 0, ""0.2.09"");
        checkVersionParsing(""2.0-01"", 2, 0, 0, 0, ""01"");

        // version schemes not really supported: fully transformed as qualifier
        checkVersionParsing(""1.0.1b"", 0, 0, 0, 0, ""1.0.1b"");
        checkVersionParsing(""1.0M2"", 0, 0, 0, 0, ""1.0M2"");
        checkVersionParsing(""1.0RC2"", 0, 0, 0, 0, ""1.0RC2"");
        checkVersionParsing(""1.1.2.beta1"", 1, 1, 2, 0, ""beta1"");
        checkVersionParsing(""1.7.3.beta1"", 1, 7, 3, 0, ""beta1"");
        checkVersionParsing(""1.7.3.0"", 0, 0, 0, 0, ""1.7.3.0"");
        checkVersionParsing(""1.7.3.0-1"", 0, 0, 0, 0, ""1.7.3.0-1"");
        checkVersionParsing(""PATCH-1193602"", 0, 0, 0, 0, ""PATCH-1193602"");
        checkVersionParsing(""5.0.0alpha-2006020117"", 0, 0, 0, 0, ""5.0.0alpha-2006020117"");
        checkVersionParsing(""1.0.0.-SNAPSHOT"", 0, 0, 0, 0, ""1.0.0.-SNAPSHOT"");
        checkVersionParsing(""1..0-SNAPSHOT"", 0, 0, 0, 0, ""1..0-SNAPSHOT"");
        checkVersionParsing(""1.0.-SNAPSHOT"", 0, 0, 0, 0, ""1.0.-SNAPSHOT"");
        checkVersionParsing("".1.0-SNAPSHOT"", 0, 0, 0, 0, "".1.0-SNAPSHOT"");

        checkVersionParsing(""1.2.3.200705301630"", 0, 0, 0, 0, ""1.2.3.200705301630"");
        checkVersionParsing(""1.2.3-200705301630"", 1, 2, 3, 0, ""200705301630"");
    }",Eager Test
"@Test
    public void testParseVersionSuccess() throws InvalidVersionException {
        Assert.assertNotNull(VersionUtil.parseVersion(""1.0""));
    }",No Smells
"@Test
    public void migrate_data_previously_store_in_elastic_search() throws Exception {
        String existingId = AbstractDeploymentConfig.generateId(""versionOK"", ""envId"");

        // given a configuration store in ES
        when(alienDao.findById(DeploymentMatchingConfiguration.class, existingId)).thenReturn(new DeploymentMatchingConfiguration(""versionOK"", ""envId""));
        // given the location of the existing config is defined
        Path configLocalPath = Paths.get(""target/deployment_config_dao_test/config"");
        Files.deleteIfExists(configLocalPath);
        when(localGitRepositoryPathResolver.resolve(eq(DeploymentMatchingConfiguration.class), eq(existingId))).thenReturn(configLocalPath);

        // when looking for a config that not existing in Git yet
        DeploymentMatchingConfiguration config = dao.findById(DeploymentMatchingConfiguration.class, existingId);

        // then we get data from ES
        assertThat(config).isNotNull();
        assertThat(config.getId()).isEqualTo(existingId);
        // ES data has been deleted
        verify(alienDao).delete(DeploymentMatchingConfiguration.class, existingId);
        // check data has been migrated into git
        assertThat(Files.exists(configLocalPath)).isTrue();
    }",Mystery Guest + Resource Optimism
"@Test
    public void testGetByNodeTypes() {
        ServiceResource serviceResource = new ServiceResource();
        serviceResource.setId(""service1"");
        serviceResource.setNodeInstance(new NodeInstance());
        serviceResource.getNodeInstance().setTypeVersion(""1.0.0-SNAPSHOT"");
        serviceResource.getNodeInstance().setNodeTemplate(new NodeTemplate());
        serviceResource.getNodeInstance().getNodeTemplate().setType(""org.alien4cloud.nodes.MyType"");

        alienDao.save(serviceResource);

        ServiceResource[] services = serviceResourceService.getByNodeTypes(""org.alien4cloud.nodes.MyType"", ""1.0.0-SNAPSHOT"");

        Assert.assertNotNull(services);
        Assert.assertEquals(1, services.length);

        services = serviceResourceService.getByNodeTypes(""org.alien4cloud.nodes.UnusedType"", ""1.0.0-SNAPSHOT"");

        Assert.assertNotNull(services);
        Assert.assertEquals(0, services.length);

        services = serviceResourceService.getByNodeTypes(""org.alien4cloud.nodes.MyType"", ""1.0.0"");

        Assert.assertNotNull(services);
        Assert.assertEquals(0, services.length);
    }",No Smells
"@Test
    public void test() throws Exception {
        alienDao.delete(NodeType.class, QueryBuilders.matchAllQuery());
        Method method = toscaTypeIndexerService.getClass().getDeclaredMethod(""hasElementWithTag"", Class.class, String.class, String.class);
        method.setAccessible(true);
        boolean hasElementWithTag = (boolean) method.invoke(toscaTypeIndexerService, NodeType.class, ""icon"", ""my_icon"");
        Assert.assertFalse(hasElementWithTag);

        NodeType nodeType = new NodeType();
        nodeType.setElementId(""element"");
        nodeType.setArchiveName(""archive"");
        nodeType.setArchiveVersion(""1.0.0"");
        nodeType.setTags(Lists.newArrayList(new Tag(""icon"", ""another_icon"")));
        alienDao.save(nodeType);

        hasElementWithTag = (boolean) method.invoke(toscaTypeIndexerService, NodeType.class, ""icon"", ""my_icon"");
        Assert.assertFalse(hasElementWithTag);

        nodeType = new NodeType();
        nodeType.setElementId(""otherelement"");
        nodeType.setArchiveName(""archive"");
        nodeType.setArchiveVersion(""1.0.0"");
        nodeType.setTags(Lists.newArrayList(new Tag(""icon"", ""my_icon"")));
        alienDao.save(nodeType);

        hasElementWithTag = (boolean) method.invoke(toscaTypeIndexerService, NodeType.class, ""icon"", ""my_icon"");
        Assert.assertTrue(hasElementWithTag);
    }",No Smells
"@Test
    public void invalidFloatGreaterOrEqualConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createGreaterOrEqualDefinition(ToscaTypes.FLOAT.toString(), ""not a float""),
                ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void invalidFloatGreaterThanConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createGreaterThanDefinition(ToscaTypes.FLOAT.toString(), ""not a float""),
                ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void invalidFloatValidValuesConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(
                createValidValuesDefinition(ToscaTypes.FLOAT.toString(), Lists.newArrayList(""42.345"", ""not a float"")), ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void invalidIntegerEqualConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createEqualDefinition(ToscaTypes.INTEGER.toString(), ""not an integer""),
                ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void invalidIntegerGreaterOrEqualConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(
                createGreaterOrEqualDefinition(ToscaTypes.INTEGER.toString(), ""not an integer""), ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void invalidIntegerGreaterThanConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(
                createGreaterThanDefinition(ToscaTypes.INTEGER.toString(), ""not an integer""), ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void invalidIntegerInRangeConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createInRangeDefinition(ToscaTypes.INTEGER.toString(), 42.456f, 65.343f),
                ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void invalidIntegerLengthConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createLenghtDefinition(ToscaTypes.INTEGER.toString(), 2),
                ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void invalidIntegerLessThanConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createLessDefinition(ToscaTypes.INTEGER.toString(), ""not an integer""),
                ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void invalidIntegerValidValuesConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(
                createValidValuesDefinition(ToscaTypes.INTEGER.toString(), Lists.newArrayList(""42"", ""not an integer"")), ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void invalidStringGreaterThanConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createGreaterThanDefinition(ToscaTypes.STRING.toString(), ""value""),
                ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void invalidStringLessThanConstraintShouldCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createLessDefinition(ToscaTypes.STRING.toString(), ""value""),
                ToscaSequence.class);
        Assert.assertEquals(2, violations.size());
    }",No Smells
"@Test
    public void validFloatInRangeConstraintShouldNotCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createInRangeDefinition(ToscaTypes.FLOAT.toString(), 42.456f, 65.343f),
                ToscaSequence.class);
        Assert.assertEquals(0, violations.size());
    }",No Smells
"@Test
    public void validIntegerInRangeConstraintShouldNotCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createInRangeDefinition(ToscaTypes.INTEGER.toString(), 42, 65),
                ToscaSequence.class);
        Assert.assertEquals(0, violations.size());
    }",No Smells
"@Test
    public void validIntegerLessThanConstraintShouldNotCreateViolations() {
        Set<ConstraintViolation<PropertyDefinition>> violations = validator.validate(createLessDefinition(ToscaTypes.INTEGER.toString(), 42),
                ToscaSequence.class);
        Assert.assertEquals(0, violations.size());
    }",No Smells
"@Test
    public void nodeGetComplexPropMap() {
        FunctionEvaluatorContext context = getEvaluationContext();
        NodeTemplate template = context.getTopology().getNodeTemplates().get(""my_node"");

        PropertyValue resolved = resolveValue(context, template, template.getProperties(), template.getProperties().get(""get_complex_prop_map""));
        Assert.assertNotNull(resolved);
        Assert.assertEquals(ScalarPropertyValue.class, resolved.getClass());
        Assert.assertEquals(""element 1 value"", resolved.getValue());
    }",No Smells
"@Test
    public void nodeGetConcatProp() {
        FunctionEvaluatorContext context = getEvaluationContext();
        NodeTemplate template = context.getTopology().getNodeTemplates().get(""my_node"");

        PropertyValue resolved = resolveValue(context, template, template.getProperties(), template.getProperties().get(""get_concat_prop""));
        Assert.assertNotNull(resolved);
        Assert.assertEquals(ScalarPropertyValue.class, resolved.getClass());
        Assert.assertEquals(""input is: scalar input value property is: scalar value"", resolved.getValue());
    }",No Smells
"@Test
    public void getCapabilityByTypeTest() {
        NodeTemplate nodeTemplate = new NodeTemplate();
        Capability nodeCapability = new Capability(""org.alien4cloud.capabilities.SampleCapability"", null);
        nodeTemplate.setCapabilities(Maps.newHashMap(""test"", nodeCapability));
        // if the capability type exactly equals then no tosca context and request is required
        Capability capability = getCapabilityByType(nodeTemplate, ""org.alien4cloud.capabilities.SampleCapability"");
        assertSame(nodeCapability, capability);

        // if the capability derives from parent type then a TOSCA context and query is required to fetch the type.
        CapabilityType capabilityType = new CapabilityType();
        capabilityType.setElementId(""org.alien4cloud.capabilities.SampleCapability"");
        capabilityType.setDerivedFrom(Lists.newArrayList(""org.alien4cloud.capabilities.TestCapability""));
        Mockito.reset(csarRepositorySearchService);
        Mockito.when(csarRepositorySearchService.getElementInDependencies(Mockito.eq(CapabilityType.class),
                Mockito.eq(""org.alien4cloud.capabilities.SampleCapability""), Mockito.any(Set.class))).thenReturn(capabilityType);

        capability = toscaContextualAspect.execInToscaContext(() -> getCapabilityByType(nodeTemplate, ""org.alien4cloud.capabilities.TestCapability""), false,
                Sets.newHashSet(new CSARDependency(""org.alien4cloud.testArchive"", ""1.0.0-SNAPSHOT"")));
        assertSame(nodeCapability, capability);
    }",No Smells
"@Test
    public void getMissingCapabilityByTypeTest() {
        NodeTemplate nodeTemplate = new NodeTemplate();
        Capability nodeCapability = new Capability(""org.alien4cloud.capabilities.SampleCapability"", null);
        nodeTemplate.setCapabilities(Maps.newHashMap(""test"", nodeCapability));
        // if the capability derives from parent type then a TOSCA context and query is required to fetch the type.
        CapabilityType capabilityType = new CapabilityType();
        capabilityType.setElementId(""org.alien4cloud.capabilities.SampleCapability"");
        capabilityType.setDerivedFrom(Lists.newArrayList(""org.alien4cloud.capabilities.TestCapability""));
        Mockito.reset(csarRepositorySearchService);
        Mockito.when(csarRepositorySearchService.getElementInDependencies(Mockito.eq(CapabilityType.class),
                Mockito.eq(""org.alien4cloud.capabilities.SampleCapability""), Mockito.any(Set.class))).thenReturn(capabilityType);

        Capability capability = toscaContextualAspect.execInToscaContext(() -> getCapabilityByType(nodeTemplate, ""org.alien4cloud.capabilities.Unknown""), false,
                Sets.newHashSet(new CSARDependency(""org.alien4cloud.testArchive"", ""1.0.0-SNAPSHOT"")));
        assertNull(capability);
    }",No Smells
"@Test
    public void check_app_meta_can_be_resolved() throws Exception {
        Assertions.assertThat(alienContextVariables.getProperty(""a4c.meta1"")).isEqualTo(""meta1 value"");
        Assertions.assertThat(alienContextVariables.getProperty(""a4c.meta2"")).isEqualTo(""meta2 value"");
    }",No Smells
"@Test
    public void parse() throws Exception {
        assertThat(spelExpressionProcessor.process(""#{ #var1 }",No Smells
"@Test
    public void convert_version_to_property_value() throws Exception {
        PropertyDefinition propertyDefinition = new PropertyDefinition();
        propertyDefinition.setType(ToscaTypes.VERSION);

        PropertyValue propertyValue = converter.toPropertyValue(""3.4-SNAPSHOT"", propertyDefinition);

        Object version = ToscaTypes.fromYamlTypeName(propertyDefinition.getType()).parse(propertyValue.getValue().toString());
        assertThat(version).isInstanceOf(Version.class);
        assertThat(version).isEqualTo(new Version(""3.4-SNAPSHOT""));
    }",No Smells
"@Test
    public void check_app_variable_can_be_overridden_in_env() throws Exception {
        assertThat(resolver.resolve(""overidden_variable"")).isEqualTo(""ok"");
    }",No Smells
"@Test
    public void check_variable_from_env_type_can_be_resolved() throws Exception {
        assertThat(resolver.resolve(""env_type_variable"")).isEqualTo(""new env type var"");
    }",No Smells
"@Test
    public void predefined_var_cannot_be_redefined() throws Exception {
        assertThat(resolver.resolve(""a4c.application.name"")).isEqualTo(""originalAppName"");
    }",No Smells
"@Test
    public void resolve_app_var_int() throws Exception {
        assertThat(resolver.resolve(""int_variable"", Integer.class)).isEqualTo(1);
    }",No Smells
"@Test
    public void resolve_complex_with_dot_field() throws Exception {
        Map map = resolver.resolve(""complex_with_dot_field.complex.dot.field"", Map.class);
        // does not work. int converted to String :(
        // assertThat(map).isEqualTo(ImmutableMap.builder().put(""value"", 3.14).build());

        assertThat(map).isEqualTo(ImmutableMap.builder().put(""value"", ""3.14"").build());
    }",No Smells
"@Test
    public void testAddAndReturn(){
        CrawlDatums datums = new CrawlDatums();


        String url = ""http://cn.bing.com/"";

        CrawlDatum addedDatum = datums.addAndReturn(url);
        assertEquals(url,addedDatum.url());


        ArrayList<String> urlList = new ArrayList<String>();
        for(int i = 0;i<10;i++){
            urlList.add(""https://www.google.com/""+i);
        }",Mystery Guest
"@Test
    public void testBerkeleyDBInjector() throws Exception {
        BerkeleyDBManager dbManager = new BerkeleyDBManager(tempCrawlPath);
        testInject(dbManager);
    }",Eager Test + Mystery Guest
"@Test
    public void testRocksDBInjector() throws Exception {
        RocksDBManager dbManager = new RocksDBManager(tempCrawlPath);
        testInject(dbManager);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testReportTrigger() {
        XmlHttpResponse resp = new XmlHttpResponse();
        UnitTestHelper.fillResponse(resp, ""leanapps/report.xml"");
        resp.setStatusCode(200);
        fixture.setResponse(resp);
        assertEquals(""NEW_POLICY_NEW_CUSTOMER"", fixture.reportTrigger());
    }",Mystery Guest + Resource Optimism
"@Test
    public void invokeBadFunction() {
        checkSlimFixtureExceptionThrown(
                () -> fixture.invokeFunctionWithArguments(""unknown"", ""1""),
                ""No function found for this name and these arguments"");
    }",No Smells
"@Test
    public void invokeFunction() {
        fixture.set(""a"", 21);
        Object result = fixture.evaluate(""function hello(name) { return 'Hello, ' + name + a; }",No Smells
"@Test
    public void testAddMonths() {
        XMLGregorianCalendar cal = calendarUtil.buildXMLGregorianCalendar();
        int tz = cal.getTimezone();
        XMLGregorianCalendar result = addMonths(2, cal);
        assertEquals(8, result.getMonth());
        assertEquals(0, result.getTimezone() - tz);
    }",No Smells
"@Test
    public void testAddMonthsIntoSummerTime() {
        XMLGregorianCalendar cal = calendarUtil.buildXMLGregorianCalendar();
        cal.setMonth(2);
        cal.setDay(1);
        cal.setHour(0);
        cal.setMinute(0);
        cal.setSecond(0);
        cal.setMillisecond(0);
        XMLGregorianCalendar result = calendarUtil.addMonths(cal, 2);
        assertEquals(4, result.getMonth());
    }",No Smells
"@Test
    public void testAddMonthsIntoWinterTime() {
        XMLGregorianCalendar cal = calendarUtil.buildXMLGregorianCalendar();
        cal.setMonth(10);
        cal.setDay(1);
        cal.setHour(0);
        cal.setMinute(0);
        cal.setSecond(0);
        cal.setMillisecond(0);
        XMLGregorianCalendar result = calendarUtil.addMonths(cal, 2);
        assertEquals(12, result.getMonth());
    }",No Smells
"@Test
    public void testAddYears() {
        XMLGregorianCalendar cal = calendarUtil.buildXMLGregorianCalendar();
        int tz = cal.getTimezone();
        XMLGregorianCalendar result = addYears(2, cal);
        assertEquals(2002, result.getYear());
        assertEquals(0, result.getTimezone() - tz);
    }",No Smells
"@Test
    public void testBuildXMLGregorianCalendarDateForNull() {
        assertNull(calendarUtil.buildXMLGregorianCalendarDate((XMLGregorianCalendar) null));
        assertNull(calendarUtil.buildXMLGregorianCalendarDate((Calendar) null));
        assertNull(calendarUtil.buildXMLGregorianCalendarDate((Date) null));
    }",No Smells
"@Test
    public void testBuildXMLGregorianCalendarDateTime() {
        GregorianCalendar today = new GregorianCalendar();
        XMLGregorianCalendar cal = calendarUtil.buildXMLGregorianCalendarDateTime(today);
        assertTrue(cal.getYear() == today.get(Calendar.YEAR));
        assertTrue(cal.getMonth() == today.get(Calendar.MONTH) + 1);
        assertTrue(cal.getDay() == today.get(Calendar.DAY_OF_MONTH));
    }",No Smells
"@Test
    public void testSubstractYears() {
        XMLGregorianCalendar cal = calendarUtil.buildXMLGregorianCalendar();
        int tz = cal.getTimezone();
        XMLGregorianCalendar result = addYears(-2, cal);
        assertEquals(1998, result.getYear());
        assertEquals(0, result.getTimezone() - tz);
    }",No Smells
"@Test
    public void firstNonNullNullCollection() {
        assertNull(firstNonNull(x -> x++, (Collection<Integer>) null));
    }",No Smells
"@Test
    public void testCleanupValueMailAddress() {
        assertEquals(""hallo@example.com"", cleaner.cleanupValue(""<a href=\""mailto:hallo@example.com\"">hallo@example.com</a>""));
        assertEquals(""hallo2@example.com"", cleaner.cleanupValue(""hallo2@example.com""));
    }",No Smells
"@Test
    public void testParseLalResponse() {
        XmlHttpResponse lalResponse = new XmlHttpResponse();
        UnitTestHelper.fillResponse(lalResponse, ""leanapps/getPolicyCheckResponse.xml"");
        String key = lalResponse.toString();
        assertSame(lalResponse, HttpResponse.parse(key));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testValidResponseOk() {
        HttpResponse resp = new HttpResponse();
        resp.setStatusCode(HttpStatus.SC_OK);
        resp.validResponse();

        resp.setStatusCode(201);
        resp.validResponse();

        resp.setStatusCode(299);
        resp.validResponse();

        resp.setStatusCode(301);
        resp.validResponse();

        resp.setStatusCode(302);
        resp.validResponse();

        resp.setStatusCode(100);
        resp.validResponse();
    }",No Smells
"@Test
    public void testValidResponseServerErrorGeneric() {
        HttpResponse resp = new HttpResponse();
        resp.setStatusCode(HttpStatus.SC_INTERNAL_SERVER_ERROR);
        assertThrows(RuntimeException.class, () -> resp.validResponse());
    }",No Smells
"@Test
    public void testSortingOnString() {
        String h = helper.sort(""{\n"" +
                ""  \""extraKey\"": 2,\n"" +
                ""  \""parameters\"": [\n"" +
                ""    {\n"" +
                ""      \""category\"": \""reference\"",\n"" +
                ""      \""price\"": 8.95\n"" +
                ""    }",No Smells
"@Test
    public void testFindWithIndexExp() {
        List<Object> result = helper.getAllJsonPath(JSON, ""$.store.book[?(@.author=='Herman Melville')].title"");
        assertEquals(""Moby Dick"", result.get(0));
    }",No Smells
"@Test
    public void testGetIntFromString() throws Throwable {
        Function<String, Integer> f = helper.getConstructor(Integer.class, String.class);
        assertEquals(Integer.valueOf(2), f.apply(""2""));
    }",No Smells
"@Test
    public void testSetValueCreatingList() {
        Map<String, Object> map = new HashMap<>();
        helper.setValueForIn(""1"", ""list[0]"", map);
        List list = (List) map.get(""list"");
        assertEquals(""1"", list.get(0));

        helper.setValueForIn(""2"", ""list[1].nested"", map);
        Map<String, Object> secondListElement = (Map<String, Object>) list.get(1);
        assertEquals(""2"", secondListElement.get(""nested""));

        helper.setValueForIn(""3"", ""list[1].nested"", map);
        assertEquals(""3"", secondListElement.get(""nested""));

        helper.setValueForIn(""4"", ""list[1].nested2[0].nested3"", map);
        assertEquals(""4"", ((Map) ((List) secondListElement.get(""nested2"")).get(0)).get(""nested3""));

        helper.setValueForIn(""5"", ""list2[0].nested"", map);
        List list2 = (List) map.get(""list2"");
        Map<String, Object> thirdListElement = (Map<String, Object>) list2.get(0);
        assertEquals(""5"", thirdListElement.get(""nested""));

        assertEquals(""first element changed"",""1"", list.get(0));
    }",No Smells
"@Test
    public void addDuplicatePrefixNullUriFirst() {
        String prefix = ""p2"";
        String uri = ""aadsad2"";

        impl.add(prefix, null);
        assertNull(impl.getNamespaceURI(prefix));

        impl.add(prefix, uri);
        assertEquals(uri, impl.getNamespaceURI(prefix));
    }",No Smells
"@Test
    public void addDuplicatePrefixOtherUri() {
        String prefix = ""p2"";
        String uri = ""aadsad2"";
        String uri2 = ""asdad"";
        impl.add(prefix, uri);
        
        try {
            impl.add(prefix, uri2);
            fail(""expected exception"");
        }",No Smells
"@Test
    public void testLowerCaseString() {
        for (int i = 0; i < 1000; i++) {
            String result = util.randomLower(10);
            assertEquals(10, result.length());
            assertEquals(result.toLowerCase(), result);
        }",Eager Test
"@Test
    public void testNestedLevel() {
        Map<String, Object> result = masker.replaceSecrets(Collections.singleton(""a""), map);
        assertNotSame(map, result);
        assertEquals(""{one=1, two=2, three=3, nested={a=*****, one=true, two=false}",No Smells
"@Test
    public void testSubMap() {
        Map<String, Object> result = masker.replaceSecrets(Arrays.asList(""nested"", ""one""), map);
        assertNotSame(map, result);
        assertEquals(""{one=*****, two=2, three=3, nested=*****}",No Smells
"@Test
    public void testTopLevel() {
        Map<String, Object> result = masker.replaceSecrets(Collections.singleton(""three""), map);
        assertNotSame(map, result);
        assertEquals(""{one=1, two=2, three=*****, nested={a=A, one=true, two=false}",No Smells
"@Test
    public void testNormalizedText() {
        assertEquals("""", getNormalizedText(""""));
        assertEquals("" "", getNormalizedText(""   \n ""));

        assertEquals(""Hallo"", getNormalizedText(""Hallo""));
        assertEquals("" Ha l lo "", getNormalizedText(""  Ha  l\n lo   ""));
        assertEquals("" Ha l lo "", getNormalizedText(""  Ha  l\n \u00a0lo   ""));
        assertEquals("" Ha l lo "", getNormalizedText(""  Ha  l\n \u00a0\u00a0\u00a0 lo   \u00a0""));
    }",No Smells
"@Test
    public void testFindChromedriverExecutable() {
        String exec = factoryFactory.getExecutable(""chromedriver"");

        assertNotNull(""No executable found for chromedriver"", exec);
        File execFile = new File(exec);
        assertTrue(""Executable for chromedriver does not exist: "" + exec, execFile.exists());
        assertTrue(""Executable for chromedriver not executable: "" + exec, execFile.canExecute());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testNoThrow() {
        Object result = callFunction(x -> callThatMightThrow(x), true);
        assertEquals(Boolean.TRUE, result);
    }",No Smells
"@Test
    public void testThrowRuntime() {
        try {
            Object result = callFunction(x -> callThatMightThrow(x), false);
            fail(""expected exception, got: "" + result);
        }",No Smells
"@Test
    public void testTrimElements() {
        String expected = FileUtil.loadFile(""GetWeatherSoapResponse.xml"");
        String formatted = FileUtil.loadFile(""GetWeatherSoapResponseFormatted.xml"");

        String trimmed = XMLFormatter.trimElements(formatted);

        assertEquals(expected, trimmed);
        assertEquals(expected, XMLFormatter.trimElements(trimmed));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testCheckXPathsIncorrect() {
        XmlHttpResponse resp = getOKResponse();

        Map<String, Object> values = new HashMap<String, Object>();
        values.put(""amount"", ""12"");
        values.put(""result"", ""1"");
        values.put(""status"", ""OK"");

        Map<String, String> expressionsToCheck = createExprToCheck();
        expressionsToCheck.put(""//*[local-name()='errorStatus']"", ""unknownKey"");
        expressionsToCheck.put(""//noMatchXPath"", ""status"");

        String expected = SoapCallMapColumnFixture.NO_ESCAPE_PREFIX
                            + ""NOK:\n<ul>\n""
                            + "" <li>amount: 12 <> 158.86</li>\n""
                            + "" <li>result: 1 <> 13.44</li>\n""
                            + "" <li>unknownKey: null <> OK</li>\n""
                            + "" <li>status: OK <> null</li>\n""
                            + ""</ul>"";
        XPathCheckResult checkResult = resp.checkXPaths(values, expressionsToCheck);
        assertEquals(""NOK"", checkResult.getResult());
        assertEquals(expected, checkResult.getMismatchDetail());
    }",No Smells
"@Test
    public void testRootNotClosed() {
        String xml = ""<root><child/><child2>a</child2></root"";
        int endPos = xml.length() + 1;
        checkNotOk(xml, String.valueOf(endPos));
    }",No Smells
"@Test
    public void testParse() {
        XPathCheckResult checkResult = new XPathCheckResult();
        XPathCheckResult checkResult2 = XPathCheckResult.parse(""OK"");
        resultsMatch(checkResult, checkResult2);
        
        checkResult.setMismatchDetail(""NOK: a"");
        checkResult2 = XPathCheckResult.parse(""NOK"");
        resultsMatch(checkResult, checkResult2);

        checkResult2 = XPathCheckResult.parse(""OK"");
        resultsDontMatch(checkResult, checkResult2);
    }",No Smells
"@Test
    public void testAllXmlNoText() {
        LalPolicyXPaths.registerNamespace();
        String responseString = FileUtil.loadFile(""leanapps/getPolicyCheckResponse.xml"");
        List<String> all = xPathHelper.getAllXPath(NS_CONTEXT, responseString, ""//*/@xsi:type"");

        assertEquals(13, all.size());
        assertEquals(""ns:PostalAddress"", all.get(1));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testAllXmlWithText() {
        LalPolicyXPaths.registerNamespace();
        String responseString = FileUtil.loadFile(""leanapps/getPolicyCheckResponse.xml"");
        List<String> all = xPathHelper.getAllXPath(NS_CONTEXT, responseString, ""//lal:key/text()"");

        assertEquals(17, all.size());
        assertEquals(""20000541"", all.get(0));
    }",No Smells
"@Test
    public void testBadXml() {
        try {
            xPathHelper.getXPath(null, ""bla"", ""//status"");
            fail(""expected exception"");
        }",No Smells
"@Test
    public void testBadXPath() {
        String responseString = FileUtil.loadFile(""leanapps/getPolicyCheckResponse.xml"");
        assertEquals("""", xPathHelper.getXPath(null, responseString, ""//status""));
        try {
            xPathHelper.getXPath(null, responseString, ""\\status"");
            fail(""expected exception"");
        }",Mystery Guest + Resource Optimism
"@Test
    public void testXPathWithNamespace() {
        LalPolicyXPaths.registerNamespace();
        String responseString = FileUtil.loadFile(""leanapps/getPolicyCheckResponse.xml"");
        assertEquals(""OK"", xPathHelper.getXPath(NS_CONTEXT, responseString, ""//lal:status/lal:status""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testFindTestResultPages() throws Exception {
        String path = getTestReportsPath();
        List<TestReportHtml> reports = new ReportFinder().findTestResultPages(new File(path));
        List<TestReportHtml> overviews = reports.stream().filter(TestReportHtml::isOverviewPage).collect(Collectors.toList());
        assertEquals(""Unexpected number of run: "" + overviews, 3, overviews.size());
        assertEquals(""Unexpected number of results"", EXPECTED_TEST_COUNT, reports.size());

        TestReportHtml mockXmlServerTest = getReport(reports, ""MockXmlServerTest"", ""MockXmlServerTest"");
        assertEquals(-1, mockXmlServerTest.getTime());
        assertEquals(Integer.MAX_VALUE - 2, mockXmlServerTest.getIndex());
        TestReportHtml mockXmlSuiteSetup = getReport(reports, ""MockXmlServerTest"", ""SuiteSetUp"");
        assertEquals(Integer.MAX_VALUE - 3, mockXmlSuiteSetup.getIndex());

        assertTrue(reports.stream().filter(r -> !""MockXmlServerTest"".equals(r.getRunName())).noneMatch(r -> r.getTime() == -1));

        TestReportHtml fitOverview = getActual(overviews, ""Fit"");
        assertEquals(0, fitOverview.getTime());
        assertEquals(Integer.MAX_VALUE, fitOverview.getIndex());
        assertEquals(2400, getActual(overviews, ""Http"").getTime());
        assertEquals(2075, getActual(overviews, ""Util"").getTime());

        TestReportHtml fitSuiteSetup = getReport(reports, ""Fit"", ""SuiteSetUp"");
        assertEquals(0, fitSuiteSetup.getIndex());
        TestReportHtml fitArraysAndSymbols = getReport(reports, ""Fit"", ""ArraysAndSymbolsComparison"");
        assertEquals(1, fitArraysAndSymbols.getIndex());
        TestReportHtml fitReturn = getReport(reports, ""Fit"", ""ReturnArrayAsSymbol"");
        assertEquals(2, fitReturn.getIndex());
    }",Mystery Guest
"@Test
    public void testSupportNull() {
        System.clearProperty(SeleniumDriverFactoryFactoryBase.SELENIUM_BROWSER);
        assertNull(factoryFactory.getProperty(SeleniumDriverFactoryFactoryBase.SELENIUM_BROWSER));
    }",No Smells
"@Test
    public void testWithSpace() {
        setBrowser(""internet explorer"");
        assertEquals(""internet explorer"", factoryFactory.getProperty(SeleniumDriverFactoryFactoryBase.SELENIUM_BROWSER));
    }",No Smells
"@Test
    public void testWithSpaceAndQuotes() {
        setBrowser(""\""internet explorer\"""");
        assertEquals(""internet explorer"", factoryFactory.getProperty(SeleniumDriverFactoryFactoryBase.SELENIUM_BROWSER));
    }",No Smells
"@Test
    public void testFromStringFilled() {
        List<String> expected = Arrays.asList(""b"", ""c"", ""d"");
        assertEquals(expected, converter.fromString(""<ol start=\""0\""> <li>   b </li> <li>   c </li><li>d</li></ol>""));
        assertEquals(expected, converter.fromString(""<ol> <li>   b </li> <li>   c </li><li>d</li></ol>""));
    }",No Smells
"@Test
    public void testToStringEmpty() {
        assertEquals(""<ol start=\""0\""></ol>"", converter.toString(new ArrayList<Object>()));
    }",No Smells
"@Test
    public void testToStringFilled() {
        ArrayList<Object> list = new ArrayList<>(Arrays.asList(""b"", ""c"", ""d"", null));
        assertEquals(""<ol start=\""0\""><li>b</li><li>c</li><li>d</li><li>null</li></ol>"", converter.toString(list));
    }",No Smells
"@Test
  public void testAcceptAsync(TestContext tc) {
    Async async = tc.async();

    vertx.runOnContext(x -> {
      VertxCompletableFuture<Integer> future = new VertxCompletableFuture<>(vertx);
      future.complete(42);

      String thread = Thread.currentThread().getName();

      future.thenAcceptAsync(i -> {
        tc.assertEquals(thread, Thread.currentThread().getName());
        tc.assertEquals(42, i);
        async.complete();
      }",No Smells
"@Test
  public void testAcceptEither(TestContext tc) {
    // Success and success
    Async async1 = tc.async();
    Async async11 = tc.async();
    // Failure and Success
    Async async2 = tc.async();
    // Success and Failure
    Async async3 = tc.async();

    VertxCompletableFuture<Integer> success = new VertxCompletableFuture<>(vertx);
    success.complete(1);

    VertxCompletableFuture<Integer> success2 = new VertxCompletableFuture<>(vertx);
    vertx.setTimer(500, l -> success2.complete(42));


    VertxCompletableFuture<Integer> failure = new VertxCompletableFuture<>(vertx);
    failure.completeExceptionally(new RuntimeException(""My bad""));

    vertx.runOnContext(v -> {
      String thread = Thread.currentThread().getName();

      success.acceptEither(
        success2,
        i -> {
          tc.assertEquals(thread, Thread.currentThread().getName());
          tc.assertEquals(i, 1);
          async1.complete();
        }",No Smells
"@Test
  public void testAcceptEitherAsync(TestContext tc) {
    // Success and success
    Async async1 = tc.async();
    Async async11 = tc.async();
    // Failure and Success
    Async async2 = tc.async();
    // Success and Failure
    Async async3 = tc.async();

    VertxCompletableFuture<Integer> success = new VertxCompletableFuture<>(vertx);
    success.complete(1);

    VertxCompletableFuture<Integer> success2 = new VertxCompletableFuture<>(vertx);
    vertx.setTimer(100, l -> success2.complete(42));


    VertxCompletableFuture<Integer> failure = new VertxCompletableFuture<>(vertx);
    failure.completeExceptionally(new RuntimeException(""My bad""));

    vertx.runOnContext(v -> {
      String thread = Thread.currentThread().getName();

      success.withContext().acceptEitherAsync(
        success2,
        i -> {
          tc.assertEquals(thread, Thread.currentThread().getName());
          tc.assertEquals(i, 1);
          async1.complete();
        }",No Smells
"@Test
  public void testApplyToEither(TestContext tc) {
    // Success and success
    Async async1 = tc.async();
    Async async11 = tc.async();
    // Failure and Success
    Async async2 = tc.async();
    // Success and Failure
    Async async3 = tc.async();

    VertxCompletableFuture<Integer> success = new VertxCompletableFuture<>(vertx);
    success.complete(1);

    VertxCompletableFuture<Integer> success2 = new VertxCompletableFuture<>(vertx);
    vertx.setTimer(100, l -> success2.complete(42));


    VertxCompletableFuture<Integer> failure = new VertxCompletableFuture<>(vertx);
    failure.completeExceptionally(new RuntimeException(""My bad""));

    vertx.runOnContext(v -> {
      String thread = Thread.currentThread().getName();

      success.applyToEither(
        success2,
        i -> {
          tc.assertEquals(thread, Thread.currentThread().getName());
          tc.assertEquals(i, 1);
          return i + 1;
        }",No Smells
"@Test
  public void testCombineAsyncWithExecutor(TestContext tc) {
    Async async = tc.async();

    VertxCompletableFuture<Integer> future2 = new VertxCompletableFuture<>(vertx);
    future2.complete(1);

    vertx.runOnContext(v -> {
      String thread = Thread.currentThread().getName();

      VertxCompletableFuture<Integer> future1 = new VertxCompletableFuture<>(vertx);
      future1.complete(42);

      CompletableFuture<Integer> test = future1.thenCombineAsync(future2, (x, y) -> {
        tc.assertNotEquals(thread, Thread.currentThread().getName());
        tc.assertEquals(42, x);
        tc.assertEquals(1, y);
        return x + y;
      }",No Smells
"@Test
  public void testCombineFailurePropagation(TestContext tc) {
    Async async0 = tc.async();
    Async async1 = tc.async();
    CompletableFuture<Integer> failure1 = new VertxCompletableFuture<>(vertx);
    CompletableFuture<Integer> failure2 = new VertxCompletableFuture<>(vertx);

    VertxCompletableFuture<Integer> future1 = new VertxCompletableFuture<>(vertx);
    future1.complete(42);

    VertxCompletableFuture<Integer> future2 = new VertxCompletableFuture<>(vertx);
    future2.complete(1);


    failure1.thenCombine(failure2, (a, b) -> {
      tc.fail(""Should not be called"");
      return 0;
    }",No Smells
"@Test
  public void testCombineWithFailures(TestContext tc) {
    // Success and success
    Async async1 = tc.async();
    // Failure and success
    Async async2 = tc.async();
    // Success and Failure
    Async async3 = tc.async();
    // Failure and failure
    Async async4 = tc.async();

    VertxCompletableFuture<Integer> success1 = new VertxCompletableFuture<>(vertx);
    VertxCompletableFuture<Integer> success2 = new VertxCompletableFuture<>(vertx);
    VertxCompletableFuture<Integer> failure1 = new VertxCompletableFuture<>(vertx);
    VertxCompletableFuture<Integer> failure2 = new VertxCompletableFuture<>(vertx);

    vertx.runOnContext(v -> {
      String thread = Thread.currentThread().getName();

      success1.thenCombine(success2, (x, y) -> {
        tc.assertEquals(thread, Thread.currentThread().getName());
        tc.assertEquals(42, x);
        tc.assertEquals(1, y);
        return x + y;
      }",No Smells
"@Test
  public void testExceptionally(TestContext tc) {
    Async async1 = tc.async();
    Async async2 = tc.async();

    VertxCompletableFuture<Integer> failure = new VertxCompletableFuture<>(vertx);
    VertxCompletableFuture<Integer> success = new VertxCompletableFuture<>(vertx);

    failure.exceptionally(t -> 43).thenAccept(i -> {
      tc.assertEquals(i, 43);
      async1.complete();
    }",No Smells
"@Test
  public void testFromCompletableStageJavadoc() {
    VertxCompletableFuture<Integer> future = new VertxCompletableFuture<>(vertx);
    future
      .thenApply(this::square)
      .thenAccept(System.out::print)
      .thenRun(System.out::println);

    future.complete(42);

  }",No Smells
"@Test
  public void testRun(TestContext tc) {
    Async async = tc.async();

    VertxCompletableFuture<Integer> future = new VertxCompletableFuture<>(vertx);
    future.complete(42);

    vertx.runOnContext(x -> {
      String thread = Thread.currentThread().getName();

      future.thenRun(() -> {
        tc.assertEquals(thread, Thread.currentThread().getName());
        async.complete();
      }",No Smells
"@Test
  public void testRunAsync(TestContext tc) {
    Async async = tc.async();

    vertx.runOnContext(x -> {
      VertxCompletableFuture<Integer> future = new VertxCompletableFuture<>(vertx);
      future.complete(42);

      String thread = Thread.currentThread().getName();

      future.thenRunAsync(() -> {
        tc.assertEquals(thread, Thread.currentThread().getName());
        async.complete();
      }",No Smells
"@Test
  public void testWhenCompleteAsync(TestContext tc) {
    Async async1 = tc.async();
    Async async2 = tc.async();

    VertxCompletableFuture<Integer> first = new VertxCompletableFuture<>(vertx);
    first
      .thenApply(x -> x + 1)
      .thenApplyAsync(i -> Integer.toString(i))
      .thenCompose(this::display)
      .whenCompleteAsync((res, err) -> {
        tc.assertTrue(Context.isOnEventLoopThread());
        tc.assertNull(err);
        tc.assertEquals(res, ""Result: "" + 43);
        async1.complete();
      }",No Smells
"@Test
  public void testKeyRequeuedOnResetIfEventsArePending() throws IOException {
    AbstractWatchService.Key key =
        watcher.register(new StubWatchable(), ImmutableSet.of(ENTRY_CREATE));
    key.post(new AbstractWatchService.Event<>(ENTRY_CREATE, 1, null));
    key.signal();

    key = (AbstractWatchService.Key) watcher.poll();
    assertThat(watcher.queuedKeys()).isEmpty();

    assertThat(key.pollEvents()).hasSize(1);

    key.post(new AbstractWatchService.Event<>(ENTRY_CREATE, 1, null));
    assertThat(watcher.queuedKeys()).isEmpty();

    key.reset();
    assertThat(key.state()).isEqualTo(SIGNALLED);
    assertThat(watcher.queuedKeys()).hasSize(1);
  }",No Smells
"@Test
  public void testPostEvent() throws IOException {
    AbstractWatchService.Key key =
        watcher.register(new StubWatchable(), ImmutableSet.of(ENTRY_CREATE));

    AbstractWatchService.Event<Path> event =
        new AbstractWatchService.Event<>(ENTRY_CREATE, 1, null);
    key.post(event);
    key.signal();

    assertThat(watcher.queuedKeys()).containsExactly(key);

    WatchKey retrievedKey = watcher.poll();
    assertThat(retrievedKey).isEqualTo(key);

    List<WatchEvent<?>> events = retrievedKey.pollEvents();
    assertThat(events).hasSize(1);
    assertThat(events.get(0)).isEqualTo(event);

    // polling should have removed all events
    assertThat(retrievedKey.pollEvents()).isEmpty();
  }",No Smells
"@Test
  public void testGetAttribute_failsForAttributesNotDefinedByProvider() {
    File file = createFile();
    try {
      service.getAttribute(file, ""test:blah"");
      fail();
    }",Mystery Guest
"@Test
  public void testGetFileAttributeView_isNullForUnsupportedView() {
    final File file = createFile();
    FileLookup fileLookup =
        new FileLookup() {
          @Override
          public File lookup() throws IOException {
            return file;
          }",Mystery Guest
"@Test
  public void testReadAttributes_asObject() {
    File file = createFile();
    service.setInitialAttributes(file);

    BasicFileAttributes basicAttrs = service.readAttributes(file, BasicFileAttributes.class);
    assertThat(basicAttrs.fileKey()).isEqualTo(0);
    assertThat(basicAttrs.isDirectory()).isTrue();
    assertThat(basicAttrs.isRegularFile()).isFalse();

    TestAttributes testAttrs = service.readAttributes(file, TestAttributes.class);
    assertThat(testAttrs.foo()).isEqualTo(""hello"");
    assertThat(testAttrs.bar()).isEqualTo(0);
    assertThat(testAttrs.baz()).isEqualTo(1);

    file.setAttribute(""test"", ""baz"", 100);
    assertThat(service.readAttributes(file, TestAttributes.class).baz()).isEqualTo(100);
  }",Mystery Guest
"@Test
  public void testReadAttributes_failsForUnsupportedAttributesType() {
    File file = createFile();
    try {
      service.readAttributes(file, PosixFileAttributes.class);
      fail();
    }",Mystery Guest
"@Test
  public void testSetAttribute_failsForAttributeThatIsNotSettable() {
    File file = createFile();
    try {
      service.setAttribute(file, ""test:foo"", ""world"", false);
      fail();
    }",Mystery Guest
"@Test
  public void testSetAttribute_onCreate_failsForAttributeThatIsNotSettableOnCreate() {
    File file = createFile();
    try {
      service.setInitialAttributes(file, new BasicFileAttribute<>(""test:foo"", ""world""));
      fail();
    }",Mystery Guest
"@Test
  public void testSupportsFileAttributeView() {
    assertThat(service.supportsFileAttributeView(BasicFileAttributeView.class)).isTrue();
    assertThat(service.supportsFileAttributeView(TestAttributeView.class)).isTrue();
    assertThat(service.supportsFileAttributeView(PosixFileAttributeView.class)).isFalse();
  }",No Smells
"@Test
  public void testDefaultWindowsConfiguration() {
    Configuration config = Configuration.windows();

    assertThat(config.pathType).isEqualTo(PathType.windows());
    assertThat(config.roots).containsExactly(""C:\\"");
    assertThat(config.workingDirectory).isEqualTo(""C:\\work"");
    assertThat(config.nameCanonicalNormalization).containsExactly(CASE_FOLD_ASCII);
    assertThat(config.nameDisplayNormalization).isEmpty();
    assertThat(config.pathEqualityUsesCanonicalForm).isTrue();
    assertThat(config.blockSize).isEqualTo(8192);
    assertThat(config.maxSize).isEqualTo(4L * 1024 * 1024 * 1024);
    assertThat(config.maxCacheSize).isEqualTo(-1);
    assertThat(config.attributeViews).containsExactly(""basic"");
    assertThat(config.attributeProviders).isEmpty();
    assertThat(config.defaultAttributeValues).isEmpty();
    assertThat(config.fileTimeSource).isEqualTo(SystemFileTimeSource.INSTANCE);
  }",No Smells
"@Test
  public void testSetDefaultAttributeValue_illegalAttributeFormat() {
    try {
      Configuration.unix().toBuilder().setDefaultAttributeValue(""foo"", 1);
      fail();
    }",No Smells
"@Test
  public void testSettingRootsUnsupportedByPathType() {
    assertIllegalRoots(PathType.unix(), ""\\"");
    assertIllegalRoots(PathType.unix(), ""/"", ""\\"");
    assertIllegalRoots(PathType.windows(), ""/"");
    assertIllegalRoots(PathType.windows(), ""C:""); // must have a \ (or a /)
  }",No Smells
"@Test
  public void testSettingWorkingDirectoryWithRelativePath() {
    try {
      Configuration.unix().toBuilder().setWorkingDirectory(""foo/bar"");
      fail();
    }",No Smells
"@Test
  public void testGet() {
    assertThat(root.get(Name.simple(""foo""))).isEqualTo(entry(root, ""foo"", dir));
    assertThat(dir.get(Name.simple(""foo""))).isNull();
    assertThat(root.get(Name.simple(""Foo""))).isNull();
  }",No Smells
"@Test
  public void testManyPutsAndRemoves() {
    // test resizing/rehashing

    Set<DirectoryEntry> entriesInDir = new HashSet<>();
    entriesInDir.add(new DirectoryEntry(dir, Name.SELF, dir));
    entriesInDir.add(new DirectoryEntry(dir, Name.PARENT, root));

    // add 1000 entries
    for (int i = 0; i < 1000; i++) {
      DirectoryEntry entry = entry(String.valueOf(i));
      dir.put(entry);
      entriesInDir.add(entry);

      assertThat(ImmutableSet.copyOf(dir)).isEqualTo(entriesInDir);

      for (DirectoryEntry expected : entriesInDir) {
        assertThat(dir.get(expected.name())).isEqualTo(expected);
      }",Eager Test
"@Test
  public void testPutAndGet() {
    dir.put(entry(""foo""));

    assertThat(dir.entryCount()).isEqualTo(3);
    assertThat(ImmutableSet.copyOf(dir)).contains(entry(""foo""));
    assertThat(dir.get(Name.simple(""foo""))).isEqualTo(entry(""foo""));

    dir.put(entry(""bar""));

    assertThat(dir.entryCount()).isEqualTo(4);
    assertThat(ImmutableSet.copyOf(dir)).containsAtLeast(entry(""foo""), entry(""bar""));
    assertThat(dir.get(Name.simple(""foo""))).isEqualTo(entry(""foo""));
    assertThat(dir.get(Name.simple(""bar""))).isEqualTo(entry(""bar""));
  }",No Smells
"@Test
  public void testRootDirectory() {
    assertThat(root.entryCount()).isEqualTo(3); // two for parent/self, one for dir
    assertThat(root.isEmpty()).isFalse();
    assertThat(root.entryInParent()).isEqualTo(entry(root, ""/"", root));
    assertThat(root.entryInParent().name()).isEqualTo(Name.simple(""/""));

    assertParentAndSelf(root, root, root);
  }",No Smells
"@Test
  public void testSnapshot() {
    root.link(Name.simple(""bar""), regularFile(10));
    root.link(Name.simple(""abc""), regularFile(10));

    // does not include . or .. and is sorted by the name
    assertThat(root.snapshot())
        .containsExactly(Name.simple(""abc""), Name.simple(""bar""), Name.simple(""foo""))
        .inOrder();
  }",No Smells
"@Test
  public void testUnlink_parentAndSelfNameFails() {
    try {
      dir.unlink(Name.simple("".""));
      fail();
    }",No Smells
"@Test
  public void testClose_multipleTimesDoNothing() throws IOException {
    state.close();
    assertEquals(1, onClose.runCount);
    state.close();
    state.close();
    assertEquals(1, onClose.runCount);
  }",No Smells
"@Test
  public void testFileBasics() {
    File file = regularFile(0);

    assertThat(file.id()).isEqualTo(0);
    assertThat(file.links()).isEqualTo(0);
  }",Mystery Guest
"@Test
  public void testRegularFile() {
    File file = regularFile(10);
    assertThat(file.isDirectory()).isFalse();
    assertThat(file.isRegularFile()).isTrue();
    assertThat(file.isSymbolicLink()).isFalse();
  }",Mystery Guest
"@Test
  public void testLookup_absolute_finalSymlink_nofollowLinks() throws IOException {
    assertExists(lookup(""/work/four/five"", NOFOLLOW_LINKS), ""four"", ""five"");
    assertExists(lookup(""/work/four/six"", NOFOLLOW_LINKS), ""four"", ""six"");
    assertExists(lookup(""/work/four/loop"", NOFOLLOW_LINKS), ""four"", ""loop"");
  }",Mystery Guest
"@Test
  public void testLookup_absolute_intermediateSymlink() throws IOException {
    assertExists(lookup(""/work/four/five/bar""), ""foo"", ""bar"");
    assertExists(lookup(""/work/four/six/two/three""), ""two"", ""three"");

    // NOFOLLOW_LINKS doesn't affect intermediate symlinks
    assertExists(lookup(""/work/four/five/bar"", NOFOLLOW_LINKS), ""foo"", ""bar"");
    assertExists(lookup(""/work/four/six/two/three"", NOFOLLOW_LINKS), ""two"", ""three"");
  }",Mystery Guest
"@Test
  public void testLookup_absolute_parentExists() throws IOException {
    assertParentExists(lookup(""/a""), ""/"");
    assertParentExists(lookup(""/foo/baz""), ""foo"");
    assertParentExists(lookup(""$c""), ""$"");
    assertParentExists(lookup(""$a/b/c/d""), ""c"");
  }",Mystery Guest
"@Test
  public void testLookup_nonExistentRoot() throws IOException {
    try {
      lookup(""!"");
      fail();
    }",No Smells
"@Test
  public void testLookup_relative_emptyPath() throws IOException {
    assertExists(lookup(""""), ""/"", ""work"");
  }",No Smells
"@Test
  public void testFullDisk() throws IOException {
    HeapDisk disk = new HeapDisk(4, 10, 4);
    disk.allocate(blocks, 10);

    try {
      disk.allocate(blocks, 1);
      fail();
    }",No Smells
"@Test
  public void testFullDisk_doesNotAllocatePartiallyWhenTooManyBlocksRequested() throws IOException {
    HeapDisk disk = new HeapDisk(4, 10, 4);
    disk.allocate(blocks, 6);

    RegularFile blocks2 = RegularFile.create(-2, fileTimeSource.now(), disk);

    try {
      disk.allocate(blocks2, 5);
      fail();
    }",Mystery Guest
"@Test
  public void testInitialSettings_fromConfiguration() {
    Configuration config =
        Configuration.unix().toBuilder()
            .setBlockSize(4)
            .setMaxSize(99) // not a multiple of 4
            .setMaxCacheSize(25)
            .build();

    HeapDisk disk = new HeapDisk(config);

    assertThat(disk.blockSize()).isEqualTo(4);
    assertThat(disk.getTotalSpace()).isEqualTo(96);
    assertThat(disk.getUnallocatedSpace()).isEqualTo(96);
    assertThat(disk.blockCache.blockCount()).isEqualTo(0);
  }",No Smells
"@Test
  public void testAsyncChannel() throws Throwable {
    RegularFile file = regularFile(15);
    ExecutorService executor = Executors.newSingleThreadExecutor();
    JimfsAsynchronousFileChannel channel = channel(file, executor, READ, WRITE);

    try {
      assertEquals(15, channel.size());

      assertSame(channel, channel.truncate(5));
      assertEquals(5, channel.size());

      file.write(5, new byte[5], 0, 5);
      checkAsyncRead(channel);
      checkAsyncWrite(channel);
      checkAsyncLock(channel);

      channel.close();
      assertFalse(channel.isOpen());
    }",Mystery Guest
"@Test
  public void testAsyncClose_read() throws Throwable {
    RegularFile file = regularFile(15);
    ExecutorService executor = Executors.newFixedThreadPool(2);

    try {
      JimfsAsynchronousFileChannel channel = channel(file, executor, READ, WRITE);

      file.writeLock().lock(); // cause another thread trying to read to block

      // future-returning read
      Future<Integer> future = channel.read(ByteBuffer.allocate(10), 0);

      // completion handler read
      SettableFuture<Integer> completionHandlerFuture = SettableFuture.create();
      channel.read(ByteBuffer.allocate(10), 0, null, setFuture(completionHandlerFuture));

      // Despite this 10ms sleep to allow plenty of time, it's possible, though very rare, for a
      // race to cause the channel to be closed before the asynchronous calls get to the initial
      // check that the channel is open, causing ClosedChannelException to be thrown rather than
      // AsynchronousCloseException. This is not a problem in practice, just a quirk of how these
      // tests work and that we don't have a way of waiting for the operations to get past that
      // check.
      Uninterruptibles.sleepUninterruptibly(10, MILLISECONDS);

      channel.close();

      assertAsynchronousClose(future);
      assertAsynchronousClose(completionHandlerFuture);
    }",Mystery Guest
"@Test
  public void testAsyncClose_write() throws Throwable {
    RegularFile file = regularFile(15);
    ExecutorService executor = Executors.newFixedThreadPool(4);

    try {
      JimfsAsynchronousFileChannel channel = channel(file, executor, READ, WRITE);

      file.writeLock().lock(); // cause another thread trying to write to block

      // future-returning write
      Future<Integer> future = channel.write(ByteBuffer.allocate(10), 0);

      // completion handler write
      SettableFuture<Integer> completionHandlerFuture = SettableFuture.create();
      channel.write(ByteBuffer.allocate(10), 0, null, setFuture(completionHandlerFuture));

      // Despite this 10ms sleep to allow plenty of time, it's possible, though very rare, for a
      // race to cause the channel to be closed before the asynchronous calls get to the initial
      // check that the channel is open, causing ClosedChannelException to be thrown rather than
      // AsynchronousCloseException. This is not a problem in practice, just a quirk of how these
      // tests work and that we don't have a way of waiting for the operations to get past that
      // check.
      Uninterruptibles.sleepUninterruptibly(10, MILLISECONDS);

      channel.close();

      assertAsynchronousClose(future);
      assertAsynchronousClose(completionHandlerFuture);
    }",Mystery Guest
"@Test
  public void testInterruptedThreads() throws IOException {
    final ByteBuffer buf = ByteBuffer.allocate(10);
    final ByteBuffer[] bufArray = {buf}",No Smells
"@Test
  public void testPosition() throws IOException {
    FileChannel channel = channel(regularFile(10), READ);
    assertEquals(0, channel.position());
    assertSame(channel, channel.position(100));
    assertEquals(100, channel.position());
  }",Mystery Guest
"@Test
  public void testRead() throws IOException {
    RegularFile file = regularFile(20);
    FileChannel channel = channel(file, READ);
    assertEquals(0, channel.position());

    ByteBuffer buf = buffer(""1234567890"");
    ByteBuffer buf2 = buffer(""123457890"");
    assertEquals(10, channel.read(buf));
    assertEquals(10, channel.position());

    buf.flip();
    assertEquals(10, channel.read(new ByteBuffer[] {buf, buf2}",Mystery Guest
"@Test
  public void testReadNegative() throws IOException {
    FileChannel channel = channel(regularFile(0), READ, WRITE);

    try {
      channel.read(buffer(""111""), -1);
      fail();
    }",Mystery Guest
"@Test
  public void testReadsInWriteOnlyMode() throws IOException {
    FileChannel channel = channel(regularFile(0), WRITE);

    try {
      channel.read(buffer(""111""));
      fail();
    }",Mystery Guest
"@Test
  public void testSize() throws IOException {
    RegularFile file = regularFile(10);
    FileChannel channel = channel(file, READ);

    assertEquals(10, channel.size());

    file.write(10, new byte[90], 0, 90);
    assertEquals(100, channel.size());
  }",Mystery Guest
"@Test
  public void testTransferFromNegative() throws IOException {
    FileChannel channel = channel(regularFile(0), READ, WRITE);

    try {
      channel.transferFrom(new ByteBufferChannel(10), -1, 0);
      fail();
    }",Mystery Guest
"@Test
  public void testFullyReadInputStream_doesNotChangeStateWhenStoreChanges() throws IOException {
    JimfsInputStream in = newInputStream(1, 2, 3, 4, 5);
    assertThat(in.read(new byte[5])).isEqualTo(5);
    assertEmpty(in);

    in.file.write(5, new byte[10], 0, 10); // append more bytes to file
    assertEmpty(in);
  }",No Smells
"@Test
  public void testRead_partialArray_invalidInput() throws IOException {
    JimfsInputStream in = newInputStream(1, 2, 3, 4, 5);

    try {
      in.read(new byte[3], -1, 1);
      fail();
    }",No Smells
"@Test
  public void testPathParsing() {
    assertPathEquals(""/"", ""/"");
    assertPathEquals(""/foo"", ""/foo"");
    assertPathEquals(""/foo"", ""/"", ""foo"");
    assertPathEquals(""/foo/bar"", ""/foo/bar"");
    assertPathEquals(""/foo/bar"", ""/"", ""foo"", ""bar"");
    assertPathEquals(""/foo/bar"", ""/foo"", ""bar"");
    assertPathEquals(""/foo/bar"", ""/"", ""foo/bar"");
    assertPathEquals(""foo/bar/baz"", ""foo/bar/baz"");
    assertPathEquals(""foo/bar/baz"", ""foo"", ""bar"", ""baz"");
    assertPathEquals(""foo/bar/baz"", ""foo/bar"", ""baz"");
    assertPathEquals(""foo/bar/baz"", ""foo"", ""bar/baz"");
  }",No Smells
"@Test
  public void testPathWithExtraSlashes() {
    assertPathEquals(""/foo/bar/baz"", pathService.parsePath(""/foo/bar/baz/""));
    assertPathEquals(""/foo/bar/baz"", pathService.parsePath(""/foo//bar///baz""));
    assertPathEquals(""/foo/bar/baz"", pathService.parsePath(""///foo/bar/baz""));
  }",No Smells
"@Test
  public void testRelativize_bothRelative() {
    assertRelativizedPathEquals(""b/c"", pathService.parsePath(""a""), ""a/b/c"");
    assertRelativizedPathEquals(""d"", pathService.parsePath(""a/b/c""), ""a/b/c/d"");
  }",No Smells
"@Test
  public void testResolve_againstEmptyPath() {
    assertResolvedPathEquals(""foo/bar"", pathService.emptyPath(), ""foo/bar"");
  }",No Smells
"@Test
  public void testResolve_fromRelative() {
    Path path = pathService.parsePath(""foo"");

    assertResolvedPathEquals(""foo/bar"", path, ""bar"");
    assertResolvedPathEquals(""foo/bar/baz/test"", path, ""bar/baz/test"");
    assertResolvedPathEquals(""foo/bar/baz/test"", path, ""bar"", ""baz"", ""test"");
    assertResolvedPathEquals(""foo/bar/baz/test"", path, ""bar/baz"", ""test"");
  }",No Smells
"@Test
  public void testResolve_fromRoot() {
    Path root = pathService.parsePath(""/"");

    assertResolvedPathEquals(""/foo"", root, ""foo"");
    assertResolvedPathEquals(""/foo/bar"", root, ""foo/bar"");
    assertResolvedPathEquals(""/foo/bar"", root, ""foo"", ""bar"");
    assertResolvedPathEquals(""/foo/bar/baz/test"", root, ""foo/bar/baz/test"");
    assertResolvedPathEquals(""/foo/bar/baz/test"", root, ""foo"", ""bar/baz"", ""test"");
  }",No Smells
"@Test
  public void testResolveSibling_givenEmptyPath() {
    Path path = pathService.parsePath(""foo/bar"");
    Path resolved = path.resolveSibling("""");
    assertPathEquals(""foo"", resolved);

    path = pathService.parsePath(""foo"");
    resolved = path.resolveSibling("""");
    assertPathEquals("""", resolved);
  }",No Smells
"@Test
  public void testRootPath() {
    new PathTester(pathService, ""/"").root(""/"").test(""/"");
  }",No Smells
"@Test
  public void testPathCreation() {
    assertAbout(paths())
        .that(service.emptyPath())
        .hasRootComponent(null)
        .and()
        .hasNameComponents("""");

    assertAbout(paths())
        .that(service.createRoot(service.name(""/"")))
        .isAbsolute()
        .and()
        .hasRootComponent(""/"")
        .and()
        .hasNoNameComponents();

    assertAbout(paths())
        .that(service.createFileName(service.name(""foo"")))
        .hasRootComponent(null)
        .and()
        .hasNameComponents(""foo"");

    JimfsPath relative = service.createRelativePath(service.names(ImmutableList.of(""foo"", ""bar"")));
    assertAbout(paths())
        .that(relative)
        .hasRootComponent(null)
        .and()
        .hasNameComponents(""foo"", ""bar"");

    JimfsPath absolute =
        service.createPath(service.name(""/""), service.names(ImmutableList.of(""foo"", ""bar"")));
    assertAbout(paths())
        .that(absolute)
        .isAbsolute()
        .and()
        .hasRootComponent(""/"")
        .and()
        .hasNameComponents(""foo"", ""bar"");
  }",No Smells
"@Test
  public void testPathCreation_emptyPath() {
    // normalized to empty path with single empty string name
    assertAbout(paths())
        .that(service.createPath(null, ImmutableList.<Name>of()))
        .hasRootComponent(null)
        .and()
        .hasNameComponents("""");
  }",No Smells
"@Test
  public void testPathCreation_parseIgnoresEmptyString() {
    // if the empty string wasn't ignored, the resulting path would be ""/foo"" since the empty
    // string would be joined with foo
    assertAbout(paths())
        .that(service.parsePath("""", ""foo""))
        .hasRootComponent(null)
        .and()
        .hasNameComponents(""foo"");
  }",No Smells
"@Test
  public void testToString() {
    ParseResult path = type.parsePath(""foo/bar\\baz"");
    assertThat(type.toString(path.root(), path.names())).isEqualTo(""foo/bar/baz"");

    ParseResult path2 = type.parsePath(""$/foo/bar"");
    assertThat(type.toString(path2.root(), path2.names())).isEqualTo(""$foo/bar"");
  }",No Smells
"@Test
  public void testToUri() {
    URI fileUri = type.toUri(fileSystemUri, ""$"", ImmutableList.of(""foo"", ""bar""), false);
    assertThat(fileUri.toString()).isEqualTo(""jimfs://foo/$/foo/bar"");
    assertThat(fileUri.getPath()).isEqualTo(""/$/foo/bar"");

    URI directoryUri = type.toUri(fileSystemUri, ""$"", ImmutableList.of(""foo"", ""bar""), true);
    assertThat(directoryUri.toString()).isEqualTo(""jimfs://foo/$/foo/bar/"");
    assertThat(directoryUri.getPath()).isEqualTo(""/$/foo/bar/"");

    URI rootUri = type.toUri(fileSystemUri, ""$"", ImmutableList.<String>of(), true);
    assertThat(rootUri.toString()).isEqualTo(""jimfs://foo/$/"");
    assertThat(rootUri.getPath()).isEqualTo(""/$/"");
  }",No Smells
"@Test
  public void testCloseCancelsAllKeysAndStopsPolling() throws IOException {
    Key key1 = watcher.register(createDirectory(), ImmutableList.of(ENTRY_CREATE));
    Key key2 = watcher.register(createDirectory(), ImmutableList.of(ENTRY_DELETE));

    assertThat(key1.isValid()).isTrue();
    assertThat(key2.isValid()).isTrue();
    assertThat(watcher.isPolling()).isTrue();

    watcher.close();

    assertThat(key1.isValid()).isFalse();
    assertThat(key2.isValid()).isFalse();
    assertThat(watcher.isPolling()).isFalse();
  }",Mystery Guest
"@Test
  public void testSetOnCreate() {
    assertSetAndGetSucceedsOnCreate(""permissions"", PosixFilePermissions.fromString(""rwxrwxrwx""));
    assertSetFailsOnCreate(""group"", createGroupPrincipal(""foo""));
  }",No Smells
"@Test
  public void testView() throws IOException {
    file.setAttribute(""owner"", ""owner"", createUserPrincipal(""user""));

    PosixFileAttributeView view =
        provider.view(
            fileLookup(),
            ImmutableMap.of(
                ""basic"", new BasicAttributeProvider().view(fileLookup(), NO_INHERITED_VIEWS),
                ""owner"", new OwnerAttributeProvider().view(fileLookup(), NO_INHERITED_VIEWS)));
    assertNotNull(view);

    assertThat(view.name()).isEqualTo(""posix"");
    assertThat(view.getOwner()).isEqualTo(createUserPrincipal(""user""));

    PosixFileAttributes attrs = view.readAttributes();
    assertThat(attrs.fileKey()).isEqualTo(0);
    assertThat(attrs.owner()).isEqualTo(createUserPrincipal(""user""));
    assertThat(attrs.group()).isEqualTo(createGroupPrincipal(""group""));
    assertThat(attrs.permissions()).isEqualTo(PosixFilePermissions.fromString(""rw-r--r--""));

    view.setOwner(createUserPrincipal(""root""));
    assertThat(view.getOwner()).isEqualTo(createUserPrincipal(""root""));
    assertThat(file.getAttribute(""owner"", ""owner"")).isEqualTo(createUserPrincipal(""root""));

    view.setGroup(createGroupPrincipal(""root""));
    assertThat(view.readAttributes().group()).isEqualTo(createGroupPrincipal(""root""));
    assertThat(file.getAttribute(""posix"", ""group"")).isEqualTo(createGroupPrincipal(""root""));

    view.setPermissions(PosixFilePermissions.fromString(""rwx------""));
    assertThat(view.readAttributes().permissions())
        .isEqualTo(PosixFilePermissions.fromString(""rwx------""));
    assertThat(file.getAttribute(""posix"", ""permissions""))
        .isEqualTo(PosixFilePermissions.fromString(""rwx------""));
  }",No Smells
"@Test
  public void testSet() {
    assertSetFails(""unix:uid"", 1);
    assertSetFails(""unix:gid"", 1);
    assertSetFails(""unix:rdev"", 1L);
    assertSetFails(""unix:dev"", 1L);
    assertSetFails(""unix:ino"", 1);
    assertSetFails(""unix:mode"", 1);
    assertSetFails(""unix:ctime"", 1L);
    assertSetFails(""unix:nlink"", 1);
  }",No Smells
"@Test
  public void testUnix() {
    PathType unix = PathType.unix();
    assertThat(unix.getSeparator()).isEqualTo(""/"");
    assertThat(unix.getOtherSeparators()).isEqualTo("""");

    // ""//foo/bar"" is what will be passed to parsePath if ""/"", ""foo"", ""bar"" is passed to getPath
    PathType.ParseResult path = unix.parsePath(""//foo/bar"");
    assertParseResult(path, ""/"", ""foo"", ""bar"");
    assertThat(unix.toString(path.root(), path.names())).isEqualTo(""/foo/bar"");

    PathType.ParseResult path2 = unix.parsePath(""foo/bar/"");
    assertParseResult(path2, null, ""foo"", ""bar"");
    assertThat(unix.toString(path2.root(), path2.names())).isEqualTo(""foo/bar"");
  }",No Smells
"@Test
  public void testUnix_illegalCharacters() {
    try {
      PathType.unix().parsePath(""/foo/bar\0"");
      fail();
    }",No Smells
"@Test
  public void testInitialAttributes() {
    // no initial attributes
    assertThat(ImmutableList.copyOf(file.getAttributeKeys())).isEmpty();
    assertThat(provider.attributes(file)).isEmpty();
  }",Mystery Guest
"@Test
  public void testSetOnCreate() {
    assertSetFailsOnCreate(""anything"", new byte[0]);
  }",Mystery Guest
"@Test
  public void testWindows_toUri_escaping() {
    URI uri =
        PathType.windows()
            .toUri(fileSystemUri, ""C:\\"", ImmutableList.of(""Users"", ""foo"", ""My Documents""), true);
    assertThat(uri.toString()).isEqualTo(""jimfs://foo/C:/Users/foo/My%20Documents/"");
    assertThat(uri.getRawPath()).isEqualTo(""/C:/Users/foo/My%20Documents/"");
    assertThat(uri.getPath()).isEqualTo(""/C:/Users/foo/My Documents/"");
  }",No Smells
"@Test
  public void testWindows_toUri_normal() {
    URI fileUri =
        PathType.windows().toUri(fileSystemUri, ""C:\\"", ImmutableList.of(""foo"", ""bar""), false);
    assertThat(fileUri.toString()).isEqualTo(""jimfs://foo/C:/foo/bar"");
    assertThat(fileUri.getPath()).isEqualTo(""/C:/foo/bar"");

    URI directoryUri =
        PathType.windows().toUri(fileSystemUri, ""C:\\"", ImmutableList.of(""foo"", ""bar""), true);
    assertThat(directoryUri.toString()).isEqualTo(""jimfs://foo/C:/foo/bar/"");
    assertThat(directoryUri.getPath()).isEqualTo(""/C:/foo/bar/"");

    URI rootUri = PathType.windows().toUri(fileSystemUri, ""C:\\"", ImmutableList.<String>of(), true);
    assertThat(rootUri.toString()).isEqualTo(""jimfs://foo/C:/"");
    assertThat(rootUri.getPath()).isEqualTo(""/C:/"");
  }",No Smells
"@Test
  public void testWindows_toUri_unc() {
    URI fileUri =
        PathType.windows()
            .toUri(fileSystemUri, ""\\\\host\\share\\"", ImmutableList.of(""foo"", ""bar""), false);
    assertThat(fileUri.toString()).isEqualTo(""jimfs://foo//host/share/foo/bar"");
    assertThat(fileUri.getPath()).isEqualTo(""//host/share/foo/bar"");

    URI rootUri =
        PathType.windows()
            .toUri(fileSystemUri, ""\\\\host\\share\\"", ImmutableList.<String>of(), true);
    assertThat(rootUri.toString()).isEqualTo(""jimfs://foo//host/share/"");
    assertThat(rootUri.getPath()).isEqualTo(""//host/share/"");
  }",No Smells
"@Test
    public void testSetViaFacade() {
        Person defaults = new Person(""jim"", 27);
        Person object = new Person(""kurt"", 22);

        FacadeUtils.set(object, defaults, SetFacade.class);

        assertEquals(""jim"", object.getName());
        assertEquals((Integer) 22, object.getAge());
    }",No Smells
"@Test
	public void testDate() {
		String dateStr = ""\""2013/12/26 23:55:01\"""";
		Date date = JsonUtils.from(yawp, dateStr, Date.class);
		String json = JsonUtils.to(date);
		assertEquals(dateStr, json);
	}",No Smells
"@Test
	public void testFrom() {
		BasicObject object = JsonUtils.from(null, DATA_OBJECT_JSON, BasicObject.class);
		object.assertObject(""object1"", ""text"", 1, 1L, 1.1, true, ""2013/12/26 23:55:01"");
	}",No Smells
"@Test
	public void testFromArray() {
		String json = String.format(""[%s, %s, %s]"", DATA_OBJECT_JSON, DATA_OBJECT_JSON, DATA_OBJECT_JSON);

		List<BasicObject> objects = JsonUtils.fromList(null, json, BasicObject.class);

		assertEquals(3, objects.size());

		objects.get(0).assertObject(""object1"", ""text"", 1, 1L, 1.1, true, ""2013/12/26 23:55:01"");
		objects.get(0).assertObject(""object1"", ""text"", 1, 1L, 1.1, true, ""2013/12/26 23:55:01"");
		objects.get(0).assertObject(""object1"", ""text"", 1, 1L, 1.1, true, ""2013/12/26 23:55:01"");
	}",No Smells
"@Test
	public void testMapWithComplexKeyAndValue() {
		Map<IdRef<BasicObject>, BasicObject> map = new HashMap<>();
		map.put(id(BasicObject.class, 1L), new BasicObject(""xpto""));

		Type keyType = ParameterizedTypeImpl.create(IdRef.class, new Type[]{Long.class}",No Smells
"@Test
    public void testCreateUpdateEntity() throws EntityNotFoundException {
        Entity entity = new Entity(""parents"");
        entity.setProperty(""name"", ""jim"");

        Key key = datastore.put(entity);

        entity.setProperty(""name"", ""robert"");
        datastore.put(entity);

        Entity retrievedEntity = datastore.get(key);
        assertEquals(""robert"", retrievedEntity.getProperty(""name""));

    }",No Smells
"@Test
    public void testForceName() throws EntityNotFoundException {
        Key key = KeyFactory.createKey(""parents"", ""xpto"");

        Entity entity = new Entity(key);
        entity.setProperty(""name"", ""jim"");

        datastore.put(entity);

        Entity retrievedEntity = datastore.get(key);
        assertEquals(""jim"", retrievedEntity.getProperty(""name""));
    }",No Smells
"@Test
    public void testQueryInWithKey() throws FalsePredicateException {
        ObjectModel model = new ObjectModel(Parent.class);

        Key key = KeyFactory.createKey(""parents"", 1l);
        Entity entity = new Entity(key);
        entity.setProperty(""name"", ""jim"");
        entity.setProperty(""__name"", ""jim"");
        entity.setProperty(""age"", 27);
        datastore.put(entity);

        Key anotherKey = KeyFactory.createKey(""parents"", 2l);

        assertQueryInForField(""id"", Arrays.asList(IdRefToKey.toIdRef(yawp, key, model), IdRefToKey.toIdRef(yawp, anotherKey, model)));
    }",No Smells
"@Test
    public void testQueryLimit() throws FalsePredicateException {
        saveParentWithName(""jim"");
        saveParentWithName(""robert"");

        QueryBuilder<Parent> builder = QueryBuilder.q(Parent.class, yawp);
        builder.order(""name"", ""desc"");
        builder.limit(1);

        List<Entity> entities = datastore.query(new Query(builder, false));

        assertEquals(1, entities.size());
        assertEquals(""robert"", entities.get(0).getProperty(""name""));
    }",No Smells
"@Test
    public void testDatabaseCreation() {
        DatabaseSynchronizer dbSynchronizer = new DatabaseSynchronizer();

        dbSynchronizer.drop();
        assertFalse(dbSynchronizer.databaseExists());

        dbSynchronizer.create();
        assertTrue(dbSynchronizer.databaseExists());

        dbSynchronizer.drop();
    }",Mystery Guest + Resource Optimism
"@Test
    public void testEndpointFilename() {
        assertEquals(""person/Person.java"", new EndpointNaming(""Person"").getFilename());
        assertEquals(""personaddress/PersonAddress.java"", new EndpointNaming(""PersonAddress"").getFilename());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testEndpointPath() {
        assertEquals(""people"", new EndpointNaming(""Person"").getPath());
        assertEquals(""person-addresses"", new EndpointNaming(""PersonAddress"").getPath());
        assertEquals(""parents"", new EndpointNaming(""Parent"").getPath());
        assertEquals(""parent-addresses"", new EndpointNaming(""ParentAddress"").getPath());
        assertEquals(""children"", new EndpointNaming(""Child"").getPath());
        assertEquals(""grandchildren"", new EndpointNaming(""Grandchild"").getPath());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testParentRootCollectionJsonStringParams() throws InvalidActionMethodException {
        List<ActionKey> keys = getActionKeysFor(""parentRootCollectionJsonStringParams"", String.class, Map.class, IdRef.class);
        assertActionKey(HttpVerb.POST, ""parent-root-collection-json-string-and-params"", true, keys.get(0));
    }",No Smells
"@Test
    public void testParentRootCollectionParams() throws InvalidActionMethodException {
        List<ActionKey> keys = getActionKeysFor(""parentRootCollectionParams"", IdRef.class, Map.class);
        assertActionKey(HttpVerb.PUT, ""parent-root-collection-params"", true, keys.get(0));
    }",No Smells
"@Test
    public void testRootCollection() throws InvalidActionMethodException {
        List<ActionKey> keys = getActionKeysFor(""rootCollection"");
        assertActionKey(HttpVerb.GET, ""root-collection"", true, keys.get(0));
    }",No Smells
"@Test
    public void testSingleObject() throws InvalidActionMethodException {
        List<ActionKey> keys = getActionKeysFor(""singleObject"", IdRef.class);
        assertActionKey(HttpVerb.GET, ""single-object"", false, keys.get(0));
        assertActionKey(HttpVerb.POST, ""single-object"", false, keys.get(1));
        assertActionKey(HttpVerb.PUT, ""single-object"", false, keys.get(2));
        assertActionKey(HttpVerb.PATCH, ""single-object"", false, keys.get(3));
        assertActionKey(HttpVerb.DELETE, ""single-object"", false, keys.get(4));
    }",No Smells
"@Test
    public void testSingleObjectWithoutName() throws InvalidActionMethodException {
        List<ActionKey> keys = getActionKeysFor(""singleObjectWithoutName"", IdRef.class);
        assertActionKey(HttpVerb.GET, ""single-object-without-name"", false, keys.get(0));
        assertActionKey(HttpVerb.POST, ""single-object-without-name"", false, keys.get(1));
        assertActionKey(HttpVerb.PUT, ""single-object-without-name"", false, keys.get(2));
        assertActionKey(HttpVerb.PATCH, ""single-object-without-name"", false, keys.get(3));
        assertActionKey(HttpVerb.DELETE, ""single-object-without-name"", false, keys.get(4));
    }",No Smells
"@Test
    public void testFetch() {
        IdRef<BasicObject> id = id(BasicObject.class, 1l);

        BasicObject object = new BasicObject(""xpto"");
        object.setId(id);

        yawp.save(object);

        FutureObject<BasicObject> future = yawp.async().fetch(id);
        BasicObject retrievedObject = future.get();
        assertEquals(""xpto"", retrievedObject.getStringValue());
    }",No Smells
"@Test
    public void testTwoLeaves() {
        FeatureTree<Hook> tree = new FeatureTree<>(Hook.class);
        tree.add(ObjectSuperClassHook.class);
        tree.add(AllObjectsHook.class);

        Set<Class<? extends Hook>> leaves = tree.getLeaves();

        assertEquals(3, tree.size());
        assertEquals(2, leaves.size());
        assertTrue(leaves.contains(ObjectSuperClassHook.class));
        assertTrue(leaves.contains(AllObjectsHook.class));
    }",No Smells
"@Test
    public void testInvalidEndpointPaths() {
        RepositoryFeatures features = new RepositoryFeatures();

        assertFalse(features.isValidEndpointPath(""parents""));
        assertFalse(features.isValidEndpointPath(""/123parents""));
        assertFalse(features.isValidEndpointPath(""/par?ents""));
    }",No Smells
"@Test
    public void testOnlyIncrement() {
        if (pipesDriverNotImplemented()) {
            return;
        }",No Smells
"@Test
    public void testSaveDifferentChildreen() {
        if (pipesDriverNotImplemented()) {
            return;
        }",No Smells
"@Test
    public void testBasicQuery() {
        saveManyBasicObjects(3);

        IdPump<BasicObject> pump = new IdPump<>(BasicObject.class, 2);

        pumpTestBasicQuery(pump);
    }",No Smells
"@Test
    public void testListQueryAndGenerator() {
        saveManyBasicObjects(5);
        List<IdRef<BasicObject>> list = getIds(saveManyBasicObjects(4, 5));
        List<IdRef<BasicObject>> idsForGenerator = getIds(saveManyBasicObjects(4, 9));

        IdPump<BasicObject> pump = new IdPump<>(BasicObject.class, 2);
        pump.addGenerator(new ListGenerator<IdRef<BasicObject>>(idsForGenerator));

        pumpTestLIstQueryAndGenerator(pump, list);
    }",No Smells
"@Test
    public void testBasicList() {
        List<BasicObject> list = saveManyBasicObjects(3);

        ObjectPump<BasicObject> pump = new ObjectPump<>(BasicObject.class, 2);

        pumpTestBasicList(pump, list);
    }",No Smells
"@Test
    public void testBasicQuery() {
        saveManyBasicObjects(3);
        ObjectPump<BasicObject> pump = new ObjectPump<>(BasicObject.class, 2);

        pumpTestBasicQuery(pump);
    }",No Smells
"@Test
    public void testJsonArrayProperty() {
        BasicObject object = new BasicObject();

        List<Pojo> list = new ArrayList<Pojo>();
        list.add(new Pojo(""xpto1""));
        list.add(new Pojo(""xpto2""));
        object.setJsonList(list);

        yawp.save(object);

        BasicObject retrievedObject = object.getId().fetch();
        assertEquals(""xpto1"", retrievedObject.getJsonList().get(0).getStringValue());
        assertEquals(""xpto2"", retrievedObject.getJsonList().get(1).getStringValue());
    }",No Smells
"@Test
    public void testSaveChild() {
        Parent parent = new Parent();
        yawp.save(parent);

        Child child = new Child(""xpto"");
        child.setParentId(parent.getId());
        yawp.save(child);

        Parent retrievedParent = parent.getId().fetch();
        Child retrievedChild = child.getId().fetch();

        assertEquals(retrievedChild.getParentId(), retrievedParent.getId());
        assertEquals(""xpto"", retrievedChild.getName());
    }",No Smells
"@Test
    public void testSaveForNotEndpointObjects() {
        NotEndpointObject object = new NotEndpointObject(""xpto"");
        object.setParentId(id(BasicObject.class, 1L));
        yawp.save(object);

        NotEndpointObject retrievedObject = yawp(NotEndpointObject.class).only();
        assertEquals(""xpto"", retrievedObject.getName());
        assertEquals(id(BasicObject.class, 1L), retrievedObject.getParentId());
    }",No Smells
"@Test
    public void testSaveParent() {
        Parent parent = new Parent(""xpto"");

        yawp.save(parent);

        Parent retrievedParent = parent.getId().fetch();
        assertEquals(""xpto"", retrievedParent.getName());
    }",No Smells
"@Test
    public void testGrandparentTrueCondition() {
        Grandchild grandchild = saveGrandchild(""granchild"", saveChild(""child"", saveParent(""parent"")));

        RuleConditions conditions = new RuleConditions(yawp, Grandchild.class, null, Arrays.asList(grandchild));
        conditions.where(c(""name"", ""="", ""granchild""));
        conditions.where(c(""parent->name"", ""="", ""child""));
        conditions.where(c(""parent->parent->name"", ""="", ""parent""));

        assertTrue(conditions.evaluate());
    }",No Smells
"@Test
    public void testGrandparentWithoutObjectFalseCondition() {
        Parent parent = saveParent(""another-parent"");
        saveGrandchild(""granchild"", saveChild(""child"", parent));

        RuleConditions conditions = new RuleConditions(yawp, Grandchild.class, parent.getId(), null);
        conditions.where(c(""name"", ""="", ""granchild""));
        conditions.and(c(""parent->name"", ""="", ""child""));
        conditions.and(c(""parent->parent->name"", ""="", ""parent""));

        assertFalse(conditions.evaluate());
    }",No Smells
"@Test
    public void testParentFalseCondition() {
        Child child = saveChild(""child"", saveParent(""another-parent""));

        RuleConditions conditions = new RuleConditions(yawp, Child.class, null, Arrays.asList(child));
        conditions.where(c(""name"", ""="", ""child""));
        conditions.and(c(""parent->name"", ""="", ""parent""));

        assertFalse(conditions.evaluate());
    }",No Smells
"@Test
    public void testParentTrueCondition() {
        Child child = saveChild(""child"", saveParent(""parent""));

        RuleConditions conditions = new RuleConditions(yawp, Child.class, null, Arrays.asList(child));
        conditions.where(c(""name"", ""="", ""child""));
        conditions.where(c(""parent->name"", ""="", ""parent""));

        assertTrue(conditions.evaluate());
    }",No Smells
"@Test
    public void testAllowWithoutWhereRemovesOtherWhere() {
        saveObject(1l, ""xpto"", 100);
        saveObject(2l, ""xpto"", 200);

        login(""richey"");
        List<ShieldedObject> objects = fromList(get(""/shielded_objects""), ShieldedObject.class);

        assertEquals(2, objects.size());
        assertEquals((Integer) 100, objects.get(0).getIntValue());
        assertEquals((Integer) 200, objects.get(1).getIntValue());
    }",No Smells
"@Test
    public void testCreateFacadeArray() {
        login(""amy"");

        String json = post(""/shielded_objects"", ""[{\""stringValue\"": \""xpto1\"", \""intValue\"": 99}",No Smells
"@Test
    public void testCreateWhereOnMissingExistingObjects() {
        login(""janis"");

        assertPostWithStatus(""/shielded_objects/1"", ""{\""stringValue\"": \""ok-for-janis\""}",No Smells
"@Test
    public void testDifferentActions() {
        saveObject(1l);
        saveObject(100l);

        assertPutWithStatus(""/shielded_objects/1/something"", 404);
        assertPutWithStatus(""/shielded_objects/1/anotherthing"", 404);
        assertPutWithStatus(""/shielded_objects/100/anotherthing"", 200);
        assertGetWithStatus(""/shielded_objects/collection"", 200);
    }",No Smells
"@Test
    public void testShowFacade() {
        saveObject(1l, ""xpto"", 10);

        login(""amy"");

        String json = get(""/shielded_objects/1"");
        ShieldedObject retrievedObject = from(json, ShieldedObject.class);

        assertEquals(""xpto"", retrievedObject.getStringValue());
        assertNull(retrievedObject.getIntValue());
    }",Mystery Guest + Resource Optimism
"@Test
    public void testUpdateWhereOnExistingObjects() {
        saveObject(1l, ""ok-for-janis"");
        saveObject(2l, ""ok-for-amy"");

        login(""janis"");

        assertPutWithStatus(""/shielded_objects/1"", ""{\""stringValue\"": \""ok-for-janis\""}",No Smells
"@Test
    public void testAddAttribute() {
        yawp.save(new BasicObject(""xpto1""));
        Map<String, Object> map = yawp(BasicObject.class).<Map<String, Object>>transform(""addAttribute"").first();
        assertEquals(""xpto"", map.get(""attr""));
    }",No Smells
"@Test
    public void testShow() {
        Parent parent = saveParent(1l);
        saveShieldedChild(1l, parent);
        saveShieldedChild(100l, parent);

        assertGetWithStatus(""/parents/1/shielded_children/1"", 404);
        assertGetWithStatus(""/parents/1/shielded_children/100"", 200);
    }",No Smells
"@Test
    public void testIndexTransformer() {
        saveChild(""xpto1"", parent);
        saveChild(""xpto2"", parent);

        String json = get(uri(""/parents/%s/children"", parent), params(""t"", ""simple""));
        List<Child> children = fromList(json, Child.class);

        assertEquals(2, children.size());
        assertEquals(""transformed xpto1"", children.get(0).getName());
        assertEquals(""transformed xpto2"", children.get(1).getName());
    }",No Smells
"@Test
    public void testUpdateTransformer() {
        Child child = saveChild(""xpto"", parent);

        String json = put(uri(""/parents/%s/children/%s"", parent, child),
                json(""{ \""name\"": \""changed xpto\"", \""parentId\"": \""%s\"", \""id\"": \""%s\"" }",No Smells
"@Test
	public void createWithEmptyConfigDefaultValues() {
		CrossDomainManager cors = new CrossDomainManager();
		cors.init(new MockedServletConfig() {
			@Override
			public String getInitParameter(String name) {
				return null;
			}",No Smells
"@Test
    public void testNestedResource() {
        EndpointRouter router = parse(""/parents/1/children/1"");

        assertFalse(router.isOverCollection());
        assertFalse(router.isCustomAction());
    }",No Smells
"@Test
    public void testRootResource() {
        EndpointRouter router = parse(""/parents/1"");

        assertFalse(router.isOverCollection());
        assertFalse(router.isCustomAction());
    }",No Smells
"@Test
    public void testRootResourceAction() {
        EndpointRouter router = parse(""/parents/1/action"");
        assertFalse(router.isOverCollection());
        assertTrue(router.isCustomAction());
        assertEquals(""action"", router.getCustomActionName());
    }",No Smells
"@Test
    public void test50thPercentile() throws Exception {
        Assert.assertEquals(50.0D, m.getPercentile(50), 0.0D);
    }",No Smells
"@Test
    public void test90thPercentile() throws Exception {
        Assert.assertEquals(90.0D, m.getPercentile(90), 0.0D);
    }",No Smells
"@Test
    public void testToKeys() {
        Meta one = new Meta(""sys.cpu.user"", ""tag1"", ""value1"");
        List<Key> keys = one.toKeys();
        Assert.assertTrue(keys.contains(new Key(""m:sys.cpu.user"")));
        Assert.assertTrue(keys.contains(new Key(""t:sys.cpu.user"", ""tag1"")));
        Assert.assertTrue(keys.contains(new Key(""v:sys.cpu.user"", ""tag1"", ""value1"")));
    }",No Smells
"@Test
    public void testParseWithViz() throws Exception {
        PairLexicoder<String,Long> rowCoder = new PairLexicoder<>(new StringLexicoder(), new LongLexicoder());
        byte[] row = rowCoder.encode(new ComparablePair<>(""sys.cpu.user"", 1000L));
        byte[] value = new byte[Double.BYTES];
        ByteBuffer.wrap(value).putDouble(2.0D);
        PairLexicoder<Long,String> colQualCoder = new PairLexicoder<>(new LongLexicoder(), new StringLexicoder());
        Key k = new Key(row, ""tag1=value1"".getBytes(), colQualCoder.encode(new ComparablePair<>(new Long(1000), ""tag2=value2,tag3=value3"")),
                        ""(a&b)|(c&d)"".getBytes(), 1000);
        Value v = new Value(value);
        Metric m = MetricAdapter.parse(k, v, true);
        Assert.assertEquals(""sys.cpu.user"", m.getName());
        List<Tag> tags = new ArrayList<>();
        tags.add(new Tag(""tag1=value1""));
        tags.add(new Tag(""tag2=value2""));
        tags.add(new Tag(""tag3=value3""));
        tags.add(new Tag(""viz=(a&b)|(c&d)""));
        Assert.assertEquals(tags, m.getTags());
        Assert.assertEquals(new Long(1000), m.getValue().getTimestamp());
        Assert.assertEquals(2.0D, m.getValue().getMeasure(), 0.0D);
    }",Eager Test
"@Test
    public void testToMutationWithViz() {
        long ts = System.currentTimeMillis();
        List<Tag> tags = new ArrayList<>();
        tags.add(new Tag(""tag1"", ""value1""));
        Metric m = Metric.newBuilder().name(""sys.cpu.user"").value(ts, 2.0D).tags(tags).tag(MetricAdapter.VISIBILITY_TAG, ""(a&b)|(c&d)"").build();

        Mutation mut = MetricAdapter.toMutation(m);

        PairLexicoder<String,Long> rowCoder = new PairLexicoder<>(new StringLexicoder(), new LongLexicoder());
        byte[] row = rowCoder.encode(new ComparablePair<>(""sys.cpu.user"", MetricAdapter.roundTimestampToLastHour(ts)));
        byte[] value = new byte[Double.BYTES];
        ByteBuffer.wrap(value).putDouble(2.0D);
        Assert.assertEquals(rowCoder.decode(row), rowCoder.decode(mut.getRow()));
        Assert.assertEquals(1, mut.getUpdates().size());
        ColumnUpdate up = mut.getUpdates().get(0);
        Assert.assertEquals(""tag1=value1"", new String(up.getColumnFamily()));
        PairLexicoder<Long,String> colQualCoder = new PairLexicoder<>(new LongLexicoder(), new StringLexicoder());
        Assert.assertEquals(new String(colQualCoder.encode(new ComparablePair<>(ts, """"))), new String(up.getColumnQualifier()));
        Assert.assertEquals(ts, up.getTimestamp());
        Assert.assertEquals(""(a&b)|(c&d)"", new String(up.getColumnVisibility()));
        Assert.assertArrayEquals(value, up.getValue());
    }",Eager Test
"@Test
    public void testAggregatorsResponseEmpty() throws Exception {
        AggregatorsResponse response = new AggregatorsResponse();
        String r = JsonUtil.getObjectMapper().writeValueAsString(response);
        Assert.assertEquals(""[]"", r);
    }",No Smells
"@Test
    public void testGenerateHtmlWithIgnoredTags() {
        timelyProperties.getMetricsReportIgnoredTags().add(""instance"");
        metaCache.add(new Meta(""sys.cpu.user"", ""host"", ""localhost""));
        metaCache.add(new Meta(""sys.cpu.user"", ""instance"", ""0""));
        metaCache.add(new Meta(""sys.cpu.idle"", ""host"", ""localhost""));
        metaCache.add(new Meta(""sys.cpu.idle"", ""instance"", ""0""));
        MetricsResponse response = new MetricsResponse(metaCache, timelyProperties);
        String html = response.generateHtml().toString();
        Assert.assertTrue(html.contains(""<td>sys.cpu.idle</td>""));
        Assert.assertTrue(html.contains(""<td>host=localhost </td>""));
        Assert.assertTrue(html.contains(""<td>sys.cpu.user</td>""));
        Assert.assertTrue(html.contains(""<td>host=localhost </td>""));
    }",Eager Test
"@Test
    public void testEmptyResponse() throws Exception {
        String r = JsonUtil.getObjectMapper().writeValueAsString(Collections.emptyList());
        Assert.assertEquals(""[]"", r);
    }",No Smells
"@Test
    public void testOneResponse() throws Exception {
        QueryResponse r = new QueryResponse();
        r.setMetric(""sys.cpu.user"");
        r.putTag(""host"", ""localhost"");
        r.putTag(""rack"", ""r1"");
        r.putDps(""1234567890"", 4.5);
        r.putDps(""1234567900"", 3.5);
        r.putDps(""1234567910"", 2.5);
        String result = JsonUtil.getObjectMapper().writeValueAsString(Collections.singletonList(r));
        String expected = ""[{\""metric\"":\""sys.cpu.user\"",\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""}",Eager Test
"@Test
    public void testSuggestResponseEmpty() throws Exception {
        SuggestResponse response = new SuggestResponse();
        String r = JsonUtil.getObjectMapper().writeValueAsString(response);
        Assert.assertEquals(""[]"", r);
    }",No Smells
"@Test
    public void testJson() throws IOException {
        ObjectMapper mapper = new ObjectMapper();

        String expectedJson = ""{\""name\"":\""m1\"",\""timestamp\"":1,\""measure\"":1.0,\""tags\"":[{\""k1\"":\""v1\""}",Eager Test
"@Test
    public void testListCombine() {
        List<Tag> tags = new ArrayList<>();
        tags.add(new Tag(""tag1"", ""value1""));
        tags.add(new Tag(""tag2"", ""value2""));
        String combined = new TagListParser().combine(tags);
        Assert.assertEquals(""tag1=value1,tag2=value2"", combined);
    }",No Smells
"@Test
    public void testListCombineMap() {
        Map<String,String> map = new TreeMap<>();
        map.put(""tag1"", ""value1"");
        map.put(""tag2"", ""value2"");
        String combined = new TagListParser().combine(map);
        Assert.assertEquals(""tag1=value1,tag2=value2"", combined);
    }",No Smells
"@Test
    public void testListParse() {
        String value = ""tag1=value1,tag2=value2"";
        List<Tag> tags = new TagListParser().parse(value);
        Assert.assertEquals(2, tags.size());
        Assert.assertEquals(new Tag(""tag1"", ""value1""), tags.get(0));
        Assert.assertEquals(new Tag(""tag2"", ""value2""), tags.get(1));
    }",No Smells
"@Test
    public void testParseTagsWithCommas() {

        try {
            String s = ""tag1=value1,tag2=3.4.3_(default\\,_Date\\,_Time)_"";
            new TagListParser().parse(s);
        }",No Smells
"@Test
    public void testCombineMissingReport() throws Exception {
        Downsample ds = new Downsample(0, 1000, 100, new Avg());
        for (int i = 0; i < 1000; i += 100) {
            if (i != 700) {
                ds.add(i, .2);
            }",Eager Test
"@Test
    public void simpleAggregatedSample() throws Exception {
        AggregationIterator iter = new AggregationIterator();
        Map<Set<Tag>,Aggregation> samples = runQuery(iter, testData2, 100);
        assertEquals(1, samples.size());
        for (Entry<Set<Tag>,Aggregation> entry : samples.entrySet()) {
            Set<Tag> tags = entry.getKey();
            assertEquals(1, tags.size());
            assertEquals(Collections.singleton(new Tag(""host"", "".*"")), tags);
            long ts = 0;
            int count = 0;
            for (Sample sample : entry.getValue()) {
                assertEquals(ts, sample.getTimestamp());
                ts += 100;
                assertEquals(count == 0 ? 0.2 : (count == 10 ? 0.5 : 0.35), sample.getValue(), 0.0001);
                count++;
            }",Eager Test
"@Test
    public void memoryEstimatorTestSmallObjects() {
        long maxMemory = 1000;
        long start = System.currentTimeMillis();
        long period = 500l;
        long sizeOfObjects = 20;
        SampleObject o = new SampleObject();
        DownsampleMemoryEstimator memoryEstimator = new DownsampleMemoryEstimator(maxMemory, start, period);
        boolean shouldReturn = false;
        for (long x = 100; x <= 5000; x += 100) {
            long timestamp = start + x;
            o.setSizeInBytes(o.sizeInBytes() + sizeOfObjects);
            shouldReturn = memoryEstimator.shouldReturnBasedOnMemoryUsage(timestamp, o);
            if (memoryEstimator.isNewBucket()) {
                long memoryPercentageUsedCalculated = Math.round((double) o.sizeInBytes() / maxMemory * 100);
                long memoryPercentageUsedEstimate = Math.round(memoryEstimator.getMemoryUsedPercentage());
                long percentError = Math.round(Math.abs(memoryPercentageUsedCalculated - memoryPercentageUsedEstimate) / memoryPercentageUsedCalculated * 100);
                assertTrue(percentError == 0);
            }",Eager Test
"@Test
    public void simpleGetOneSample() throws Exception {
        // check that data gets pulled out
        DownsampleIterator iter = new DownsampleIterator();
        Map<Set<Tag>,Downsample> samples = runQuery(iter, testData1, 100, -1);
        assertEquals(1, samples.size());
        for (Entry<Set<Tag>,Downsample> entry : samples.entrySet()) {
            Set<Tag> tags = entry.getKey();
            assertEquals(1, tags.size());
            assertEquals(Collections.singleton(new Tag(""host"", ""host1"")), tags);
            long ts = 0;
            for (Sample sample : entry.getValue()) {
                assertEquals(ts, sample.getTimestamp());
                ts += 100;
                assertEquals(0.2, sample.getValue(), 0.0001);
            }",Eager Test
"@Test
    public void simpleGetTwoSamples() throws Exception {
        DownsampleIterator iter = new DownsampleIterator();
        Map<Set<Tag>,Downsample> samples = runQuery(iter, testData2, 100, -1);
        assertEquals(2, samples.size());
        for (Tag tag : new Tag[] {new Tag(""host"", ""host1""), new Tag(""host"", ""host2"")}",Eager Test
"@Test
    public void testDownsampleCombining() throws Exception {

        int numTagVariations = 2;
        int sampleInterval = 50;
        int elapsedTime = 100;
        int skipInterval = 10;
        SortedMap<Key,Value> testData3 = createTestData3(elapsedTime, skipInterval, numTagVariations);
        DownsampleIterator iter = new DownsampleIterator();
        Map<Set<Tag>,Downsample> samples = runQuery(iter, testData3, sampleInterval, 1000);
        assertEquals(numTagVariations, samples.size());
        long totalBuckets = 0;
        for (Entry<Set<Tag>,Downsample> entry : samples.entrySet()) {
            totalBuckets = totalBuckets + entry.getValue().getNumBuckets();
        }",Eager Test
"@Test
    public void testCounterRate() throws Exception {
        table.clear();
        long ts = System.currentTimeMillis();
        for (int j = 0; j < 10; j++) {
            for (int i = 1; i <= 10; i++) {
                ts += 1000;
                Metric m = new Metric(""sys.cpu.user"", ts, i * 1.0D, tags);
                byte[] row = MetricAdapter.encodeRowKey(m);
                Key k = new Key(row, tags.get(0).join().getBytes(StandardCharsets.UTF_8), MetricAdapter.encodeColQual(ts, """"), new byte[0], ts);
                Value v = new Value(MetricAdapter.encodeValue(m.getValue().getMeasure()));
                table.put(k, v);
            }",Eager Test
"@Test
    public void testAdditionalTimeSeries() throws Exception {
        table.clear();
        long ts = ((System.currentTimeMillis() / 1000) * 1000);
        List<Tag> tags1 = new ArrayList<>();
        tags1.add(new Tag(""host"", ""r01n01""));
        List<Tag> tags2 = new ArrayList<>();
        tags2.add(new Tag(""host"", ""r01n02""));
        for (int i = 0; i < 100; i++) {
            ts += 1000;
            Metric m = new Metric(""sys.cpu.user"", ts, i * 1.0D, tags1);
            byte[] row = MetricAdapter.encodeRowKey(m);
            Key k = new Key(row, tags1.get(0).join().getBytes(StandardCharsets.UTF_8), MetricAdapter.encodeColQual(ts, """"), new byte[0], ts);
            Value v = new Value(MetricAdapter.encodeValue(m.getValue().getMeasure()));
            table.put(k, v);
            if (i > 50) {
                // only populate this series 50 times
                Metric m2 = new Metric(""sys.cpu.user"", ts, i * 2.0D, tags2);
                byte[] row2 = MetricAdapter.encodeRowKey(m2);
                Key k2 = new Key(row2, tags2.get(0).join().getBytes(StandardCharsets.UTF_8), MetricAdapter.encodeColQual(ts, """"), new byte[0], ts);
                Value v2 = new Value(MetricAdapter.encodeValue(m2.getValue().getMeasure()));
                table.put(k2, v2);
            }",Eager Test
"@Test
    public void testMixed() throws Exception {
        MetricAgeOffFilter filter = new MetricAgeOffFilter();
        HashMap<String,String> options = new HashMap<>();
        options.put(MetricAgeOffFilter.AGE_OFF_PREFIX + ""default"", Integer.toString(1 * ONE_DAY));
        filter.init(null, options, null);
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.idle"", TEST_TIME), new byte[0], new byte[0], new byte[0], TEST_TIME), null));
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.idle"", TEST_TIME + 1), new byte[0], new byte[0], new byte[0], TEST_TIME + 1),
                        null));
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.idle"", TEST_TIME + 2), new byte[0], new byte[0], new byte[0], TEST_TIME + 2),
                        null));
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.idle"", TEST_TIME + 3), new byte[0], new byte[0], new byte[0], TEST_TIME + 3),
                        null));
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.idle"", TEST_TIME + 4), new byte[0], new byte[0], new byte[0], TEST_TIME + 4),
                        null));
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.idle"", TEST_TIME + 5), new byte[0], new byte[0], new byte[0], TEST_TIME + 5),
                        null));
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME), new byte[0], new byte[0], new byte[0], TEST_TIME), null));
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME + 1), new byte[0], new byte[0], new byte[0], TEST_TIME + 1),
                        null));
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME + 2), new byte[0], new byte[0], new byte[0], TEST_TIME + 2),
                        null));
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME + 3), new byte[0], new byte[0], new byte[0], TEST_TIME + 3),
                        null));
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME + 4), new byte[0], new byte[0], new byte[0], TEST_TIME + 4),
                        null));
        assertTrue(filter.accept(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME + 5), new byte[0], new byte[0], new byte[0], TEST_TIME + 5),
                        null));
    }",Eager Test
"@Test
    public void testDefault() throws Exception {
        SortedMap<Key,Value> table = new TreeMap<>();
        table.put(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME), new byte[0], new byte[0], new byte[0], TEST_TIME), EMPTY_VALUE);
        table.put(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME + 1), new byte[0], new byte[0], new byte[0], TEST_TIME + 1), EMPTY_VALUE);
        table.put(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME + 2), new byte[0], new byte[0], new byte[0], TEST_TIME + 2), EMPTY_VALUE);
        table.put(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME + 3), new byte[0], new byte[0], new byte[0], TEST_TIME + 3), EMPTY_VALUE);
        table.put(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME + 4), new byte[0], new byte[0], new byte[0], TEST_TIME + 4), EMPTY_VALUE);
        table.put(new Key(MetricAdapter.encodeRowKey(""sys.cpu.user"", TEST_TIME + 5), new byte[0], new byte[0], new byte[0], TEST_TIME + 5), EMPTY_VALUE);

        SortedKeyValueIterator<Key,Value> source = new SortedMapIterator(table);
        MetricAgeOffIterator iter = new MetricAgeOffIterator();
        HashMap<String,String> options = new HashMap<>();
        options.put(MetricAgeOffIterator.AGE_OFF_PREFIX + ""default"", Integer.toString(1 * ONE_DAY));
        iter.init(source, options, null);
        iter.seek(new Range(), columnFamilies, true);
        int seen = 0;
        while (iter.hasTop()) {
            Key k = iter.getTopKey();
            Assert.assertTrue(k.getTimestamp() >= TEST_TIME && k.getTimestamp() <= TEST_TIME + 5);
            seen++;
            iter.next();
        }",Eager Test
"@Test
    public void testPersistenceWithVisibility() throws Exception {
        // @formatter:off
        put(""sys.cpu.user "" + TEST_TIME + "" 1.0 tag1=value1 tag2=value2"",
                   ""sys.cpu.idle "" + (TEST_TIME + 1) + "" 1.0 tag3=value3 tag4=value4 viz=(A|B)"",
                   ""sys.cpu.idle "" + (TEST_TIME + 2) + "" 1.0 tag3=value3 tag4=value4 viz=(C&B)"");
        // @formatter:on
        dataStore.flush();
        sleepUninterruptibly(WAIT_SECONDS, TimeUnit.SECONDS);
        int count = 0;
        for (final Map.Entry<Key,Value> entry : accumuloClient.createScanner(timelyProperties.getMetricsTable(), Authorizations.EMPTY)) {
            final double value = ByteBuffer.wrap(entry.getValue().get()).getDouble();
            assertEquals(1.0, value, 1e-9);
            count++;
        }",Eager Test + Mystery Guest
"@Test
    public void testClientAuthAccess() throws Exception {
        WebSocketSubscriptionClient client = new WebSocketSubscriptionClient(outboundSSLContext, ""localhost"", httpProperties.getPort(),
                        websocketProperties.getPort(), true, false, false, 65536);
        testWorkflow(client);
    }",Eager Test + Mystery Guest
"@Test
    public void testMultipleAgeOffWithoutCache() throws Exception {
        cacheProperties.setEnabled(false);
        testMultipleAgeOff(timelyProperties, cacheProperties);
    }",Eager Test + Mystery Guest
"@Test
    public void testMultipleAgeOffWithoutCache() throws Exception {
        cacheProperties.setEnabled(false);
        testMultipleAgeOff(timelyProperties, cacheProperties);
    }",No Smells
"@Test
    public void testMetrics() throws Exception {
      // @formatter:off
        put(""sys.cpu.user "" + TEST_TIME + "" 1.0 tag1=value1 tag2=value2"",
            ""sys.cpu.idle "" + (TEST_TIME + 1) + "" 1.0 tag3=value3 tag4=value4"",
            ""sys.cpu.idle "" + (TEST_TIME + 2) + "" 1.0 tag3=value3 tag4=value4 viz=(a|b|c)"",
            ""zzzz 1234567892 1.0 host=localhost"");
        // @formatter:on
        dataStore.flush();
        dataStoreCache.flushCaches(-1);
        // Latency in TestConfiguration is 2s, wait for it
        sleepUninterruptibly(TestConfiguration.WAIT_SECONDS, TimeUnit.SECONDS);

        String metrics = baseUrl + ""/api/metrics"";
        // Test prefix matching
        String result = query(metrics);
        Document doc = Jsoup.parse(result);
        Elements tableData = doc.select(""td"");

        assertEquals(1, tableData.select("":contains(sys.cpu.user)"").size());
        assertEquals(1, tableData.select("":contains(tag1=value1 tag2=value2)"").size());
        assertEquals(1, tableData.select("":contains(sys.cpu.idle)"").size());
        assertEquals(1, tableData.select("":contains(tag3=value3 tag4=value4)"").size());
        assertEquals(1, tableData.select("":contains(zzzz)"").size());
        assertEquals(1, tableData.select("":contains(host=localhost)"").size());
    }",Eager Test + Mystery Guest
"@Test
    public void testPutMetric() throws Exception {
        Metric m = Metric.newBuilder().name(""sys.cpu.user"").value(TEST_TIME, 1.0D).tag(new Tag(""tag1"", ""value1"")).build();
        new Metric();
        URL url = new URL(baseUrl + ""/api/put"");
        HttpsURLConnection con = getUrlConnection(url);
        con.setRequestMethod(""POST"");
        con.setDoOutput(true);
        con.setRequestProperty(""Content-Type"", ""application/json"");
        String requestJSON = JsonUtil.getObjectMapper().writeValueAsString(m);
        con.setRequestProperty(""Content-Length"", String.valueOf(requestJSON.length()));
        OutputStream wr = con.getOutputStream();
        wr.write(requestJSON.getBytes(UTF_8));
        int responseCode = con.getResponseCode();
        Assert.assertEquals(200, responseCode);
    }",Eager Test + Mystery Guest
"@Test
    public void testQueryWithNoTagsMultipleSeries() throws Exception {
        // @formatter:off
        put(""sys.cpu.user "" + TEST_TIME + "" 1.0 tag1=value1 tag2=value2 host=h1"",
           ""sys.cpu.user "" + TEST_TIME + "" 2.0 tag1=value1 tag2=value2 host=h2"",
           ""sys.cpu.user "" + (TEST_TIME + 1000) + "" 4.0 tag1=value1 tag2=value2 host=h1"",
           ""sys.cpu.user "" + (TEST_TIME + 1000) + "" 3.0 tag1=value1 tag2=value2 host=h2"",
           ""sys.cpu.user "" + (TEST_TIME + 2000) + "" 5.0 tag1=value1 tag2=value2 host=h1"",
           ""sys.cpu.user "" + (TEST_TIME + 2000) + "" 6.0 tag1=value1 tag2=value2 host=h2"");
        // @formatter:on
        dataStore.flush();
        dataStoreCache.flushCaches(-1);
        // Latency in TestConfiguration is 2s, wait for it
        sleepUninterruptibly(TestConfiguration.WAIT_SECONDS, TimeUnit.SECONDS);
        QueryRequest request = new QueryRequest();
        request.setStart(TEST_TIME);
        request.setEnd(TEST_TIME + 4000);
        SubQuery subQuery = new SubQuery();
        subQuery.setMetric(""sys.cpu.user"");
        subQuery.setDownsample(Optional.of(""1s-max""));
        request.addQuery(subQuery);
        List<QueryResponse> response = query(baseUrl + ""/api/query"", request);
        assertEquals(1, response.size());
        Map<String,String> tags = response.get(0).getTags();
        assertEquals(0, tags.size());
        Map<String,Object> dps = response.get(0).getDps();
        assertEquals(3, dps.size());
        Iterator<Entry<String,Object>> entries = dps.entrySet().iterator();
        Entry<String,Object> entry = entries.next();
        assertEquals(Long.toString((TEST_TIME / 1000)), entry.getKey());
        assertEquals(2.0, entry.getValue());
        entry = entries.next();
        assertEquals(Long.toString((TEST_TIME / 1000) + 1), entry.getKey());
        assertEquals(4.0, entry.getValue());
        entry = entries.next();
        assertEquals(Long.toString((TEST_TIME / 1000) + 2), entry.getKey());
        assertEquals(6.0, entry.getValue());
    }",Eager Test + Mystery Guest
"@Test
    public void testQueryWithoutMsResolution() throws Exception {
        // @formatter:off
        put(""sys.cpu.user "" + TEST_TIME + "" 1.0 tag1=value1 tag2=value2"",
           ""sys.cpu.user "" + (TEST_TIME + 1) + "" 1.0 tag3=value3"",
           ""sys.cpu.idle "" + (TEST_TIME + 2) + "" 1.0 tag3=value3 tag4=value4"",
           ""sys.cpu.idle "" + (TEST_TIME + 1000) + "" 3.0 tag3=value3 tag4=value4"");
        // @formatter:on
        dataStore.flush();
        dataStoreCache.flushCaches(-1);
        // Latency in TestConfiguration is 2s, wait for it
        sleepUninterruptibly(TestConfiguration.WAIT_SECONDS, TimeUnit.SECONDS);
        QueryRequest request = new QueryRequest();
        request.setStart(TEST_TIME);
        request.setEnd(TEST_TIME + 6000);
        SubQuery subQuery = new SubQuery();
        subQuery.setMetric(""sys.cpu.idle"");
        subQuery.setTags(Collections.singletonMap(""tag3"", ""value3""));
        subQuery.setDownsample(Optional.of(""1s-max""));
        request.addQuery(subQuery);
        List<QueryResponse> response = query(baseUrl + ""/api/query"", request);
        assertEquals(1, response.size());
        Map<String,String> tags = response.get(0).getTags();
        assertEquals(1, tags.size());
        assertTrue(tags.containsKey(""tag3""));
        assertTrue(tags.get(""tag3"").equals(""value3""));
        Map<String,Object> dps = response.get(0).getDps();
        assertEquals(2, dps.size());
        Iterator<Entry<String,Object>> entries = dps.entrySet().iterator();
        Entry<String,Object> entry = entries.next();
        assertEquals(Long.toString((TEST_TIME / 1000)), entry.getKey());
        assertEquals(1.0, entry.getValue());
        entry = entries.next();
        assertEquals(Long.toString((TEST_TIME / 1000) + 1), entry.getKey());
        assertEquals(3.0, entry.getValue());
    }",Eager Test + Mystery Guest
"@Test
    public void testQueryWithTagWildcard() throws Exception {
        // @formatter:off
        put(""sys.cpu.user "" + TEST_TIME + "" 1.0 tag1=value1 tag2=value2 rack=r1"",
            ""sys.cpu.user "" + (TEST_TIME + 1) + "" 1.0 tag3=value3 rack=r2"",
            ""sys.cpu.idle "" + (TEST_TIME + 2) + "" 1.0 tag3=value3 tag4=value4 rack=r1"",
            ""sys.cpu.idle "" + (TEST_TIME + 1000) + "" 3.0 tag3=value3 tag4=value4 rack=r2"");
        // @formatter:on
        dataStore.flush();
        dataStoreCache.flushCaches(-1);
        // Latency in TestConfiguration is 2s, wait for it
        sleepUninterruptibly(TestConfiguration.WAIT_SECONDS, TimeUnit.SECONDS);
        QueryRequest request = new QueryRequest();
        request.setStart(TEST_TIME);
        request.setEnd(TEST_TIME + 6000);
        SubQuery subQuery = new SubQuery();
        subQuery.setMetric(""sys.cpu.idle"");
        subQuery.setTags(Collections.singletonMap(""rack"", ""r.*""));
        subQuery.setDownsample(Optional.of(""1s-max""));
        request.addQuery(subQuery);

        List<QueryResponse> response = query(baseUrl + ""/api/query"", request);
        assertEquals(2, response.size());

        AtomicInteger rack1Count = new AtomicInteger(0);
        AtomicInteger rack2Count = new AtomicInteger(0);
        response.forEach(r -> {
            Map<String,String> tags = r.getTags();
            Map<String,Object> dps = r.getDps();
            assertEquals(1, tags.size());
            assertEquals(1, dps.size());
            assertTrue(tags.containsKey(""rack""));
            Value value = parseDps(dps);
            switch (tags.get(""rack"")) {
                case ""r2"":
                    assertEquals((Long) ((TEST_TIME / 1000L) + 1L), value.getTimestamp());
                    assertEquals(3.0D, value.getMeasure(), 0.0);
                    rack2Count.incrementAndGet();
                    break;
                case ""r1"":
                    assertEquals((Long) (TEST_TIME / 1000L), value.getTimestamp());
                    assertEquals(1.0D, value.getMeasure(), 0.0);
                    rack1Count.incrementAndGet();
                    break;
                default:
                    assertTrue(""Found invalid rack number: "" + tags.get(""rack""), false);
                    break;
            }",Eager Test + Mystery Guest
"@Test
    public void testHSTSRequestGet() throws Exception {
        String secureMe = baseHttpsUrl + ""/secure-me"";
        URL url = new URL(secureMe);
        HttpsURLConnection con = getUrlConnection(url);
        int responseCode = con.getResponseCode();
        assertEquals(404, responseCode);
        assertEquals(""max-age="" + httpProperties.getStrictTransportMaxAge(), con.getHeaderField(StrictTransportHandler.HSTS_HEADER_NAME));
    }",Eager Test + Mystery Guest
"@Test
    public void testPutMultiple() throws Exception {

        try (Socket sock = new Socket(serverProperties.getIp(), serverProperties.getTcpPort());
                PrintWriter writer = new PrintWriter(sock.getOutputStream(), true)) {
            // @formatter:off
            writer.write(""put sys.cpu.user "" + TEST_TIME + "" 1.0 tag1=value1 tag2=value2\n""
                       + ""put sys.cpu.idle "" + (TEST_TIME + 1) + "" 1.0 tag3=value3 tag4=value4\n"");
            writer.flush();
            while (2 != tcpRequests.getCount()) {
                Thread.sleep(5);
            }",Eager Test + Mystery Guest
"@Test
    public void testPersistenceWithVisibility() throws Exception {
        put(""sys.cpu.user "" + TEST_TIME + "" 1.0 tag1=value1 tag2=value2"", ""sys.cpu.idle "" + (TEST_TIME + 1) + "" 1.0 tag3=value3 tag4=value4 viz=(a|b)"",
                        ""sys.cpu.idle "" + (TEST_TIME + 2) + "" 1.0 tag3=value3 tag4=value4 viz=(c&b)"");
        sleepUninterruptibly(TestConfiguration.WAIT_SECONDS, TimeUnit.SECONDS);
        accumuloClient.securityOperations().changeUserAuthorizations(""root"", new Authorizations(""a"", ""b"", ""c""));

        int count = 0;
        for (final Map.Entry<Key,Value> entry : accumuloClient.createScanner(""timely.metrics"", Authorizations.EMPTY)) {
            log.debug(""Entry: "" + entry);
            final double value = ByteBuffer.wrap(entry.getValue().get()).getDouble();
            assertEquals(1.0, value, 1e-9);
            count++;
        }",Eager Test + Mystery Guest
"@Test
    public void testPutMultipleBinary() throws Exception {

        FlatBufferBuilder builder = new FlatBufferBuilder(1);

        int[] metric = new int[2];
        Map<String,String> t = new HashMap<>();
        t.put(""tag1"", ""value1"");
        t.put(""tag2"", ""value2"");
        metric[0] = createMetric(builder, ""sys.cpu.user"", TEST_TIME, 1.0D, t);
        t = new HashMap<>();
        t.put(""tag3"", ""value3"");
        t.put(""tag4"", ""value4"");
        metric[1] = createMetric(builder, ""sys.cpu.idle"", TEST_TIME + 1, 1.0D, t);

        int metricVector = timely.api.flatbuffer.Metrics.createMetricsVector(builder, metric);

        timely.api.flatbuffer.Metrics.startMetrics(builder);
        timely.api.flatbuffer.Metrics.addMetrics(builder, metricVector);
        int metrics = timely.api.flatbuffer.Metrics.endMetrics(builder);
        timely.api.flatbuffer.Metrics.finishMetricsBuffer(builder, metrics);

        ByteBuffer binary = builder.dataBuffer();
        byte[] data = new byte[binary.remaining()];
        binary.get(data, 0, binary.remaining());
        log.debug(""Sending {}",Eager Test + Mystery Guest
"@Test
  public void testGetDeletableFiles() throws IOException {
    // 1. Create a file
    Path file = new Path(root, ""testIsFileDeletableWithNoHFileRefs"");
    fs.createNewFile(file);
    // 2. Assert file is successfully created
    assertTrue(""Test file not created!"", fs.exists(file));
    BackupHFileCleaner cleaner = new BackupHFileCleaner();
    cleaner.setConf(conf);
    cleaner.setCheckForFullyBackedUpTables(false);
    List<FileStatus> stats = new ArrayList<>();
    // Prime the cleaner
    cleaner.getDeletableFiles(stats);
    // 3. Assert that file as is should be deletable
    FileStatus stat = fs.getFileStatus(file);
    stats.add(stat);
    Iterable<FileStatus> deletable = cleaner.getDeletableFiles(stats);
    boolean found = false;
    for (FileStatus stat1 : deletable) {
      if (stat.equals(stat1)) {
        found = true;
      }",Eager Test + Mystery Guest
"@Test
  public void testStartBackupExclusiveOperation() {

    long sleepTime = 2000;
    Runnable r = new Runnable() {
      @Override
      public void run() {
        try {
          backupManager.startBackupSession();
          boolean result = startTimes.compareAndSet(0, 0, EnvironmentEdgeManager.currentTime());
          if (!result) {
            result = startTimes.compareAndSet(1, 0, EnvironmentEdgeManager.currentTime());
            if (!result) {
              throw new IOException(""PANIC! Unreachable code"");
            }",Eager Test
"@Test
  public void testBackupHistory() throws Exception {
    int n = 10;
    List<BackupInfo> list = createBackupInfoList(n);

    // Load data
    for (BackupInfo bc : list) {
      // Make sure we set right status
      bc.setState(BackupState.COMPLETE);
      table.updateBackupInfo(bc);
    }",Eager Test
"@Test
  public void testBackupDelete() throws Exception {
    try (BackupSystemTable table = new BackupSystemTable(conn)) {
      int n = 10;
      List<BackupInfo> list = createBackupInfoList(n);

      // Load data
      for (BackupInfo bc : list) {
        // Make sure we set right status
        bc.setState(BackupState.COMPLETE);
        table.updateBackupInfo(bc);
      }",Eager Test
"@Test
  public void testBackupSetAddNotExists() throws IOException {
    try (BackupSystemTable table = new BackupSystemTable(conn)) {

      String[] tables = new String[] { ""table1"", ""table2"", ""table3"" }",Eager Test
"@Test
  public void testBackupSetList() throws IOException {
    try (BackupSystemTable table = new BackupSystemTable(conn)) {

      String[] tables = new String[] { ""table1"", ""table2"", ""table3"", ""table4"" }",Eager Test
"@Test
  public void testBackupSetRemoveSomeNotExists() throws IOException {
    try (BackupSystemTable table = new BackupSystemTable(conn)) {

      String[] tables = new String[] { ""table1"", ""table2"", ""table3"", ""table4"" }",Eager Test
"@Test
  public void testIncrementalBackupTableSet() throws IOException {
    TreeSet<TableName> tables1 = new TreeSet<>();

    tables1.add(TableName.valueOf(""t1""));
    tables1.add(TableName.valueOf(""t2""));
    tables1.add(TableName.valueOf(""t3""));

    TreeSet<TableName> tables2 = new TreeSet<>();

    tables2.add(TableName.valueOf(""t3""));
    tables2.add(TableName.valueOf(""t4""));
    tables2.add(TableName.valueOf(""t5""));

    table.addIncrementalBackupTableSet(tables1, ""root"");

    try (BackupSystemTable systemTable = new BackupSystemTable(conn)) {
      TreeSet<TableName> res1 =
        (TreeSet<TableName>) systemTable.getIncrementalBackupTableSet(""root"");
      assertTrue(tables1.size() == res1.size());
      Iterator<TableName> desc1 = tables1.descendingIterator();
      Iterator<TableName> desc2 = res1.descendingIterator();
      while (desc1.hasNext()) {
        assertEquals(desc1.next(), desc2.next());
      }",Eager Test
"@Test
  public void test() throws Exception {
    AsyncClientExample tool = new AsyncClientExample();
    tool.setConf(UTIL.getConfiguration());
    assertEquals(0, ToolRunner.run(tool, new String[] { TABLE_NAME.getNameAsString() }",No Smells
"@Test
  public void testOperationTimeout() throws Exception {
    // set retry number to 100 to make sure that this test only be affected by operation timeout
    TEST_UTIL.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 100);
    TEST_UTIL.getConfiguration().set(CoprocessorHost.MASTER_COPROCESSOR_CONF_KEY,
      TestOperationTimeoutCoprocessor.class.getName());
    TEST_UTIL.startMiniCluster(2);
    ASYNC_CONN = ConnectionFactory.createAsyncConnection(TEST_UTIL.getConfiguration()).get();

    try {
      getAdminBuilder.get()
        .setOperationTimeout(DEFAULT_OPERATION_TIMEOUT / 2, TimeUnit.MILLISECONDS).build()
        .getNamespaceDescriptor(DEFAULT_NAMESPACE_NAME_STR).get();
      fail(""We expect an exception here"");
    }",Eager Test
"@Test
  public void testCheckAndMutateWithTimeRange() throws Exception {
    AsyncTable<?> table = getTable.get();
    final long ts = EnvironmentEdgeManager.currentTime() / 2;
    Put put = new Put(row);
    put.addColumn(FAMILY, QUALIFIER, ts, VALUE);

    CheckAndMutateResult result =
      table.checkAndMutate(CheckAndMutate.newBuilder(row).ifNotExists(FAMILY, QUALIFIER).build(put))
        .get();
    assertTrue(result.isSuccess());
    assertNull(result.getResult());

    result = table.checkAndMutate(CheckAndMutate.newBuilder(row).ifEquals(FAMILY, QUALIFIER, VALUE)
      .timeRange(TimeRange.at(ts + 10000)).build(put)).get();
    assertFalse(result.isSuccess());
    assertNull(result.getResult());

    result = table.checkAndMutate(CheckAndMutate.newBuilder(row).ifEquals(FAMILY, QUALIFIER, VALUE)
      .timeRange(TimeRange.at(ts)).build(put)).get();
    assertTrue(result.isSuccess());
    assertNull(result.getResult());

    RowMutations rm = new RowMutations(row).add((Mutation) put);

    result = table.checkAndMutate(CheckAndMutate.newBuilder(row).ifEquals(FAMILY, QUALIFIER, VALUE)
      .timeRange(TimeRange.at(ts + 10000)).build(rm)).get();
    assertFalse(result.isSuccess());
    assertNull(result.getResult());

    result = table.checkAndMutate(CheckAndMutate.newBuilder(row).ifEquals(FAMILY, QUALIFIER, VALUE)
      .timeRange(TimeRange.at(ts)).build(rm)).get();
    assertTrue(result.isSuccess());
    assertNull(result.getResult());

    Delete delete = new Delete(row).addColumn(FAMILY, QUALIFIER);

    result = table.checkAndMutate(CheckAndMutate.newBuilder(row).ifEquals(FAMILY, QUALIFIER, VALUE)
      .timeRange(TimeRange.at(ts + 10000)).build(delete)).get();
    assertFalse(result.isSuccess());
    assertNull(result.getResult());

    result = table.checkAndMutate(CheckAndMutate.newBuilder(row).ifEquals(FAMILY, QUALIFIER, VALUE)
      .timeRange(TimeRange.at(ts)).build(delete)).get();
    assertTrue(result.isSuccess());
    assertNull(result.getResult());
  }",Eager Test
"@Test
  public void testSimpleMultiple() throws Exception {
    AsyncTable<?> table = getTable.get();
    int count = 100;
    CountDownLatch putLatch = new CountDownLatch(count);
    IntStream.range(0, count).forEach(
      i -> table.put(new Put(concat(row, i)).addColumn(FAMILY, QUALIFIER, concat(VALUE, i)))
        .thenAccept(x -> putLatch.countDown()));
    putLatch.await();
    BlockingQueue<Boolean> existsResp = new ArrayBlockingQueue<>(count);
    IntStream.range(0, count)
      .forEach(i -> table.exists(new Get(concat(row, i)).addColumn(FAMILY, QUALIFIER))
        .thenAccept(x -> existsResp.add(x)));
    for (int i = 0; i < count; i++) {
      assertTrue(existsResp.take());
    }",Eager Test
"@Test
  public void testDeleteAttributes() {
    Delete del = new Delete(new byte[] { 'r' }",Eager Test
"@Test
  public void testDeleteId() {
    Delete delete = new Delete(ROW);
    Assert.assertNull(""Make sure id is null if unset"", delete.toMap().get(""id""));
    delete.setId(""myId"");
    Assert.assertEquals(""myId"", delete.toMap().get(""id""));
  }",No Smells
"@Test
  public void testPutId() {
    Put put = new Put(ROW);
    Assert.assertNull(""Make sure id is null if unset"", put.toMap().get(""id""));
    put.setId(""myId"");
    Assert.assertEquals(""myId"", put.toMap().get(""id""));
  }",No Smells
"@Test
  public void testScanId() {
    Scan scan = new Scan();
    Assert.assertNull(""Make sure id is null if unset"", scan.toMap().get(""id""));
    scan.setId(""myId"");
    Assert.assertEquals(""myId"", scan.toMap().get(""id""));
  }",No Smells
"@Test
  public void test() throws IOException {
    assertSame(ScanResultCache.EMPTY_RESULT_ARRAY,
      resultCache.addAndGet(ScanResultCache.EMPTY_RESULT_ARRAY, false));
    assertSame(ScanResultCache.EMPTY_RESULT_ARRAY,
      resultCache.addAndGet(ScanResultCache.EMPTY_RESULT_ARRAY, true));

    ExtendedCell[] cells1 = createCells(CF, 1, 10);
    ExtendedCell[] cells2 = createCells(CF, 2, 10);
    ExtendedCell[] cells3 = createCells(CF, 3, 10);
    assertEquals(0, resultCache.addAndGet(
      new Result[] { Result.create(Arrays.copyOf(cells1, 3), null, false, true) }",Eager Test
"@Test
  public void testAddGetRemoveConfiguration() {
    ColumnFamilyDescriptorBuilder builder =
      ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(""foo""));
    String key = ""Some"";
    String value = ""value"";
    builder.setConfiguration(key, value);
    assertEquals(value, builder.build().getConfigurationValue(key));
    builder.removeConfiguration(key);
    assertEquals(null, builder.build().getConfigurationValue(key));
  }",Eager Test
"@Test
  public void testClassMethodsAreBuilderStyle() {
    /*
     * ColumnFamilyDescriptorBuilder should have a builder style setup where setXXX/addXXX methods
     * can be chainable together: . For example: ColumnFamilyDescriptorBuilder builder =
     * ColumnFamilyDescriptorBuilder.newBuilder() .setFoo(foo) .setBar(bar) .setBuz(buz) This test
     * ensures that all methods starting with ""set"" returns the declaring object
     */

    BuilderStyleTest.assertClassesAreBuilderStyle(ColumnFamilyDescriptorBuilder.class);
  }",No Smells
"@Test
  public void testSetTimeToLive() throws HBaseException {
    String ttl;
    ColumnFamilyDescriptorBuilder builder =
      ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(""foo""));

    ttl = ""50000"";
    builder.setTimeToLive(ttl);
    Assert.assertEquals(50000, builder.build().getTimeToLive());

    ttl = ""50000 seconds"";
    builder.setTimeToLive(ttl);
    Assert.assertEquals(50000, builder.build().getTimeToLive());

    ttl = """";
    builder.setTimeToLive(ttl);
    Assert.assertEquals(0, builder.build().getTimeToLive());

    ttl = ""FOREVER"";
    builder.setTimeToLive(ttl);
    Assert.assertEquals(HConstants.FOREVER, builder.build().getTimeToLive());

    ttl = ""1 HOUR 10 minutes 1 second"";
    builder.setTimeToLive(ttl);
    Assert.assertEquals(4201, builder.build().getTimeToLive());

    ttl = ""500 Days 23 HOURS"";
    builder.setTimeToLive(ttl);
    Assert.assertEquals(43282800, builder.build().getTimeToLive());

    ttl = ""43282800 SECONDS (500 Days 23 hours)"";
    builder.setTimeToLive(ttl);
    Assert.assertEquals(43282800, builder.build().getTimeToLive());
  }",Eager Test
"@Test
  public void testIncrementInstance() {
    final long expected = 13;
    Increment inc = new Increment(new byte[] { 'r' }",Eager Test
"@Test
  public void testPreserveMetaCacheOnException() throws Exception {
    ((FakeRSRpcServices) badRS.getRSRpcServices())
      .setExceptionInjector(new RoundRobinExceptionInjector());
    setupConnection(1);
    try (Table table = conn.getTable(TABLE_NAME)) {
      byte[] row = Bytes.toBytes(""row1"");

      Put put = new Put(row);
      put.addColumn(FAMILY, QUALIFIER, Bytes.toBytes(10));
      Get get = new Get(row);
      Append append = new Append(row);
      append.addColumn(FAMILY, QUALIFIER, Bytes.toBytes(11));
      Increment increment = new Increment(row);
      increment.addColumn(FAMILY, QUALIFIER, 10);
      Delete delete = new Delete(row);
      delete.addColumn(FAMILY, QUALIFIER);
      RowMutations mutations = new RowMutations(row);
      mutations.add(put);
      mutations.add(delete);

      Exception exp;
      boolean success;
      for (int i = 0; i < 50; i++) {
        exp = null;
        success = false;
        try {
          table.put(put);
          // If at least one operation succeeded, we should have cached the region location.
          success = true;
          table.get(get);
          table.append(append);
          table.increment(increment);
          table.delete(delete);
          table.mutateRow(mutations);
        }",Eager Test
"@Test
  public void testStaticMetrics() throws IOException {
    final byte[] foo = Bytes.toBytes(""foo"");
    String table = ""TableX"";
    final RegionSpecifier region = RegionSpecifier.newBuilder()
      .setValue(ByteString.copyFromUtf8(table)).setType(RegionSpecifierType.REGION_NAME).build();
    final int loop = 5;

    for (int i = 0; i < loop; i++) {
      METRICS.updateRpc(ClientService.getDescriptor().findMethodByName(""Get""),
        TableName.valueOf(table),
        GetRequest.newBuilder().setRegion(region).setGet(ProtobufUtil.toGet(new Get(foo))).build(),
        MetricsConnection.newCallStats(), null);
      METRICS.updateRpc(ClientService.getDescriptor().findMethodByName(""Scan""),
        TableName.valueOf(table),
        ScanRequest.newBuilder().setRegion(region)
          .setScan(ProtobufUtil.toScan(new Scan(new Get(foo)))).build(),
        MetricsConnection.newCallStats(),
        new RemoteWithExtrasException(""java.io.IOException"", null, false, false));
      METRICS.updateRpc(ClientService.getDescriptor().findMethodByName(""Multi""),
        TableName.valueOf(table),
        MultiRequest.newBuilder()
          .addRegionAction(ClientProtos.RegionAction.newBuilder()
            .addAction(
              ClientProtos.Action.newBuilder().setGet(ProtobufUtil.toGet(new Get(foo))).build())
            .setRegion(region).build())
          .build(),
        MetricsConnection.newCallStats(),
        new CallTimeoutException(""test with CallTimeoutException""));
      METRICS.updateRpc(ClientService.getDescriptor().findMethodByName(""Mutate""),
        TableName.valueOf(table),
        MutateRequest.newBuilder()
          .setMutation(ProtobufUtil.toMutation(MutationType.APPEND, new Append(foo)))
          .setRegion(region).build(),
        MetricsConnection.newCallStats(), null);
      METRICS.updateRpc(ClientService.getDescriptor().findMethodByName(""Mutate""),
        TableName.valueOf(table),
        MutateRequest.newBuilder()
          .setMutation(ProtobufUtil.toMutation(MutationType.DELETE, new Delete(foo)))
          .setRegion(region).build(),
        MetricsConnection.newCallStats(), null);
      METRICS.updateRpc(ClientService.getDescriptor().findMethodByName(""Mutate""),
        TableName.valueOf(table),
        MutateRequest.newBuilder()
          .setMutation(ProtobufUtil.toMutation(MutationType.INCREMENT, new Increment(foo)))
          .setRegion(region).build(),
        MetricsConnection.newCallStats(), null);
      METRICS.updateRpc(ClientService.getDescriptor().findMethodByName(""Mutate""),
        TableName.valueOf(table),
        MutateRequest.newBuilder()
          .setMutation(ProtobufUtil.toMutation(MutationType.PUT, new Put(foo))).setRegion(region)
          .build(),
        MetricsConnection.newCallStats(),
        new CallTimeoutException(""test with CallTimeoutException""));
    }",Eager Test
"@Test
  public void testPutCopyConstructor() throws IOException {
    Put origin = new Put(Bytes.toBytes(""ROW-01""));
    origin.setPriority(100);
    byte[] family = Bytes.toBytes(""CF-01"");

    origin.add(CellBuilderFactory.create(CellBuilderType.SHALLOW_COPY).setRow(origin.getRow())
      .setFamily(family).setQualifier(Bytes.toBytes(""q"")).setType(Cell.Type.Put)
      .setValue(Bytes.toBytes(""value"")).build());
    origin.addColumn(family, Bytes.toBytes(""q0""), Bytes.toBytes(""V-01""));
    origin.addColumn(family, Bytes.toBytes(""q1""), 100, Bytes.toBytes(""V-01""));
    Put clone = new Put(origin);
    assertEquals(origin, clone);
    origin.addColumn(family, Bytes.toBytes(""q2""), Bytes.toBytes(""V-02""));

    // They should have different cell lists
    assertNotEquals(origin.getCellList(family), clone.getCellList(family));
  }",Eager Test
"@Test
  public void testOperationJSON() throws IOException {
    // produce a Scan Operation
    Scan scan = new Scan().withStartRow(ROW);
    scan.addColumn(FAMILY, QUALIFIER);
    // get its JSON representation, and parse it
    String json = scan.toJSON();
    Type typeOfHashMap = new TypeToken<Map<String, Object>>() {
    }",Eager Test + Mystery Guest
"@Test
  public void testTaskCountChecker() throws InterruptedIOException {
    long heapSizeOfRow = 12345;
    int maxTotalConcurrentTasks = 100;
    int maxConcurrentTasksPerServer = 2;
    int maxConcurrentTasksPerRegion = 1;
    AtomicLong tasksInProgress = new AtomicLong(0);
    Map<ServerName, AtomicInteger> taskCounterPerServer = new HashMap<>();
    Map<byte[], AtomicInteger> taskCounterPerRegion = new TreeMap<>(Bytes.BYTES_COMPARATOR);
    SimpleRequestController.TaskCountChecker checker = new SimpleRequestController.TaskCountChecker(
      maxTotalConcurrentTasks, maxConcurrentTasksPerServer, maxConcurrentTasksPerRegion,
      tasksInProgress, taskCounterPerServer, taskCounterPerRegion);

    // inner state is unchanged.
    for (int i = 0; i != 10; ++i) {
      ReturnCode code = checker.canTakeOperation(LOC1, heapSizeOfRow);
      assertEquals(ReturnCode.INCLUDE, code);
    }",Eager Test
"@Test
  public void testWaitForMaximumCurrentTasks() throws Exception {
    final AtomicInteger max = new AtomicInteger(0);
    final CyclicBarrier barrier = new CyclicBarrier(2);
    SimpleRequestController controller = new SimpleRequestController(HBaseConfiguration.create());
    final AtomicLong tasks = controller.tasksInProgress;
    Runnable runnable = () -> {
      try {
        barrier.await();
        controller.waitForMaximumCurrentTasks(max.get(), 123, 1, null);
      }",Eager Test
"@Test
  public void testClassMethodsAreBuilderStyle() {
    BuilderStyleTest.assertClassesAreBuilderStyle(TableDescriptorBuilder.class);
  }",No Smells
"@Test
  public void testGetMaxFileSize() {
    TableDescriptor desc =
      TableDescriptorBuilder.newBuilder(TableName.valueOf(name.getMethodName())).build();
    assertEquals(-1, desc.getMaxFileSize());
    desc = TableDescriptorBuilder.newBuilder(TableName.valueOf(name.getMethodName()))
      .setMaxFileSize(1111L).build();
    assertEquals(1111L, desc.getMaxFileSize());
  }",Eager Test
"@Test
  public void testSetListRemoveCP() throws Exception {
    TableDescriptor desc =
      TableDescriptorBuilder.newBuilder(TableName.valueOf(name.getMethodName())).build();
    // Check that any coprocessor is present.
    assertTrue(desc.getCoprocessorDescriptors().isEmpty());

    // simple CP
    String className1 = ""org.apache.hadoop.hbase.coprocessor.SimpleRegionObserver"";
    String className2 = ""org.apache.hadoop.hbase.coprocessor.SampleRegionWALObserver"";
    // Add the 1 coprocessor and check if present.
    desc = TableDescriptorBuilder.newBuilder(desc).setCoprocessor(className1).build();
    assertTrue(desc.getCoprocessorDescriptors().size() == 1);
    assertTrue(desc.getCoprocessorDescriptors().stream().map(CoprocessorDescriptor::getClassName)
      .anyMatch(name -> name.equals(className1)));
    // Add the 2nd coprocessor and check if present.
    // remove it and check that it is gone
    desc = TableDescriptorBuilder.newBuilder(desc)

      .setCoprocessor(className2).build();
    assertTrue(desc.getCoprocessorDescriptors().size() == 2);
    assertTrue(desc.getCoprocessorDescriptors().stream().map(CoprocessorDescriptor::getClassName)
      .anyMatch(name -> name.equals(className2)));
    // Remove one and check
    desc = TableDescriptorBuilder.newBuilder(desc)

      .removeCoprocessor(className1).build();
    assertTrue(desc.getCoprocessorDescriptors().size() == 1);
    assertFalse(desc.getCoprocessorDescriptors().stream().map(CoprocessorDescriptor::getClassName)
      .anyMatch(name -> name.equals(className1)));
    assertTrue(desc.getCoprocessorDescriptors().stream().map(CoprocessorDescriptor::getClassName)
      .anyMatch(name -> name.equals(className2)));
    // Remove the last and check
    desc = TableDescriptorBuilder.newBuilder(desc)

      .removeCoprocessor(className2).build();
    assertTrue(desc.getCoprocessorDescriptors().isEmpty());
    assertFalse(desc.getCoprocessorDescriptors().stream().map(CoprocessorDescriptor::getClassName)
      .anyMatch(name -> name.equals(className1)));
    assertFalse(desc.getCoprocessorDescriptors().stream().map(CoprocessorDescriptor::getClassName)
      .anyMatch(name -> name.equals(className2)));
  }",Eager Test
"@Test
  public void testScannerWithRestoreScanner() throws Exception {
    TableName tableName = TableName.valueOf(""testScanner"");
    String snapshotName = ""testScannerWithRestoreScanner"";
    try {
      createTableAndSnapshot(UTIL, tableName, snapshotName, 50);
      Path restoreDir = UTIL.getDataTestDirOnTestFS(snapshotName);
      Scan scan = new Scan().withStartRow(bbb).withStopRow(yyy); // limit the scan

      Configuration conf = UTIL.getConfiguration();
      Path rootDir = CommonFSUtils.getRootDir(conf);

      TableSnapshotScanner scanner0 =
        new TableSnapshotScanner(conf, restoreDir, snapshotName, scan);
      verifyScanner(scanner0, bbb, yyy);
      scanner0.close();

      // restore snapshot.
      RestoreSnapshotHelper.copySnapshotForScanner(conf, fs, rootDir, restoreDir, snapshotName);

      // scan the snapshot without restoring snapshot
      TableSnapshotScanner scanner =
        new TableSnapshotScanner(conf, rootDir, restoreDir, snapshotName, scan, true);
      verifyScanner(scanner, bbb, yyy);
      scanner.close();

      // check whether the snapshot has been deleted by the close of scanner.
      scanner = new TableSnapshotScanner(conf, rootDir, restoreDir, snapshotName, scan, true);
      verifyScanner(scanner, bbb, yyy);
      scanner.close();

      // restore snapshot again.
      RestoreSnapshotHelper.copySnapshotForScanner(conf, fs, rootDir, restoreDir, snapshotName);

      // check whether the snapshot has been deleted by the close of scanner.
      scanner = new TableSnapshotScanner(conf, rootDir, restoreDir, snapshotName, scan, true);
      verifyScanner(scanner, bbb, yyy);
      scanner.close();
    }",Eager Test
"@Test
  public void testOne() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    CountingOutputStream cos = new CountingOutputStream(baos);
    DataOutputStream dos = new DataOutputStream(cos);
    Codec codec = new CellCodec();
    Codec.Encoder encoder = codec.getEncoder(dos);
    final KeyValue kv =
      new KeyValue(Bytes.toBytes(""r""), Bytes.toBytes(""f""), Bytes.toBytes(""q""), Bytes.toBytes(""v""));
    kv.setSequenceId(Long.MAX_VALUE);
    encoder.write(kv);
    encoder.flush();
    dos.close();
    long offset = cos.getCount();
    CountingInputStream cis = new CountingInputStream(new ByteArrayInputStream(baos.toByteArray()));
    DataInputStream dis = new DataInputStream(cis);
    Codec.Decoder decoder = codec.getDecoder(dis);
    assertTrue(decoder.advance()); // First read should pull in the KV
    // Second read should trip over the end-of-stream marker and return false
    assertFalse(decoder.advance());
    dis.close();
    assertEquals(offset, cis.getCount());
  }",Eager Test
"@Test
  public void testOne() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    CountingOutputStream cos = new CountingOutputStream(baos);
    DataOutputStream dos = new DataOutputStream(cos);
    KeyValueCodec kvc = new KeyValueCodec();
    Codec.Encoder encoder = kvc.getEncoder(dos);
    final KeyValue kv =
      new KeyValue(Bytes.toBytes(""r""), Bytes.toBytes(""f""), Bytes.toBytes(""q""), Bytes.toBytes(""v""));
    final int length = kv.getLength() + Bytes.SIZEOF_INT;
    encoder.write(kv);
    encoder.flush();
    dos.close();
    long offset = cos.getCount();
    assertEquals(length, offset);
    CountingInputStream cis = new CountingInputStream(new ByteArrayInputStream(baos.toByteArray()));
    DataInputStream dis = new DataInputStream(cis);
    Codec.Decoder decoder = kvc.getDecoder(dis);
    assertTrue(decoder.advance()); // First read should pull in the KV
    // Second read should trip over the end-of-stream marker and return false
    assertFalse(decoder.advance());
    dis.close();
    assertEquals(length, cis.getCount());
  }",Eager Test
"@Test
  public void testKeyValueWithTag() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    CountingOutputStream cos = new CountingOutputStream(baos);
    DataOutputStream dos = new DataOutputStream(cos);
    Codec codec = new KeyValueCodecWithTags();
    Codec.Encoder encoder = codec.getEncoder(dos);
    final KeyValue kv1 = new KeyValue(Bytes.toBytes(""r""), Bytes.toBytes(""f""), Bytes.toBytes(""1""),
      HConstants.LATEST_TIMESTAMP, Bytes.toBytes(""1""),
      new Tag[] { new ArrayBackedTag((byte) 1, Bytes.toBytes(""teststring1"")),
        new ArrayBackedTag((byte) 2, Bytes.toBytes(""teststring2"")) }",Eager Test
"@Test
  public void testDeregisterOnOutOfScope() {
    Configuration conf = new Configuration();
    ConfigurationManager cm = new ConfigurationManager();

    boolean outOfScopeObserversDeregistered = false;

    // On my machine, I was able to cause a GC after around 5 iterations.
    // If we do not cause a GC in 100k iterations, which is very unlikely,
    // there might be something wrong with the GC.
    for (int i = 0; i < 100000; i++) {
      registerLocalObserver(cm);
      cm.notifyAllObservers(conf);

      // 'Suggest' the system to do a GC. We should be able to cause GC
      // atleast once in the 2000 iterations.
      System.gc();

      // If GC indeed happened, all the observers (which are all out of scope),
      // should have been deregistered.
      if (cm.getNumObservers() <= i) {
        outOfScopeObserversDeregistered = true;
        break;
      }",Eager Test
"@Test
  public void testDisableConstraint() throws Exception {
    // create the table
    TableDescriptorBuilder builder = TableDescriptorBuilder.newBuilder(tableName);
    // add a family to the table
    for (byte[] family : new byte[][] { dummy, test }",Eager Test
"@Test
  public void testIsUnloaded() throws Exception {
    // create the table
    TableDescriptorBuilder builder = TableDescriptorBuilder.newBuilder(tableName);

    // add a family to the table
    for (byte[] family : new byte[][] { dummy, test }",Eager Test
"@Test
  public void testConfigurationPreserved() throws Exception {
    Configuration conf = new Configuration();
    conf.setBoolean(""_ENABLED"", false);
    conf.setLong(""_PRIORITY"", 10);
    TableDescriptorBuilder builder = TableDescriptorBuilder.newBuilder(name.getTableName());
    Constraints.add(builder, AlsoWorks.class, conf);
    Constraints.add(builder, WorksConstraint.class);
    assertFalse(Constraints.enabled(builder.build(), AlsoWorks.class));
    List<? extends Constraint> constraints =
      Constraints.getConstraints(builder.build(), this.getClass().getClassLoader());
    for (Constraint c : constraints) {
      Configuration storedConf = c.getConf();
      if (c instanceof AlsoWorks) {
        assertEquals(10, storedConf.getLong(""_PRIORITY"", -1));
      }",Eager Test
"@Test
  public void testNamespaceOperations() throws Exception {
    SingleProcessHBaseCluster cluster = UTIL.getHBaseCluster();
    String testNamespace = ""observed_ns"";
    HMaster master = cluster.getMaster();
    MasterCoprocessorHost host = master.getMasterCoprocessorHost();
    CPMasterObserver cp = host.findCoprocessor(CPMasterObserver.class);

    // create a table
    Admin admin = UTIL.getAdmin();

    admin.listNamespaces();
    assertTrue(""preListNamespaces should have been called"", cp.preListNamespacesCalled);
    assertTrue(""postListNamespaces should have been called"", cp.postListNamespacesCalled);

    admin.createNamespace(NamespaceDescriptor.create(testNamespace).build());
    assertTrue(""Test namespace should be created"", cp.wasCreateNamespaceCalled());

    assertNotNull(admin.getNamespaceDescriptor(testNamespace));
    assertTrue(""Test namespace descriptor should have been called"",
      cp.wasGetNamespaceDescriptorCalled());
    // This test used to do a bunch w/ bypass but bypass of these table and namespace stuff has
    // been removed so the testing code was removed.
  }",Eager Test
"@Test
  public void testSnapshotOperations() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    SingleProcessHBaseCluster cluster = UTIL.getHBaseCluster();
    HMaster master = cluster.getMaster();
    MasterCoprocessorHost host = master.getMasterCoprocessorHost();
    CPMasterObserver cp = host.findCoprocessor(CPMasterObserver.class);
    cp.resetStates();

    // create a table
    TableDescriptor tableDescriptor = TableDescriptorBuilder.newBuilder(tableName)
      .setColumnFamily(ColumnFamilyDescriptorBuilder.of(TEST_FAMILY)).build();
    Admin admin = UTIL.getAdmin();

    tableCreationLatch = new CountDownLatch(1);
    admin.createTable(tableDescriptor);
    tableCreationLatch.await();
    tableCreationLatch = new CountDownLatch(1);

    admin.disableTable(tableName);
    assertTrue(admin.isTableDisabled(tableName));

    try {
      // Test snapshot operation
      assertFalse(""Coprocessor should not have been called yet"", cp.wasSnapshotCalled());
      admin.snapshot(TEST_SNAPSHOT, tableName);
      assertTrue(""Coprocessor should have been called on snapshot"", cp.wasSnapshotCalled());

      // Test list operation
      admin.listSnapshots();
      assertTrue(""Coprocessor should have been called on snapshot list"",
        cp.wasListSnapshotCalled());

      // Test clone operation
      admin.cloneSnapshot(TEST_SNAPSHOT, TEST_CLONE);
      assertTrue(""Coprocessor should have been called on snapshot clone"",
        cp.wasCloneSnapshotCalled());
      assertFalse(""Coprocessor restore should not have been called on snapshot clone"",
        cp.wasRestoreSnapshotCalled());
      admin.disableTable(TEST_CLONE);
      assertTrue(admin.isTableDisabled(tableName));
      deleteTable(admin, TEST_CLONE);

      // Test restore operation
      cp.resetStates();
      admin.restoreSnapshot(TEST_SNAPSHOT);
      assertTrue(""Coprocessor should have been called on snapshot restore"",
        cp.wasRestoreSnapshotCalled());
      assertFalse(""Coprocessor clone should not have been called on snapshot restore"",
        cp.wasCloneSnapshotCalled());

      admin.deleteSnapshot(TEST_SNAPSHOT);
      assertTrue(""Coprocessor should have been called on snapshot delete"",
        cp.wasDeleteSnapshotCalled());
    }",Eager Test
"@Test
  public void testTableNamesEnumeration() throws Exception {
    SingleProcessHBaseCluster cluster = UTIL.getHBaseCluster();

    HMaster master = cluster.getMaster();
    MasterCoprocessorHost host = master.getMasterCoprocessorHost();
    CPMasterObserver cp = host.findCoprocessor(CPMasterObserver.class);
    cp.resetStates();

    master.getMasterRpcServices().getTableNames(null, GetTableNamesRequest.newBuilder().build());
    assertTrue(""Coprocessor should be called on table names request"", cp.wasGetTableNamesCalled());
  }",Eager Test
"@Test
  public void testWALObserverRoll() throws Exception {
    final WAL wal = wals.getWAL(null);
    final SampleRegionWALCoprocessor cp = getCoprocessor(wal, SampleRegionWALCoprocessor.class);
    cp.setTestValues(TEST_TABLE, null, null, null, null, null, null, null);

    assertFalse(cp.isPreWALRollCalled());
    assertFalse(cp.isPostWALRollCalled());

    wal.rollWriter(true);
    assertTrue(cp.isPreWALRollCalled());
    assertTrue(cp.isPostWALRollCalled());
  }",No Smells
"@Test
  public void testErrorPropagation() {
    ForeignExceptionListener listener1 = Mockito.mock(ForeignExceptionListener.class);
    ForeignExceptionListener listener2 = Mockito.mock(ForeignExceptionListener.class);
    ForeignExceptionDispatcher dispatcher = new ForeignExceptionDispatcher();

    // add the listeners
    dispatcher.addListener(listener1);
    dispatcher.addListener(listener2);

    // create an artificial error
    dispatcher.receive(EXTEXN);

    // make sure the listeners got the error
    Mockito.verify(listener1, Mockito.times(1)).receive(EXTEXN);
    Mockito.verify(listener2, Mockito.times(1)).receive(EXTEXN);

    // make sure that we get an exception
    try {
      dispatcher.rethrowException();
      fail(""Monitor should have thrown an exception after getting error."");
    }",No Smells
"@Test
  public void testTimerPassesOnErrorInfo() {
    final long time = 1000000;
    ForeignExceptionListener listener = mock(ForeignExceptionListener.class);
    TimeoutExceptionInjector timer = new TimeoutExceptionInjector(listener, time);
    timer.start();
    timer.trigger();
    verify(listener).receive(any());
  }",No Smells
"@Test
  public void testConstrainedPlacement() throws Exception {
    List<ServerName> servers = Lists.newArrayList();
    servers.add(ServerName.valueOf(""foo"" + 1 + "":1234"", -1));
    servers.add(ServerName.valueOf(""foo"" + 2 + "":1234"", -1));
    servers.add(ServerName.valueOf(""foo"" + 15 + "":1234"", -1));
    FavoredNodeAssignmentHelper helper = new FavoredNodeAssignmentHelper(servers, rackManager);
    helper.initialize();
    assertTrue(helper.canPlaceFavoredNodes());

    List<RegionInfo> regions = new ArrayList<>(20);
    for (int i = 0; i < 20; i++) {
      regions.add(RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName()))
        .setStartKey(Bytes.toBytes(i)).setEndKey(Bytes.toBytes(i + 1)).build());
    }",Eager Test
"@Test
  public void testGenMissingFavoredNodeMultiRack() throws IOException {

    ServerName snRack1SN1 = ServerName.valueOf(""foo1:1234"", ServerName.NON_STARTCODE);
    ServerName snRack1SN2 = ServerName.valueOf(""foo2:1234"", ServerName.NON_STARTCODE);
    ServerName snRack2SN1 = ServerName.valueOf(""foo10:1234"", ServerName.NON_STARTCODE);
    ServerName snRack2SN2 = ServerName.valueOf(""foo11:1234"", ServerName.NON_STARTCODE);

    Map<String, Integer> rackToServerCount = new HashMap<>();
    Set<String> rackList = Sets.newHashSet(""rack1"", ""rack2"");
    for (String rack : rackList) {
      rackToServerCount.put(rack, 4);
    }",Eager Test
"@Test
  public void testGreaterThanValue() {
    // given
    byte[] val1 = Bytes.toBytes(new BigDecimal(""1000000000000000000000000000000.9999999999999999""));
    byte[] val2 = Bytes.toBytes(new BigDecimal(0));
    byte[] val3 = Bytes.toBytes(new BigDecimal(Double.MIN_VALUE));
    BigDecimal bd = new BigDecimal(Double.MAX_VALUE);
    BigDecimalComparator comparator = new BigDecimalComparator(bd);

    // when
    int comp1 = comparator.compareTo(val1);
    int comp2 = comparator.compareTo(val2);
    int comp3 = comparator.compareTo(val3);

    // then
    Assert.assertEquals(1, comp1);
    Assert.assertEquals(1, comp2);
    Assert.assertEquals(1, comp3);
  }",Eager Test
"@Test
  public void testObjectEquals() {
    BigDecimal bd = new BigDecimal(Double.MIN_VALUE);
    // Check that equals returns true for identical objects
    final BigDecimalComparator bdc = new BigDecimalComparator(bd);
    Assert.assertTrue(bdc.equals(bdc));
    Assert.assertEquals(bdc.hashCode(), bdc.hashCode());

    // Check that equals returns true for the same object
    final BigDecimalComparator bdc1 = new BigDecimalComparator(bd);
    final BigDecimalComparator bdc2 = new BigDecimalComparator(bd);
    Assert.assertTrue(bdc1.equals(bdc2));
    Assert.assertEquals(bdc1.hashCode(), bdc2.hashCode());

    // Check that equals returns false for different objects
    final BigDecimalComparator bdc3 = new BigDecimalComparator(bd);
    final BigDecimalComparator bdc4 = new BigDecimalComparator(new BigDecimal(Long.MIN_VALUE));
    Assert.assertFalse(bdc3.equals(bdc4));
    Assert.assertNotEquals(bdc3.hashCode(), bdc4.hashCode());

    // Check that equals returns false for a different type
    final BigDecimalComparator bdc5 = new BigDecimalComparator(bd);
    Assert.assertFalse(bdc5.equals(0));
  }",No Smells
"@Test
  public void testOROperation() {
    testOperation(ones, zeros, BitComparator.BitwiseOp.OR, Equal);
    testOperation(zeros, zeros, BitComparator.BitwiseOp.OR, NotEqual);
    testOperation(data1, zeros, BitComparator.BitwiseOp.OR, Equal);
    testOperation(data2, data1, BitComparator.BitwiseOp.OR, Equal);
    testOperation(ones, data3, BitComparator.BitwiseOp.OR, NotEqual);

    testOperation(ones_bb, zeros, BitComparator.BitwiseOp.OR, Equal);
    testOperation(zeros_bb, zeros, BitComparator.BitwiseOp.OR, NotEqual);
    testOperation(data1_bb, zeros, BitComparator.BitwiseOp.OR, Equal);
    testOperation(data2_bb, data1, BitComparator.BitwiseOp.OR, Equal);
    testOperation(ones_bb, data3, BitComparator.BitwiseOp.OR, NotEqual);
  }",No Smells
"@Test
  public void testOROperationWithOffset() {
    testOperationWithOffset(data1_2, zeros, BitComparator.BitwiseOp.OR, Equal);
    testOperationWithOffset(data2_2, data1, BitComparator.BitwiseOp.OR, Equal);

    testOperationWithOffset(data1_2_bb, zeros, BitComparator.BitwiseOp.OR, Equal);
    testOperationWithOffset(data2_2_bb, data1, BitComparator.BitwiseOp.OR, Equal);
  }",No Smells
"@Test
  public void testXOROperation() {
    testOperation(ones, zeros, BitComparator.BitwiseOp.XOR, Equal);
    testOperation(zeros, zeros, BitComparator.BitwiseOp.XOR, NotEqual);
    testOperation(ones, ones, BitComparator.BitwiseOp.XOR, NotEqual);
    testOperation(data2, data1, BitComparator.BitwiseOp.XOR, Equal);
    testOperation(ones, data3, BitComparator.BitwiseOp.XOR, NotEqual);

    testOperation(ones_bb, zeros, BitComparator.BitwiseOp.XOR, Equal);
    testOperation(zeros_bb, zeros, BitComparator.BitwiseOp.XOR, NotEqual);
    testOperation(ones_bb, ones, BitComparator.BitwiseOp.XOR, NotEqual);
    testOperation(data2_bb, data1, BitComparator.BitwiseOp.XOR, Equal);
    testOperation(ones_bb, data3, BitComparator.BitwiseOp.XOR, NotEqual);
  }",No Smells
"@Test
  public void testSerialization() throws Exception {
    Filter newFilter = serializationTest(columnPaginationFilter);
    basicFilterTests((ColumnPaginationFilter) newFilter);

    Filter newFilterOffset = serializationTest(columnPaginationFilterOffset);
    basicFilterTests((ColumnPaginationFilter) newFilterOffset);
  }",No Smells
"@Test
  public void testFilterDropping() throws Exception {
    Filter filter = new DependentColumnFilter(FAMILIES[0], QUALIFIER);
    List<Cell> accepted = new ArrayList<>();
    for (Cell val : testVals) {
      if (filter.filterCell(val) == ReturnCode.INCLUDE) {
        accepted.add(val);
      }",Eager Test
"@Test
  public void test94FilterRowCompatibility() throws Exception {
    Scan s = new Scan();
    OldTestFilter filter = new OldTestFilter();
    s.setFilter(filter);

    InternalScanner scanner = this.region.getScanner(s);
    ArrayList<Cell> values = new ArrayList<>();
    scanner.next(values);
    assertTrue(""All rows should be filtered out"", values.isEmpty());
  }",Eager Test
"@Test
  public void testFirstKeyOnlyFilter() throws IOException {
    Scan s = new Scan();
    s.setFilter(new FirstKeyOnlyFilter());
    // Expected KVs, the first KV from each of the remaining 6 rows
    KeyValue[] kvs = { new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]) }",Eager Test
"@Test
  public void testKeyOnlyFilter() throws Exception {

    // KVs in first 6 rows
    KeyValue[] expectedKVs = {
      // testRowOne-0
      new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[3], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[1], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[1], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[1], QUALIFIERS_ONE[3], VALUES[0]),
      // testRowOne-2
      new KeyValue(ROWS_ONE[2], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[0], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[0], QUALIFIERS_ONE[3], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[1], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[1], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[1], QUALIFIERS_ONE[3], VALUES[0]),
      // testRowOne-3
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[3], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[1], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[1], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[1], QUALIFIERS_ONE[3], VALUES[0]),
      // testRowTwo-0
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]),
      // testRowTwo-2
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]),
      // testRowTwo-3
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]) }",Eager Test
"@Test
  public void testLatestVersionFilterWithExplicitColumn() throws Exception {
    // Add multiple versions
    Put p = new Put(ROWS_ONE[0]);
    p.setDurability(Durability.SKIP_WAL);
    p.addColumn(FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]);
    this.region.put(p);
    p = new Put(ROWS_ONE[0]);
    p.setDurability(Durability.SKIP_WAL);
    p.addColumn(FAMILIES[0], QUALIFIERS_ONE[0], VALUES[1]);
    this.region.put(p);
    this.region.flush(true);
    Scan s = new Scan();
    s.setFilter(new FilterBase() {
      @Override
      public ReturnCode filterCell(Cell c) throws IOException {
        return ReturnCode.INCLUDE_AND_NEXT_COL;
      }",Eager Test
"@Test
  public void testPageFilter() throws Exception {

    // KVs in first 6 rows
    KeyValue[] expectedKVs = {
      // testRowOne-0
      new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[3], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[1], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[1], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[1], QUALIFIERS_ONE[3], VALUES[0]),
      // testRowOne-2
      new KeyValue(ROWS_ONE[2], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[0], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[0], QUALIFIERS_ONE[3], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[1], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[1], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[1], QUALIFIERS_ONE[3], VALUES[0]),
      // testRowOne-3
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[3], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[1], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[1], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[1], QUALIFIERS_ONE[3], VALUES[0]),
      // testRowTwo-0
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]),
      // testRowTwo-2
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]),
      // testRowTwo-3
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]) }",Eager Test
"@Test
  public void testQualifierFilter() throws IOException {

    // Match two keys (one from each family) in half the rows
    long expectedRows = this.numRows / 2;
    long expectedKeys = 2;
    Filter f = new QualifierFilter(CompareOperator.EQUAL,
      new BinaryComparator(Bytes.toBytes(""testQualifierOne-2"")));
    Scan s = new Scan();
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match keys less than same qualifier
    // Expect only two keys (one from each family) in half the rows
    expectedRows = this.numRows / 2;
    expectedKeys = 2;
    f = new QualifierFilter(CompareOperator.LESS,
      new BinaryComparator(Bytes.toBytes(""testQualifierOne-2"")));
    s = new Scan();
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match keys less than or equal
    // Expect four keys (two from each family) in half the rows
    expectedRows = this.numRows / 2;
    expectedKeys = 4;
    f = new QualifierFilter(CompareOperator.LESS_OR_EQUAL,
      new BinaryComparator(Bytes.toBytes(""testQualifierOne-2"")));
    s = new Scan();
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match keys not equal
    // Expect four keys (two from each family)
    // Only look in first group of rows
    expectedRows = this.numRows / 2;
    expectedKeys = 4;
    f = new QualifierFilter(CompareOperator.NOT_EQUAL,
      new BinaryComparator(Bytes.toBytes(""testQualifierOne-2"")));
    s =
      new Scan().withStartRow(HConstants.EMPTY_START_ROW).withStopRow(Bytes.toBytes(""testRowTwo""));
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match keys greater or equal
    // Expect four keys (two from each family)
    // Only look in first group of rows
    expectedRows = this.numRows / 2;
    expectedKeys = 4;
    f = new QualifierFilter(CompareOperator.GREATER_OR_EQUAL,
      new BinaryComparator(Bytes.toBytes(""testQualifierOne-2"")));
    s =
      new Scan().withStartRow(HConstants.EMPTY_START_ROW).withStopRow(Bytes.toBytes(""testRowTwo""));
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match keys greater
    // Expect two keys (one from each family)
    // Only look in first group of rows
    expectedRows = this.numRows / 2;
    expectedKeys = 2;
    f = new QualifierFilter(CompareOperator.GREATER,
      new BinaryComparator(Bytes.toBytes(""testQualifierOne-2"")));
    s =
      new Scan().withStartRow(HConstants.EMPTY_START_ROW).withStopRow(Bytes.toBytes(""testRowTwo""));
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match keys not equal to
    // Look across rows and fully validate the keys and ordering
    // Expect varied numbers of keys, 4 per row in group one, 6 per row in group two
    f = new QualifierFilter(CompareOperator.NOT_EQUAL, new BinaryComparator(QUALIFIERS_ONE[2]));
    s = new Scan();
    s.setFilter(f);

    KeyValue[] kvs = {
      // testRowOne-0
      new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[3], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[1], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[1], QUALIFIERS_ONE[3], VALUES[0]),
      // testRowOne-2
      new KeyValue(ROWS_ONE[2], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[0], QUALIFIERS_ONE[3], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[1], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[2], FAMILIES[1], QUALIFIERS_ONE[3], VALUES[0]),
      // testRowOne-3
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[3], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[1], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[1], QUALIFIERS_ONE[3], VALUES[0]),
      // testRowTwo-0
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]),
      // testRowTwo-2
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]),
      // testRowTwo-3
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]), }",Eager Test
"@Test
  public void testRowFilter() throws IOException {

    // Match a single row, all keys
    long expectedRows = 1;
    long expectedKeys = this.colsPerRow;
    Filter f =
      new RowFilter(CompareOperator.EQUAL, new BinaryComparator(Bytes.toBytes(""testRowOne-2"")));
    Scan s = new Scan();
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match a two rows, one from each group, using regex
    expectedRows = 2;
    expectedKeys = this.colsPerRow;
    f = new RowFilter(CompareOperator.EQUAL, new RegexStringComparator(""testRow.+-2""));
    s = new Scan();
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match rows less than
    // Expect all keys in one row
    expectedRows = 1;
    expectedKeys = this.colsPerRow;
    f = new RowFilter(CompareOperator.LESS, new BinaryComparator(Bytes.toBytes(""testRowOne-2"")));
    s = new Scan();
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match rows less than or equal
    // Expect all keys in two rows
    expectedRows = 2;
    expectedKeys = this.colsPerRow;
    f = new RowFilter(CompareOperator.LESS_OR_EQUAL,
      new BinaryComparator(Bytes.toBytes(""testRowOne-2"")));
    s = new Scan();
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match rows not equal
    // Expect all keys in all but one row
    expectedRows = this.numRows - 1;
    expectedKeys = this.colsPerRow;
    f =
      new RowFilter(CompareOperator.NOT_EQUAL, new BinaryComparator(Bytes.toBytes(""testRowOne-2"")));
    s = new Scan();
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match keys greater or equal
    // Expect all keys in all but one row
    expectedRows = this.numRows - 1;
    expectedKeys = this.colsPerRow;
    f = new RowFilter(CompareOperator.GREATER_OR_EQUAL,
      new BinaryComparator(Bytes.toBytes(""testRowOne-2"")));
    s = new Scan();
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match keys greater
    // Expect all keys in all but two rows
    expectedRows = this.numRows - 2;
    expectedKeys = this.colsPerRow;
    f = new RowFilter(CompareOperator.GREATER, new BinaryComparator(Bytes.toBytes(""testRowOne-2"")));
    s = new Scan();
    s.setFilter(f);
    verifyScanNoEarlyOut(s, expectedRows, expectedKeys);

    // Match rows not equal to testRowTwo-2
    // Look across rows and fully validate the keys and ordering
    // Should see all keys in all rows but testRowTwo-2
    f =
      new RowFilter(CompareOperator.NOT_EQUAL, new BinaryComparator(Bytes.toBytes(""testRowOne-2"")));
    s = new Scan();
    s.setFilter(f);

    KeyValue[] kvs = {
      // testRowOne-0
      new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[0], QUALIFIERS_ONE[3], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[1], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[1], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[0], FAMILIES[1], QUALIFIERS_ONE[3], VALUES[0]),
      // testRowOne-3
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[0], QUALIFIERS_ONE[3], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[1], QUALIFIERS_ONE[0], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[1], QUALIFIERS_ONE[2], VALUES[0]),
      new KeyValue(ROWS_ONE[3], FAMILIES[1], QUALIFIERS_ONE[3], VALUES[0]),
      // testRowTwo-0
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]),
      // testRowTwo-2
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]),
      // testRowTwo-3
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]), }",Eager Test
"@Test
  public void testSkipFilter() throws IOException {

    // Test for qualifier regex: ""testQualifierOne-2""
    // Should only get rows from second group, and all keys
    Filter f = new SkipFilter(new QualifierFilter(CompareOperator.NOT_EQUAL,
      new BinaryComparator(Bytes.toBytes(""testQualifierOne-2""))));
    Scan s = new Scan();
    s.setFilter(f);

    KeyValue[] kvs = {
      // testRowTwo-0
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[0], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]),
      // testRowTwo-2
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[2], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]),
      // testRowTwo-3
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[0], QUALIFIERS_TWO[3], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[0], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[2], VALUES[1]),
      new KeyValue(ROWS_TWO[3], FAMILIES[1], QUALIFIERS_TWO[3], VALUES[1]), }",Eager Test
"@Test
  public void testConstruction() {
    FirstKeyOnlyFilter f1 = new FirstKeyOnlyFilter();
    FirstKeyOnlyFilter f2 = new FirstKeyOnlyFilter();
    f1.setReversed(true);
    f2.setReversed(false);

    try {
      FilterList ff = new FilterList(f1, f2);
      fail(""The IllegalArgumentException should be thrown"");
    }",Eager Test
"@Test
  public void testKeyOnlyFilterTransformCell() throws IOException {
    Cell c;
    KeyValue kv1 = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""cf""), Bytes.toBytes(""column1""),
      1, Bytes.toBytes(""value1""));
    KeyValue kv2 = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""cf""), Bytes.toBytes(""column1""),
      2, Bytes.toBytes(""value2""));

    Filter filter1 = new SingleColumnValueFilter(Bytes.toBytes(""cf""), Bytes.toBytes(""column1""),
      CompareOperator.EQUAL, Bytes.toBytes(""value1""));
    Filter filter2 = new SingleColumnValueFilter(Bytes.toBytes(""cf""), Bytes.toBytes(""column1""),
      CompareOperator.EQUAL, Bytes.toBytes(""value2""));
    FilterList internalFilterList = new FilterList(Operator.MUST_PASS_ONE, filter1, filter2);

    FilterList keyOnlyFilterFirst =
      new FilterList(Operator.MUST_PASS_ALL, new KeyOnlyFilter(), internalFilterList);

    assertEquals(ReturnCode.INCLUDE, keyOnlyFilterFirst.filterCell(kv1));
    c = keyOnlyFilterFirst.transformCell(kv1);
    assertEquals(0, c.getValueLength());
    assertEquals(ReturnCode.INCLUDE, keyOnlyFilterFirst.filterCell(kv2));
    c = keyOnlyFilterFirst.transformCell(kv2);
    assertEquals(0, c.getValueLength());

    internalFilterList.reset();
    FilterList keyOnlyFilterLast =
      new FilterList(Operator.MUST_PASS_ALL, new KeyOnlyFilter(), internalFilterList);
    assertEquals(ReturnCode.INCLUDE, keyOnlyFilterLast.filterCell(kv1));
    c = keyOnlyFilterLast.transformCell(kv1);
    assertEquals(0, c.getValueLength());
    assertEquals(ReturnCode.INCLUDE, keyOnlyFilterLast.filterCell(kv2));
    c = keyOnlyFilterLast.transformCell(kv2);
    assertEquals(0, c.getValueLength());
  }",Eager Test
"@Test
  public void testMPALL() throws Exception {
    mpAllTest(getMPALLFilter());
  }",No Smells
"@Test
  public void testMPONE() throws Exception {
    mpOneTest(getFilterMPONE());
  }",No Smells
"@Test
  public void testMPONEWithSeekNextUsingHint() throws Exception {
    byte[] col = Bytes.toBytes(""c"");
    FilterList filterList =
      new FilterList(Operator.MUST_PASS_ONE, new ColumnPaginationFilter(1, col));

    KeyValue kv1 = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""fam""), Bytes.toBytes(""a""), 1,
      Bytes.toBytes(""value""));
    KeyValue kv2 = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""fam""), Bytes.toBytes(""b""), 2,
      Bytes.toBytes(""value""));
    KeyValue kv3 = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""fam""), Bytes.toBytes(""c""), 3,
      Bytes.toBytes(""value""));
    KeyValue kv4 = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""fam""), Bytes.toBytes(""c""), 4,
      Bytes.toBytes(""value""));

    assertEquals(ReturnCode.SEEK_NEXT_USING_HINT, filterList.filterCell(kv1));
    assertEquals(ReturnCode.SEEK_NEXT_USING_HINT, filterList.filterCell(kv2));
    assertEquals(ReturnCode.INCLUDE_AND_NEXT_COL, filterList.filterCell(kv3));
    assertEquals(ReturnCode.NEXT_COL, filterList.filterCell(kv4));
  }",Eager Test
"@Test
  public void testOrdering() throws Exception {
    orderingTest(getOrderingFilter());
  }",No Smells
"@Test
  public void testReversedFilterListWithOR() throws IOException {
    byte[] r22 = Bytes.toBytes(""Row22"");
    byte[] r2 = Bytes.toBytes(""Row2"");
    byte[] r1 = Bytes.toBytes(""Row1"");

    FilterList filterList = new FilterList(FilterList.Operator.MUST_PASS_ONE);
    filterList.setReversed(true);
    PrefixFilter prefixFilter = new PrefixFilter(r2);
    prefixFilter.setReversed(true);
    filterList.addFilter(prefixFilter);
    filterList.filterRowKey(KeyValueUtil.createFirstOnRow(r22));
    assertEquals(ReturnCode.INCLUDE, filterList.filterCell(new KeyValue(r22, r22, r22)));
    assertEquals(ReturnCode.INCLUDE, filterList.filterCell(new KeyValue(r2, r2, r2)));

    filterList.reset();
    filterList.filterRowKey(KeyValueUtil.createFirstOnRow(r1));
    assertEquals(ReturnCode.SKIP, filterList.filterCell(new KeyValue(r1, r1, r1)));

    filterList = new FilterList(FilterList.Operator.MUST_PASS_ONE);
    filterList.setReversed(true);
    AlwaysNextColFilter alwaysNextColFilter = new AlwaysNextColFilter();
    alwaysNextColFilter.setReversed(true);
    prefixFilter = new PrefixFilter(r2);
    prefixFilter.setReversed(true);
    filterList.addFilter(alwaysNextColFilter);
    filterList.addFilter(prefixFilter);
    filterList.filterRowKey(KeyValueUtil.createFirstOnRow(r22));
    assertEquals(ReturnCode.INCLUDE, filterList.filterCell(new KeyValue(r22, r22, r22)));
    assertEquals(ReturnCode.INCLUDE, filterList.filterCell(new KeyValue(r2, r2, r2)));

    filterList.reset();
    filterList.filterRowKey(KeyValueUtil.createFirstOnRow(r1));
    assertEquals(ReturnCode.NEXT_COL, filterList.filterCell(new KeyValue(r1, r1, r1)));
  }",Eager Test
"@Test
  public void testRowCountFilter() throws IOException {
    KeyValue kv1 = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""fam1""), Bytes.toBytes(""a""), 1,
      Bytes.toBytes(""value""));
    KeyValue kv2 = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""fam2""), Bytes.toBytes(""a""), 2,
      Bytes.toBytes(""value""));
    MockNextRowFilter mockNextRowFilter = new MockNextRowFilter();
    FilterList filter = new FilterList(Operator.MUST_PASS_ONE, mockNextRowFilter);
    filter.filterCell(kv1);
    filter.filterCell(kv2);
    assertEquals(2, mockNextRowFilter.getHitCount());
  }",Eager Test
"@Test
  public void testShouldPassCurrentCellToFilter() throws IOException {
    KeyValue kv1 = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""fam""), Bytes.toBytes(""a""), 1,
      Bytes.toBytes(""value""));
    KeyValue kv2 = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""fam""), Bytes.toBytes(""a""), 2,
      Bytes.toBytes(""value""));
    KeyValue kv3 = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""fam""), Bytes.toBytes(""b""), 3,
      Bytes.toBytes(""value""));
    KeyValue kv4 = new KeyValue(Bytes.toBytes(""row1""), Bytes.toBytes(""fam""), Bytes.toBytes(""c""), 4,
      Bytes.toBytes(""value""));

    MockFilter mockFilter = new MockFilter(ReturnCode.NEXT_COL);
    FilterList filter = new FilterList(Operator.MUST_PASS_ONE, mockFilter);

    filter.filterCell(kv1);
    assertTrue(mockFilter.didCellPassToTheFilter);

    mockFilter.didCellPassToTheFilter = false;
    filter.filterCell(kv2);
    assertFalse(mockFilter.didCellPassToTheFilter);

    mockFilter.didCellPassToTheFilter = false;
    filter.filterCell(kv3);
    assertTrue(mockFilter.didCellPassToTheFilter);

    mockFilter = new MockFilter(ReturnCode.INCLUDE_AND_NEXT_COL);
    filter = new FilterList(Operator.MUST_PASS_ONE, mockFilter);

    filter.filterCell(kv1);
    assertTrue(mockFilter.didCellPassToTheFilter);

    mockFilter.didCellPassToTheFilter = false;
    filter.filterCell(kv2);
    assertFalse(mockFilter.didCellPassToTheFilter);

    mockFilter.didCellPassToTheFilter = false;
    filter.filterCell(kv3);
    assertTrue(mockFilter.didCellPassToTheFilter);

    mockFilter = new MockFilter(ReturnCode.NEXT_ROW);
    filter = new FilterList(Operator.MUST_PASS_ONE, mockFilter);
    filter.filterCell(kv1);
    assertTrue(mockFilter.didCellPassToTheFilter);

    mockFilter.didCellPassToTheFilter = false;
    filter.filterCell(kv2);
    assertFalse(mockFilter.didCellPassToTheFilter);

    mockFilter.didCellPassToTheFilter = false;
    filter.filterCell(kv3);
    assertFalse(mockFilter.didCellPassToTheFilter);

    filter.reset();
    mockFilter.didCellPassToTheFilter = false;
    filter.filterCell(kv4);
    assertTrue(mockFilter.didCellPassToTheFilter);

    mockFilter = new MockFilter(ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW);
    filter = new FilterList(Operator.MUST_PASS_ONE, mockFilter);
    filter.filterCell(kv1);
    assertTrue(mockFilter.didCellPassToTheFilter);

    mockFilter.didCellPassToTheFilter = false;
    filter.filterCell(kv2);
    assertFalse(mockFilter.didCellPassToTheFilter);

    mockFilter.didCellPassToTheFilter = false;
    filter.filterCell(kv3);
    assertFalse(mockFilter.didCellPassToTheFilter);

    filter.reset();
    mockFilter.didCellPassToTheFilter = false;
    filter.filterCell(kv4);
    assertTrue(mockFilter.didCellPassToTheFilter);
  }",Eager Test
"@Test
  public void testFilterWrapper() {
    int kv_number = 0;
    int row_number = 0;
    try {
      Scan scan = new Scan();
      List<Filter> fs = new ArrayList<>();

      DependentColumnFilter f1 = new DependentColumnFilter(Bytes.toBytes(""f1""), Bytes.toBytes(""c5""),
        true, CompareOperator.EQUAL, new SubstringComparator(""c5""));
      PageFilter f2 = new PageFilter(2);
      fs.add(f1);
      fs.add(f2);
      FilterList filter = new FilterList(fs);

      scan.setFilter(filter);
      Table table = connection.getTable(name);
      ResultScanner scanner = table.getScanner(scan);

      // row2 (c1-c4) and row3(c1-c4) are returned
      for (Result result : scanner) {
        row_number++;
        for (Cell kv : result.listCells()) {
          LOG.debug(kv_number + "". kv: "" + kv);
          kv_number++;
          assertEquals(""Returned row is not correct"", Bytes.toString(CellUtil.cloneRow(kv)),
            ""row"" + (row_number + 1));
        }",Eager Test
"@Test
  public void testSatisfiesForward() {

    Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.YES, FuzzyRowFilter.satisfies(false,
      new byte[] { 1, (byte) -128, 1, 0, 1 }",No Smells
"@Test
  public void testSatisfiesNoUnsafeForward() {

    Assert.assertEquals(FuzzyRowFilter.SatisfiesCode.YES,
      FuzzyRowFilter.satisfiesNoUnsafe(false, new byte[] { 1, (byte) -128, 1, 0, 1 }",No Smells
"@Test
  public void testSerialization() throws Exception {
    // Decompose mainFilter to bytes.
    byte[] buffer = mainFilter.toByteArray();

    // Recompose mainFilter.
    Filter newFilter = InclusiveStopFilter.parseFrom(buffer);

    // Ensure the serialization preserved the filter by running a full test.
    stopRowTests(newFilter);
  }",No Smells
"@Test
  public void testStopRowIdentification() throws Exception {
    stopRowTests(mainFilter);
  }",No Smells
"@Test
  public void testSimple() {
    for (int i = 1; i < values.length; i++) {
      for (int j = 0; j < i; j++) {
        LongComparator cp = new LongComparator(values[i]);
        assertEquals(1, cp.compareTo(Bytes.toBytes(values[j])));
        ByteBuffer data_bb = ByteBuffer.wrap(Bytes.toBytes(values[j]));
        assertEquals(1, cp.compareTo(data_bb, 0, data_bb.capacity()));
      }",Eager Test
"@Test
  public void testMultipleColumnPrefixFilterWithManyFamilies() throws IOException {
    String family1 = ""Family1"";
    String family2 = ""Family2"";
    TableDescriptorBuilder tableDescriptorBuilder =
      TableDescriptorBuilder.newBuilder(TableName.valueOf(name.getMethodName()));
    ColumnFamilyDescriptor columnFamilyDescriptor =
      ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(family1)).setMaxVersions(3).build();
    tableDescriptorBuilder.setColumnFamily(columnFamilyDescriptor);
    columnFamilyDescriptor =
      ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(family2)).setMaxVersions(3).build();
    tableDescriptorBuilder.setColumnFamily(columnFamilyDescriptor);
    TableDescriptor tableDescriptor = tableDescriptorBuilder.build();
    RegionInfo info = RegionInfoBuilder.newBuilder(tableDescriptor.getTableName()).build();
    HRegion region = HBaseTestingUtil.createRegionAndWAL(info, TEST_UTIL.getDataTestDir(),
      TEST_UTIL.getConfiguration(), tableDescriptor);

    List<String> rows = generateRandomWords(100, ""row"");
    List<String> columns = generateRandomWords(10000, ""column"");
    long maxTimestamp = 3;

    List<Cell> kvList = new ArrayList<>();

    Map<String, List<Cell>> prefixMap = new HashMap<>();

    prefixMap.put(""p"", new ArrayList<>());
    prefixMap.put(""q"", new ArrayList<>());
    prefixMap.put(""s"", new ArrayList<>());

    String valueString = ""ValueString"";

    for (String row : rows) {
      Put p = new Put(Bytes.toBytes(row));
      p.setDurability(Durability.SKIP_WAL);
      for (String column : columns) {
        for (long timestamp = 1; timestamp <= maxTimestamp; timestamp++) {
          double rand = Math.random();
          Cell kv;
          if (rand < 0.5) {
            kv = KeyValueTestUtil.create(row, family1, column, timestamp, valueString);
          }",Eager Test
"@Test
  public void testMergeAndSortWithEmptyStartRow() throws IOException {
    List<RowRange> ranges = new ArrayList<>();
    ranges.add(new RowRange(Bytes.toBytes(""""), true, Bytes.toBytes(20), false));
    ranges.add(new RowRange(Bytes.toBytes(15), true, Bytes.toBytes(40), false));
    List<RowRange> actualRanges = MultiRowRangeFilter.sortAndMerge(ranges);
    List<RowRange> expectedRanges = new ArrayList<>();
    expectedRanges.add(new RowRange(Bytes.toBytes(""""), true, Bytes.toBytes(40), false));
    assertRangesEqual(expectedRanges, actualRanges);
  }",No Smells
"@Test
  public void testMergeAndSortWithEmptyStartRowAndStopRow() throws IOException {
    List<RowRange> ranges = new ArrayList<>();
    ranges.add(new RowRange(Bytes.toBytes(10), true, Bytes.toBytes(20), false));
    ranges.add(new RowRange(Bytes.toBytes(""""), true, Bytes.toBytes(""""), false));
    ranges.add(new RowRange(Bytes.toBytes(30), true, Bytes.toBytes(70), false));
    List<RowRange> actualRanges = MultiRowRangeFilter.sortAndMerge(ranges);
    List<RowRange> expectedRanges = new ArrayList<>();
    expectedRanges.add(new RowRange(Bytes.toBytes(""""), true, Bytes.toBytes(""""), false));
    assertRangesEqual(expectedRanges, actualRanges);
  }",No Smells
"@Test
  public void testMergeAndSortWithEmptyStopRow() throws IOException {
    List<RowRange> ranges = new ArrayList<>();
    ranges.add(new RowRange(Bytes.toBytes(10), true, Bytes.toBytes(20), false));
    ranges.add(new RowRange(Bytes.toBytes(15), true, Bytes.toBytes(""""), false));
    ranges.add(new RowRange(Bytes.toBytes(30), true, Bytes.toBytes(70), false));
    List<RowRange> actualRanges = MultiRowRangeFilter.sortAndMerge(ranges);
    List<RowRange> expectedRanges = new ArrayList<>();
    expectedRanges.add(new RowRange(Bytes.toBytes(10), true, Bytes.toBytes(""""), false));
    assertRangesEqual(expectedRanges, actualRanges);
  }",No Smells
"@Test
  public void testMergeAndSortWithOverlap() throws IOException {
    List<RowRange> ranges = new ArrayList<>();
    ranges.add(new RowRange(Bytes.toBytes(10), true, Bytes.toBytes(20), false));
    ranges.add(new RowRange(Bytes.toBytes(15), true, Bytes.toBytes(40), false));
    ranges.add(new RowRange(Bytes.toBytes(20), true, Bytes.toBytes(30), false));
    ranges.add(new RowRange(Bytes.toBytes(30), true, Bytes.toBytes(50), false));
    ranges.add(new RowRange(Bytes.toBytes(30), true, Bytes.toBytes(70), false));
    ranges.add(new RowRange(Bytes.toBytes(90), true, Bytes.toBytes(100), false));
    ranges.add(new RowRange(Bytes.toBytes(95), true, Bytes.toBytes(100), false));
    List<RowRange> actualRanges = MultiRowRangeFilter.sortAndMerge(ranges);
    List<RowRange> expectedRanges = new ArrayList<>();
    expectedRanges.add(new RowRange(Bytes.toBytes(10), true, Bytes.toBytes(70), false));
    expectedRanges.add(new RowRange(Bytes.toBytes(90), true, Bytes.toBytes(100), false));
    assertRangesEqual(expectedRanges, actualRanges);
  }",No Smells
"@Test
  public void testMultiRowRangeFilterWithEmptyStartRow() throws IOException {
    tableName = TableName.valueOf(name.getMethodName());
    Table ht = TEST_UTIL.createTable(tableName, family, Integer.MAX_VALUE);
    generateRows(numRows, ht, family, qf, value);
    Scan scan = new Scan();
    scan.readAllVersions();

    List<RowRange> ranges = new ArrayList<>();
    ranges.add(new RowRange(Bytes.toBytes(""""), true, Bytes.toBytes(10), false));
    ranges.add(new RowRange(Bytes.toBytes(30), true, Bytes.toBytes(40), false));

    MultiRowRangeFilter filter = new MultiRowRangeFilter(ranges);
    scan.setFilter(filter);
    int resultsSize = getResultsSize(ht, scan);
    List<Cell> results1 = getScanResult(Bytes.toBytes(""""), Bytes.toBytes(10), ht);
    List<Cell> results2 = getScanResult(Bytes.toBytes(30), Bytes.toBytes(40), ht);
    assertEquals(results1.size() + results2.size(), resultsSize);

    ht.close();
  }",No Smells
"@Test
  public void testMultiRowRangeFilterWithInclusive() throws IOException {
    tableName = TableName.valueOf(name.getMethodName());
    Table ht = TEST_UTIL.createTable(tableName, family, Integer.MAX_VALUE);
    generateRows(numRows, ht, family, qf, value);

    Scan scan = new Scan();
    scan.readAllVersions();

    List<RowRange> ranges = new ArrayList<>();
    ranges.add(new RowRange(Bytes.toBytes(10), true, Bytes.toBytes(20), false));
    ranges.add(new RowRange(Bytes.toBytes(20), true, Bytes.toBytes(40), false));
    ranges.add(new RowRange(Bytes.toBytes(65), true, Bytes.toBytes(75), false));
    ranges.add(new RowRange(Bytes.toBytes(60), true, null, false));
    ranges.add(new RowRange(Bytes.toBytes(60), true, Bytes.toBytes(80), false));

    MultiRowRangeFilter filter = new MultiRowRangeFilter(ranges);
    scan.setFilter(filter);
    int resultsSize = getResultsSize(ht, scan);
    LOG.info(""found "" + resultsSize + "" results"");
    List<Cell> results1 = getScanResult(Bytes.toBytes(10), Bytes.toBytes(40), ht);
    List<Cell> results2 = getScanResult(Bytes.toBytes(60), Bytes.toBytes(""""), ht);

    assertEquals(results1.size() + results2.size(), resultsSize);

    ht.close();
  }",No Smells
"@Test
  public void testMultiRowRangeWithFilterListAndOperator() throws IOException {
    tableName = TableName.valueOf(name.getMethodName());
    Table ht = TEST_UTIL.createTable(tableName, family, Integer.MAX_VALUE);
    generateRows(numRows, ht, family, qf, value);

    Scan scan = new Scan();
    scan.readAllVersions();

    List<RowRange> ranges1 = new ArrayList<>();
    ranges1.add(new RowRange(Bytes.toBytes(10), true, Bytes.toBytes(20), false));
    ranges1.add(new RowRange(Bytes.toBytes(30), true, Bytes.toBytes(40), false));
    ranges1.add(new RowRange(Bytes.toBytes(60), true, Bytes.toBytes(70), false));

    MultiRowRangeFilter filter1 = new MultiRowRangeFilter(ranges1);

    List<RowRange> ranges2 = new ArrayList<>();
    ranges2.add(new RowRange(Bytes.toBytes(20), true, Bytes.toBytes(40), false));
    ranges2.add(new RowRange(Bytes.toBytes(80), true, Bytes.toBytes(90), false));

    MultiRowRangeFilter filter2 = new MultiRowRangeFilter(ranges2);

    FilterList filterList = new FilterList(FilterList.Operator.MUST_PASS_ALL);
    filterList.addFilter(filter1);
    filterList.addFilter(filter2);
    scan.setFilter(filterList);
    int resultsSize = getResultsSize(ht, scan);
    LOG.info(""found "" + resultsSize + "" results"");
    List<Cell> results1 = getScanResult(Bytes.toBytes(30), Bytes.toBytes(40), ht);

    assertEquals(results1.size(), resultsSize);

    ht.close();
  }",No Smells
"@Test
  public void testOutOfOrderScannerNextException() throws Exception {
    MultiRowRangeFilter filter = new MultiRowRangeFilter(Arrays.asList(
      new MultiRowRangeFilter.RowRange(Bytes.toBytes(""b""), true, Bytes.toBytes(""c""), true),
      new MultiRowRangeFilter.RowRange(Bytes.toBytes(""d""), true, Bytes.toBytes(""e""), true)));
    filter.filterRowKey(KeyValueUtil.createFirstOnRow(Bytes.toBytes(""a"")));
    assertEquals(Filter.ReturnCode.SEEK_NEXT_USING_HINT, filter.filterCell(null));
    filter.filterRowKey(KeyValueUtil.createFirstOnRow(Bytes.toBytes(""b"")));
    assertEquals(Filter.ReturnCode.INCLUDE, filter.filterCell(null));
    filter.filterRowKey(KeyValueUtil.createFirstOnRow(Bytes.toBytes(""c"")));
    assertEquals(Filter.ReturnCode.INCLUDE, filter.filterCell(null));
    filter.filterRowKey(KeyValueUtil.createFirstOnRow(Bytes.toBytes(""d"")));
    assertEquals(Filter.ReturnCode.INCLUDE, filter.filterCell(null));
    filter.filterRowKey(KeyValueUtil.createFirstOnRow(Bytes.toBytes(""e"")));
    assertEquals(Filter.ReturnCode.INCLUDE, filter.filterCell(null));
  }",No Smells
"@Test
  public void testEmptyValue() {
    // given
    byte[] value = new byte[] { 0 }",Eager Test
"@Test
  public void testNonNullValue() {
    // given
    byte[] value = new byte[] { 0, 1, 2, 3, 4, 5 }",Eager Test
"@Test
  public void testColumnCountGetFilter() throws IOException {
    String filterString = "" ColumnCountGetFilter(4)"";
    ColumnCountGetFilter columnCountGetFilter =
      doTestFilter(filterString, ColumnCountGetFilter.class);
    int limit = columnCountGetFilter.getLimit();
    assertEquals(4, limit);

    filterString = "" ColumnCountGetFilter('abc')"";
    try {
      doTestFilter(filterString, ColumnCountGetFilter.class);
      assertTrue(false);
    }",Eager Test
"@Test
  public void testCompoundFilter4() throws IOException {
    String filterString = "" ColumnPrefixFilter ('realtime') OR ""
      + ""FirstKeyOnlyFilter() OR SKIP FamilyFilter(=, 'substring:hihi')"";
    FilterList filterList = doTestFilter(filterString, FilterList.class);
    ArrayList<Filter> filters = (ArrayList<Filter>) filterList.getFilters();

    assertTrue(filters.get(0) instanceof ColumnPrefixFilter);
    assertTrue(filters.get(1) instanceof FirstKeyOnlyFilter);
    assertTrue(filters.get(2) instanceof SkipFilter);

    ColumnPrefixFilter columnPrefixFilter = (ColumnPrefixFilter) filters.get(0);
    FirstKeyOnlyFilter firstKeyOnlyFilter = (FirstKeyOnlyFilter) filters.get(1);
    SkipFilter skipFilter = (SkipFilter) filters.get(2);

    byte[] columnPrefix = columnPrefixFilter.getPrefix();
    assertEquals(""realtime"", new String(columnPrefix, StandardCharsets.UTF_8));

    assertTrue(skipFilter.getFilter() instanceof FamilyFilter);
    FamilyFilter familyFilter = (FamilyFilter) skipFilter.getFilter();

    assertEquals(CompareOperator.EQUAL, familyFilter.getCompareOperator());
    assertTrue(familyFilter.getComparator() instanceof SubstringComparator);
    SubstringComparator substringComparator = (SubstringComparator) familyFilter.getComparator();
    assertEquals(""hihi"", new String(substringComparator.getValue(), StandardCharsets.UTF_8));
  }",Eager Test
"@Test
  public void testCompoundFilter5() throws IOException {
    String filterStr = ""(ValueFilter(!=, 'substring:pre'))"";
    ValueFilter valueFilter = doTestFilter(filterStr, ValueFilter.class);
    assertTrue(valueFilter.getComparator() instanceof SubstringComparator);

    filterStr = ""(ValueFilter(>=,'binary:x') AND (ValueFilter(<=,'binary:y')))""
      + "" OR ValueFilter(=,'binary:ab')"";
    filter = f.parseFilterString(filterStr);
    assertTrue(filter instanceof FilterList);
    List<Filter> list = ((FilterList) filter).getFilters();
    assertEquals(2, list.size());
    assertTrue(list.get(0) instanceof FilterList);
    assertTrue(list.get(1) instanceof ValueFilter);
  }",Eager Test
"@Test
  public void testInclusiveStopFilter() throws IOException {
    String filterString = ""InclusiveStopFilter ('row 3')"";
    InclusiveStopFilter inclusiveStopFilter = doTestFilter(filterString, InclusiveStopFilter.class);
    byte[] stopRowKey = inclusiveStopFilter.getStopRowKey();
    assertEquals(""row 3"", new String(stopRowKey, StandardCharsets.UTF_8));
  }",Eager Test
"@Test
  public void testQualifierFilter() throws IOException {
    String filterString = ""QualifierFilter(=, 'regexstring:pre*')"";
    QualifierFilter qualifierFilter = doTestFilter(filterString, QualifierFilter.class);
    assertEquals(CompareOperator.EQUAL, qualifierFilter.getCompareOperator());
    assertTrue(qualifierFilter.getComparator() instanceof RegexStringComparator);
    RegexStringComparator regexStringComparator =
      (RegexStringComparator) qualifierFilter.getComparator();
    assertEquals(""pre*"", new String(regexStringComparator.getValue(), StandardCharsets.UTF_8));
  }",Eager Test
"@Test
  public void testRegisterFilter() {
    ParseFilter.registerFilter(""MyFilter"", ""some.class"");

    assertTrue(f.getSupportedFilters().contains(""MyFilter""));
  }",No Smells
"@Test
  public void testSingleColumnValueExcludeFilter() throws IOException {
    String filterString =
      ""SingleColumnValueExcludeFilter ('family', 'qualifier', <, 'binaryprefix:a')"";
    SingleColumnValueExcludeFilter singleColumnValueExcludeFilter =
      doTestFilter(filterString, SingleColumnValueExcludeFilter.class);
    assertEquals(CompareOperator.LESS, singleColumnValueExcludeFilter.getCompareOperator());
    assertEquals(""family"",
      new String(singleColumnValueExcludeFilter.getFamily(), StandardCharsets.UTF_8));
    assertEquals(""qualifier"",
      new String(singleColumnValueExcludeFilter.getQualifier(), StandardCharsets.UTF_8));
    assertEquals(""a"", new String(singleColumnValueExcludeFilter.getComparator().getValue(),
      StandardCharsets.UTF_8));
    assertFalse(singleColumnValueExcludeFilter.getFilterIfMissing());
    assertTrue(singleColumnValueExcludeFilter.getLatestVersionOnly());

    filterString = ""SingleColumnValueExcludeFilter ""
      + ""('family', 'qualifier', <=, 'binaryprefix:a', true, false)"";
    singleColumnValueExcludeFilter =
      doTestFilter(filterString, SingleColumnValueExcludeFilter.class);
    assertEquals(""family"",
      new String(singleColumnValueExcludeFilter.getFamily(), StandardCharsets.UTF_8));
    assertEquals(""qualifier"",
      new String(singleColumnValueExcludeFilter.getQualifier(), StandardCharsets.UTF_8));
    assertEquals(CompareOperator.LESS_OR_EQUAL,
      singleColumnValueExcludeFilter.getCompareOperator());
    assertTrue(singleColumnValueExcludeFilter.getComparator() instanceof BinaryPrefixComparator);
    BinaryPrefixComparator binaryPrefixComparator =
      (BinaryPrefixComparator) singleColumnValueExcludeFilter.getComparator();
    assertEquals(""a"", new String(binaryPrefixComparator.getValue(), StandardCharsets.UTF_8));
    assertTrue(singleColumnValueExcludeFilter.getFilterIfMissing());
    assertFalse(singleColumnValueExcludeFilter.getLatestVersionOnly());
  }",Eager Test
"@Test
  public void testTimestampsFilter() throws IOException {
    String filterString = ""TimestampsFilter(9223372036854775806, 6)"";
    TimestampsFilter timestampsFilter = doTestFilter(filterString, TimestampsFilter.class);
    List<Long> timestamps = timestampsFilter.getTimestamps();
    assertEquals(2, timestamps.size());
    assertEquals(Long.valueOf(6), timestamps.get(0));

    filterString = ""TimestampsFilter()"";
    timestampsFilter = doTestFilter(filterString, TimestampsFilter.class);
    timestamps = timestampsFilter.getTimestamps();
    assertEquals(0, timestamps.size());

    filterString = ""TimestampsFilter(9223372036854775808, 6)"";
    try {
      doTestFilter(filterString, ColumnPaginationFilter.class);
      assertTrue(false);
    }",Eager Test
"@Test
  public void testUnescapedQuote2() throws IOException {
    String filterString = ""InclusiveStopFilter ('row''3''')"";
    InclusiveStopFilter inclusiveStopFilter = doTestFilter(filterString, InclusiveStopFilter.class);
    byte[] stopRowKey = inclusiveStopFilter.getStopRowKey();
    assertEquals(""row'3'"", new String(stopRowKey, StandardCharsets.UTF_8));
  }",Eager Test
"@Test
  public void testPrefixOnRowInsideWhileMatchRow() throws Exception {
    prefixRowTests(new WhileMatchFilter(this.mainFilter), true);
  }",No Smells
"@Test
  public void testFilterCell() throws Exception {
    Filter filter = new SingleColumnValueExcludeFilter(COLUMN_FAMILY, COLUMN_QUALIFIER,
      CompareOperator.EQUAL, VAL_1);

    // A 'match' situation
    List<Cell> kvs = new ArrayList<>();
    KeyValue c = new KeyValue(ROW, COLUMN_FAMILY, COLUMN_QUALIFIER_2, VAL_1);

    kvs.add(new KeyValue(ROW, COLUMN_FAMILY, COLUMN_QUALIFIER_2, VAL_1));
    kvs.add(new KeyValue(ROW, COLUMN_FAMILY, COLUMN_QUALIFIER, VAL_1));
    kvs.add(new KeyValue(ROW, COLUMN_FAMILY, COLUMN_QUALIFIER_2, VAL_1));

    filter.filterRowCells(kvs);

    assertEquals(""resultSize"", 2, kvs.size());
    assertTrue(""leftKV1"", CellComparatorImpl.COMPARATOR.compare(kvs.get(0), c) == 0);
    assertTrue(""leftKV2"", CellComparatorImpl.COMPARATOR.compare(kvs.get(1), c) == 0);
    assertFalse(""allRemainingWhenMatch"", filter.filterAllRemaining());

    // A 'mismatch' situation
    filter.reset();
    // INCLUDE expected because test column has not yet passed
    c = new KeyValue(ROW, COLUMN_FAMILY, COLUMN_QUALIFIER_2, VAL_1);
    assertTrue(""otherColumn"", filter.filterCell(c) == Filter.ReturnCode.INCLUDE);
    // Test column will pass (wont match), expect NEXT_ROW
    c = new KeyValue(ROW, COLUMN_FAMILY, COLUMN_QUALIFIER, VAL_2);
    assertTrue(""testedMismatch"", filter.filterCell(c) == Filter.ReturnCode.NEXT_ROW);
    // After a mismatch (at least with LatestVersionOnly), subsequent columns are EXCLUDE
    c = new KeyValue(ROW, COLUMN_FAMILY, COLUMN_QUALIFIER_2, VAL_1);
    assertTrue(""otherColumn"", filter.filterCell(c) == Filter.ReturnCode.NEXT_ROW);
  }",Eager Test
"@Test
  public void testQuery() throws Exception {
    String result = readOutput(new URL(baseUrl, ""/jmx?qry=java.lang:type=Runtime""));
    LOG.info(""/jmx?qry=java.lang:type=Runtime RESULT: "" + result);
    assertReFind(""\""name\""\\s*:\\s*\""java.lang:type=Runtime\"""", result);
    assertReFind(""\""modelerType\"""", result);

    result = readOutput(new URL(baseUrl, ""/jmx?qry=java.lang:type=Memory""));
    LOG.info(""/jmx?qry=java.lang:type=Memory RESULT: "" + result);
    assertReFind(""\""name\""\\s*:\\s*\""java.lang:type=Memory\"""", result);
    assertReFind(""\""modelerType\"""", result);

    result = readOutput(new URL(baseUrl, ""/jmx""));
    LOG.info(""/jmx RESULT: "" + result);
    assertReFind(""\""name\""\\s*:\\s*\""java.lang:type=Memory\"""", result);

    // test to get an attribute of a mbean
    result = readOutput(new URL(baseUrl, ""/jmx?get=java.lang:type=Memory::HeapMemoryUsage""));
    LOG.info(""/jmx RESULT: "" + result);
    assertReFind(""\""name\""\\s*:\\s*\""java.lang:type=Memory\"""", result);
    assertReFind(""\""committed\""\\s*:"", result);

    // negative test to get an attribute of a mbean
    result = readOutput(new URL(baseUrl, ""/jmx?get=java.lang:type=Memory::""));
    LOG.info(""/jmx RESULT: "" + result);
    assertReFind(""\""ERROR\"""", result);

    // test to get JSONP result
    result = readOutput(new URL(baseUrl, ""/jmx?qry=java.lang:type=Memory&callback=mycallback1""));
    LOG.info(""/jmx?qry=java.lang:type=Memory&callback=mycallback RESULT: "" + result);
    assertReFind(""^mycallback1\\(\\{"", result);
    assertReFind(""\\}",No Smells
"@Test
  public void testQuery() throws Exception {
    String result = readOutput(new URL(baseUrl, ""/jmx?qry=java.lang:type=Runtime""));
    LOG.info(""/jmx?qry=java.lang:type=Runtime RESULT: "" + result);
    assertReFind(""\""name\""\\s*:\\s*\""java.lang:type=Runtime\"""", result);
    assertReFind(""\""modelerType\"""", result);

    result = readOutput(new URL(baseUrl, ""/jmx?qry=java.lang:type=Memory""));
    LOG.info(""/jmx?qry=java.lang:type=Memory RESULT: "" + result);
    assertReFind(""\""name\""\\s*:\\s*\""java.lang:type=Memory\"""", result);
    assertReFind(""\""modelerType\"""", result);

    result = readOutput(new URL(baseUrl, ""/jmx""));
    LOG.info(""/jmx RESULT: "" + result);
    assertReFind(""\""name\""\\s*:\\s*\""java.lang:type=Memory\"""", result);

    // test to get an attribute of a mbean
    result = readOutput(new URL(baseUrl, ""/jmx?get=java.lang:type=Memory::HeapMemoryUsage""));
    LOG.info(""/jmx RESULT: "" + result);
    assertReFind(""\""name\""\\s*:\\s*\""java.lang:type=Memory\"""", result);
    assertReFind(""\""committed\""\\s*:"", result);

    // negative test to get an attribute of a mbean
    result = readOutput(new URL(baseUrl, ""/jmx?get=java.lang:type=Memory::""));
    LOG.info(""/jmx RESULT: "" + result);
    assertReFind(""\""ERROR\"""", result);

    // test to get JSONP result
    result = readOutput(new URL(baseUrl, ""/jmx?qry=java.lang:type=Memory&callback=mycallback1""));
    LOG.info(""/jmx?qry=java.lang:type=Memory&callback=mycallback RESULT: "" + result);
    assertReFind(""^mycallback1\\(\\{"", result);
    assertReFind(""\\}",Eager Test + Mystery Guest
"@Test
  public void testConfiguration() {
    Configuration conf = new Configuration();
    conf.set(CommonConfigurationKeys.HADOOP_HTTP_STATIC_USER, ""dr.stack"");
    assertEquals(""dr.stack"", StaticUserWebFilter.getUsernameFromConf(conf));
  }",No Smells
"@Test
  public void testOldStyleConfiguration() {
    Configuration conf = new Configuration();
    conf.set(""dfs.web.ugi"", ""joe,group1,group2"");
    assertEquals(""joe"", StaticUserWebFilter.getUsernameFromConf(conf));
  }",No Smells
"@Test
  public void testNeedsQuoting() throws Exception {
    assertTrue(HtmlQuoting.needsQuoting(""abcde>""));
    assertTrue(HtmlQuoting.needsQuoting(""<abcde""));
    assertTrue(HtmlQuoting.needsQuoting(""abc'de""));
    assertTrue(HtmlQuoting.needsQuoting(""abcde\""""));
    assertTrue(HtmlQuoting.needsQuoting(""&""));
    assertFalse(HtmlQuoting.needsQuoting(""""));
    assertFalse(HtmlQuoting.needsQuoting(""ab\ncdef""));
    assertFalse(HtmlQuoting.needsQuoting(null));
  }",No Smells
"@Test
  public void testBindAddress() throws Exception {
    checkBindAddress(""localhost"", 0, false).stop();
    // hang onto this one for a bit more testing
    HttpServer myServer = checkBindAddress(""localhost"", 0, false);
    HttpServer myServer2 = null;
    try {
      int port = myServer.getConnectorAddress(0).getPort();
      // it's already in use, true = expect a higher port
      myServer2 = checkBindAddress(""localhost"", port, true);
      // try to reuse the port
      port = myServer2.getConnectorAddress(0).getPort();
      myServer2.stop();
      assertNull(myServer2.getConnectorAddress(0)); // not bound
      myServer2.openListeners();
      assertEquals(port, myServer2.getConnectorAddress(0).getPort()); // expect same port
    }",Eager Test
"@Test
  public void testHttpMethods() throws Exception {
    // HTTP TRACE method should be disabled for security
    // See https://www.owasp.org/index.php/Cross_Site_Tracing
    URL url = new URL(baseUrl, ""/echo?a=b"");
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.setRequestMethod(""TRACE"");
    conn.connect();
    assertEquals(HttpURLConnection.HTTP_FORBIDDEN, conn.getResponseCode());
  }",Eager Test
"@Test
  public void testBucketAllocator() throws BucketAllocatorException {
    BucketAllocator mAllocator = cache.getAllocator();
    /*
     * Test the allocator first
     */
    final List<Integer> BLOCKSIZES = Arrays.asList(4 * 1024, 8 * 1024, 64 * 1024, 96 * 1024);

    boolean full = false;
    ArrayList<Pair<Long, Integer>> allocations = new ArrayList<>();
    // Fill the allocated extents by choosing a random blocksize. Continues selecting blocks until
    // the cache is completely filled.
    List<Integer> tmp = new ArrayList<>(BLOCKSIZES);
    while (!full) {
      Integer blockSize = null;
      try {
        blockSize = randFrom(tmp);
        allocations.add(new Pair<>(mAllocator.allocateBlock(blockSize), blockSize));
      }",Eager Test
"@Test
  public void testCacheBlockNextBlockMetadataMissing() throws Exception {
    int size = 100;
    int length = HConstants.HFILEBLOCK_HEADER_SIZE + size;
    ByteBuffer buf1 = ByteBuffer.allocate(size), buf2 = ByteBuffer.allocate(size);
    HFileContext meta = new HFileContextBuilder().build();
    ByteBuffAllocator allocator = ByteBuffAllocator.HEAP;
    HFileBlock blockWithNextBlockMetadata = new HFileBlock(BlockType.DATA, size, size, -1,
      ByteBuff.wrap(buf1), HFileBlock.FILL_HEADER, -1, 52, -1, meta, allocator);
    HFileBlock blockWithoutNextBlockMetadata = new HFileBlock(BlockType.DATA, size, size, -1,
      ByteBuff.wrap(buf2), HFileBlock.FILL_HEADER, -1, -1, -1, meta, allocator);

    BlockCacheKey key = new BlockCacheKey(""testCacheBlockNextBlockMetadataMissing"", 0);
    ByteBuffer actualBuffer = ByteBuffer.allocate(length);
    ByteBuffer block1Buffer = ByteBuffer.allocate(length);
    ByteBuffer block2Buffer = ByteBuffer.allocate(length);
    blockWithNextBlockMetadata.serialize(block1Buffer, true);
    blockWithoutNextBlockMetadata.serialize(block2Buffer, true);

    // Add blockWithNextBlockMetadata, expect blockWithNextBlockMetadata back.
    CacheTestUtils.getBlockAndAssertEquals(cache, key, blockWithNextBlockMetadata, actualBuffer,
      block1Buffer);

    waitUntilFlushedToBucket(cache, key);
    assertNotNull(cache.backingMap.get(key));
    assertEquals(1, cache.backingMap.get(key).refCnt());
    assertEquals(1, blockWithNextBlockMetadata.getBufferReadOnly().refCnt());
    assertEquals(1, blockWithoutNextBlockMetadata.getBufferReadOnly().refCnt());

    // Add blockWithoutNextBlockMetada, expect blockWithNextBlockMetadata back.
    CacheTestUtils.getBlockAndAssertEquals(cache, key, blockWithoutNextBlockMetadata, actualBuffer,
      block1Buffer);
    assertEquals(1, blockWithNextBlockMetadata.getBufferReadOnly().refCnt());
    assertEquals(1, blockWithoutNextBlockMetadata.getBufferReadOnly().refCnt());
    assertEquals(1, cache.backingMap.get(key).refCnt());

    // Clear and add blockWithoutNextBlockMetadata
    assertTrue(cache.evictBlock(key));
    assertEquals(1, blockWithNextBlockMetadata.getBufferReadOnly().refCnt());
    assertEquals(1, blockWithoutNextBlockMetadata.getBufferReadOnly().refCnt());

    assertNull(cache.getBlock(key, false, false, false));
    CacheTestUtils.getBlockAndAssertEquals(cache, key, blockWithoutNextBlockMetadata, actualBuffer,
      block2Buffer);

    waitUntilFlushedToBucket(cache, key);
    assertEquals(1, blockWithNextBlockMetadata.getBufferReadOnly().refCnt());
    assertEquals(1, blockWithoutNextBlockMetadata.getBufferReadOnly().refCnt());

    // Add blockWithNextBlockMetadata, expect blockWithNextBlockMetadata to replace.
    CacheTestUtils.getBlockAndAssertEquals(cache, key, blockWithNextBlockMetadata, actualBuffer,
      block1Buffer);

    waitUntilFlushedToBucket(cache, key);
    assertEquals(1, blockWithNextBlockMetadata.getBufferReadOnly().refCnt());
    assertEquals(1, blockWithoutNextBlockMetadata.getBufferReadOnly().refCnt());
  }",Eager Test
"@Test
  public void testInvalidAcceptFactorConfig() throws IOException {
    float[] configValues = { -1f, 0.2f, 0.86f, 1.05f }",Eager Test
"@Test
  public void testMemoryLeak() throws Exception {
    final BlockCacheKey cacheKey = new BlockCacheKey(""dummy"", 1L);
    cacheAndWaitUntilFlushedToBucket(cache, cacheKey,
      new CacheTestUtils.ByteArrayCacheable(new byte[10]), true);
    long lockId = cache.backingMap.get(cacheKey).offset();
    ReentrantReadWriteLock lock = cache.offsetLock.getLock(lockId);
    lock.writeLock().lock();
    Thread evictThread = new Thread(""evict-block"") {
      @Override
      public void run() {
        cache.evictBlock(cacheKey);
      }",Eager Test
"@Test
  public void testOffsetProducesPositiveOutput() {
    // This number is picked because it produces negative output if the values isn't ensured to be
    // positive. See HBASE-18757 for more information.
    long testValue = 549888460800L;
    BucketEntry bucketEntry = new BucketEntry(testValue, 10, 10, 10L, true, (entry) -> {
      return ByteBuffAllocator.NONE;
    }",No Smells
"@Test
  public void testRetrieveFromFile() throws Exception {
    Path testDir = createAndGetTestDir();
    String ioEngineName = ""file:"" + testDir + ""/bucket.cache"";
    testRetrievalUtils(testDir, ioEngineName);
    int[] smallBucketSizes = new int[] { 3 * 1024, 5 * 1024 }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testValidBucketCacheConfigs() throws IOException {
    Configuration conf = HBaseConfiguration.create();
    conf.setFloat(ACCEPT_FACTOR_CONFIG_NAME, 0.9f);
    conf.setFloat(MIN_FACTOR_CONFIG_NAME, 0.5f);
    conf.setFloat(EXTRA_FREE_FACTOR_CONFIG_NAME, 0.5f);
    conf.setFloat(BucketCache.SINGLE_FACTOR_CONFIG_NAME, 0.1f);
    conf.setFloat(BucketCache.MULTI_FACTOR_CONFIG_NAME, 0.7f);
    conf.setFloat(BucketCache.MEMORY_FACTOR_CONFIG_NAME, 0.2f);

    BucketCache cache = new BucketCache(ioEngineName, capacitySize, constructedBlockSize,
      constructedBlockSizes, writeThreads, writerQLen, null, 100, conf);
    assertTrue(cache.waitForCacheInitialization(10000));

    assertEquals(ACCEPT_FACTOR_CONFIG_NAME + "" failed to propagate."", 0.9f,
      cache.getAcceptableFactor(), 0);
    assertEquals(MIN_FACTOR_CONFIG_NAME + "" failed to propagate."", 0.5f, cache.getMinFactor(), 0);
    assertEquals(EXTRA_FREE_FACTOR_CONFIG_NAME + "" failed to propagate."", 0.5f,
      cache.getExtraFreeFactor(), 0);
    assertEquals(BucketCache.SINGLE_FACTOR_CONFIG_NAME + "" failed to propagate."", 0.1f,
      cache.getSingleFactor(), 0);
    assertEquals(BucketCache.MULTI_FACTOR_CONFIG_NAME + "" failed to propagate."", 0.7f,
      cache.getMultiFactor(), 0);
    assertEquals(BucketCache.MEMORY_FACTOR_CONFIG_NAME + "" failed to propagate."", 0.2f,
      cache.getMemoryFactor(), 0);
  }",Eager Test
"@Test
  public void testRefreshFileConnection() throws IOException {
    FileChannel[] fileChannels = fileIOEngine.getFileChannels();
    FileChannel fileChannel = fileChannels[0];
    assertNotNull(fileChannel);
    fileChannel.close();
    fileIOEngine.refreshFileConnection(0, new IOException(""Test Exception""));
    FileChannel[] reopenedFileChannels = fileIOEngine.getFileChannels();
    FileChannel reopenedFileChannel = reopenedFileChannels[0];
    assertNotEquals(fileChannel, reopenedFileChannel);
    assertEquals(fileChannels.length, reopenedFileChannels.length);
    for (int i = 1; i < fileChannels.length; i++) {
      assertEquals(fileChannels[i], reopenedFileChannels[i]);
    }",Eager Test
"@Test
  public void testL2CacheWithInvalidBucketSize() {
    Configuration c = new Configuration(this.conf);
    c.set(HConstants.BUCKET_CACHE_IOENGINE_KEY, ""offheap"");
    c.set(BlockCacheFactory.BUCKET_CACHE_BUCKETS_KEY, ""256,512,1024,2048,4000,4096"");
    c.setFloat(HConstants.BUCKET_CACHE_SIZE_KEY, 1024);
    try {
      BlockCacheFactory.createBlockCache(c);
      fail(""Should throw IllegalArgumentException when passing illegal value for bucket size"");
    }",No Smells
"@Test
  public void testTrailerForV2NonPBCompatibility() throws Exception {
    if (version == 2) {
      FixedFileTrailer t = new FixedFileTrailer(version, HFileReaderImpl.MINOR_VERSION_NO_CHECKSUM);
      t.setDataIndexCount(3);
      t.setEntryCount(((long) Integer.MAX_VALUE) + 1);
      t.setLastDataBlockOffset(291);
      t.setNumDataIndexLevels(3);
      t.setComparatorClass(CellComparatorImpl.COMPARATOR.getClass());
      t.setFirstDataBlockOffset(9081723123L); // Completely unrealistic.
      t.setUncompressedDataIndexSize(827398717L); // Something random.
      t.setLoadOnOpenOffset(128);
      t.setMetaIndexCount(7);
      t.setTotalUncompressedBytes(129731987);

      {
        DataOutputStream dos = new DataOutputStream(baos); // Limited scope.
        serializeAsWritable(dos, t);
        dos.flush();
        assertEquals(FixedFileTrailer.getTrailerSize(version), dos.size());
      }",Eager Test
"@Test
  public void testCorrupt0LengthHFile() throws IOException {
    Path f = new Path(ROOT_DIR, testName.getMethodName());
    FSDataOutputStream fsos = fs.create(f);
    fsos.close();

    try {
      Reader r = HFile.createReader(fs, f, cacheConf, true, conf);
    }",Eager Test
"@Test
  public void testShortMidpointSameQual() {
    ExtendedCell left =
      ExtendedCellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(Bytes.toBytes(""a""))
        .setFamily(Bytes.toBytes(""a"")).setQualifier(Bytes.toBytes(""a"")).setTimestamp(11)
        .setType(Type.Maximum.getCode()).setValue(HConstants.EMPTY_BYTE_ARRAY).build();
    ExtendedCell right =
      ExtendedCellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(Bytes.toBytes(""a""))
        .setFamily(Bytes.toBytes(""a"")).setQualifier(Bytes.toBytes(""a"")).setTimestamp(9)
        .setType(Type.Maximum.getCode()).setValue(HConstants.EMPTY_BYTE_ARRAY).build();
    ExtendedCell mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
    assertTrue(
      PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) <= 0);
    assertTrue(
      PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) == 0);
  }",Eager Test
"@Test
  public void testDataBlockEncoding() throws IOException {
    testInternals();
  }",No Smells
"@Test
  public void testGzipCompression() throws IOException {
    // @formatter:off
    String correctTestBlockStr = ""DATABLK*\\x00\\x00\\x00>\\x00\\x00\\x0F\\xA0\\xFF\\xFF\\xFF\\xFF""
      + ""\\xFF\\xFF\\xFF\\xFF""
      + ""\\x0"" + ChecksumType.getDefaultChecksumType().getCode()
      + ""\\x00\\x00@\\x00\\x00\\x00\\x00[""
      // gzip-compressed block: http://www.gzip.org/zlib/rfc-gzip.html
      + ""\\x1F\\x8B""  // gzip magic signature
      + ""\\x08""  // Compression method: 8 = ""deflate""
      + ""\\x00""  // Flags
      + ""\\x00\\x00\\x00\\x00""  // mtime
      + ""\\x00""  // XFL (extra flags)
      // OS (0 = FAT filesystems, 3 = Unix). However, this field
      // sometimes gets set to 0 on Linux and Mac, so we reset it to 3.
      // This appears to be a difference caused by the availability
      // (and use) of the native GZ codec.
      + ""\\x03""
      + ""\\xED\\xC3\\xC1\\x11\\x00 \\x08\\xC00DD\\xDD\\x7Fa""
      + ""\\xD6\\xE8\\xA3\\xB9K\\x84`\\x96Q\\xD3\\xA8\\xDB\\xA8e\\xD4c""
      + ""\\xD46\\xEA5\\xEA3\\xEA7\\xE7\\x00LI\\x5Cs\\xA0\\x0F\\x00\\x00""
      + ""\\x00\\x00\\x00\\x00""; //  4 byte checksum (ignored)
    // @formatter:on
    int correctGzipBlockLength = 95;
    String testBlockStr = createTestBlockStr(GZ, correctGzipBlockLength, false);
    // We ignore the block checksum because createTestBlockStr can change the
    // gzip header after the block is produced
    assertEquals(correctTestBlockStr.substring(0, correctGzipBlockLength - 4),
      testBlockStr.substring(0, correctGzipBlockLength - 4));
  }",Eager Test
"@Test
  public void testBlockIndex() throws IOException {
    testBlockIndexInternals(false);
    clear();
    testBlockIndexInternals(true);
  }",No Smells
"@Test
  public void testBlockIndexChunk() throws IOException {
    BlockIndexChunk c = new HFileBlockIndex.BlockIndexChunkImpl();
    HFileIndexBlockEncoder indexBlockEncoder = NoOpIndexBlockEncoder.INSTANCE;
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    int N = 1000;
    int[] numSubEntriesAt = new int[N];
    int numSubEntries = 0;
    for (int i = 0; i < N; ++i) {
      baos.reset();
      DataOutputStream dos = new DataOutputStream(baos);
      indexBlockEncoder.encode(c, false, dos);
      assertEquals(c.getNonRootSize(), dos.size());

      baos.reset();
      dos = new DataOutputStream(baos);
      indexBlockEncoder.encode(c, true, dos);
      assertEquals(c.getRootSize(), dos.size());

      byte[] k = RandomKeyValueUtil.randomOrderedKey(RNG, i);
      numSubEntries += RNG.nextInt(5) + 1;
      keys.add(k);
      c.add(k, getDummyFileOffset(i), getDummyOnDiskSize(i), numSubEntries);
    }",Eager Test
"@Test
  public void testIntermediateLevelIndicesWithLargeKeysWithMinNumEntries() throws IOException {
    // because of the large rowKeys, we will end up with a 50-level block index without sanity check
    testIntermediateLevelIndicesWithLargeKeys(2);
  }",No Smells
"@Test
  public void testMidKeyOnLeafIndexBlockBoundary() throws IOException {
    Path hfilePath = new Path(TEST_UTIL.getDataTestDir(), ""hfile_for_midkey"");
    int maxChunkSize = 512;
    conf.setInt(HFileBlockIndex.MAX_CHUNK_SIZE_KEY, maxChunkSize);
    // should open hfile.block.index.cacheonwrite
    conf.setBoolean(CacheConfig.CACHE_INDEX_BLOCKS_ON_WRITE_KEY, true);
    CacheConfig cacheConf = new CacheConfig(conf, BlockCacheFactory.createBlockCache(conf));
    BlockCache blockCache = cacheConf.getBlockCache().get();
    // Evict all blocks that were cached-on-write by the previous invocation.
    blockCache.evictBlocksByHfileName(hfilePath.getName());
    // Write the HFile
    HFileContext meta = new HFileContextBuilder().withBlockSize(SMALL_BLOCK_SIZE)
      .withCompression(Algorithm.NONE).withDataBlockEncoding(DataBlockEncoding.NONE).build();
    HFile.Writer writer = HFile.getWriterFactory(conf, cacheConf).withPath(fs, hfilePath)
      .withFileContext(meta).create();
    Random rand = new Random(19231737);
    byte[] family = Bytes.toBytes(""f"");
    byte[] qualifier = Bytes.toBytes(""q"");
    int kvNumberToBeWritten = 16;
    // the new generated hfile will contain 2 leaf-index blocks and 16 data blocks,
    // midkey is just on the boundary of the first leaf-index block
    for (int i = 0; i < kvNumberToBeWritten; ++i) {
      byte[] row = RandomKeyValueUtil.randomOrderedFixedLengthKey(rand, i, 30);

      // Key will be interpreted by KeyValue.KEY_COMPARATOR
      KeyValue kv = new KeyValue(row, family, qualifier, EnvironmentEdgeManager.currentTime(),
        RandomKeyValueUtil.randomFixedLengthValue(rand, SMALL_BLOCK_SIZE));
      writer.append(kv);
    }",Eager Test
"@Test
  public void testEncodingWithCache() throws IOException {
    testEncodingWithCacheInternals(false);
    testEncodingWithCacheInternals(true);
  }",No Smells
"@Test
  public void testCacheEvictionInMemoryForceMode() throws Exception {
    long maxSize = 100000;
    long blockSize = calculateBlockSize(maxSize, 10);

    LruBlockCache cache =
      new LruBlockCache(maxSize, blockSize, false, (int) Math.ceil(1.2 * maxSize / blockSize),
        LruBlockCache.DEFAULT_LOAD_FACTOR, LruBlockCache.DEFAULT_CONCURRENCY_LEVEL, 0.98f, // min
        0.99f, // acceptable
        0.2f, // single
        0.3f, // multi
        0.5f, // memory
        1.2f, // limit
        true, 16 * 1024 * 1024);

    CachedItem[] singleBlocks = generateFixedBlocks(10, blockSize, ""single"");
    CachedItem[] multiBlocks = generateFixedBlocks(10, blockSize, ""multi"");
    CachedItem[] memoryBlocks = generateFixedBlocks(10, blockSize, ""memory"");

    long expectedCacheSize = cache.heapSize();

    // 0. Add 5 single blocks and 4 multi blocks to make cache full, si:mu:me = 5:4:0
    for (int i = 0; i < 4; i++) {
      // Just add single blocks
      cache.cacheBlock(singleBlocks[i].cacheKey, singleBlocks[i]);
      expectedCacheSize += singleBlocks[i].cacheBlockHeapSize();
      // Add and get multi blocks
      cache.cacheBlock(multiBlocks[i].cacheKey, multiBlocks[i]);
      expectedCacheSize += multiBlocks[i].cacheBlockHeapSize();
      cache.getBlock(multiBlocks[i].cacheKey, true, false, true);
    }",Eager Test
"@Test
  public void testCacheEvictionThreePriorities() throws Exception {
    long maxSize = 100000;
    long blockSize = calculateBlockSize(maxSize, 10);

    LruBlockCache cache =
      new LruBlockCache(maxSize, blockSize, false, (int) Math.ceil(1.2 * maxSize / blockSize),
        LruBlockCache.DEFAULT_LOAD_FACTOR, LruBlockCache.DEFAULT_CONCURRENCY_LEVEL, 0.98f, // min
        0.99f, // acceptable
        0.33f, // single
        0.33f, // multi
        0.34f, // memory
        1.2f, // limit
        false, 16 * 1024 * 1024);

    CachedItem[] singleBlocks = generateFixedBlocks(5, blockSize, ""single"");
    CachedItem[] multiBlocks = generateFixedBlocks(5, blockSize, ""multi"");
    CachedItem[] memoryBlocks = generateFixedBlocks(5, blockSize, ""memory"");

    long expectedCacheSize = cache.heapSize();

    // Add 3 blocks from each priority
    for (int i = 0; i < 3; i++) {

      // Just add single blocks
      cache.cacheBlock(singleBlocks[i].cacheKey, singleBlocks[i]);
      expectedCacheSize += singleBlocks[i].cacheBlockHeapSize();

      // Add and get multi blocks
      cache.cacheBlock(multiBlocks[i].cacheKey, multiBlocks[i]);
      expectedCacheSize += multiBlocks[i].cacheBlockHeapSize();
      cache.getBlock(multiBlocks[i].cacheKey, true, false, true);

      // Add memory blocks as such
      cache.cacheBlock(memoryBlocks[i].cacheKey, memoryBlocks[i], true);
      expectedCacheSize += memoryBlocks[i].cacheBlockHeapSize();

    }",Eager Test
"@Test
  public void testCacheEvictionTwoPriorities() throws Exception {
    long maxSize = 100000;
    long blockSize = calculateBlockSizeDefault(maxSize, 10);

    LruBlockCache cache = new LruBlockCache(maxSize, blockSize, false);

    CachedItem[] singleBlocks = generateFixedBlocks(5, 10000, ""single"");
    CachedItem[] multiBlocks = generateFixedBlocks(5, 10000, ""multi"");

    long expectedCacheSize = cache.heapSize();

    // Add and get the multi blocks
    for (CachedItem block : multiBlocks) {
      cache.cacheBlock(block.cacheKey, block);
      expectedCacheSize += block.cacheBlockHeapSize();
      assertEquals(cache.getBlock(block.cacheKey, true, false, true), block);
    }",Eager Test
"@Test
  public void testWrites() throws Exception {
    ByteBuffAllocator alloc = new ByteBuffAllocator(true, 3, 10, 10 / 6);
    ByteBufferListOutputStream bbos = new ByteBufferListOutputStream(alloc);
    bbos.write(2);// Write a byte
    bbos.writeInt(100);// Write an int
    byte[] b = Bytes.toBytes(""row123"");// 6 bytes
    bbos.write(b);
    assertEquals(2, bbos.allBufs.size());
    // Just use the 3rd BB from pool so that pabos, on request, wont get one
    ByteBuff bb1 = alloc.allocateOneBuffer();
    ByteBuffer bb = ByteBuffer.wrap(Bytes.toBytes(""row123_cf1_q1""));// 13 bytes
    bbos.write(bb, 0, bb.capacity());
    bb1.release();
    bbos.writeInt(123);
    bbos.writeInt(124);
    assertEquals(0, alloc.getFreeBufferCount());
    List<ByteBuffer> allBufs = bbos.getByteBuffers();
    assertEquals(4, allBufs.size());
    assertEquals(4, bbos.allBufs.size());
    ByteBuffer b1 = allBufs.get(0);
    assertEquals(10, b1.remaining());
    assertEquals(2, b1.get());
    assertEquals(100, b1.getInt());
    byte[] bActual = new byte[b.length];
    b1.get(bActual, 0, 5);// 5 bytes in 1st BB
    ByteBuffer b2 = allBufs.get(1);
    assertEquals(10, b2.remaining());
    b2.get(bActual, 5, 1);// Remaining 1 byte in 2nd BB
    assertTrue(Bytes.equals(b, bActual));
    bActual = new byte[bb.capacity()];
    b2.get(bActual, 0, 9);
    ByteBuffer b3 = allBufs.get(2);
    assertEquals(8, b3.remaining());
    b3.get(bActual, 9, 4);
    assertTrue(ByteBufferUtils.equals(bb, 0, bb.capacity(), bActual, 0, bActual.length));
    assertEquals(123, b3.getInt());
    ByteBuffer b4 = allBufs.get(3);
    assertEquals(4, b4.remaining());
    assertEquals(124, b4.getInt());
    bbos.releaseResources();
    assertEquals(3, alloc.getFreeBufferCount());
  }",Eager Test
"@Test
  public void testByteBufferReuse() throws IOException {
    byte[] someBytes = Bytes.toBytes(""some bytes"");
    ByteBuffer bb = ByteBuffer.allocate(someBytes.length);
    ByteBuffer bbToReuse = write(bb, someBytes);
    bbToReuse = write(bbToReuse, Bytes.toBytes(""less""));
    assertTrue(bb == bbToReuse);
  }",No Smells
"@Test
  public void testEquals() {
    Path p1 = new Path(""/p1"");
    Path p2 = new Path(""/p2"");
    Path p3 = new Path(""/p3"");

    assertEquals(new FileLink(), new FileLink());
    assertEquals(new FileLink(p1), new FileLink(p1));
    assertEquals(new FileLink(p1, p2), new FileLink(p1, p2));
    assertEquals(new FileLink(p1, p2, p3), new FileLink(p1, p2, p3));

    assertNotEquals(new FileLink(p1), new FileLink(p3));
    assertNotEquals(new FileLink(p1, p2), new FileLink(p1));
    assertNotEquals(new FileLink(p1, p2), new FileLink(p2));
    assertNotEquals(new FileLink(p1, p2), new FileLink(p2, p1)); // ordering important!
  }",No Smells
"@Test
  public void testHDFSLinkReadDuringRename() throws Exception {
    HBaseTestingUtil testUtil = new HBaseTestingUtil();
    Configuration conf = testUtil.getConfiguration();
    conf.setInt(""dfs.blocksize"", 1024 * 1024);
    conf.setInt(""dfs.client.read.prefetch.size"", 2 * 1024 * 1024);

    testUtil.startMiniDFSCluster(1);
    MiniDFSCluster cluster = testUtil.getDFSCluster();
    FileSystem fs = cluster.getFileSystem();
    assertEquals(""hdfs"", fs.getUri().getScheme());

    try {
      testLinkReadDuringRename(fs, testUtil.getDefaultRootDirPath());
    }",Eager Test + Mystery Guest
"@Test
  public void testHalfScanAndReseek() throws Exception {
    ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);
    Configuration conf = TEST_UTIL.getConfiguration();
    FileSystem fs = FileSystem.get(conf);
    String root_dir = TEST_UTIL.getDataTestDir().toString();
    Path parentPath = new Path(new Path(root_dir, ""parent""), ""CF"");
    fs.mkdirs(parentPath);
    String tableName = Paths.get(root_dir).getFileName().toString();
    RegionInfo splitAHri = RegionInfoBuilder.newBuilder(TableName.valueOf(tableName)).build();
    Thread.currentThread().sleep(1000);
    RegionInfo splitBHri = RegionInfoBuilder.newBuilder(TableName.valueOf(tableName)).build();
    Path splitAPath = new Path(new Path(root_dir, splitAHri.getRegionNameAsString()), ""CF"");
    Path splitBPath = new Path(new Path(root_dir, splitBHri.getRegionNameAsString()), ""CF"");
    Path filePath = StoreFileWriter.getUniqueFile(fs, parentPath);
    String ioEngineName = ""file:"" + TEST_UTIL.getDataTestDir() + ""/bucketNoRecycler.cache"";
    BucketCache bucketCache = new BucketCache(ioEngineName, 32 * 1024 * 1024, 1024,
      new int[] { 4 * 1024, 8 * 1024, 64 * 1024, 96 * 1024 }",Eager Test + Mystery Guest
"@Test
  public void testNativeSizes() throws IOException {
    Class<?> cl;
    long expected;
    long actual;

    // ArrayList
    cl = ArrayList.class;
    expected = ClassSize.estimateBase(cl, false);
    actual = ClassSize.ARRAYLIST;
    if (expected != actual) {
      ClassSize.estimateBase(cl, true);
      assertEquals(expected, actual);
    }",Eager Test
"@Test
  public void testSpecificCompare() {
    ImmutableBytesWritable ibw1 = new ImmutableBytesWritable(new byte[] { 0x0f }",No Smells
"@Test
  public void testCompressUncompressTagsWithOffheapKeyValue2() throws Exception {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    DataOutputStream daos = new ByteBufferWriterDataOutputStream(baos);
    TagCompressionContext context = new TagCompressionContext(LRUDictionary.class, Byte.MAX_VALUE);
    ByteBufferExtendedCell kv1 = (ByteBufferExtendedCell) createOffheapKVWithTags(1);
    int tagsLength1 = kv1.getTagsLength();
    context.compressTags(daos, kv1.getTagsByteBuffer(), kv1.getTagsPosition(), tagsLength1);
    ByteBufferExtendedCell kv2 = (ByteBufferExtendedCell) createOffheapKVWithTags(3);
    int tagsLength2 = kv2.getTagsLength();
    context.compressTags(daos, kv2.getTagsByteBuffer(), kv2.getTagsPosition(), tagsLength2);

    context.clear();

    ByteArrayInputStream bais = new ByteArrayInputStream(baos.getBuffer());
    byte[] dest = new byte[tagsLength1];
    context.uncompressTags(bais, dest, 0, tagsLength1);
    assertTrue(
      Bytes.equals(kv1.getTagsArray(), kv1.getTagsOffset(), tagsLength1, dest, 0, tagsLength1));
    dest = new byte[tagsLength2];
    context.uncompressTags(bais, dest, 0, tagsLength2);
    assertTrue(
      Bytes.equals(kv2.getTagsArray(), kv2.getTagsOffset(), tagsLength2, dest, 0, tagsLength2));
  }",Eager Test
"@Test
  public void TestLRUPolicy() {
    // start by filling the dictionary up with byte arrays
    for (int i = 0; i < Short.MAX_VALUE; i++) {
      testee.findEntry(BigInteger.valueOf(i).toByteArray(), 0,
        BigInteger.valueOf(i).toByteArray().length);
    }",Eager Test
"@Test
  public void testSimpleCall() {
    RpcServerInterface mockRpcServer = Mockito.mock(RpcServerInterface.class);
    Mockito.when(mockRpcServer.isStarted()).thenReturn(true);
    ServerCall<?> mockCall = Mockito.mock(ServerCall.class);

    TraceUtil.trace(() -> {
      CallRunner cr = new CallRunner(mockRpcServer, mockCall);
      cr.setStatus(new MonitoredRPCHandlerImpl(""test""));
      cr.run();
    }",No Smells
"@Test
  public void testBuildCellBlock() throws IOException {
    doBuildCellBlockUndoCellBlock(this.builder, new KeyValueCodec(), null);
    doBuildCellBlockUndoCellBlock(this.builder, new KeyValueCodec(), new DefaultCodec());
    doBuildCellBlockUndoCellBlock(this.builder, new KeyValueCodec(), new GzipCodec());
  }",No Smells
"@Test
  public void testServiceName() throws Exception {
    // verify that we de-namespace build in HBase rpc services
    ServiceDescriptor authService = AuthenticationProtos.AuthenticationService.getDescriptor();
    assertEquals(authService.getName(), CoprocessorRpcUtils.getServiceName(authService));

    // non-hbase rpc services should remain fully qualified
    ServiceDescriptor dummyService = DummyRegionServerEndpointProtos.DummyService.getDescriptor();
    assertEquals(dummyService.getFullName(), CoprocessorRpcUtils.getServiceName(dummyService));
  }",No Smells
"@Test
  public void testCallQueueInfo() throws Exception {
    Configuration conf = HBaseConfiguration.create();
    AtomicInteger callExecutionCount = new AtomicInteger(0);

    RpcScheduler scheduler = new MockMasterFifoRpcScheduler(conf, 2, 1);
    scheduler.start();

    int totalCallMethods = 30;
    int unableToDispatch = 0;

    for (int i = totalCallMethods; i > 0; i--) {
      CallRunner task = createMockTask(callExecutionCount, i < 20);
      if (!scheduler.dispatch(task)) {
        unableToDispatch++;
      }",Eager Test
"@Test
  public void testNettyRpcServer() throws Exception {
    doTest(name.getTableName());
  }",Eager Test + Mystery Guest
"@Test
  public void testRpcScheduler() throws Exception {
    testRpcScheduler(RpcExecutor.CALL_QUEUE_TYPE_DEADLINE_CONF_VALUE);
    testRpcScheduler(RpcExecutor.CALL_QUEUE_TYPE_FIFO_CONF_VALUE);
  }",No Smells
"@Test
  public void testSoftAndHardQueueLimits() throws Exception {

    Configuration schedConf = HBaseConfiguration.create();

    schedConf.setInt(HConstants.REGION_SERVER_HANDLER_COUNT, 0);
    schedConf.setInt(""hbase.ipc.server.max.callqueue.length"", 5);
    schedConf.set(RpcExecutor.CALL_QUEUE_TYPE_CONF_KEY,
      RpcExecutor.CALL_QUEUE_TYPE_DEADLINE_CONF_VALUE);

    PriorityFunction priority = mock(PriorityFunction.class);
    when(priority.getPriority(any(), any(), any())).thenReturn(HConstants.NORMAL_QOS);
    SimpleRpcScheduler scheduler =
      new SimpleRpcScheduler(schedConf, 0, 0, 0, priority, HConstants.QOS_THRESHOLD);
    try {
      scheduler.start();

      CallRunner putCallTask = mock(CallRunner.class);
      ServerCall putCall = mock(ServerCall.class);
      putCall.param =
        RequestConverter.buildMutateRequest(Bytes.toBytes(""abc""), new Put(Bytes.toBytes(""row"")));
      RequestHeader putHead = RequestHeader.newBuilder().setMethodName(""mutate"").build();
      when(putCallTask.getRpcCall()).thenReturn(putCall);
      when(putCall.getHeader()).thenReturn(putHead);

      assertTrue(scheduler.dispatch(putCallTask));

      schedConf.setInt(""hbase.ipc.server.max.callqueue.length"", 0);
      scheduler.onConfigurationChange(schedConf);
      assertFalse(scheduler.dispatch(putCallTask));
      waitUntilQueueEmpty(scheduler);
      schedConf.setInt(""hbase.ipc.server.max.callqueue.length"", 1);
      scheduler.onConfigurationChange(schedConf);
      assertTrue(scheduler.dispatch(putCallTask));
    }",Eager Test
"@Test
  public void shouldReturnNullFromCreateGroupKey() throws Exception {
    GroupingTableMap gTableMap = null;
    try {
      gTableMap = new GroupingTableMap();
      assertNull(gTableMap.createGroupKey(null));
    }",No Smells
"@Test
  public void testExtensionOfTableInputFormatBase() throws IOException {
    LOG.info(""testing use of an InputFormat taht extends InputFormatBase"");
    final Table table = createTable(Bytes.toBytes(""exampleTable""),
      new byte[][] { Bytes.toBytes(""columnA""), Bytes.toBytes(""columnB"") }",No Smells
"@Test
  public void testTableRecordReader() throws IOException {
    Table table = createTable(Bytes.toBytes(""table1""));
    runTestMapred(table);
  }",No Smells
"@Test
  public void testTableRecordReaderScannerTimeout() throws IOException {
    Table htable = createDNRIOEScannerTable(Bytes.toBytes(""table4""), 1);
    runTestMapred(htable);
  }",No Smells
"@Test
  public void TestCellCounterWithoutOutputDir() throws Exception {
    String[] args = new String[] { ""tableName"" }",No Smells
"@Test
  public void testMainMethod() throws Exception {
    String[] emptyArgs = { ""-h"" }",Eager Test
"@Test
  public void testRenameFamily() throws Exception {
    testRenameFamily(TEST_UTIL.getConfiguration());
  }",Eager Test
"@Test
  public void testExcludeAllFromMinorCompaction() throws Exception {
    Configuration conf = util.getConfiguration();
    conf.setInt(""hbase.hstore.compaction.min"", 2);
    generateRandomStartKeys(5);

    util.startMiniCluster();
    try (Connection conn = ConnectionFactory.createConnection(); Admin admin = conn.getAdmin();
      Table table = util.createTable(TABLE_NAMES[0], FAMILIES);
      RegionLocator locator = conn.getRegionLocator(TABLE_NAMES[0])) {
      final FileSystem fs = util.getDFSCluster().getFileSystem();
      assertEquals(""Should start with empty table"", 0, util.countRows(table));

      // deep inspection: get the StoreFile dir
      final Path storePath =
        new Path(CommonFSUtils.getTableDir(CommonFSUtils.getRootDir(conf), TABLE_NAMES[0]),
          new Path(admin.getRegions(TABLE_NAMES[0]).get(0).getEncodedName(),
            Bytes.toString(FAMILIES[0])));
      assertEquals(0, fs.listStatus(storePath).length);

      // Generate two bulk load files
      conf.setBoolean(""hbase.mapreduce.hfileoutputformat.compaction.exclude"", true);

      for (int i = 0; i < 2; i++) {
        Path testDir = util.getDataTestDirOnTestFS(""testExcludeAllFromMinorCompaction_"" + i);
        runIncrementalPELoad(conf,
          Arrays.asList(new HFileOutputFormat2.TableInfo(table.getDescriptor(),
            conn.getRegionLocator(TABLE_NAMES[0]))),
          testDir, false);
        // Perform the actual load
        BulkLoadHFiles.create(conf).bulkLoad(table.getName(), testDir);
      }",Eager Test + Mystery Guest
"@Test
  public void testMRIncrementalLoad() throws Exception {
    LOG.info(""\nStarting test testMRIncrementalLoad\n"");
    doIncrementalLoadTest(false, false, false, ""testMRIncrementalLoad"");
  }",No Smells
"@Test
  public void testMRIncrementalLoadWithLocality() throws Exception {
    LOG.info(""\nStarting test testMRIncrementalLoadWithLocality\n"");
    doIncrementalLoadTest(false, true, false, ""testMRIncrementalLoadWithLocality1"");
    doIncrementalLoadTest(true, true, false, ""testMRIncrementalLoadWithLocality2"");
  }",No Smells
"@Test
  public void testWritingPEData() throws Exception {
    Configuration conf = util.getConfiguration();
    Path testDir = util.getDataTestDirOnTestFS(""testWritingPEData"");
    FileSystem fs = testDir.getFileSystem(conf);

    // Set down this value or we OOME in eclipse.
    conf.setInt(""mapreduce.task.io.sort.mb"", 20);
    // Write a few files.
    long hregionMaxFilesize = 10 * 1024;
    conf.setLong(HConstants.HREGION_MAX_FILESIZE, hregionMaxFilesize);

    Job job = new Job(conf, ""testWritingPEData"");
    setupRandomGeneratorMapper(job, false);
    // This partitioner doesn't work well for number keys but using it anyways
    // just to demonstrate how to configure it.
    byte[] startKey = new byte[RandomKVGeneratingMapper.KEYLEN_DEFAULT];
    byte[] endKey = new byte[RandomKVGeneratingMapper.KEYLEN_DEFAULT];

    Arrays.fill(startKey, (byte) 0);
    Arrays.fill(endKey, (byte) 0xff);

    job.setPartitionerClass(SimpleTotalOrderPartitioner.class);
    // Set start and end rows for partitioner.
    SimpleTotalOrderPartitioner.setStartKey(job.getConfiguration(), startKey);
    SimpleTotalOrderPartitioner.setEndKey(job.getConfiguration(), endKey);
    job.setReducerClass(CellSortReducer.class);
    job.setOutputFormatClass(HFileOutputFormat2.class);
    job.setNumReduceTasks(4);
    job.getConfiguration().setStrings(""io.serializations"", conf.get(""io.serializations""),
      MutationSerialization.class.getName(), ResultSerialization.class.getName(),
      CellSerialization.class.getName());

    FileOutputFormat.setOutputPath(job, testDir);
    assertTrue(job.waitForCompletion(false));
    FileStatus[] files = fs.listStatus(testDir);
    assertTrue(files.length > 0);

    // check output file num and size.
    for (byte[] family : FAMILIES) {
      long kvCount = 0;
      RemoteIterator<LocatedFileStatus> iterator =
        fs.listFiles(testDir.suffix(""/"" + new String(family)), true);
      while (iterator.hasNext()) {
        LocatedFileStatus keyFileStatus = iterator.next();
        HFile.Reader reader =
          HFile.createReader(fs, keyFileStatus.getPath(), new CacheConfig(conf), true, conf);
        HFileScanner scanner = reader.getScanner(conf, false, false, false);

        kvCount += reader.getEntries();
        scanner.seekTo();
        long perKVSize = scanner.getCell().getSerializedSize();
        assertTrue(""Data size of each file should not be too large."",
          perKVSize * reader.getEntries() <= hregionMaxFilesize);
      }",Eager Test + Mystery Guest
"@Test
  public void testBulkOutputWithAnExistingTableNoStrictTrue() throws Exception {
    util.createTable(tn, FAMILY);

    // Prepare the arguments required for the test.
    Path hfiles = new Path(util.getDataTestDirOnTestFS(tn.getNameAsString()), ""hfiles"");
    args.put(ImportTsv.BULK_OUTPUT_CONF_KEY, hfiles.toString());
    args.put(ImportTsv.NO_STRICT_COL_FAMILY, ""true"");
    doMROnTableTest(null, 3);
    util.deleteTable(tn);
  }",No Smells
"@Test
  public void testDryModeWithBulkModeAndTableDoesNotExistsCreateTableSetToYes() throws Exception {
    // Prepare the arguments required for the test.
    Path hfiles = new Path(util.getDataTestDirOnTestFS(tn.getNameAsString()), ""hfiles"");
    args.put(ImportTsv.BULK_OUTPUT_CONF_KEY, hfiles.toString());
    args.put(ImportTsv.DRY_RUN_CONF_KEY, ""true"");
    args.put(ImportTsv.CREATE_TABLE_CONF_KEY, ""yes"");
    doMROnTableTest(null, 1);
    // Verify temporary table was deleted.
    exception.expect(TableNotFoundException.class);
    util.deleteTable(tn);
  }",No Smells
"@Test
  public void testDryModeWithBulkOutputAndTableDoesNotExistsCreateTableSetToNo() throws Exception {
    // Prepare the arguments required for the test.
    Path hfiles = new Path(util.getDataTestDirOnTestFS(tn.getNameAsString()), ""hfiles"");
    args.put(ImportTsv.BULK_OUTPUT_CONF_KEY, hfiles.toString());
    args.put(ImportTsv.DRY_RUN_CONF_KEY, ""true"");
    args.put(ImportTsv.CREATE_TABLE_CONF_KEY, ""no"");
    exception.expect(TableNotFoundException.class);
    doMROnTableTest(null, 1);
  }",No Smells
"@Test
  public void testDryModeWithoutBulkOutputAndTableExists() throws Exception {
    util.createTable(tn, FAMILY);
    args.put(ImportTsv.DRY_RUN_CONF_KEY, ""true"");
    doMROnTableTest(null, 1);
    // Dry mode should not delete an existing table. If it's not present,
    // this will throw TableNotFoundException.
    util.deleteTable(tn);
  }",No Smells
"@Test
  public void testSetInputSetsSnapshotToScans() throws Exception {

    callSetInput();

    Map<String, Collection<Scan>> actual = subject.getSnapshotsToScans(conf);

    // convert to scans we can use .equals on
    Map<String, Collection<ScanWithEquals>> actualWithEquals = toScanWithEquals(actual);
    Map<String, Collection<ScanWithEquals>> expectedWithEquals = toScanWithEquals(snapshotScans);

    assertEquals(expectedWithEquals, actualWithEquals);
  }",Eager Test
"@Test
  public void testDisabled() throws Exception {
    String regionName = ""cz.goout:/index.html"";
    RegionLocator table = mockRegionLocator(regionName);

    Admin admin = mockAdmin(mockRegion(regionName, 999, 888));

    // first request on enabled calculator
    RegionSizeCalculator calculator = new RegionSizeCalculator(table, admin);
    assertEquals((999 + 888) * megabyte, calculator.getRegionSize(Bytes.toBytes(regionName)));

    // then disabled calculator.
    configuration.setBoolean(RegionSizeCalculator.ENABLE_REGIONSIZECALCULATOR, false);
    RegionSizeCalculator disabledCalculator = new RegionSizeCalculator(table, admin);
    assertEquals(0, disabledCalculator.getRegionSize(Bytes.toBytes(regionName)));
    assertEquals(0, disabledCalculator.getRegionSizeMap().size());
  }",No Smells
"@Test
  public void testLargeRegion() throws Exception {

    RegionLocator regionLocator = mockRegionLocator(""largeRegion"");

    Admin admin = mockAdmin(mockRegion(""largeRegion"", Integer.MAX_VALUE, Integer.MAX_VALUE));

    RegionSizeCalculator calculator = new RegionSizeCalculator(regionLocator, admin);

    assertEquals(((long) Integer.MAX_VALUE) * 2L * megabyte,
      calculator.getRegionSize(Bytes.toBytes(""largeRegion"")));
  }",No Smells
"@Test
  public void testSyncTableDoDeletesFalse() throws Exception {
    final TableName sourceTableName = TableName.valueOf(name.getMethodName() + ""_source"");
    final TableName targetTableName = TableName.valueOf(name.getMethodName() + ""_target"");
    Path testDir = UTIL1.getDataTestDirOnTestFS(name.getMethodName());

    writeTestData(UTIL1, sourceTableName, UTIL1, targetTableName);
    hashSourceTable(UTIL1, sourceTableName, testDir);
    Counters syncCounters = syncTables(UTIL1.getConfiguration(), sourceTableName, targetTableName,
      testDir, ""--doDeletes=false"");
    assertTargetDoDeletesFalse(100, UTIL1, sourceTableName, UTIL1, targetTableName);

    assertEquals(60, syncCounters.findCounter(Counter.ROWSWITHDIFFS).getValue());
    assertEquals(10, syncCounters.findCounter(Counter.SOURCEMISSINGROWS).getValue());
    assertEquals(10, syncCounters.findCounter(Counter.TARGETMISSINGROWS).getValue());
    assertEquals(50, syncCounters.findCounter(Counter.SOURCEMISSINGCELLS).getValue());
    assertEquals(50, syncCounters.findCounter(Counter.TARGETMISSINGCELLS).getValue());
    assertEquals(20, syncCounters.findCounter(Counter.DIFFERENTCELLVALUES).getValue());

    UTIL1.deleteTable(sourceTableName);
    UTIL1.deleteTable(targetTableName);
  }",No Smells
"@Test
  public void testDeprecatedExtensionOfTableInputFormatBase() throws IOException {
    LOG.info(
      ""testing use of an InputFormat taht extends InputFormatBase, "" + ""as it was given in 0.98."");
    final Table table = createTable(Bytes.toBytes(""exampleDeprecatedTable""),
      new byte[][] { Bytes.toBytes(""columnA""), Bytes.toBytes(""columnB"") }",No Smells
"@Test
  public void testExtensionOfTableInputFormatBase() throws IOException {
    LOG.info(""testing use of an InputFormat taht extends InputFormatBase"");
    final Table table = createTable(Bytes.toBytes(""exampleTable""),
      new byte[][] { Bytes.toBytes(""columnA""), Bytes.toBytes(""columnB"") }",No Smells
"@Test
  public void testHashCode_length() {
    TableSplit split1 = new TableSplit(TableName.valueOf(name.getMethodName()),
      Bytes.toBytes(""row-start""), Bytes.toBytes(""row-end""), ""location"", 1984);
    TableSplit split2 = new TableSplit(TableName.valueOf(name.getMethodName()),
      Bytes.toBytes(""row-start""), Bytes.toBytes(""row-end""), ""location"", 1982);

    assertEquals(split1, split2);
    assertTrue(split1.hashCode() == split2.hashCode());
    HashSet<TableSplit> set = new HashSet<>(2);
    set.add(split1);
    set.add(split2);
    assertEquals(1, set.size());
  }",Eager Test
"@Test
  public void testAssignWithGoodExec() throws Exception {
    // collect AM metrics before test
    collectAssignmentManagerMetrics();

    testAssign(new GoodRsExecutor());

    assertEquals(assignSubmittedCount + NREGIONS,
      assignProcMetrics.getSubmittedCounter().getCount());
    assertEquals(assignFailedCount, assignProcMetrics.getFailedCounter().getCount());
  }",No Smells
"@Test
  public void testUnassignAnUnassignedRegion() throws Exception {
    final TableName tableName = TableName.valueOf(""testUnassignAnUnassignedRegion"");
    final RegionInfo hri = createRegionInfo(tableName, 1);

    // collect AM metrics before test
    collectAssignmentManagerMetrics();

    rsDispatcher.setMockRsExecutor(new GoodRsExecutor());

    // assign the region first
    waitOnFuture(submitProcedure(createAssignProcedure(hri)));

    final Future<byte[]> futureA = submitProcedure(createUnassignProcedure(hri));

    // Wait first unassign.
    waitOnFuture(futureA);
    am.getRegionStates().isRegionInState(hri, State.CLOSED);
    // Second should be a noop. We should recognize region is already CLOSED internally
    // and skip out doing nothing.
    final Future<byte[]> futureB = submitProcedure(createUnassignProcedure(hri));
    waitOnFuture(futureB);
    // Ensure we are still CLOSED.
    am.getRegionStates().isRegionInState(hri, State.CLOSED);
    // TODO: What else can we do to ensure just a noop.

    assertEquals(assignSubmittedCount + 1, assignProcMetrics.getSubmittedCounter().getCount());
    assertEquals(assignFailedCount, assignProcMetrics.getFailedCounter().getCount());
    // TODO: Though second unassign is noop, it's considered success, can noop be handled in a
    // better way?
    assertEquals(unassignSubmittedCount + 2, unassignProcMetrics.getSubmittedCounter().getCount());
    assertEquals(unassignFailedCount, unassignProcMetrics.getFailedCounter().getCount());
  }",No Smells
"@Test
  public void testMergeTwoRegions() throws Exception {
    final TableName tableName = TableName.valueOf(this.name.getMethodName());
    UTIL.createTable(tableName, new byte[][] { HConstants.CATALOG_FAMILY }",Eager Test
"@Test
  public void testInvalidSplitKey() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    RegionInfo[] regions = MasterProcedureTestingUtility.createTable(procExec, tableName, null,
      columnFamilyName1, columnFamilyName2);
    insertData(UTIL, tableName, rowCount, startRowNum, columnFamilyName1, columnFamilyName2);

    assertTrue(""not able to find a splittable region"", regions != null);
    assertTrue(""not able to find a splittable region"", regions.length == 1);

    // collect AM metrics before test
    collectAssignmentManagerMetrics();

    // Split region of the table with null split key
    try {
      long procId1 = procExec.submitProcedure(
        new SplitTableRegionProcedure(procExec.getEnvironment(), regions[0], null));
      ProcedureTestingUtility.waitProcedure(procExec, procId1);
      fail(""unexpected procedure start with invalid split-key"");
    }",Eager Test + Redundent Print
"@Test
  public void testRecoveryAndDoubleExecution() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    RegionInfo[] regions = MasterProcedureTestingUtility.createTable(procExec, tableName, null,
      columnFamilyName1, columnFamilyName2);
    insertData(UTIL, tableName, rowCount, startRowNum, columnFamilyName1, columnFamilyName2);
    int splitRowNum = startRowNum + rowCount / 2;
    byte[] splitKey = Bytes.toBytes("""" + splitRowNum);

    assertTrue(""not able to find a splittable region"", regions != null);
    assertTrue(""not able to find a splittable region"", regions.length == 1);
    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    ProcedureTestingUtility.setKillIfHasParent(procExec, false);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec, true);

    // collect AM metrics before test
    collectAssignmentManagerMetrics();

    // Split region of the table
    long procId = procExec.submitProcedure(
      new SplitTableRegionProcedure(procExec.getEnvironment(), regions[0], splitKey));

    // Restart the executor and execute the step twice
    MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec, procId);
    ProcedureTestingUtility.assertProcNotFailed(procExec, procId);

    verify(tableName, splitRowNum);

    assertEquals(splitSubmittedCount + 1, splitProcMetrics.getSubmittedCounter().getCount());
    assertEquals(splitFailedCount, splitProcMetrics.getFailedCounter().getCount());
  }",Eager Test + Redundent Print
"@Test
  public void testSplitWithoutPONR() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    RegionInfo[] regions = MasterProcedureTestingUtility.createTable(procExec, tableName, null,
      columnFamilyName1, columnFamilyName2);
    insertData(UTIL, tableName, rowCount, startRowNum, columnFamilyName1, columnFamilyName2);
    int splitRowNum = startRowNum + rowCount / 2;
    byte[] splitKey = Bytes.toBytes("""" + splitRowNum);

    assertTrue(""not able to find a splittable region"", regions != null);
    assertTrue(""not able to find a splittable region"", regions.length == 1);
    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec, true);

    // Split region of the table
    long procId = procExec.submitProcedure(
      new SplitTableRegionProcedure(procExec.getEnvironment(), regions[0], splitKey));

    // Execute until step 7 of split procedure
    // NOTE: the 7 (number after SPLIT_TABLE_REGION_UPDATE_META step)
    MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec, procId, 7, false);

    // Unset Toggle Kill and make ProcExec work correctly
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec, false);
    MasterProcedureTestingUtility.restartMasterProcedureExecutor(procExec);
    ProcedureTestingUtility.waitProcedure(procExec, procId);

    // Even split failed after step 4, it should still works fine
    verify(tableName, splitRowNum);
  }",Eager Test + Redundent Print
"@Test
  public void testClusterRegionLocations() {
    // tests whether region locations are handled correctly in Cluster
    List<ServerName> servers = getListOfServerNames(randomServers(10, 10));
    List<RegionInfo> regions = randomRegions(101);
    Map<ServerName, List<RegionInfo>> clusterState = new HashMap<>();

    assignRegions(regions, servers, clusterState);

    // mock block locality for some regions
    RegionHDFSBlockLocationFinder locationFinder = mock(RegionHDFSBlockLocationFinder.class);
    // block locality: region:0 => {server:0}",Eager Test
"@Test
  public void testRandomAssignment() throws Exception {
    for (int i = 1; i != 5; ++i) {
      LOG.info(""run testRandomAssignment() with idle servers:"" + i);
      testRandomAssignment(i);
    }",Eager Test
"@Test
  public void testRegionAvailability() throws Exception {
    // Create a cluster with a few servers, assign them to specific racks
    // then assign some regions. The tests should check whether moving a
    // replica from one node to a specific other node or rack lowers the
    // availability of the region or not

    List<RegionInfo> list0 = new ArrayList<>();
    List<RegionInfo> list1 = new ArrayList<>();
    List<RegionInfo> list2 = new ArrayList<>();
    // create a region (region1)
    RegionInfo hri1 = RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName()))
      .setStartKey(Bytes.toBytes(""key1"")).setEndKey(Bytes.toBytes(""key2"")).setSplit(false)
      .setRegionId(100).build();
    // create a replica of the region (replica_of_region1)
    RegionInfo hri2 = RegionReplicaUtil.getRegionInfoForReplica(hri1, 1);
    // create a second region (region2)
    RegionInfo hri3 = RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName()))
      .setStartKey(Bytes.toBytes(""key2"")).setEndKey(Bytes.toBytes(""key3"")).setSplit(false)
      .setRegionId(101).build();
    list0.add(hri1); // only region1
    list1.add(hri2); // only replica_of_region1
    list2.add(hri3); // only region2
    Map<ServerName, List<RegionInfo>> clusterState = new LinkedHashMap<>();
    clusterState.put(servers[0], list0); // servers[0] hosts region1
    clusterState.put(servers[1], list1); // servers[1] hosts replica_of_region1
    clusterState.put(servers[2], list2); // servers[2] hosts region2
    // create a cluster with the above clusterState. The way in which the
    // cluster is created (constructor code) would make sure the indices of
    // the servers are in the order in which it is inserted in the clusterState
    // map (linkedhashmap is important). A similar thing applies to the region lists
    BalancerClusterState cluster = new BalancerClusterState(clusterState, null, null, rackManager);
    // check whether a move of region1 from servers[0] to servers[1] would lower
    // the availability of region1
    assertTrue(cluster.wouldLowerAvailability(hri1, servers[1]));
    // check whether a move of region1 from servers[0] to servers[2] would lower
    // the availability of region1
    assertTrue(!cluster.wouldLowerAvailability(hri1, servers[2]));
    // check whether a move of replica_of_region1 from servers[0] to servers[2] would lower
    // the availability of replica_of_region1
    assertTrue(!cluster.wouldLowerAvailability(hri2, servers[2]));
    // check whether a move of region2 from servers[0] to servers[1] would lower
    // the availability of region2
    assertTrue(!cluster.wouldLowerAvailability(hri3, servers[1]));

    // now lets have servers[1] host replica_of_region2
    list1.add(RegionReplicaUtil.getRegionInfoForReplica(hri3, 1));
    // create a new clusterState with the above change
    cluster = new BalancerClusterState(clusterState, null, null, rackManager);
    // now check whether a move of a replica from servers[0] to servers[1] would lower
    // the availability of region2
    assertTrue(cluster.wouldLowerAvailability(hri3, servers[1]));

    // start over again
    clusterState.clear();
    clusterState.put(servers[0], list0); // servers[0], rack1 hosts region1
    clusterState.put(servers[5], list1); // servers[5], rack2 hosts replica_of_region1 and
                                         // replica_of_region2
    clusterState.put(servers[6], list2); // servers[6], rack2 hosts region2
    clusterState.put(servers[10], new ArrayList<>()); // servers[10], rack3 hosts no region
    // create a cluster with the above clusterState
    cluster = new BalancerClusterState(clusterState, null, null, rackManager);
    // check whether a move of region1 from servers[0],rack1 to servers[6],rack2 would
    // lower the availability

    assertTrue(cluster.wouldLowerAvailability(hri1, servers[0]));

    // now create a cluster without the rack manager
    cluster = new BalancerClusterState(clusterState, null, null, null);
    // now repeat check whether a move of region1 from servers[0] to servers[6] would
    // lower the availability
    assertTrue(!cluster.wouldLowerAvailability(hri1, servers[6]));
  }",Eager Test
"@Test
  public void testRegionAvailabilityWithRegionMoves() throws Exception {
    List<RegionInfo> list0 = new ArrayList<>();
    List<RegionInfo> list1 = new ArrayList<>();
    List<RegionInfo> list2 = new ArrayList<>();
    // create a region (region1)
    RegionInfo hri1 = RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName()))
      .setStartKey(Bytes.toBytes(""key1"")).setEndKey(Bytes.toBytes(""key2"")).setSplit(false)
      .setRegionId(100).build();
    // create a replica of the region (replica_of_region1)
    RegionInfo hri2 = RegionReplicaUtil.getRegionInfoForReplica(hri1, 1);
    // create a second region (region2)
    RegionInfo hri3 = RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName()))
      .setStartKey(Bytes.toBytes(""key2"")).setEndKey(Bytes.toBytes(""key3"")).setSplit(false)
      .setRegionId(101).build();
    list0.add(hri1); // only region1
    list1.add(hri2); // only replica_of_region1
    list2.add(hri3); // only region2
    Map<ServerName, List<RegionInfo>> clusterState = new LinkedHashMap<>();
    clusterState.put(servers[0], list0); // servers[0] hosts region1
    clusterState.put(servers[1], list1); // servers[1] hosts replica_of_region1
    clusterState.put(servers[2], list2); // servers[2] hosts region2
    // create a cluster with the above clusterState. The way in which the
    // cluster is created (constructor code) would make sure the indices of
    // the servers are in the order in which it is inserted in the clusterState
    // map (linkedhashmap is important).
    BalancerClusterState cluster = new BalancerClusterState(clusterState, null, null, rackManager);
    // check whether moving region1 from servers[1] to servers[2] would lower availability
    assertTrue(!cluster.wouldLowerAvailability(hri1, servers[2]));

    // now move region1 from servers[0] to servers[2]
    cluster.doAction(new MoveRegionAction(0, 0, 2));
    // now repeat check whether moving region1 from servers[1] to servers[2]
    // would lower availability
    assertTrue(cluster.wouldLowerAvailability(hri1, servers[2]));

    // start over again
    clusterState.clear();
    List<RegionInfo> list3 = new ArrayList<>();
    RegionInfo hri4 = RegionReplicaUtil.getRegionInfoForReplica(hri3, 1);
    list3.add(hri4);
    clusterState.put(servers[0], list0); // servers[0], rack1 hosts region1
    clusterState.put(servers[5], list1); // servers[5], rack2 hosts replica_of_region1
    clusterState.put(servers[6], list2); // servers[6], rack2 hosts region2
    clusterState.put(servers[12], list3); // servers[12], rack3 hosts replica_of_region2
    // create a cluster with the above clusterState
    cluster = new BalancerClusterState(clusterState, null, null, rackManager);
    // check whether a move of replica_of_region2 from servers[12],rack3 to servers[0],rack1 would
    // lower the availability
    assertTrue(!cluster.wouldLowerAvailability(hri4, servers[0]));
    // now move region2 from servers[6],rack2 to servers[0],rack1
    cluster.doAction(new MoveRegionAction(2, 2, 0));
    // now repeat check if replica_of_region2 from servers[12],rack3 to servers[0],rack1 would
    // lower the availability
    assertTrue(cluster.wouldLowerAvailability(hri3, servers[0]));
  }",Eager Test
"@Test
  public void testBalanceCluster() throws Exception {
    // Test with/without per table balancer.
    boolean[] perTableBalancerConfigs = { true, false }",No Smells
"@Test
  public void testBulkAssignment() throws Exception {
    List<RegionInfo> regions = randomRegions(25);
    Map<ServerName, List<RegionInfo>> assignments =
      loadBalancer.roundRobinAssignment(regions, servers);
    // test empty region/servers scenario
    // this should not throw an NPE
    loadBalancer.roundRobinAssignment(regions, Collections.emptyList());
    // test regular scenario
    assertTrue(assignments.keySet().size() == servers.size());
    for (ServerName sn : assignments.keySet()) {
      List<RegionInfo> regionAssigned = assignments.get(sn);
      for (RegionInfo region : regionAssigned) {
        TableName tableName = region.getTable();
        String groupName =
          tableDescs.get(tableName).getRegionServerGroup().orElse(RSGroupInfo.DEFAULT_GROUP);
        assertTrue(StringUtils.isNotEmpty(groupName));
        RSGroupInfo gInfo = getMockedGroupInfoManager().getRSGroup(groupName);
        assertTrue(""Region is not correctly assigned to group servers."",
          gInfo.containsServer(sn.getAddress()));
      }",Eager Test
"@Test
  public void testRetainAssignment() throws Exception {
    // Test simple case where all same servers are there
    Map<ServerName, List<RegionInfo>> currentAssignments = mockClusterServers();
    Map<RegionInfo, ServerName> inputForTest = new HashMap<>();
    for (ServerName sn : currentAssignments.keySet()) {
      for (RegionInfo region : currentAssignments.get(sn)) {
        inputForTest.put(region, sn);
      }",Eager Test
"@Test
  public void testCPRequestCost() {
    // in order to pass needsBalance judgement
    conf.setFloat(""hbase.master.balancer.stochastic.cpRequestCost"", 10000f);
    loadBalancer.onConfigurationChange(conf);
    // mock cluster State
    Map<ServerName, List<RegionInfo>> clusterState = new HashMap<ServerName, List<RegionInfo>>();
    ServerName serverA = randomServer(3).getServerName();
    ServerName serverB = randomServer(3).getServerName();
    ServerName serverC = randomServer(3).getServerName();
    List<RegionInfo> regionsOnServerA = randomRegions(3);
    List<RegionInfo> regionsOnServerB = randomRegions(3);
    List<RegionInfo> regionsOnServerC = randomRegions(3);
    clusterState.put(serverA, regionsOnServerA);
    clusterState.put(serverB, regionsOnServerB);
    clusterState.put(serverC, regionsOnServerC);
    // mock ClusterMetrics
    Map<ServerName, ServerMetrics> serverMetricsMap = new TreeMap<>();
    serverMetricsMap.put(serverA, mockServerMetricsWithCpRequests(regionsOnServerA, 0));
    serverMetricsMap.put(serverB, mockServerMetricsWithCpRequests(regionsOnServerB, 0));
    serverMetricsMap.put(serverC, mockServerMetricsWithCpRequests(regionsOnServerC, 0));
    ClusterMetrics clusterStatus = mock(ClusterMetrics.class);
    when(clusterStatus.getLiveServerMetrics()).thenReturn(serverMetricsMap);
    loadBalancer.updateClusterMetrics(clusterStatus);

    // CPRequestCostFunction are Rate based, So doing setClusterMetrics again
    // this time, regions on serverA with more cpRequestCount load
    // serverA : 1000,1000,1000
    // serverB : 0,0,0
    // serverC : 0,0,0
    // so should move two regions from serverA to serverB & serverC
    serverMetricsMap = new TreeMap<>();
    serverMetricsMap.put(serverA, mockServerMetricsWithCpRequests(regionsOnServerA, 1000));
    serverMetricsMap.put(serverB, mockServerMetricsWithCpRequests(regionsOnServerB, 0));
    serverMetricsMap.put(serverC, mockServerMetricsWithCpRequests(regionsOnServerC, 0));
    clusterStatus = mock(ClusterMetrics.class);
    when(clusterStatus.getLiveServerMetrics()).thenReturn(serverMetricsMap);
    loadBalancer.updateClusterMetrics(clusterStatus);

    List<RegionPlan> plans =
      loadBalancer.balanceTable(HConstants.ENSEMBLE_TABLE_NAME, clusterState);
    Set<RegionInfo> regionsMoveFromServerA = new HashSet<>();
    Set<ServerName> targetServers = new HashSet<>();
    for (RegionPlan plan : plans) {
      if (plan.getSource().equals(serverA)) {
        regionsMoveFromServerA.add(plan.getRegionInfo());
        targetServers.add(plan.getDestination());
      }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testMinimumNumberOfThreads() throws Exception {
    Configuration conf = UTIL.getConfiguration();
    String confKey = ""hbase.test.cleaner.delegates"";
    conf.set(confKey, AlwaysDelete.class.getName());
    conf.set(CleanerChore.CHORE_POOL_SIZE, ""2"");
    int numProcs = Runtime.getRuntime().availableProcessors();
    // Sanity
    assertEquals(numProcs, CleanerChore.calculatePoolSize(Integer.toString(numProcs)));
    // The implementation does not allow us to set more threads than we have processors
    assertEquals(numProcs, CleanerChore.calculatePoolSize(Integer.toString(numProcs + 2)));
    // Force us into the branch that is multiplying 0.0 against the number of processors
    assertEquals(1, CleanerChore.calculatePoolSize(""0.0""));
  }",Eager Test + Mystery Guest
"@Test
  public void testStoppedCleanerDoesNotDeleteFiles() throws Exception {
    Stoppable stop = new StoppableImplementation();
    Configuration conf = UTIL.getConfiguration();
    Path testDir = UTIL.getDataTestDir();
    FileSystem fs = UTIL.getTestFileSystem();
    String confKey = ""hbase.test.cleaner.delegates"";
    conf.set(confKey, AlwaysDelete.class.getName());

    AllValidPaths chore =
      new AllValidPaths(""test-file-cleaner"", stop, conf, fs, testDir, confKey, POOL);

    // also create a file in the top level directory
    Path topFile = new Path(testDir, ""topFile"");
    fs.create(topFile).close();
    assertTrue(""Test file didn't get created."", fs.exists(topFile));

    // stop the chore
    stop.stop(""testing stop"");

    // run the chore
    chore.chore();

    // test that the file still exists
    assertTrue(""File got deleted while chore was stopped"", fs.exists(topFile));
  }",Eager Test + Mystery Guest
"@Test
  public void testOnConfigurationChange() throws Exception {
    // constants
    final int ORIGINAL_THROTTLE_POINT = 512 * 1024;
    final int ORIGINAL_QUEUE_INIT_SIZE = 512;
    final int UPDATE_THROTTLE_POINT = 1024;// small enough to change large/small check
    final int UPDATE_QUEUE_INIT_SIZE = 1024;
    final int LARGE_FILE_NUM = 5;
    final int SMALL_FILE_NUM = 20;
    final int LARGE_THREAD_NUM = 2;
    final int SMALL_THREAD_NUM = 4;
    final long THREAD_TIMEOUT_MSEC = 30 * 1000L;
    final long THREAD_CHECK_INTERVAL_MSEC = 500L;

    Configuration conf = UTIL.getConfiguration();
    // no cleaner policies = delete all files
    conf.setStrings(HFileCleaner.MASTER_HFILE_CLEANER_PLUGINS, """");
    conf.setInt(HFileCleaner.HFILE_DELETE_THROTTLE_THRESHOLD, ORIGINAL_THROTTLE_POINT);
    conf.setInt(HFileCleaner.LARGE_HFILE_QUEUE_INIT_SIZE, ORIGINAL_QUEUE_INIT_SIZE);
    conf.setInt(HFileCleaner.SMALL_HFILE_QUEUE_INIT_SIZE, ORIGINAL_QUEUE_INIT_SIZE);
    Server server = new DummyServer();
    Path archivedHfileDir =
      new Path(UTIL.getDataTestDirOnTestFS(), HConstants.HFILE_ARCHIVE_DIRECTORY);

    // setup the cleaner
    FileSystem fs = UTIL.getDFSCluster().getFileSystem();
    final HFileCleaner cleaner = new HFileCleaner(1000, server, conf, fs, archivedHfileDir, POOL);
    Assert.assertEquals(ORIGINAL_THROTTLE_POINT, cleaner.getThrottlePoint());
    Assert.assertEquals(ORIGINAL_QUEUE_INIT_SIZE, cleaner.getLargeQueueInitSize());
    Assert.assertEquals(ORIGINAL_QUEUE_INIT_SIZE, cleaner.getSmallQueueInitSize());
    Assert.assertEquals(HFileCleaner.DEFAULT_HFILE_DELETE_THREAD_TIMEOUT_MSEC,
      cleaner.getCleanerThreadTimeoutMsec());
    Assert.assertEquals(HFileCleaner.DEFAULT_HFILE_DELETE_THREAD_CHECK_INTERVAL_MSEC,
      cleaner.getCleanerThreadCheckIntervalMsec());

    // clean up archive directory and create files for testing
    fs.delete(archivedHfileDir, true);
    fs.mkdirs(archivedHfileDir);
    createFilesForTesting(LARGE_FILE_NUM, SMALL_FILE_NUM, fs, archivedHfileDir);

    // call cleaner, run as daemon to test the interrupt-at-middle case
    Thread t = new Thread() {
      @Override
      public void run() {
        cleaner.chore();
      }",Eager Test
"@Test
  public void testRemovesEmptyDirectories() throws Exception {
    Configuration conf = UTIL.getConfiguration();
    // no cleaner policies = delete all files
    conf.setStrings(HFileCleaner.MASTER_HFILE_CLEANER_PLUGINS, """");
    Server server = new DummyServer();
    Path archivedHfileDir =
      new Path(UTIL.getDataTestDirOnTestFS(), HConstants.HFILE_ARCHIVE_DIRECTORY);

    // setup the cleaner
    FileSystem fs = UTIL.getDFSCluster().getFileSystem();
    HFileCleaner cleaner = new HFileCleaner(1000, server, conf, fs, archivedHfileDir, POOL);

    // make all the directories for archiving files
    Path table = new Path(archivedHfileDir, ""table"");
    Path region = new Path(table, ""regionsomthing"");
    Path family = new Path(region, ""fam"");
    Path file = new Path(family, ""file12345"");
    fs.mkdirs(family);
    if (!fs.exists(family)) throw new RuntimeException(""Couldn't create test family:"" + family);
    fs.create(file).close();
    if (!fs.exists(file)) throw new RuntimeException(""Test file didn't get created:"" + file);

    // run the chore to cleanup the files (and the directories above it)
    cleaner.chore();

    // make sure all the parent directories get removed
    assertFalse(""family directory not removed for empty directory"", fs.exists(family));
    assertFalse(""region directory not removed for empty directory"", fs.exists(region));
    assertFalse(""table directory not removed for empty directory"", fs.exists(table));
    assertTrue(""archive directory"", fs.exists(archivedHfileDir));
  }",Eager Test + Mystery Guest
"@Test
  public void testThreadCleanup() throws Exception {
    Configuration conf = UTIL.getConfiguration();
    conf.setStrings(HFileCleaner.MASTER_HFILE_CLEANER_PLUGINS, """");
    Server server = new DummyServer();
    Path archivedHfileDir =
      new Path(UTIL.getDataTestDirOnTestFS(), HConstants.HFILE_ARCHIVE_DIRECTORY);

    // setup the cleaner
    FileSystem fs = UTIL.getDFSCluster().getFileSystem();
    HFileCleaner cleaner = new HFileCleaner(1000, server, conf, fs, archivedHfileDir, POOL);
    // clean up archive directory
    fs.delete(archivedHfileDir, true);
    fs.mkdirs(archivedHfileDir);
    // create some file to delete
    fs.createNewFile(new Path(archivedHfileDir, ""dfd-dfd""));
    // launch the chore
    cleaner.chore();
    // call cleanup
    cleaner.cleanup();
    // wait awhile for thread to die
    Thread.sleep(100);
    for (Thread thread : cleaner.getCleanerThreads()) {
      Assert.assertFalse(thread.isAlive());
    }",Eager Test + Mystery Guest
"@Test
  public void testTTLCleaner() throws IOException {
    FileSystem fs = UTIL.getDFSCluster().getFileSystem();
    Path root = UTIL.getDataTestDirOnTestFS();
    Path file = new Path(root, ""file"");
    fs.createNewFile(file);
    long createTime = EnvironmentEdgeManager.currentTime();
    assertTrue(""Test file not created!"", fs.exists(file));
    TimeToLiveHFileCleaner cleaner = new TimeToLiveHFileCleaner();
    // update the time info for the file, so the cleaner removes it
    fs.setTimes(file, createTime - 100, -1);
    Configuration conf = UTIL.getConfiguration();
    conf.setLong(TimeToLiveHFileCleaner.TTL_CONF_KEY, 100);
    cleaner.setConf(conf);
    assertTrue(""File not set deletable - check mod time:"" + getFileStats(file, fs)
      + "" with create time:"" + createTime, cleaner.isFileDeletable(fs.getFileStatus(file)));
  }",Eager Test + Mystery Guest
"@Test
  public void testNothing() throws IOException {
    ReplicationPeerManager peerManager = mock(ReplicationPeerManager.class);
    ReplicationBarrierCleaner cleaner = create(peerManager);
    cleaner.chore();
    verify(peerManager, never()).getSerialPeerIdsBelongsTo(any(TableName.class));
    verify(peerManager, never()).getQueueStorage();
  }",No Smells
"@Test
  public void testMasterLockAcquireTimeout() throws Exception {
    LockManager.MasterLock lock =
      masterServices.getLockManager().createMasterLock(tableName, LockType.EXCLUSIVE, ""desc"");
    LockManager.MasterLock lock2 =
      masterServices.getLockManager().createMasterLock(tableName, LockType.EXCLUSIVE, ""desc"");
    assertTrue(lock.tryAcquire(2000));
    assertFalse(lock2.tryAcquire(LOCAL_LOCKS_TIMEOUT / 2)); // wait less than other lock's timeout
    assertEquals(null, lock2.getProc());
    lock.release();
    assertTrue(lock2.tryAcquire(2000));
    assertTrue(lock2.getProc().isLocked());
    lock2.release();
  }",Eager Test
"@Test
  public void testMasterLockAcquireTimeoutRegionVsTableExclusive() throws Exception {
    LockManager.MasterLock lock =
      masterServices.getLockManager().createMasterLock(tableRegions, ""desc"");
    LockManager.MasterLock lock2 =
      masterServices.getLockManager().createMasterLock(tableName, LockType.EXCLUSIVE, ""desc"");
    assertTrue(lock.tryAcquire(2000));
    assertFalse(lock2.tryAcquire(LOCAL_LOCKS_TIMEOUT / 2)); // wait less than other lock's timeout
    assertEquals(null, lock2.getProc());
    lock.release();
    assertTrue(lock2.tryAcquire(2000));
    assertTrue(lock2.getProc().isLocked());
    lock2.release();
  }",Eager Test
"@Test
  public void testMergeOfSmallRegions() {
    final TableName tableName = name.getTableName();
    final List<RegionInfo> regionInfos = createRegionInfos(tableName, 5);
    final Map<byte[], Integer> regionSizes = createRegionSizesMap(regionInfos, 15, 5, 5, 15, 16);
    setupMocksForNormalizer(regionSizes, regionInfos);

    assertThat(normalizer.computePlansForTable(tableDescriptor),
      contains(new MergeNormalizationPlan.Builder().addTarget(regionInfos.get(1), 5)
        .addTarget(regionInfos.get(2), 5).build()));
  }",Eager Test
"@Test
  public void testSplitOfLargeRegion() {
    final TableName tableName = name.getTableName();
    final List<RegionInfo> regionInfos = createRegionInfos(tableName, 4);
    final Map<byte[], Integer> regionSizes = createRegionSizesMap(regionInfos, 8, 6, 10, 30);
    setupMocksForNormalizer(regionSizes, regionInfos);

    assertThat(normalizer.computePlansForTable(tableDescriptor),
      contains(new SplitNormalizationPlan(regionInfos.get(3), 30)));
  }",Eager Test
"@Test
  public void testCreateNamespaceWithInvalidRegionCount() throws Exception {
    final NamespaceDescriptor nsd =
      NamespaceDescriptor.create(""testCreateNamespaceWithInvalidRegionCount"").build();
    final String nsKey = ""hbase.namespace.quota.maxregions"";
    final String nsValue = ""-1"";
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    nsd.setConfiguration(nsKey, nsValue);

    long procId =
      procExec.submitProcedure(new CreateNamespaceProcedure(procExec.getEnvironment(), nsd));
    // Wait the completion
    ProcedureTestingUtility.waitProcedure(procExec, procId);
    Procedure<?> result = procExec.getResult(procId);
    assertTrue(result.isFailed());
    LOG.debug(""Create namespace failed with exception: "" + result.getException());
    assertTrue(ProcedureTestingUtility.getExceptionCause(result) instanceof ConstraintException);
  }",Eager Test
"@Test
  public void testCreateSameNamespaceTwice() throws Exception {
    final NamespaceDescriptor nsd =
      NamespaceDescriptor.create(""testCreateSameNamespaceTwice"").build();
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    long procId1 =
      procExec.submitProcedure(new CreateNamespaceProcedure(procExec.getEnvironment(), nsd));
    // Wait the completion
    ProcedureTestingUtility.waitProcedure(procExec, procId1);
    ProcedureTestingUtility.assertProcNotFailed(procExec, procId1);

    // Create the namespace that exists
    long procId2 =
      procExec.submitProcedure(new CreateNamespaceProcedure(procExec.getEnvironment(), nsd));
    // Wait the completion
    ProcedureTestingUtility.waitProcedure(procExec, procId2);

    // Second create should fail with NamespaceExistException
    Procedure<?> result = procExec.getResult(procId2);
    assertTrue(result.isFailed());
    LOG.debug(""Create namespace failed with exception: "" + result.getException());
    assertTrue(
      ProcedureTestingUtility.getExceptionCause(result) instanceof NamespaceExistException);
  }",Eager Test
"@Test
  public void testCreateSystemNamespace() throws Exception {
    final NamespaceDescriptor nsd =
      UTIL.getAdmin().getNamespaceDescriptor(NamespaceDescriptor.SYSTEM_NAMESPACE.getName());
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    long procId =
      procExec.submitProcedure(new CreateNamespaceProcedure(procExec.getEnvironment(), nsd));
    // Wait the completion
    ProcedureTestingUtility.waitProcedure(procExec, procId);
    Procedure<?> result = procExec.getResult(procId);
    assertTrue(result.isFailed());
    LOG.debug(""Create namespace failed with exception: "" + result.getException());
    assertTrue(
      ProcedureTestingUtility.getExceptionCause(result) instanceof NamespaceExistException);
  }",Eager Test
"@Test
  public void testRecoveryAndDoubleExecution() throws Exception {
    final NamespaceDescriptor nsd =
      NamespaceDescriptor.create(""testRecoveryAndDoubleExecution"").build();
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec, true);

    // Start the CreateNamespace procedure && kill the executor
    long procId =
      procExec.submitProcedure(new CreateNamespaceProcedure(procExec.getEnvironment(), nsd));

    // Restart the executor and execute the step twice
    MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec, procId);

    // Validate the creation of namespace
    ProcedureTestingUtility.assertProcNotFailed(procExec, procId);
    validateNamespaceCreated(nsd);
  }",Eager Test
"@Test
  public void testRollbackAndDoubleExecutionOnMobTable() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    TableDescriptor htd = MasterProcedureTestingUtility.createHTD(tableName, F1, F2);
    TableDescriptorBuilder builder =
      TableDescriptorBuilder.newBuilder(htd).modifyColumnFamily(ColumnFamilyDescriptorBuilder
        .newBuilder(htd.getColumnFamily(Bytes.toBytes(F1))).setMobEnabled(true).build());
    testRollbackAndDoubleExecution(builder);
  }",No Smells
"@Test
  public void testSimpleCreateWithSplits() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final byte[][] splitKeys =
      new byte[][] { Bytes.toBytes(""a""), Bytes.toBytes(""b""), Bytes.toBytes(""c"") }",No Smells
"@Test
  public void testDisableTable() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    MasterProcedureTestingUtility.createTable(procExec, tableName, null, ""f1"", ""f2"");

    // Disable the table
    long procId = procExec
      .submitProcedure(new DisableTableProcedure(procExec.getEnvironment(), tableName, false));
    // Wait the completion
    ProcedureTestingUtility.waitProcedure(procExec, procId);
    ProcedureTestingUtility.assertProcNotFailed(procExec, procId);
    MasterProcedureTestingUtility.validateTableIsDisabled(getMaster(), tableName);
  }",Eager Test
"@Test
  public void testCreateDeleteTableOperationsWithReadLock() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final int nitems = 2;

    final TestTableProcedure dummyProc =
      new TestTableProcedure(100, tableName, TableProcedureInterface.TableOperationType.DELETE);

    for (int i = 1; i <= nitems; ++i) {
      queue.addBack(
        new TestTableProcedure(i, tableName, TableProcedureInterface.TableOperationType.READ));
    }",Eager Test
"@Test
  public void testListLocksPeer() throws Exception {
    String peerId = ""1"";
    LockProcedure procedure = createExclusiveLockProcedure(4);
    queue.waitPeerExclusiveLock(procedure, peerId);

    List<LockedResource> locks = queue.getLocks();
    assertEquals(1, locks.size());

    LockedResource resource = locks.get(0);
    assertLockResource(resource, LockedResourceType.PEER, peerId);
    assertExclusiveLock(resource, procedure);
    assertTrue(resource.getWaitingProcedures().isEmpty());

    // Try to acquire the exclusive lock again with same procedure
    assertFalse(queue.waitPeerExclusiveLock(procedure, peerId));

    // Try to acquire the exclusive lock again with new procedure
    LockProcedure procedure2 = createExclusiveLockProcedure(5);
    assertTrue(queue.waitPeerExclusiveLock(procedure2, peerId));

    // Same peerId, still only has 1 LockedResource
    locks = queue.getLocks();
    assertEquals(1, locks.size());

    resource = locks.get(0);
    assertLockResource(resource, LockedResourceType.PEER, peerId);
    // LockedResource owner still is the origin procedure
    assertExclusiveLock(resource, procedure);
    // The new procedure should in the waiting list
    assertEquals(1, resource.getWaitingProcedures().size());
  }",No Smells
"@Test
  public void testRootXLockAndChildrenXLock() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    // simulate 3 procedures: 1 (root), (2) child of root, (3) child of proc-2
    testInheritedXLockAndChildrenXLock(tableName,
      new TestTableProcedure(1, tableName, TableProcedureInterface.TableOperationType.EDIT),
      new TestTableProcedure(1, 1, 2, tableName, TableProcedureInterface.TableOperationType.EDIT),
      new TestTableProcedure(1, 2, 3, tableName, TableProcedureInterface.TableOperationType.EDIT));
  }",No Smells
"@Test
  public void testVerifyNamespaceRwLocks() throws Exception {
    String nsName1 = ""ns1"";
    String nsName2 = ""ns2"";
    TableName tableName1 = TableName.valueOf(nsName1, name.getMethodName());
    TableName tableName2 = TableName.valueOf(nsName2, name.getMethodName());
    queue.addBack(
      new TestNamespaceProcedure(1, nsName1, TableProcedureInterface.TableOperationType.EDIT));
    queue.addBack(
      new TestTableProcedure(2, tableName1, TableProcedureInterface.TableOperationType.EDIT));
    queue.addBack(
      new TestTableProcedure(3, tableName2, TableProcedureInterface.TableOperationType.EDIT));
    queue.addBack(
      new TestNamespaceProcedure(4, nsName2, TableProcedureInterface.TableOperationType.EDIT));

    // Fetch the 1st item and take the write lock
    Procedure<?> procNs1 = queue.poll();
    assertEquals(1, procNs1.getProcId());
    assertFalse(queue.waitNamespaceExclusiveLock(procNs1, nsName1));

    // namespace table has higher priority so we still return procedure for it
    Procedure<?> procNs2 = queue.poll();
    assertEquals(4, procNs2.getProcId());
    assertFalse(queue.waitNamespaceExclusiveLock(procNs2, nsName2));
    queue.wakeNamespaceExclusiveLock(procNs2, nsName2);

    // add procNs2 back in the queue
    queue.yield(procNs2);

    // again
    procNs2 = queue.poll();
    assertEquals(4, procNs2.getProcId());
    assertFalse(queue.waitNamespaceExclusiveLock(procNs2, nsName2));

    // ns1 and ns2 are both locked so we get nothing
    assertNull(queue.poll());

    // release the ns1 lock
    queue.wakeNamespaceExclusiveLock(procNs1, nsName1);

    // we are now able to execute table of ns1
    long procId = queue.poll().getProcId();
    assertEquals(2, procId);

    // release ns2
    queue.wakeNamespaceExclusiveLock(procNs2, nsName2);

    // we are now able to execute table of ns2
    procId = queue.poll().getProcId();
    assertEquals(3, procId);
  }",Eager Test
"@Test
  public void testVerifyRegionLocks() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final RegionInfo regionA = RegionInfoBuilder.newBuilder(tableName)
      .setStartKey(Bytes.toBytes(""a"")).setEndKey(Bytes.toBytes(""b"")).build();
    final RegionInfo regionB = RegionInfoBuilder.newBuilder(tableName)
      .setStartKey(Bytes.toBytes(""b"")).setEndKey(Bytes.toBytes(""c"")).build();
    final RegionInfo regionC = RegionInfoBuilder.newBuilder(tableName)
      .setStartKey(Bytes.toBytes(""c"")).setEndKey(Bytes.toBytes(""d"")).build();

    queue.addBack(
      new TestTableProcedure(1, tableName, TableProcedureInterface.TableOperationType.EDIT));
    queue.addBack(new TestRegionProcedure(2, tableName,
      TableProcedureInterface.TableOperationType.REGION_MERGE, regionA, regionB));
    queue.addBack(new TestRegionProcedure(3, tableName,
      TableProcedureInterface.TableOperationType.REGION_SPLIT, regionA));
    queue.addBack(new TestRegionProcedure(4, tableName,
      TableProcedureInterface.TableOperationType.REGION_SPLIT, regionB));
    queue.addBack(new TestRegionProcedure(5, tableName,
      TableProcedureInterface.TableOperationType.REGION_UNASSIGN, regionC));

    // Fetch the 1st item and take the write lock
    Procedure<?> proc = queue.poll();
    assertEquals(1, proc.getProcId());
    assertEquals(false, queue.waitTableExclusiveLock(proc, tableName));

    // everything is locked by the table operation
    assertEquals(null, queue.poll(0));

    // release the table lock
    queue.wakeTableExclusiveLock(proc, tableName);

    // Fetch the 2nd item and the the lock on regionA and regionB
    Procedure<?> mergeProc = queue.poll();
    assertEquals(2, mergeProc.getProcId());
    assertEquals(false, queue.waitRegions(mergeProc, tableName, regionA, regionB));

    // Fetch the 3rd item and the try to lock region A which will fail
    // because already locked. this procedure will go in waiting.
    // (this stuff will be explicit until we get rid of the zk-lock)
    Procedure<?> procA = queue.poll();
    assertEquals(3, procA.getProcId());
    assertEquals(true, queue.waitRegions(procA, tableName, regionA));

    // Fetch the 4th item, same story as the 3rd
    Procedure<?> procB = queue.poll();
    assertEquals(4, procB.getProcId());
    assertEquals(true, queue.waitRegions(procB, tableName, regionB));

    // Fetch the 5th item, since it is a non-locked region we are able to execute it
    Procedure<?> procC = queue.poll();
    assertEquals(5, procC.getProcId());
    assertEquals(false, queue.waitRegions(procC, tableName, regionC));

    // 3rd and 4th are in the region suspended queue
    assertEquals(null, queue.poll(0));

    // Release region A-B from merge operation (procId=2)
    queue.wakeRegions(mergeProc, tableName, regionA, regionB);

    // Fetch the 3rd item, now the lock on the region is available
    procA = queue.poll();
    assertEquals(3, procA.getProcId());
    assertEquals(false, queue.waitRegions(procA, tableName, regionA));

    // Fetch the 4th item, now the lock on the region is available
    procB = queue.poll();
    assertEquals(4, procB.getProcId());
    assertEquals(false, queue.waitRegions(procB, tableName, regionB));

    // release the locks on the regions
    queue.wakeRegions(procA, tableName, regionA);
    queue.wakeRegions(procB, tableName, regionB);
    queue.wakeRegions(procC, tableName, regionC);
  }",Eager Test
"@Test
  public void testVerifyRwLocks() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    queue.addBack(
      new TestTableProcedure(1, tableName, TableProcedureInterface.TableOperationType.EDIT));
    queue.addBack(
      new TestTableProcedure(2, tableName, TableProcedureInterface.TableOperationType.READ));
    queue.addBack(
      new TestTableProcedure(3, tableName, TableProcedureInterface.TableOperationType.EDIT));

    // Fetch the 1st item and take the write lock
    Procedure<?> proc = queue.poll();
    assertEquals(1, proc.getProcId());
    assertEquals(false, queue.waitTableExclusiveLock(proc, tableName));

    // Fetch the 2nd item and verify that the lock can't be acquired
    assertEquals(null, queue.poll(0));

    // Release the write lock and acquire the read lock
    releaseTableExclusiveLockAndComplete(proc, tableName);

    // Fetch the 2nd item and take the read lock
    Procedure<?> rdProc = queue.poll();
    assertEquals(2, rdProc.getProcId());
    assertEquals(false, queue.waitTableSharedLock(rdProc, tableName));

    // Fetch the 3rd item and verify that the lock can't be acquired
    assertEquals(null, queue.poll(0));

    // release the rdlock of item 2 and take the wrlock for the 3d item
    queue.wakeTableSharedLock(rdProc, tableName);

    queue.addBack(
      new TestTableProcedure(4, tableName, TableProcedureInterface.TableOperationType.READ));
    queue.addBack(
      new TestTableProcedure(5, tableName, TableProcedureInterface.TableOperationType.READ));

    // Fetch the 3rd item and take the write lock
    Procedure<?> wrProc = queue.poll();
    assertEquals(false, queue.waitTableExclusiveLock(wrProc, tableName));

    // Fetch 4th item and verify that the lock can't be acquired
    assertEquals(null, queue.poll(0));

    // Release the write lock and acquire the read lock
    releaseTableExclusiveLockAndComplete(wrProc, tableName);

    // Fetch the 4th item and take the read lock
    rdProc = queue.poll();
    assertEquals(4, rdProc.getProcId());
    assertEquals(false, queue.waitTableSharedLock(rdProc, tableName));

    // Fetch the 4th item and take the read lock
    Procedure<?> rdProc2 = queue.poll();
    assertEquals(5, rdProc2.getProcId());
    assertEquals(false, queue.waitTableSharedLock(rdProc2, tableName));

    // Release 4th and 5th read-lock
    queue.wakeTableSharedLock(rdProc, tableName);
    queue.wakeTableSharedLock(rdProc2, tableName);

    // remove table queue
    assertEquals(0, queue.size());
    assertTrue(""queue should be deleted"", queue.markTableAsDeleted(tableName, wrProc));
  }",Eager Test
"@Test
  public void testVerifySubProcRegionLocks() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final RegionInfo regionA = RegionInfoBuilder.newBuilder(tableName)
      .setStartKey(Bytes.toBytes(""a"")).setEndKey(Bytes.toBytes(""b"")).build();
    final RegionInfo regionB = RegionInfoBuilder.newBuilder(tableName)
      .setStartKey(Bytes.toBytes(""b"")).setEndKey(Bytes.toBytes(""c"")).build();
    final RegionInfo regionC = RegionInfoBuilder.newBuilder(tableName)
      .setStartKey(Bytes.toBytes(""c"")).setEndKey(Bytes.toBytes(""d"")).build();

    queue.addBack(
      new TestTableProcedure(1, tableName, TableProcedureInterface.TableOperationType.ENABLE));

    // Fetch the 1st item from the queue, ""the root procedure"" and take the table lock
    Procedure<?> rootProc = queue.poll();
    assertEquals(1, rootProc.getProcId());
    assertEquals(false, queue.waitTableExclusiveLock(rootProc, tableName));
    assertEquals(null, queue.poll(0));

    // Execute the 1st step of the root-proc.
    // we should get 3 sub-proc back, one for each region.
    // (this step is done by the executor/rootProc, we are simulating it)
    Procedure<?>[] subProcs = new Procedure[] {
      new TestRegionProcedure(1, 2, tableName,
        TableProcedureInterface.TableOperationType.REGION_EDIT, regionA),
      new TestRegionProcedure(1, 3, tableName,
        TableProcedureInterface.TableOperationType.REGION_EDIT, regionB),
      new TestRegionProcedure(1, 4, tableName,
        TableProcedureInterface.TableOperationType.REGION_EDIT, regionC), }",Eager Test
"@Test
  public void testYieldWithSharedLockHeld() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());

    queue.addBack(
      new TestTableProcedure(1, tableName, TableProcedureInterface.TableOperationType.READ));
    queue.addBack(
      new TestTableProcedure(2, tableName, TableProcedureInterface.TableOperationType.READ));
    queue.addBack(
      new TestTableProcedure(3, tableName, TableProcedureInterface.TableOperationType.EDIT));

    // fetch and acquire the first shared-lock
    Procedure<?> proc1 = queue.poll();
    assertEquals(1, proc1.getProcId());
    assertEquals(false, queue.waitTableSharedLock(proc1, tableName));

    // fetch and acquire the second shared-lock
    Procedure<?> proc2 = queue.poll();
    assertEquals(2, proc2.getProcId());
    assertEquals(false, queue.waitTableSharedLock(proc2, tableName));

    // nothing available, until xlock release
    assertEquals(null, queue.poll(0));

    // put the procs back in the queue
    queue.yield(proc1);
    queue.yield(proc2);

    // fetch from the queue, it should fetch the ones with just added back
    proc1 = queue.poll();
    assertEquals(1, proc1.getProcId());
    proc2 = queue.poll();
    assertEquals(2, proc2.getProcId());

    // release the xlock
    queue.wakeTableSharedLock(proc1, tableName);
    queue.wakeTableSharedLock(proc2, tableName);

    Procedure<?> proc3 = queue.poll();
    assertEquals(3, proc3.getProcId());
  }",Eager Test
"@Test
  public void testModifyNamespaceWithInvalidTableCount() throws Exception {
    final NamespaceDescriptor nsd =
      NamespaceDescriptor.create(""testModifyNamespaceWithInvalidTableCount"").build();
    final String nsKey = ""hbase.namespace.quota.maxtables"";
    final String nsValue = ""-1"";
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    createNamespaceForTesting(nsd);

    // Modify
    nsd.setConfiguration(nsKey, nsValue);

    long procId =
      procExec.submitProcedure(new ModifyNamespaceProcedure(procExec.getEnvironment(), nsd));
    // Wait the completion
    ProcedureTestingUtility.waitProcedure(procExec, procId);
    Procedure<?> result = procExec.getResult(procId);
    assertTrue(result.isFailed());
    LOG.debug(""Modify namespace failed with exception: "" + result.getException());
    assertTrue(ProcedureTestingUtility.getExceptionCause(result) instanceof ConstraintException);
  }",Eager Test + Mystery Guest
"@Test
  public void testRecoveryAndDoubleExecutionOffline() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final String cf2 = ""cf2"";
    final String cf3 = ""cf3"";
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    // create the table
    RegionInfo[] regions =
      MasterProcedureTestingUtility.createTable(procExec, tableName, null, ""cf1"", cf3);
    UTIL.getAdmin().disableTable(tableName);

    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec, true);

    // Modify multiple properties of the table.
    TableDescriptor oldDescriptor = UTIL.getAdmin().getDescriptor(tableName);
    TableDescriptor newDescriptor = TableDescriptorBuilder.newBuilder(oldDescriptor)
      .setCompactionEnabled(!oldDescriptor.isCompactionEnabled())
      .setColumnFamily(ColumnFamilyDescriptorBuilder.of(cf2)).removeColumnFamily(Bytes.toBytes(cf3))
      .setRegionReplication(3).build();

    // Start the Modify procedure && kill the executor
    long procId =
      procExec.submitProcedure(new ModifyTableProcedure(procExec.getEnvironment(), newDescriptor));

    // Restart the executor and execute the step twice
    MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec, procId);

    // Validate descriptor
    TableDescriptor currentDescriptor = UTIL.getAdmin().getDescriptor(tableName);
    assertEquals(newDescriptor.isCompactionEnabled(), currentDescriptor.isCompactionEnabled());
    assertEquals(2, newDescriptor.getColumnFamilyNames().size());

    // cf2 should be added cf3 should be removed
    MasterProcedureTestingUtility.validateTableCreation(UTIL.getHBaseCluster().getMaster(),
      tableName, regions, false, ""cf1"", cf2);
  }",Eager Test
"@Test
  public void testRollbackAndDoubleExecutionOffline() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final String familyName = ""cf2"";
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    // create the table
    RegionInfo[] regions =
      MasterProcedureTestingUtility.createTable(procExec, tableName, null, ""cf1"");
    UTIL.getAdmin().disableTable(tableName);

    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec, true);

    TableDescriptor td = UTIL.getAdmin().getDescriptor(tableName);
    TableDescriptor newTd =
      TableDescriptorBuilder.newBuilder(td).setCompactionEnabled(!td.isCompactionEnabled())
        .setColumnFamily(ColumnFamilyDescriptorBuilder.of(familyName)).setRegionReplication(3)
        .build();

    // Start the Modify procedure && kill the executor
    long procId =
      procExec.submitProcedure(new ModifyTableProcedure(procExec.getEnvironment(), newTd));

    // Restart the executor and rollback the step twice
    int lastStep = 8; // failing before MODIFY_TABLE_UPDATE_TABLE_DESCRIPTOR
    MasterProcedureTestingUtility.testRollbackAndDoubleExecution(procExec, procId, lastStep);

    // cf2 should not be present
    MasterProcedureTestingUtility.validateTableCreation(UTIL.getHBaseCluster().getMaster(),
      tableName, regions, ""cf1"");
  }",Eager Test
"@Test
  public void testRecoveryAndDoubleExecution() throws Exception {
    final ProcedureExecutor<MasterProcedureEnv> procExec = getMasterProcedureExecutor();

    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec, true);

    // Start the Restore snapshot procedure && kill the executor
    long procId = procExec.submitProcedure(
      new RestoreSnapshotProcedure(procExec.getEnvironment(), snapshotHTD, snapshot));

    // Restart the executor and execute the step twice
    MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec, procId);

    resetProcExecutorTestingKillFlag();
    validateSnapshotRestore();
  }",Eager Test
"@Test
  public void testOnHDFSFailureNoPreserveSplits() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    testOnHDFSFailure(tableName, false);
  }",No Smells
"@Test
  public void testRecoveryAndDoubleExecutionNoPreserveSplits() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    testRecoveryAndDoubleExecution(tableName, false);
  }",No Smells
"@Test
  public void testSimpleTruncatePreserveSplits() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    testSimpleTruncate(tableName, true);
  }",No Smells
"@Test
  public void testCorruptedDataManifest() throws IOException {
    SnapshotTestingUtils.SnapshotMock snapshotMock =
      new SnapshotTestingUtils.SnapshotMock(conf, fs, rootDir);
    SnapshotTestingUtils.SnapshotMock.SnapshotBuilder builder =
      snapshotMock.createSnapshotV2(SNAPSHOT_NAME_STR, TABLE_NAME_STR);
    builder.addRegionV2();
    // consolidate to generate a data.manifest file
    builder.consolidate();
    builder.corruptDataManifest();

    long period = Long.MAX_VALUE;
    SnapshotFileCache cache = new SnapshotFileCache(conf, period, 10000000,
      ""test-snapshot-file-cache-refresh"", new SnapshotFiles());
    try {
      cache.getSnapshotsInProgress();
    }",Eager Test
"@Test
  public void testCorruptedRegionManifest() throws IOException {
    SnapshotTestingUtils.SnapshotMock snapshotMock =
      new SnapshotTestingUtils.SnapshotMock(conf, fs, rootDir);
    SnapshotTestingUtils.SnapshotMock.SnapshotBuilder builder =
      snapshotMock.createSnapshotV2(SNAPSHOT_NAME_STR, TABLE_NAME_STR);
    builder.addRegionV2();
    builder.corruptOneRegionManifest();

    long period = Long.MAX_VALUE;
    SnapshotFileCache cache = new SnapshotFileCache(conf, period, 10000000,
      ""test-snapshot-file-cache-refresh"", new SnapshotFiles());
    try {
      cache.getSnapshotsInProgress();
    }",Eager Test
"@Test
  public void testActiveMasterManagerFromZK() throws Exception {
    try (ZKWatcher zk =
      new ZKWatcher(TEST_UTIL.getConfiguration(), ""testActiveMasterManagerFromZK"", null, true)) {
      try {
        ZKUtil.deleteNode(zk, zk.getZNodePaths().masterAddressZNode);
        ZKUtil.deleteNode(zk, zk.getZNodePaths().clusterStateZNode);
      }",Eager Test
"@Test
  public void testDuplicateHFileResolution() throws Exception {
    TableDescriptor td = createTableDescriptorForCurrentMethod();

    // Create regions.
    RegionInfo parent =
      createRegionInfo(td.getTableName(), Bytes.toBytes(""aaa""), Bytes.toBytes(""eee""));
    RegionInfo splita =
      createRegionInfo(td.getTableName(), Bytes.toBytes(""aaa""), Bytes.toBytes(""ccc""));
    RegionInfo splitb =
      createRegionInfo(td.getTableName(), Bytes.toBytes(""ccc""), Bytes.toBytes(""eee""));
    // Test that when both daughter regions are in place, that we do not
    // remove the parent.
    Result r = createResult(parent, splita, splitb);
    FileSystem fs = FileSystem.get(HTU.getConfiguration());
    Path rootdir = this.masterServices.getMasterFileSystem().getRootDir();
    // Have to set the root directory since we use it in HFileDisposer to figure out to get to the
    // archive directory. Otherwise, it just seems to pick the first root directory it can find (so
    // the single test passes, but when the full suite is run, things get borked).
    CommonFSUtils.setRootDir(fs.getConf(), rootdir);
    Path tabledir = CommonFSUtils.getTableDir(rootdir, parent.getTable());
    Path storedir =
      HRegionFileSystem.getStoreHomedir(tabledir, parent, td.getColumnFamilies()[0].getName());
    LOG.info(""Old root:"" + rootdir);
    LOG.info(""Old table:"" + tabledir);
    LOG.info(""Old store:"" + storedir);

    Path storeArchive = HFileArchiveUtil.getStoreArchivePath(this.masterServices.getConfiguration(),
      parent, tabledir, td.getColumnFamilies()[0].getName());
    LOG.info(""Old archive:"" + storeArchive);

    // enable archiving, make sure that files get archived
    addMockStoreFiles(2, this.masterServices, storedir);
    // get the current store files for comparison
    FileStatus[] storeFiles = fs.listStatus(storedir);
    // Do the cleaning of the parent
    assertTrue(CatalogJanitor.cleanParent(masterServices, parent, r));
    Path parentDir = new Path(tabledir, parent.getEncodedName());
    ProcedureTestingUtility.waitAllProcedures(masterServices.getMasterProcedureExecutor());
    assertTrue(!fs.exists(parentDir));

    // And now check to make sure that the files have actually been archived
    FileStatus[] archivedStoreFiles = fs.listStatus(storeArchive);
    assertArchiveEqualToOriginal(storeFiles, archivedStoreFiles, fs);

    // now add store files with the same names as before to check backup
    // enable archiving, make sure that files get archived
    addMockStoreFiles(2, this.masterServices, storedir);

    // Do the cleaning of the parent
    assertTrue(CatalogJanitor.cleanParent(masterServices, parent, r));
    // Cleanup procedure runs async. Wait till it done.
    ProcedureTestingUtility.waitAllProcedures(masterServices.getMasterProcedureExecutor());
    assertTrue(!fs.exists(parentDir));

    // and now check to make sure that the files have actually been archived
    archivedStoreFiles = fs.listStatus(storeArchive);
    assertArchiveEqualToOriginal(storeFiles, archivedStoreFiles, fs, true);
  }",Eager Test
"@Test
  public void testEmpty() {
    ClusterStatusPublisher csp = new ClusterStatusPublisher() {
      @Override
      protected List<Pair<ServerName, Long>> getDeadServers(long since) {
        return new ArrayList<>();
      }",No Smells
"@Test
  public void testIsDead() {
    DeadServer ds = new DeadServer();
    ds.putIfAbsent(hostname123);

    ds.putIfAbsent(hostname1234);

    ds.putIfAbsent(hostname12345);

    // Already dead = 127.0.0.1,9090,112321
    // Coming back alive = 127.0.0.1,9090,223341

    final ServerName deadServer = ServerName.valueOf(""127.0.0.1"", 9090, 112321L);
    assertFalse(ds.cleanPreviousInstance(deadServer));
    ds.putIfAbsent(deadServer);
    assertTrue(ds.isDeadServer(deadServer));
    Set<ServerName> deadServerNames = ds.copyServerNames();
    for (ServerName eachDeadServer : deadServerNames) {
      Assert.assertNotNull(ds.getTimeOfDeath(eachDeadServer));
    }",Eager Test
"@Test
  public void testSortExtract() {
    ManualEnvironmentEdge mee = new ManualEnvironmentEdge();
    EnvironmentEdgeManager.injectEdge(mee);
    mee.setValue(1);

    DeadServer d = new DeadServer();

    d.putIfAbsent(hostname123);
    mee.incValue(1);
    d.putIfAbsent(hostname1234);
    mee.incValue(1);
    d.putIfAbsent(hostname12345);

    List<Pair<ServerName, Long>> copy = d.copyDeadServersSince(2L);
    Assert.assertEquals(2, copy.size());

    Assert.assertEquals(hostname1234, copy.get(0).getFirst());
    Assert.assertEquals(new Long(2L), copy.get(0).getSecond());

    Assert.assertEquals(hostname12345, copy.get(1).getFirst());
    Assert.assertEquals(new Long(3L), copy.get(1).getSecond());

    EnvironmentEdgeManager.reset();
  }",No Smells
"@Test
  public void testRun() throws Exception {
    HMasterCommandLine masterCommandLine = new HMasterCommandLine(HMaster.class);
    masterCommandLine.setConf(TESTING_UTIL.getConfiguration());
    assertEquals(0, masterCommandLine.run(new String[] { ""clear"" }",No Smells
"@Test
  public void testStatusTemplateNoTables() throws IOException {
    new MasterStatusTmpl().render(new StringWriter(), master);
  }",No Smells
"@Test
  public void testStatusTemplateWithServers() throws IOException {
    setupMockTables();

    List<ServerName> servers = Lists.newArrayList(ServerName.valueOf(""rootserver,123,12345""),
      ServerName.valueOf(""metaserver,123,12345""));
    Set<ServerName> deadServers =
      new HashSet<>(Lists.newArrayList(ServerName.valueOf(""badserver,123,12345""),
        ServerName.valueOf(""uglyserver,123,12345"")));

    new MasterStatusTmpl().setMetaLocation(ServerName.valueOf(""metaserver,123,12345""))
      .setServers(servers).setDeadServers(deadServers).render(new StringWriter(), master);
  }",No Smells
"@Test
  public void testGetInstance() {
    MetricsMasterSourceFactory metricsMasterSourceFactory =
      CompatibilitySingletonFactory.getInstance(MetricsMasterSourceFactory.class);
    MetricsMasterSource masterSource = metricsMasterSourceFactory.create(null);
    assertTrue(masterSource instanceof MetricsMasterSourceImpl);
    assertSame(metricsMasterSourceFactory,
      CompatibilitySingletonFactory.getInstance(MetricsMasterSourceFactory.class));
  }",No Smells
"@Test
  public void testEqualsWithNulls() {
    RegionInfo hri = RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName())).build();
    RegionPlan a = new RegionPlan(hri, null, null);
    RegionPlan b = new RegionPlan(hri, null, null);
    assertTrue(a.equals(b));
    a = new RegionPlan(hri, SRC, null);
    b = new RegionPlan(hri, null, null);
    assertFalse(a.equals(b));
    a = new RegionPlan(hri, SRC, null);
    b = new RegionPlan(hri, SRC, null);
    assertTrue(a.equals(b));
    a = new RegionPlan(hri, SRC, null);
    b = new RegionPlan(hri, SRC, DEST);
    assertFalse(a.equals(b));
  }",Eager Test
"@Test
  public void testDeadWorker() throws Exception {
    LOG.info(""testDeadWorker"");

    conf.setLong(""hbase.splitlog.max.resubmit"", 0);
    slm = new SplitLogManager(master, conf);
    TaskBatch batch = new TaskBatch();

    String tasknode = submitTaskAndWait(batch, ""foo/1"");
    int version = ZKUtil.checkExists(zkw, tasknode);
    final ServerName worker1 = ServerName.valueOf(""worker1,1,1"");
    SplitLogTask slt = new SplitLogTask.Owned(worker1);
    ZKUtil.setData(zkw, tasknode, slt.toByteArray());
    if (tot_mgr_heartbeat.sum() == 0) {
      waitForCounter(tot_mgr_heartbeat, 0, 1, to / 2);
    }",Eager Test
"@Test
  public void testMultipleResubmits() throws Exception {
    LOG.info(""TestMultipleResbmits - no indefinite resubmissions"");
    conf.setInt(""hbase.splitlog.max.resubmit"", 2);
    slm = new SplitLogManager(master, conf);
    TaskBatch batch = new TaskBatch();

    String tasknode = submitTaskAndWait(batch, ""foo/1"");
    int version = ZKUtil.checkExists(zkw, tasknode);
    final ServerName worker1 = ServerName.valueOf(""worker1,1,1"");
    final ServerName worker2 = ServerName.valueOf(""worker2,1,1"");
    final ServerName worker3 = ServerName.valueOf(""worker3,1,1"");
    SplitLogTask slt = new SplitLogTask.Owned(worker1);
    ZKUtil.setData(zkw, tasknode, slt.toByteArray());
    waitForCounter(tot_mgr_heartbeat, 0, 1, to / 2);
    waitForCounter(tot_mgr_resubmit, 0, 1, to + to / 2);
    int version1 = ZKUtil.checkExists(zkw, tasknode);
    assertTrue(version1 > version);
    slt = new SplitLogTask.Owned(worker2);
    ZKUtil.setData(zkw, tasknode, slt.toByteArray());
    waitForCounter(tot_mgr_heartbeat, 1, 2, to / 2);
    waitForCounter(tot_mgr_resubmit, 1, 2, to + to / 2);
    int version2 = ZKUtil.checkExists(zkw, tasknode);
    assertTrue(version2 > version1);
    slt = new SplitLogTask.Owned(worker3);
    ZKUtil.setData(zkw, tasknode, slt.toByteArray());
    waitForCounter(tot_mgr_heartbeat, 2, 3, to / 2);
    waitForCounter(tot_mgr_resubmit_threshold_reached, 0, 1, to + to / 2);
    Thread.sleep(to + to / 2);
    assertEquals(2L, tot_mgr_resubmit.sum() - tot_mgr_resubmit_force.sum());
  }",Eager Test
"@Test
  public void testGetValue() {
    SimpleGauge gauge = new SimpleGauge();

    assertEquals(0, (long) gauge.getValue());

    gauge.setValue(1000L);

    assertEquals(1000L, (long) gauge.getValue());
  }",No Smells
"@Test
  public void testSnapshot() {
    HistogramImpl histogram = new HistogramImpl();
    IntStream.range(0, 100).forEach(histogram::update);

    Snapshot snapshot = histogram.snapshot();

    assertEquals(100, snapshot.getCount());
    assertEquals(49, snapshot.getMedian());
    assertEquals(49, snapshot.getMean());
    assertEquals(0, snapshot.getMin());
    assertEquals(99, snapshot.getMax());
    assertEquals(24, snapshot.get25thPercentile());
    assertEquals(74, snapshot.get75thPercentile());
    assertEquals(89, snapshot.get90thPercentile());
    assertEquals(94, snapshot.get95thPercentile());
    assertEquals(97, snapshot.get98thPercentile());
    assertEquals(98, snapshot.get99thPercentile());
    assertEquals(98, snapshot.get999thPercentile());

    assertEquals(100, snapshot.getCountAtOrBelow(50));

    // check that histogram is reset.
    assertEquals(100, histogram.getCount()); // count does not reset

    // put more data after reset
    IntStream.range(100, 200).forEach(histogram::update);

    assertEquals(200, histogram.getCount());

    snapshot = histogram.snapshot();
    assertEquals(100, snapshot.getCount()); // only 100 more events
    assertEquals(150, snapshot.getMedian());
    assertEquals(149, snapshot.getMean());
    assertEquals(100, snapshot.getMin());
    assertEquals(199, snapshot.getMax());
    assertEquals(125, snapshot.get25thPercentile());
    assertEquals(175, snapshot.get75thPercentile());
    assertEquals(190, snapshot.get90thPercentile());
    assertEquals(195, snapshot.get95thPercentile());
    assertEquals(198, snapshot.get98thPercentile());
    assertEquals(199, snapshot.get99thPercentile());
    assertEquals(199, snapshot.get999thPercentile());

    IntStream.range(500, 1000).forEach(histogram::update);

    snapshot = histogram.snapshot();

    assertEquals(500, snapshot.getCount());
    assertEquals(749, snapshot.getMedian());
    assertEquals(749, snapshot.getMean());
    assertEquals(500, snapshot.getMin());
    assertEquals(999, snapshot.getMax());
    assertEquals(624, snapshot.get25thPercentile());
    assertEquals(874, snapshot.get75thPercentile());
    assertEquals(949, snapshot.get90thPercentile());
    assertEquals(974, snapshot.get95thPercentile());
    assertEquals(989, snapshot.get98thPercentile());
    assertEquals(994, snapshot.get99thPercentile());
    assertEquals(998, snapshot.get999thPercentile());

  }",Eager Test
"@Test
  public void testGetMetrics() {
    CounterImpl counter = new CounterImpl();
    registry.register(""mycounter"", counter);
    Gauge gauge = registry.register(""mygauge"", () -> 42L);
    Timer timer = registry.timer(""mytimer"");

    Map<String, Metric> metrics = registry.getMetrics();
    assertEquals(3, metrics.size());

    assertEquals(counter, metrics.get(""mycounter""));
    assertEquals(gauge, metrics.get(""mygauge""));
    assertEquals(timer, metrics.get(""mytimer""));
  }",Eager Test
"@Test
  public void testRegisterGauge() {
    registry.register(""mygauge"", new Gauge<Long>() {
      @Override
      public Long getValue() {
        return 42L;
      }",Eager Test
"@Test
  public void testClear() {
    map.put(""foo"", () -> ""foovalue"");
    map.put(""bar"", () -> ""foovalue2"");
    map.put(""baz"", () -> ""foovalue3"");

    map.clear();

    assertEquals(0, map.size());
  }",No Smells
"@Test
  public void testPutMulti() {
    String v1 = map.put(""foo"", () -> ""foovalue"");
    String v2 = map.put(""foo"", () -> ""foovalue2"");
    String v3 = map.put(""foo"", () -> ""foovalue3"");

    String v = map.get(""foo"");
    assertEquals(""foovalue"", v);
    assertEquals(v, v1);
    assertEquals(v, v2);
    assertEquals(v, v3);
  }",No Smells
"@Test
  public void testIncGauge() throws Exception {
    bmsi.incGauge(""testincgauge"", 100);
    assertEquals(100, ((MutableGaugeLong) bmsi.metricsRegistry.get(""testincgauge"")).value());
    bmsi.incGauge(""testincgauge"", 100);
    assertEquals(200, ((MutableGaugeLong) bmsi.metricsRegistry.get(""testincgauge"")).value());

  }",No Smells
"@Test
  public void testFlushNonMobFile() throws Exception {
    final TableName tableName = TableName.valueOf(TestMobUtils.getTableName(name));
    TableDescriptor tableDescriptor = TableDescriptorBuilder.newBuilder(tableName)
      .setColumnFamily(ColumnFamilyDescriptorBuilder.newBuilder(family).setMaxVersions(4).build())
      .build();
    testFlushFile(tableDescriptor);
  }",No Smells
"@Test
  public void testCleaner() throws Exception {
    init();

    Path mobDirPath = MobUtils.getMobFamilyPath(TEST_UTIL.getConfiguration(), tableName, family);

    byte[] dummyData = makeDummyData(600);
    long ts = EnvironmentEdgeManager.currentTime() - 3 * secondsOfDay() * 1000; // 3 days before
    putKVAndFlush(table, row1, dummyData, ts);
    LOG.info(""test log to be deleted, tablename is "" + tableName);
    CommonFSUtils.logFileSystemState(TEST_UTIL.getTestFileSystem(),
      TEST_UTIL.getDefaultRootDirPath(), LOG);
    FileStatus[] firstFiles = TEST_UTIL.getTestFileSystem().listStatus(mobDirPath);
    // the first mob file
    assertEquals(""Before cleanup without delay 1"", 1, firstFiles.length);
    String firstFile = firstFiles[0].getPath().getName();

    // 1.5 day before
    ts = (long) (EnvironmentEdgeManager.currentTime() - 1.5 * secondsOfDay() * 1000);
    putKVAndFlush(table, row2, dummyData, ts);
    FileStatus[] secondFiles = TEST_UTIL.getTestFileSystem().listStatus(mobDirPath);
    // now there are 2 mob files
    assertEquals(""Before cleanup without delay 2"", 2, secondFiles.length);
    String f1 = secondFiles[0].getPath().getName();
    String f2 = secondFiles[1].getPath().getName();
    String secondFile = f1.equals(firstFile) ? f2 : f1;

    ts = EnvironmentEdgeManager.currentTime() - 4 * secondsOfDay() * 1000; // 4 days before
    putKVAndFlush(table, row3, dummyData, ts);
    ts = EnvironmentEdgeManager.currentTime() - 4 * secondsOfDay() * 1000; // 4 days before
    putKVAndFlush(table, row3, dummyData, ts);
    FileStatus[] thirdFiles = TEST_UTIL.getTestFileSystem().listStatus(mobDirPath);
    // now there are 4 mob files
    assertEquals(""Before cleanup without delay 3"", 4, thirdFiles.length);

    modifyColumnExpiryDays(2); // ttl = 2, make the first row expired

    // run the cleaner
    String[] args = new String[2];
    args[0] = tableName.getNameAsString();
    args[1] = family;
    ToolRunner.run(TEST_UTIL.getConfiguration(), new ExpiredMobFileCleaner(), args);

    FileStatus[] filesAfterClean = TEST_UTIL.getTestFileSystem().listStatus(mobDirPath);
    String lastFile = filesAfterClean[0].getPath().getName();
    // there are 4 mob files in total, but only 3 need to be cleaned
    assertEquals(""After cleanup without delay 1"", 1, filesAfterClean.length);
    assertEquals(""After cleanup without delay 2"", secondFile, lastFile);
  }",Eager Test
"@Test
  public void testReadKeyValue() throws Exception {
    Path testDir = TEST_UTIL.getDataTestDir();
    FileSystem fs = testDir.getFileSystem(conf);
    HFileContext meta = new HFileContextBuilder().withBlockSize(8 * 1024).build();
    StoreFileWriter writer = new StoreFileWriter.Builder(conf, cacheConf, fs).withOutputDir(testDir)
      .withFileContext(meta).build();
    String caseName = testName.getMethodName();
    MobTestUtil.writeStoreFile(writer, caseName);

    StoreFileInfo storeFileInfo =
      StoreFileInfo.createStoreFileInfoForHFile(conf, fs, writer.getPath(), true);
    MobFile mobFile = new MobFile(new HStoreFile(storeFileInfo, BloomType.NONE, cacheConf));
    byte[] family = Bytes.toBytes(caseName);
    byte[] qualify = Bytes.toBytes(caseName);

    // Test the start key
    byte[] startKey = Bytes.toBytes(""aa""); // The start key bytes
    KeyValue expectedKey =
      new KeyValue(startKey, family, qualify, Long.MAX_VALUE, Type.Put, startKey);
    KeyValue seekKey = expectedKey.createKeyOnly(false);
    Cell cell = mobFile.readCell(seekKey, false).getCell();
    MobTestUtil.assertCellEquals(expectedKey, cell);

    // Test the end key
    byte[] endKey = Bytes.toBytes(""zz""); // The end key bytes
    expectedKey = new KeyValue(endKey, family, qualify, Long.MAX_VALUE, Type.Put, endKey);
    seekKey = expectedKey.createKeyOnly(false);
    cell = mobFile.readCell(seekKey, false).getCell();
    MobTestUtil.assertCellEquals(expectedKey, cell);

    // Test the random key
    byte[] randomKey = Bytes.toBytes(MobTestUtil.generateRandomString(2));
    expectedKey = new KeyValue(randomKey, family, qualify, Long.MAX_VALUE, Type.Put, randomKey);
    seekKey = expectedKey.createKeyOnly(false);
    cell = mobFile.readCell(seekKey, false).getCell();
    MobTestUtil.assertCellEquals(expectedKey, cell);

    // Test the key which is less than the start key
    byte[] lowerKey = Bytes.toBytes(""a1""); // Smaller than ""aa""
    expectedKey = new KeyValue(startKey, family, qualify, Long.MAX_VALUE, Type.Put, startKey);
    seekKey = new KeyValue(lowerKey, family, qualify, Long.MAX_VALUE, Type.Put, lowerKey);
    cell = mobFile.readCell(seekKey, false).getCell();
    MobTestUtil.assertCellEquals(expectedKey, cell);

    // Test the key which is more than the end key
    byte[] upperKey = Bytes.toBytes(""z{""); // Bigger than ""zz""
    seekKey = new KeyValue(upperKey, family, qualify, Long.MAX_VALUE, Type.Put, upperKey);
    assertNull(mobFile.readCell(seekKey, false));
  }",Eager Test
"@Test
  public void testCreate() {
    MobFileName mobFileName = MobFileName.create(startKey, dateStr, uuid, regionName);
    assertEquals(mobFileName, MobFileName.create(mobFileName.getFileName()));
  }",No Smells
"@Test
  public void testGet() {
    MobFileName mobFileName = MobFileName.create(startKey, dateStr, uuid, regionName);
    assertEquals(MD5Hash.getMD5AsHex(startKey, 0, startKey.length), mobFileName.getStartKey());
    assertEquals(dateStr, mobFileName.getDate());
    assertEquals(mobFileName.getFileName(),
      MD5Hash.getMD5AsHex(startKey, 0, startKey.length) + dateStr + uuid + ""_"" + regionName);
  }",No Smells
"@Test
  public void testNonAsciiEncoding() {
    MemoryBoundedLogMessageBuffer buf = new MemoryBoundedLogMessageBuffer(TEN_KB);

    buf.add(JP_TEXT);
    StringWriter sw = new StringWriter();
    buf.dumpTo(new PrintWriter(sw));
    String dump = sw.toString();
    assertTrue(dump.contains(JP_TEXT));
  }",Eager Test
"@Test
  public void testTasksGetAbortedOnLeak() throws InterruptedException {
    final TaskMonitor tm = new TaskMonitor(new Configuration());
    assertTrue(""Task monitor should start empty"", tm.getTasks().isEmpty());

    final AtomicBoolean threadSuccess = new AtomicBoolean(false);
    // Make a task in some other thread and leak it
    Thread t = new Thread() {
      @Override
      public void run() {
        MonitoredTask task = tm.createStatus(""Test task"");
        assertEquals(MonitoredTask.State.RUNNING, task.getState());
        threadSuccess.set(true);
      }",Eager Test
"@Test
  public void testCloneSnapshot() throws Exception {
    String nsp = prefix + ""_testCloneSnapshot"";
    NamespaceDescriptor nspDesc =
      NamespaceDescriptor.create(nsp).addConfiguration(TableNamespaceManager.KEY_MAX_TABLES, ""2"")
        .addConfiguration(TableNamespaceManager.KEY_MAX_REGIONS, ""20"").build();
    ADMIN.createNamespace(nspDesc);
    assertNotNull(""Namespace descriptor found null."", ADMIN.getNamespaceDescriptor(nsp));
    TableName tableName = TableName.valueOf(nsp + TableName.NAMESPACE_DELIM + ""table1"");
    TableName cloneTableName = TableName.valueOf(nsp + TableName.NAMESPACE_DELIM + ""table2"");

    ColumnFamilyDescriptor columnFamilyDescriptor =
      ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(""fam1"")).build();
    TableDescriptorBuilder tableDescOne = TableDescriptorBuilder.newBuilder(tableName);
    tableDescOne.setColumnFamily(columnFamilyDescriptor);

    ADMIN.createTable(tableDescOne.build(), Bytes.toBytes(""AAA""), Bytes.toBytes(""ZZZ""), 4);
    String snapshot = ""snapshot_testCloneSnapshot"";
    ADMIN.snapshot(snapshot, tableName);
    ADMIN.cloneSnapshot(snapshot, cloneTableName);

    int tableLength;
    try (RegionLocator locator = ADMIN.getConnection().getRegionLocator(tableName)) {
      tableLength = locator.getStartKeys().length;
    }",Eager Test + Mystery Guest
"@Test
  public void testArrayBasedMethods() {
    byte[] b = new byte[15];
    ByteBuffer bb1 = ByteBuffer.wrap(b, 1, 10).slice();
    ByteBuffer bb2 = ByteBuffer.allocate(15);
    ByteBuff mbb1 = new MultiByteBuff(bb1, bb2);
    assertFalse(mbb1.hasArray());
    try {
      mbb1.array();
      fail();
    }",Eager Test
"@Test
  public void testMarkAndResetWithMBB() {
    ByteBuffer bb1 = ByteBuffer.allocateDirect(15);
    ByteBuffer bb2 = ByteBuffer.allocateDirect(15);
    bb1.putInt(4);
    long l1 = 45L, l2 = 100L, l3 = 12345L;
    bb1.putLong(l1);
    bb1.putShort((short) 2);
    byte[] b = Bytes.toBytes(l2);
    bb1.put(b, 0, 1);
    bb2.put(b, 1, 7);
    bb2.putLong(l3);
    ByteBuff multi = new MultiByteBuff(bb1, bb2);
    assertEquals(4, multi.getInt());
    assertEquals(l1, multi.getLong());
    multi.mark();
    assertEquals((short) 2, multi.getShort());
    multi.reset();
    assertEquals((short) 2, multi.getShort());
    multi.mark();
    assertEquals(l2, multi.getLong());
    multi.reset();
    assertEquals(l2, multi.getLong());
    multi.mark();
    assertEquals(l3, multi.getLong());
    multi.reset();
    assertEquals(l3, multi.getLong());
    // Try absolute gets with mark and reset
    multi.mark();
    assertEquals(l2, multi.getLong(14));
    multi.reset();
    assertEquals(l3, multi.getLong(22));
    // Just reset to see what happens
    multi.reset();
    assertEquals(l2, multi.getLong(14));
    multi.mark();
    assertEquals(l3, multi.getLong(22));
    multi.reset();
  }",Eager Test
"@Test
  public void testPositionalReads() {
    // Off heap buffer
    testPositionalReads(ByteBuffer.allocateDirect(15));
    // On heap buffer
    testPositionalReads(ByteBuffer.allocate(15));
  }",No Smells
"@Test
  public void testSingleCohortOrchestration() throws Exception {
    runSimpleProcedure(""one"");
  }",No Smells
"@Test
  public void testUnreachableControllerDuringCommit() throws Exception {
    coordinator = buildNewCoordinator();

    // setup the task and spy on it
    List<String> expected = Arrays.asList(""cohort"");
    final Procedure spy =
      spy(new Procedure(coordinator, WAKE_FREQUENCY, TIMEOUT, procName, procData, expected));

    when(coordinator.createProcedure(any(), eq(procName), eq(procData), anyList())).thenReturn(spy);

    // use the passed controller responses
    IOException cause = new IOException(""Failed to reach controller during prepare"");
    doAnswer(new AcquireBarrierAnswer(procName, new String[] { ""cohort"" }",No Smells
"@Test
  public void testPropagateConnectionErrorBackToManager() throws Exception {
    // setup the operation
    member = buildCohortMember();
    ProcedureMember memberSpy = spy(member);

    // setup the commit and the spy
    final ForeignExceptionDispatcher dispatcher = new ForeignExceptionDispatcher();
    ForeignExceptionDispatcher dispSpy = spy(dispatcher);
    Subprocedure commit = new EmptySubprocedure(member, dispatcher);
    Subprocedure spy = spy(commit);
    when(mockBuilder.buildSubprocedure(op, data)).thenReturn(spy);

    // fail during the prepare phase
    doThrow(new ForeignException(""SRC"", ""prepare exception"")).when(spy).acquireBarrier();
    // and throw a connection error when we try to tell the controller about it
    doThrow(new IOException(""Controller is down!"")).when(mockMemberComms).sendMemberAborted(eq(spy),
      any());

    // run the operation
    // build a new operation
    Subprocedure subproc = memberSpy.createSubprocedure(op, data);
    memberSpy.submitSubprocedure(subproc);
    // if the operation doesn't die properly, then this will timeout
    memberSpy.closeAndWait(TIMEOUT);

    // make sure everything ran in order
    InOrder order = inOrder(mockMemberComms, spy, dispSpy);
    // make sure we acquire.
    order.verify(spy).acquireBarrier();
    order.verify(mockMemberComms, never()).sendMemberAcquired(spy);

    // TODO Need to do another refactor to get this to propagate to the coordinator.
    // make sure we pass a remote exception back the controller
    // order.verify(mockMemberComms).sendMemberAborted(eq(spy),
    // any());
    // order.verify(dispSpy).receiveError(anyString(),
    // any(), any());
  }",Eager Test
"@Test
  public void testLoad() {
    final int MAX_PROCS = 1000;
    final ProcedureStoreTracker tracker = new ProcedureStoreTracker();
    for (int numProcs = 1; numProcs < MAX_PROCS; ++numProcs) {
      for (int start = 1; start <= numProcs; ++start) {
        assertTrue(tracker.isEmpty());

        LOG.debug(""loading "" + numProcs + "" procs from start="" + start);
        for (int i = start; i <= numProcs; ++i) {
          tracker.setDeleted(i, false);
        }",Eager Test
"@Test
  public void testPartialTracker() {
    ProcedureStoreTracker tracker = new ProcedureStoreTracker();
    tracker.setPartialFlag(true);

    // nothing in the tracker, the state is unknown
    assertTrue(tracker.isEmpty());
    assertEquals(ProcedureStoreTracker.DeleteState.MAYBE, tracker.isDeleted(1));
    assertEquals(ProcedureStoreTracker.DeleteState.MAYBE, tracker.isDeleted(579));

    // Mark 1 as deleted, now that is a known state
    tracker.setDeleted(1, true);
    tracker.dump();
    assertEquals(ProcedureStoreTracker.DeleteState.YES, tracker.isDeleted(1));
    assertEquals(ProcedureStoreTracker.DeleteState.MAYBE, tracker.isDeleted(2));
    assertEquals(ProcedureStoreTracker.DeleteState.MAYBE, tracker.isDeleted(579));

    // Mark 579 as non-deleted, now that is a known state
    tracker.setDeleted(579, false);
    assertEquals(ProcedureStoreTracker.DeleteState.YES, tracker.isDeleted(1));
    assertEquals(ProcedureStoreTracker.DeleteState.MAYBE, tracker.isDeleted(2));
    assertEquals(ProcedureStoreTracker.DeleteState.NO, tracker.isDeleted(579));
    assertEquals(ProcedureStoreTracker.DeleteState.MAYBE, tracker.isDeleted(577));
    assertEquals(ProcedureStoreTracker.DeleteState.MAYBE, tracker.isDeleted(580));

    tracker.setDeleted(579, true);
    tracker.setPartialFlag(false);
    assertTrue(tracker.isEmpty());
  }",Eager Test
"@Test
  public void testCorruptedEntries() throws Exception {
    // Insert something
    for (int i = 0; i < 100; ++i) {
      procStore.insert(new TestSequentialProcedure(), null);
    }",Eager Test + Mystery Guest
"@Test
  public void testCorruptedProcedures() throws Exception {
    // Insert root-procedures
    TestProcedure[] rootProcs = new TestProcedure[10];
    for (int i = 1; i <= rootProcs.length; i++) {
      rootProcs[i - 1] = new TestProcedure(i, 0);
      procStore.insert(rootProcs[i - 1], null);
      rootProcs[i - 1].addStackId(0);
      procStore.update(rootProcs[i - 1]);
    }",Eager Test + Mystery Guest
"@Test
  public void testCorruptedTrailer() throws Exception {
    // Insert something
    for (int i = 0; i < 100; ++i) {
      procStore.insert(new TestSequentialProcedure(), null);
    }",Eager Test + Mystery Guest
"@Test
  public void testLoad() throws Exception {
    Set<Long> procIds = new HashSet<>();

    // Insert something in the log
    Procedure<?> proc1 = new TestSequentialProcedure();
    procIds.add(proc1.getProcId());
    procStore.insert(proc1, null);

    Procedure<?> proc2 = new TestSequentialProcedure();
    Procedure<?>[] child2 = new Procedure[2];
    child2[0] = new TestSequentialProcedure();
    child2[1] = new TestSequentialProcedure();

    procIds.add(proc2.getProcId());
    procIds.add(child2[0].getProcId());
    procIds.add(child2[1].getProcId());
    procStore.insert(proc2, child2);

    // Verify that everything is there
    verifyProcIdsOnRestart(procIds);

    // Update and delete something
    procStore.update(proc1);
    procStore.update(child2[1]);
    procStore.delete(child2[1].getProcId());
    procIds.remove(child2[1].getProcId());

    // Verify that everything is there
    verifyProcIdsOnRestart(procIds);

    // Remove 4 byte from the trailers
    procStore.stop(false);
    FileStatus[] logs = fs.listStatus(logDir);
    assertEquals(3, logs.length);
    for (int i = 0; i < logs.length; ++i) {
      corruptLog(logs[i], 4);
    }",Eager Test + Mystery Guest
"@Test
  public void testWalCleanerNoHoles() throws Exception {
    final Procedure<?>[] procs = new Procedure[5];
    ArrayList<ProcedureWALFile> logs = null;
    // Insert procedures and roll wal after every insert.
    for (int i = 0; i < procs.length; i++) {
      procs[i] = new TestSequentialProcedure();
      procStore.insert(procs[i], null);
      procStore.rollWriterForTesting();
      logs = procStore.getActiveLogs();
      assertEquals(i + 2, logs.size()); // Extra 1 for current ongoing wal.
    }",Eager Test + Mystery Guest
"@Test
  public void testWalCleanerSequentialClean() throws Exception {
    final Procedure<?>[] procs = new Procedure[5];
    ArrayList<ProcedureWALFile> logs = null;

    // Insert procedures and roll wal after every insert.
    for (int i = 0; i < procs.length; i++) {
      procs[i] = new TestSequentialProcedure();
      procStore.insert(procs[i], null);
      procStore.rollWriterForTesting();
      logs = procStore.getActiveLogs();
      assertEquals(logs.size(), i + 2); // Extra 1 for current ongoing wal.
    }",Eager Test + Mystery Guest
"@Test
  public void testWalCleanerUpdates() throws Exception {
    TestSequentialProcedure p1 = new TestSequentialProcedure();
    TestSequentialProcedure p2 = new TestSequentialProcedure();
    procStore.insert(p1, null);
    procStore.insert(p2, null);
    procStore.rollWriterForTesting();
    ProcedureWALFile firstLog = procStore.getActiveLogs().get(0);
    procStore.update(p1);
    procStore.rollWriterForTesting();
    procStore.update(p2);
    procStore.rollWriterForTesting();
    procStore.removeInactiveLogsForTesting();
    assertFalse(procStore.getActiveLogs().contains(firstLog));
  }",Eager Test + Mystery Guest
"@Test
  public void testWalCleanerWithEmptyRolls() throws Exception {
    final Procedure<?>[] procs = new Procedure[3];
    for (int i = 0; i < procs.length; ++i) {
      procs[i] = new TestSequentialProcedure();
      procStore.insert(procs[i], null);
    }",Eager Test + Mystery Guest
"@Test
  public void testSubmitBatch() throws Exception {
    Procedure[] procs = new Procedure[5];
    for (int i = 0; i < procs.length; ++i) {
      procs[i] = new NoopProcedure<TestProcEnv>();
    }",Eager Test
"@Test
  public void testChoreAddAndRemove() throws Exception {
    final int timeoutMSec = 50;
    final int nCountDown = 5;

    // submit the chore and wait for execution
    CountDownLatch latch = new CountDownLatch(nCountDown);
    TestLatchChore chore = new TestLatchChore(timeoutMSec, latch);
    procExecutor.addChore(chore);
    assertTrue(chore.isWaiting());
    latch.await();

    // remove the chore and verify it is no longer executed
    assertTrue(chore.isWaiting());
    procExecutor.removeChore(chore);
    latch = new CountDownLatch(nCountDown);
    chore.setLatch(latch);
    latch.await(timeoutMSec * nCountDown, TimeUnit.MILLISECONDS);
    LOG.info(""chore latch count="" + latch.getCount());
    assertFalse(chore.isWaiting());
    assertTrue(""latchCount="" + latch.getCount(), latch.getCount() > 0);
  }",Eager Test
"@Test
  public void testMetricForFailedYiledProcedure() {
    // procedure that yields and fails
    ProcedureMetrics proc = new ProcedureMetrics(false, true);
    long id = ProcedureTestingUtility.submitAndWait(procExecutor, proc);
    assertNotEquals(""ProcId zero!"", 0, id);
    beginCount++;
    failedCount++;
    ProcedureTestingUtility.waitProcedure(procExecutor, proc);
    assertEquals(""beginCount doesn't match!"", beginCount, proc.beginCount);
    assertEquals(""successCount doesn't match!"", successCount, proc.successCount);
    assertEquals(""failedCont doesn't match!"", failedCount, proc.failedCount);
  }",Eager Test + Mystery Guest
"@Test
  public void testDelayedContainerEquals() {
    Object o1 = new Object();
    Object o2 = new Object();
    ZeroDelayContainer<Long> lnull = new ZeroDelayContainer(null);
    ZeroDelayContainer<Long> l10a = new ZeroDelayContainer<>(10L);
    ZeroDelayContainer<Long> l10b = new ZeroDelayContainer(10L);
    ZeroDelayContainer<Long> l15 = new ZeroDelayContainer(15L);
    ZeroDelayContainer<Object> onull = new ZeroDelayContainer<>(null);
    ZeroDelayContainer<Object> o1ca = new ZeroDelayContainer<>(o1);
    ZeroDelayContainer<Object> o1cb = new ZeroDelayContainer<>(o1);
    ZeroDelayContainer<Object> o2c = new ZeroDelayContainer<>(o2);

    ZeroDelayContainer[] items =
      new ZeroDelayContainer[] { lnull, l10a, l10b, l15, onull, o1ca, o1cb, o2c, }",Eager Test
"@Test
  public void testDelete() throws IOException {
    MutationProto.Builder mutateBuilder = MutationProto.newBuilder();
    mutateBuilder.setRow(ByteString.copyFromUtf8(""row""));
    mutateBuilder.setMutateType(MutationType.DELETE);
    mutateBuilder.setTimestamp(111111);
    ColumnValue.Builder valueBuilder = ColumnValue.newBuilder();
    valueBuilder.setFamily(ByteString.copyFromUtf8(""f1""));
    QualifierValue.Builder qualifierBuilder = QualifierValue.newBuilder();
    qualifierBuilder.setQualifier(ByteString.copyFromUtf8(""c1""));
    qualifierBuilder.setDeleteType(DeleteType.DELETE_ONE_VERSION);
    qualifierBuilder.setTimestamp(111222);
    valueBuilder.addQualifierValue(qualifierBuilder.build());
    qualifierBuilder.setQualifier(ByteString.copyFromUtf8(""c2""));
    qualifierBuilder.setDeleteType(DeleteType.DELETE_MULTIPLE_VERSIONS);
    qualifierBuilder.setTimestamp(111333);
    valueBuilder.addQualifierValue(qualifierBuilder.build());
    mutateBuilder.addColumnValue(valueBuilder.build());

    MutationProto proto = mutateBuilder.build();
    // default fields
    assertEquals(MutationProto.Durability.USE_DEFAULT, proto.getDurability());

    // set the default value for equal comparison
    mutateBuilder = MutationProto.newBuilder(proto);
    mutateBuilder.setDurability(MutationProto.Durability.USE_DEFAULT);

    Delete delete = ProtobufUtil.toDelete(proto);

    // delete always have empty value,
    // add empty value to the original mutate
    for (ColumnValue.Builder column : mutateBuilder.getColumnValueBuilderList()) {
      for (QualifierValue.Builder qualifier : column.getQualifierValueBuilderList()) {
        qualifier.setValue(ByteString.EMPTY);
      }",Eager Test
"@Test
  public void testNonViolatingQuotaCachesPolicyEnforcment() {
    final Map<TableName, SpaceQuotaSnapshot> snapshots = new HashMap<>();
    final TableName tableName = TableName.valueOf(""my_table"");
    snapshots.put(tableName, new SpaceQuotaSnapshot(SpaceQuotaStatus.notInViolation(), 0, 1024));
    final ActivePolicyEnforcement ape =
      new ActivePolicyEnforcement(Collections.emptyMap(), snapshots, rss);
    SpaceViolationPolicyEnforcement policyEnforcement = ape.getPolicyEnforcement(tableName);
    assertTrue(""Found the wrong class: "" + policyEnforcement.getClass(),
      policyEnforcement instanceof DefaultViolationPolicyEnforcement);
    SpaceViolationPolicyEnforcement copy = ape.getPolicyEnforcement(tableName);
    assertTrue(""Expected the instance to be cached"", policyEnforcement == copy);
    Entry<TableName, SpaceViolationPolicyEnforcement> entry =
      ape.getLocallyCachedPolicies().entrySet().iterator().next();
    assertTrue(policyEnforcement == entry.getValue());
  }",Eager Test
"@Test
  public void testNoPolicyReturnsNoopEnforcement() {
    ActivePolicyEnforcement ape = new ActivePolicyEnforcement(new HashMap<>(),
      Collections.emptyMap(), mock(RegionServerServices.class));
    SpaceViolationPolicyEnforcement enforcement =
      ape.getPolicyEnforcement(TableName.valueOf(""nonexistent""));
    assertNotNull(enforcement);
    assertTrue(""Expected an instance of MissingSnapshotViolationPolicyEnforcement, but got ""
      + enforcement.getClass(), enforcement instanceof MissingSnapshotViolationPolicyEnforcement);
  }",Eager Test
"@Test
  public void testNoQuotaReturnsSingletonPolicyEnforcement() {
    final ActivePolicyEnforcement ape =
      new ActivePolicyEnforcement(Collections.emptyMap(), Collections.emptyMap(), rss);
    final TableName tableName = TableName.valueOf(""my_table"");
    SpaceViolationPolicyEnforcement policyEnforcement = ape.getPolicyEnforcement(tableName);
    // This should be the same exact instance, the singleton
    assertTrue(policyEnforcement == MissingSnapshotViolationPolicyEnforcement.getInstance());
    assertEquals(1, ape.getLocallyCachedPolicies().size());
    Entry<TableName, SpaceViolationPolicyEnforcement> entry =
      ape.getLocallyCachedPolicies().entrySet().iterator().next();
    assertTrue(policyEnforcement == entry.getValue());
  }",Eager Test
"@Test
  public void testIgnoreSplitParents() {
    final Configuration conf = getDefaultHBaseConfiguration();
    final HRegionServer rs = mockRegionServer(conf);

    // Three regions with multiple store sizes
    final List<Long> r1Sizes = Arrays.asList(1024L, 2048L);
    final long r1Sum = sum(r1Sizes);
    final List<Long> r2Sizes = Arrays.asList(1024L * 1024L);

    final FileSystemUtilizationChore chore = new FileSystemUtilizationChore(rs);
    doAnswer(new ExpectedRegionSizeSummationAnswer(sum(Arrays.asList(r1Sum)))).when(rs)
      .reportRegionSizesForQuotas(any(RegionSizeStore.class));

    final Region r1 = mockRegionWithSize(r1Sizes);
    final Region r2 = mockSplitParentRegionWithSize(r2Sizes);
    doReturn(Arrays.asList(r1, r2)).when(rs).getRegions();
    chore.chore();
  }",Eager Test
"@Test
  public void testNonDefaultConfigurationProperties() {
    final Configuration conf = getDefaultHBaseConfiguration();
    // Override the default values
    final int period = 60 * 10;
    final long delay = 30L;
    final TimeUnit timeUnit = TimeUnit.SECONDS;
    conf.setInt(FileSystemUtilizationChore.FS_UTILIZATION_CHORE_PERIOD_KEY, period);
    conf.setLong(FileSystemUtilizationChore.FS_UTILIZATION_CHORE_DELAY_KEY, delay);
    conf.set(FileSystemUtilizationChore.FS_UTILIZATION_CHORE_TIMEUNIT_KEY, timeUnit.name());

    // Verify that the chore reports these non-default values
    final HRegionServer rs = mockRegionServer(conf);
    final FileSystemUtilizationChore chore = new FileSystemUtilizationChore(rs);
    assertEquals(period, chore.getPeriod());
    assertEquals(delay, chore.getInitialDelay());
    assertEquals(timeUnit, chore.getTimeUnit());
  }",Eager Test
"@Test
  public void testNonHFilesAreIgnored() {
    final Configuration conf = getDefaultHBaseConfiguration();
    final HRegionServer rs = mockRegionServer(conf);

    // Region r1 has two store files, one hfile link and one hfile
    final List<Long> r1StoreFileSizes = Arrays.asList(1024L, 2048L);
    final List<Long> r1HFileSizes = Arrays.asList(0L, 2048L);
    final long r1HFileSizeSum = sum(r1HFileSizes);
    // Region r2 has one store file which is a hfile link
    final List<Long> r2StoreFileSizes = Arrays.asList(1024L * 1024L);
    final List<Long> r2HFileSizes = Arrays.asList(0L);
    final long r2HFileSizeSum = sum(r2HFileSizes);

    // We expect that only the hfiles would be counted (hfile links are ignored)
    final FileSystemUtilizationChore chore = new FileSystemUtilizationChore(rs);
    doAnswer(
      new ExpectedRegionSizeSummationAnswer(sum(Arrays.asList(r1HFileSizeSum, r2HFileSizeSum))))
        .when(rs).reportRegionSizesForQuotas(any(RegionSizeStore.class));

    final Region r1 = mockRegionWithHFileLinks(r1StoreFileSizes, r1HFileSizes);
    final Region r2 = mockRegionWithHFileLinks(r2StoreFileSizes, r2HFileSizes);
    doReturn(Arrays.asList(r1, r2)).when(rs).getRegions();
    chore.chore();
  }",Eager Test
"@Test
  public void testNoOnlineRegions() {
    // One region with a store size of one.
    final List<Long> regionSizes = Collections.emptyList();
    final Configuration conf = getDefaultHBaseConfiguration();
    final HRegionServer rs = mockRegionServer(conf);
    final FileSystemUtilizationChore chore = new FileSystemUtilizationChore(rs);
    doAnswer(new ExpectedRegionSizeSummationAnswer(sum(regionSizes))).when(rs)
      .reportRegionSizesForQuotas(any(RegionSizeStore.class));

    final Region region = mockRegionWithSize(regionSizes);
    doReturn(Arrays.asList(region)).when(rs).getRegions();
    chore.chore();
  }",Eager Test
"@Test
  public void testProcessingLeftoverRegions() {
    final Configuration conf = getDefaultHBaseConfiguration();
    final HRegionServer rs = mockRegionServer(conf);

    // Some leftover regions from a previous chore()
    final List<Long> leftover1Sizes = Arrays.asList(1024L, 4096L);
    final long leftover1Sum = sum(leftover1Sizes);
    final List<Long> leftover2Sizes = Arrays.asList(2048L);
    final long leftover2Sum = sum(leftover2Sizes);

    final Region lr1 = mockRegionWithSize(leftover1Sizes);
    final Region lr2 = mockRegionWithSize(leftover2Sizes);
    final FileSystemUtilizationChore chore = new FileSystemUtilizationChore(rs) {
      @Override
      Iterator<Region> getLeftoverRegions() {
        return Arrays.asList(lr1, lr2).iterator();
      }",Eager Test
"@Test
  public void testMergeSpace() throws IOException {
    TableName tn = TableName.valueOf(""foo"");
    QuotaProtos.Quotas quota = QuotaProtos.Quotas.newBuilder().setSpace(SPACE_QUOTA).build();

    GlobalQuotaSettingsImpl settings = new GlobalQuotaSettingsImpl(null, tn, null, null, quota);
    // Switch the violation policy to DISABLE
    GlobalQuotaSettingsImpl merged = settings
      .merge(new SpaceLimitSettings(tn, SPACE_QUOTA.getSoftLimit(), SpaceViolationPolicy.DISABLE));

    QuotaProtos.SpaceQuota mergedSpaceQuota = merged.getSpaceProto();
    assertEquals(SPACE_QUOTA.getSoftLimit(), mergedSpaceQuota.getSoftLimit());
    assertEquals(QuotaProtos.SpaceViolationPolicy.DISABLE, mergedSpaceQuota.getViolationPolicy());
  }",Eager Test
"@Test
  public void testUninitializedQuotaManangerDoesNotFail() {
    MasterServices masterServices = mock(MasterServices.class);
    MasterQuotaManager manager = new MasterQuotaManager(masterServices);
    manager.addRegionSize(null, 0, 0);
    assertNotNull(manager.snapshotRegionSizes());
  }",No Smells
"@Test
  public void testNamespaceRPCQuotaRemoved() throws Exception {
    final Connection conn = TEST_UTIL.getConnection();
    final Admin admin = conn.getAdmin();
    final String ns = testName.getMethodName();
    // Drop the ns if it somehow exists
    if (namespaceExists(ns)) {
      admin.deleteNamespace(ns);
    }",Eager Test
"@Test
  public void testNamespaceSpaceAndRPCQuotaRemoved() throws Exception {
    final Connection conn = TEST_UTIL.getConnection();
    final Admin admin = conn.getAdmin();
    final String ns = testName.getMethodName();
    // Drop the ns if it somehow exists
    if (namespaceExists(ns)) {
      admin.deleteNamespace(ns);
    }",Eager Test
"@Test
  public void testNamespaceSpaceQuotaRemoved() throws Exception {
    final Connection conn = TEST_UTIL.getConnection();
    final Admin admin = conn.getAdmin();
    final String ns = testName.getMethodName();
    // Drop the ns if it somehow exists
    if (namespaceExists(ns)) {
      admin.deleteNamespace(ns);
    }",Eager Test
"@Test
  public void testTableSpaceQuotaRemoved() throws Exception {
    final Connection conn = TEST_UTIL.getConnection();
    final Admin admin = conn.getAdmin();
    final TableName tn = TableName.valueOf(testName.getMethodName());
    // Drop the table if it somehow exists
    if (admin.tableExists(tn)) {
      dropTable(admin, tn);
    }",Eager Test
"@Test
  public void testSpaceLimitSettings() {
    final TableName tableName = TableName.valueOf(""foo"");
    final long sizeLimit = 1024L * 1024L * 1024L * 75; // 75GB
    final SpaceViolationPolicy violationPolicy = SpaceViolationPolicy.NO_INSERTS;
    QuotaSettings settings =
      QuotaSettingsFactory.limitTableSpace(tableName, sizeLimit, violationPolicy);
    assertNotNull(""QuotaSettings should not be null"", settings);
    assertTrue(""Should be an instance of SpaceLimitSettings"",
      settings instanceof SpaceLimitSettings);
    SpaceLimitSettings spaceLimitSettings = (SpaceLimitSettings) settings;
    SpaceLimitRequest protoRequest = spaceLimitSettings.getProto();
    assertTrue(""Request should have a SpaceQuota"", protoRequest.hasQuota());
    SpaceQuota quota = protoRequest.getQuota();
    assertEquals(sizeLimit, quota.getSoftLimit());
    assertEquals(violationPolicy, ProtobufUtil.toViolationPolicy(quota.getViolationPolicy()));
    assertFalse(""The remove attribute should be false"", quota.getRemove());
  }",Eager Test
"@Test
  public void testQuotaStateUpdateGlobalThrottle() {
    final int NUM_GLOBAL_THROTTLE_1 = 3;
    final int NUM_GLOBAL_THROTTLE_2 = 11;
    final long LAST_UPDATE_1 = 10;
    final long LAST_UPDATE_2 = 20;
    final long LAST_UPDATE_3 = 30;

    QuotaState quotaInfo = new QuotaState();
    assertEquals(0, quotaInfo.getLastUpdate());
    assertTrue(quotaInfo.isBypass());

    // Add global throttle
    QuotaState otherQuotaState = new QuotaState(LAST_UPDATE_1);
    otherQuotaState.setQuotas(buildReqNumThrottle(NUM_GLOBAL_THROTTLE_1));
    assertEquals(LAST_UPDATE_1, otherQuotaState.getLastUpdate());
    assertFalse(otherQuotaState.isBypass());

    quotaInfo.update(otherQuotaState);
    assertEquals(LAST_UPDATE_1, quotaInfo.getLastUpdate());
    assertFalse(quotaInfo.isBypass());
    assertThrottleException(quotaInfo.getGlobalLimiter(), NUM_GLOBAL_THROTTLE_1);

    // Update global Throttle
    otherQuotaState = new QuotaState(LAST_UPDATE_2);
    otherQuotaState.setQuotas(buildReqNumThrottle(NUM_GLOBAL_THROTTLE_2));
    assertEquals(LAST_UPDATE_2, otherQuotaState.getLastUpdate());
    assertFalse(otherQuotaState.isBypass());

    quotaInfo.update(otherQuotaState);
    assertEquals(LAST_UPDATE_2, quotaInfo.getLastUpdate());
    assertFalse(quotaInfo.isBypass());
    assertThrottleException(quotaInfo.getGlobalLimiter(),
      NUM_GLOBAL_THROTTLE_2 - NUM_GLOBAL_THROTTLE_1);

    // Remove global throttle
    otherQuotaState = new QuotaState(LAST_UPDATE_3);
    assertEquals(LAST_UPDATE_3, otherQuotaState.getLastUpdate());
    assertTrue(otherQuotaState.isBypass());

    quotaInfo.update(otherQuotaState);
    assertEquals(LAST_UPDATE_3, quotaInfo.getLastUpdate());
    assertTrue(quotaInfo.isBypass());
    assertNoopLimiter(quotaInfo.getGlobalLimiter());
  }",Eager Test
"@Test
  public void testQuotaStateUpdateTableThrottle() {
    final TableName tableNameA = TableName.valueOf(name.getMethodName() + ""A"");
    final TableName tableNameB = TableName.valueOf(name.getMethodName() + ""B"");
    final TableName tableNameC = TableName.valueOf(name.getMethodName() + ""C"");
    final int TABLE_A_THROTTLE_1 = 3;
    final int TABLE_A_THROTTLE_2 = 11;
    final int TABLE_B_THROTTLE = 4;
    final int TABLE_C_THROTTLE = 5;
    final long LAST_UPDATE_1 = 10;
    final long LAST_UPDATE_2 = 20;
    final long LAST_UPDATE_3 = 30;

    UserQuotaState quotaInfo = new UserQuotaState();
    assertEquals(0, quotaInfo.getLastUpdate());
    assertTrue(quotaInfo.isBypass());

    // Add A B table limiters
    UserQuotaState otherQuotaState = new UserQuotaState(LAST_UPDATE_1);
    otherQuotaState.setQuotas(tableNameA, buildReqNumThrottle(TABLE_A_THROTTLE_1));
    otherQuotaState.setQuotas(tableNameB, buildReqNumThrottle(TABLE_B_THROTTLE));
    assertEquals(LAST_UPDATE_1, otherQuotaState.getLastUpdate());
    assertFalse(otherQuotaState.isBypass());

    quotaInfo.update(otherQuotaState);
    assertEquals(LAST_UPDATE_1, quotaInfo.getLastUpdate());
    assertFalse(quotaInfo.isBypass());
    assertThrottleException(quotaInfo.getTableLimiter(tableNameA), TABLE_A_THROTTLE_1);
    assertThrottleException(quotaInfo.getTableLimiter(tableNameB), TABLE_B_THROTTLE);
    assertNoopLimiter(quotaInfo.getTableLimiter(tableNameC));

    // Add C, Remove B, Update A table limiters
    otherQuotaState = new UserQuotaState(LAST_UPDATE_2);
    otherQuotaState.setQuotas(tableNameA, buildReqNumThrottle(TABLE_A_THROTTLE_2));
    otherQuotaState.setQuotas(tableNameC, buildReqNumThrottle(TABLE_C_THROTTLE));
    assertEquals(LAST_UPDATE_2, otherQuotaState.getLastUpdate());
    assertFalse(otherQuotaState.isBypass());

    quotaInfo.update(otherQuotaState);
    assertEquals(LAST_UPDATE_2, quotaInfo.getLastUpdate());
    assertFalse(quotaInfo.isBypass());
    assertThrottleException(quotaInfo.getTableLimiter(tableNameA),
      TABLE_A_THROTTLE_2 - TABLE_A_THROTTLE_1);
    assertThrottleException(quotaInfo.getTableLimiter(tableNameC), TABLE_C_THROTTLE);
    assertNoopLimiter(quotaInfo.getTableLimiter(tableNameB));

    // Remove table limiters
    otherQuotaState = new UserQuotaState(LAST_UPDATE_3);
    assertEquals(LAST_UPDATE_3, otherQuotaState.getLastUpdate());
    assertTrue(otherQuotaState.isBypass());

    quotaInfo.update(otherQuotaState);
    assertEquals(LAST_UPDATE_3, quotaInfo.getLastUpdate());
    assertTrue(quotaInfo.isBypass());
    assertNoopLimiter(quotaInfo.getTableLimiter(UNKNOWN_TABLE_NAME));
  }",Eager Test
"@Test
  public void testTableThrottleWithBatch() {
    final TableName TABLE_A = TableName.valueOf(""TableA"");
    final int TABLE_A_THROTTLE_1 = 3;
    final long LAST_UPDATE_1 = 10;

    UserQuotaState quotaInfo = new UserQuotaState();
    assertEquals(0, quotaInfo.getLastUpdate());
    assertTrue(quotaInfo.isBypass());

    // Add A table limiters
    UserQuotaState otherQuotaState = new UserQuotaState(LAST_UPDATE_1);
    otherQuotaState.setQuotas(TABLE_A, buildReqNumThrottle(TABLE_A_THROTTLE_1));
    assertEquals(LAST_UPDATE_1, otherQuotaState.getLastUpdate());
    assertFalse(otherQuotaState.isBypass());

    quotaInfo.update(otherQuotaState);
    assertEquals(LAST_UPDATE_1, quotaInfo.getLastUpdate());
    assertFalse(quotaInfo.isBypass());
    QuotaLimiter limiter = quotaInfo.getTableLimiter(TABLE_A);
    try {
      limiter.checkQuota(TABLE_A_THROTTLE_1 + 1, TABLE_A_THROTTLE_1 + 1, 0, 0, 1, 0);
      fail(""Should have thrown RpcThrottlingException"");
    }",Eager Test
"@Test
  public void testNamespaceQuotaUtil() throws Exception {
    final String namespace = ""testNamespaceQuotaUtilNS"";

    Quotas quota = Quotas.newBuilder()
      .setThrottle(Throttle.newBuilder()
        .setReqNum(ProtobufUtil.toTimedQuota(1000, TimeUnit.SECONDS, QuotaScope.MACHINE))
        .setWriteNum(ProtobufUtil.toTimedQuota(600, TimeUnit.SECONDS, QuotaScope.MACHINE))
        .setReadSize(ProtobufUtil.toTimedQuota(8192, TimeUnit.SECONDS, QuotaScope.MACHINE)).build())
      .build();

    // Add user quota and verify it
    QuotaUtil.addNamespaceQuota(this.connection, namespace, quota);
    Quotas resQuota = QuotaUtil.getNamespaceQuota(this.connection, namespace);
    assertEquals(quota, resQuota);

    // Remove user quota and verify it
    QuotaUtil.deleteNamespaceQuota(this.connection, namespace);
    resQuota = QuotaUtil.getNamespaceQuota(this.connection, namespace);
    assertEquals(null, resQuota);
  }",Eager Test
"@Test
  public void testCanExecuteOfFixedIntervalRateLimiter() throws InterruptedException {
    RateLimiter limiter = new FixedIntervalRateLimiter();
    // when set limit is 100 per sec, this FixedIntervalRateLimiter will support at max 100 per sec
    limiter.set(100, TimeUnit.SECONDS);
    limiter.setNextRefillTime(EnvironmentEdgeManager.currentTime());
    assertEquals(50, testCanExecuteByRate(limiter, 50));

    // refill the avail to limit
    limiter.set(100, TimeUnit.SECONDS);
    limiter.setNextRefillTime(EnvironmentEdgeManager.currentTime());
    assertEquals(100, testCanExecuteByRate(limiter, 100));

    // refill the avail to limit
    limiter.set(100, TimeUnit.SECONDS);
    limiter.setNextRefillTime(EnvironmentEdgeManager.currentTime());
    assertEquals(100, testCanExecuteByRate(limiter, 200));
  }",No Smells
"@Test
  public void testLimiterCompensationOverflow() throws InterruptedException {

    long limit = Long.MAX_VALUE - 1;
    long guessNumber = 100;

    // For unconfigured limiters, it is supposed to use as much as possible
    RateLimiter avgLimiter = new AverageIntervalRateLimiter();
    avgLimiter.set(limit, TimeUnit.SECONDS);

    assertEquals(limit, avgLimiter.getAvailable());

    // The initial guess is that 100 bytes.
    assertEquals(0, avgLimiter.getWaitIntervalMs(guessNumber));
    avgLimiter.consume(guessNumber);

    // Make sure that available is whatever left
    assertEquals((limit - guessNumber), avgLimiter.getAvailable());

    // Manually set avil to simulate that another thread call canExecute().
    // It is simulated by consume().
    avgLimiter.consume(-80);
    assertEquals((limit - guessNumber + 80), avgLimiter.getAvailable());

    // Now thread1 compensates 80
    avgLimiter.consume(-80);
    assertEquals(limit, avgLimiter.getAvailable());
  }",No Smells
"@Test
  public void testUnconfiguredLimiters() throws InterruptedException {

    ManualEnvironmentEdge testEdge = new ManualEnvironmentEdge();
    EnvironmentEdgeManager.injectEdge(testEdge);
    long limit = Long.MAX_VALUE;

    // For unconfigured limiters, it is supposed to use as much as possible
    RateLimiter avgLimiter = new AverageIntervalRateLimiter();
    RateLimiter fixLimiter = new FixedIntervalRateLimiter();

    assertEquals(limit, avgLimiter.getAvailable());
    assertEquals(limit, fixLimiter.getAvailable());

    assertEquals(0, avgLimiter.getWaitIntervalMs(limit));
    avgLimiter.consume(limit);

    assertEquals(0, fixLimiter.getWaitIntervalMs(limit));
    fixLimiter.consume(limit);

    // Make sure that available is Long.MAX_VALUE
    assertEquals(limit, avgLimiter.getAvailable());
    assertEquals(limit, fixLimiter.getAvailable());

    // after 100 millseconds, it should be able to execute limit as well
    testEdge.incValue(100);

    assertEquals(0, avgLimiter.getWaitIntervalMs(limit));
    avgLimiter.consume(limit);

    assertEquals(0, fixLimiter.getWaitIntervalMs(limit));
    fixLimiter.consume(limit);

    // Make sure that available is Long.MAX_VALUE
    assertEquals(limit, avgLimiter.getAvailable());
    assertEquals(limit, fixLimiter.getAvailable());

    EnvironmentEdgeManager.reset();
  }",No Smells
"@Test
  public void testWaitIntervalTimeUnitSeconds() {
    testWaitInterval(TimeUnit.SECONDS, 10, 100);
  }",No Smells
"@Test
  public void testBucketingFilesToSnapshots() throws Exception {
    // Create a table and set a quota
    TableName tn1 = helper.createTableWithRegions(1);
    admin.setQuota(QuotaSettingsFactory.limitTableSpace(tn1, SpaceQuotaHelperForTests.ONE_GIGABYTE,
      SpaceViolationPolicy.NO_INSERTS));

    // Write some data and flush it
    helper.writeData(tn1, 256L * SpaceQuotaHelperForTests.ONE_KILOBYTE);
    admin.flush(tn1);

    final AtomicReference<Long> lastSeenSize = new AtomicReference<>();
    // Wait for the Master chore to run to see the usage (with a fudge factor)
    TEST_UTIL.waitFor(30_000, new SpaceQuotaSnapshotPredicate(conn, tn1) {
      @Override
      boolean evaluate(SpaceQuotaSnapshot snapshot) throws Exception {
        lastSeenSize.set(snapshot.getUsage());
        return snapshot.getUsage() > 230L * SpaceQuotaHelperForTests.ONE_KILOBYTE;
      }",Eager Test + Mystery Guest
"@Test
  public void testSnapshotsFromNamespaces() throws Exception {
    NamespaceDescriptor ns = NamespaceDescriptor.create(""snapshots_from_namespaces"").build();
    admin.createNamespace(ns);

    TableName tn1 = helper.createTableWithRegions(ns.getName(), 1);
    TableName tn2 = helper.createTableWithRegions(ns.getName(), 1);
    TableName tn3 = helper.createTableWithRegions(1);

    // Set a throttle quota on 'default' namespace
    admin.setQuota(QuotaSettingsFactory.throttleNamespace(tn3.getNamespaceAsString(),
      ThrottleType.WRITE_NUMBER, 100, TimeUnit.SECONDS));
    // Set a user throttle quota
    admin.setQuota(
      QuotaSettingsFactory.throttleUser(""user"", ThrottleType.WRITE_NUMBER, 100, TimeUnit.MINUTES));

    // Set a space quota on the namespace
    admin.setQuota(QuotaSettingsFactory.limitNamespaceSpace(ns.getName(),
      SpaceQuotaHelperForTests.ONE_GIGABYTE, SpaceViolationPolicy.NO_INSERTS));

    // Create snapshots on each table (we didn't write any data, so just skipflush)
    admin.snapshot(new SnapshotDescription(tn1.getQualifierAsString() + ""snapshot"", tn1,
      SnapshotType.SKIPFLUSH));
    admin.snapshot(new SnapshotDescription(tn2.getQualifierAsString() + ""snapshot"", tn2,
      SnapshotType.SKIPFLUSH));
    admin.snapshot(new SnapshotDescription(tn3.getQualifierAsString() + ""snapshot"", tn3,
      SnapshotType.SKIPFLUSH));

    Multimap<TableName, String> mapping = testChore.getSnapshotsToComputeSize();
    assertEquals(2, mapping.size());
    assertEquals(1, mapping.get(tn1).size());
    assertEquals(tn1.getQualifierAsString() + ""snapshot"", mapping.get(tn1).iterator().next());
    assertEquals(1, mapping.get(tn2).size());
    assertEquals(tn2.getQualifierAsString() + ""snapshot"", mapping.get(tn2).iterator().next());

    admin.snapshot(new SnapshotDescription(tn2.getQualifierAsString() + ""snapshot1"", tn2,
      SnapshotType.SKIPFLUSH));
    admin.snapshot(new SnapshotDescription(tn3.getQualifierAsString() + ""snapshot2"", tn3,
      SnapshotType.SKIPFLUSH));

    mapping = testChore.getSnapshotsToComputeSize();
    assertEquals(3, mapping.size());
    assertEquals(1, mapping.get(tn1).size());
    assertEquals(tn1.getQualifierAsString() + ""snapshot"", mapping.get(tn1).iterator().next());
    assertEquals(2, mapping.get(tn2).size());
    assertEquals(new HashSet<String>(Arrays.asList(tn2.getQualifierAsString() + ""snapshot"",
      tn2.getQualifierAsString() + ""snapshot1"")), mapping.get(tn2));
  }",Eager Test + Mystery Guest
"@Test
  public void testSnapshotSize() throws Exception {
    // Create a table and set a quota
    TableName tn1 = helper.createTableWithRegions(5);
    admin.setQuota(QuotaSettingsFactory.limitTableSpace(tn1, SpaceQuotaHelperForTests.ONE_GIGABYTE,
      SpaceViolationPolicy.NO_INSERTS));

    // Write some data and flush it
    helper.writeData(tn1, 256L * SpaceQuotaHelperForTests.ONE_KILOBYTE);
    admin.flush(tn1);

    final long snapshotSize = TEST_UTIL.getMiniHBaseCluster().getRegions(tn1).stream()
      .flatMap(r -> r.getStores().stream()).mapToLong(HStore::getHFilesSize).sum();

    // Wait for the Master chore to run to see the usage (with a fudge factor)
    TEST_UTIL.waitFor(30_000, new SpaceQuotaSnapshotPredicate(conn, tn1) {
      @Override
      boolean evaluate(SpaceQuotaSnapshot snapshot) throws Exception {
        return snapshot.getUsage() == snapshotSize;
      }",Eager Test + Mystery Guest
"@Test
  public void testSanityCheckMinVersion() throws IOException {
    error.expect(DoNotRetryIOException.class);
    error.expectMessage(""MIN_VERSION > 0 is not supported for FIFO compaction"");
    TableName tableName = TableName.valueOf(getClass().getSimpleName() + ""-MinVersion"");
    TableDescriptor desc = TableDescriptorBuilder.newBuilder(tableName)
      .setValue(DefaultStoreEngine.DEFAULT_COMPACTION_POLICY_CLASS_KEY,
        FIFOCompactionPolicy.class.getName())
      .setValue(HConstants.HBASE_REGION_SPLIT_POLICY_KEY, DisabledRegionSplitPolicy.class.getName())
      .setColumnFamily(
        ColumnFamilyDescriptorBuilder.newBuilder(family).setTimeToLive(1).setMinVersions(1).build())
      .build();
    TEST_UTIL.getAdmin().createTable(desc);
  }",Eager Test
"@Test
  public void testSetPeakHourOutsideCurrentSelection() {
    conf.setLong(CompactionConfiguration.HBASE_HSTORE_OFFPEAK_START_HOUR, hourMinusTwo);
    conf.setLong(CompactionConfiguration.HBASE_HSTORE_OFFPEAK_END_HOUR, hourMinusOne);
    OffPeakHours target = OffPeakHours.getInstance(conf);
    assertFalse(target.isOffPeakHour(hourOfDay));
  }",No Smells
"@Test
  public void testSetPeakHourToTargetTime() {
    conf.setLong(CompactionConfiguration.HBASE_HSTORE_OFFPEAK_START_HOUR, hourMinusOne);
    conf.setLong(CompactionConfiguration.HBASE_HSTORE_OFFPEAK_END_HOUR, hourPlusOne);
    OffPeakHours target = OffPeakHours.getInstance(conf);
    assertTrue(target.isOffPeakHour(hourOfDay));
  }",No Smells
"@Test
  public void testSingleStripeDropDeletes() throws Exception {
    Configuration conf = HBaseConfiguration.create();
    // Test depends on this not being set to pass. Default breaks test. TODO: Revisit.
    conf.unset(""hbase.hstore.compaction.min.size"");
    StripeCompactionPolicy policy = createPolicy(conf);
    // Verify the deletes can be dropped if there are no L0 files.
    Long[][] stripes = new Long[][] { new Long[] { 3L, 2L, 2L, 2L }",Eager Test + Mystery Guest
"@Test
  public void testSizeCompactions() throws Exception {
    // General verification with different sizes.
    verifySizeCompaction(a(KV_A, KV_A, KV_B, KV_C, KV_D), 3, 2, OPEN_KEY, OPEN_KEY,
      a(a(KV_A, KV_A), a(KV_B, KV_C), a(KV_D)));
    verifySizeCompaction(a(KV_A, KV_B, KV_C, KV_D), 4, 1, OPEN_KEY, OPEN_KEY,
      a(a(KV_A), a(KV_B), a(KV_C), a(KV_D)));
    verifySizeCompaction(a(KV_B, KV_C), 2, 1, KEY_B, KEY_D, a(a(KV_B), a(KV_C)));
    // Verify row boundaries are preserved.
    verifySizeCompaction(a(KV_A, KV_A, KV_A, KV_C, KV_D), 3, 2, OPEN_KEY, OPEN_KEY,
      a(a(KV_A, KV_A, KV_A), a(KV_C, KV_D)));
    verifySizeCompaction(a(KV_A, KV_B, KV_B, KV_C), 3, 1, OPEN_KEY, OPEN_KEY,
      a(a(KV_A), a(KV_B, KV_B), a(KV_C)));
    // Too much data, count limits the number of files.
    verifySizeCompaction(a(KV_A, KV_B, KV_C, KV_D), 2, 1, OPEN_KEY, OPEN_KEY,
      a(a(KV_A), a(KV_B, KV_C, KV_D)));
    verifySizeCompaction(a(KV_A, KV_B, KV_C), 1, Long.MAX_VALUE, OPEN_KEY, KEY_D,
      new KeyValue[][] { a(KV_A, KV_B, KV_C) }",No Smells
"@Test
  public void testMaxVersionMask() {
    NewVersionBehaviorTracker tracker =
      new NewVersionBehaviorTracker(null, comparator, 1, 3, 3, 10000);

    KeyValue keyValue = new KeyValue(row, family, col1, 20000, KeyValue.Type.Put, value);
    keyValue.setTimestamp(20000);
    keyValue.setSequenceId(1000);
    assertEquals(DeleteResult.NOT_DELETED, tracker.isDeleted(keyValue));
    keyValue.setTimestamp(19999);
    keyValue.setSequenceId(999);
    assertEquals(DeleteResult.NOT_DELETED, tracker.isDeleted(keyValue));
    keyValue.setTimestamp(19999);
    keyValue.setSequenceId(998);
    assertEquals(DeleteResult.VERSION_MASKED, tracker.isDeleted(keyValue));
    keyValue.setTimestamp(19998);
    keyValue.setSequenceId(997);
    assertEquals(DeleteResult.NOT_DELETED, tracker.isDeleted(keyValue));
    keyValue.setTimestamp(19997);
    keyValue.setSequenceId(996);
    assertEquals(DeleteResult.VERSION_MASKED, tracker.isDeleted(keyValue));

    keyValue = new KeyValue(row, family, col2, 20000, KeyValue.Type.Put, value);
    keyValue.setTimestamp(20000);
    keyValue.setSequenceId(1000);
    assertEquals(DeleteResult.NOT_DELETED, tracker.isDeleted(keyValue));
    keyValue.setTimestamp(19999);
    keyValue.setSequenceId(1002);
    assertEquals(DeleteResult.NOT_DELETED, tracker.isDeleted(keyValue));
    keyValue.setTimestamp(19999);
    keyValue.setSequenceId(1001);
    assertEquals(DeleteResult.VERSION_MASKED, tracker.isDeleted(keyValue));
    keyValue.setTimestamp(19998);
    keyValue.setSequenceId(1003);
    assertEquals(DeleteResult.NOT_DELETED, tracker.isDeleted(keyValue));
    keyValue.setTimestamp(19997);
    keyValue.setSequenceId(1004);
    assertEquals(DeleteResult.VERSION_MASKED, tracker.isDeleted(keyValue));
  }",Eager Test
"@Test
  public void testVersionsDelete() {
    NewVersionBehaviorTracker tracker =
      new NewVersionBehaviorTracker(null, comparator, 1, 3, 3, 10000);
    KeyValue put = new KeyValue(row, family, col1, 20000, KeyValue.Type.Put, value);
    KeyValue delete = new KeyValue(row, family, col1, 20000, KeyValue.Type.DeleteColumn, value);
    delete.setSequenceId(1000);
    delete.setTimestamp(20000);
    tracker.add(delete);
    put.setSequenceId(1001);
    put.setTimestamp(19999);
    assertEquals(DeleteResult.NOT_DELETED, tracker.isDeleted(put));
    put.setSequenceId(999);
    put.setTimestamp(19998);
    assertEquals(DeleteResult.COLUMN_DELETED, tracker.isDeleted(put));

    delete = new KeyValue(row, family, col2, 20000, KeyValue.Type.DeleteColumn, value);
    delete.setSequenceId(1002);
    delete.setTimestamp(20000);
    tracker.add(delete);
    put = new KeyValue(row, family, col2, 20000, KeyValue.Type.Put, value);
    put.setSequenceId(1001);
    put.setTimestamp(19999);
    assertEquals(DeleteResult.COLUMN_DELETED, tracker.isDeleted(put));
    put.setSequenceId(999);
    put.setTimestamp(19998);
    assertEquals(DeleteResult.COLUMN_DELETED, tracker.isDeleted(put));
  }",Eager Test
"@Test
  public void testDeleteKeepDelete() {
    byte[] qualifier = Bytes.toBytes(""qualifier"");
    KeyValue kv = new KeyValue(Bytes.toBytes(""row""), Bytes.toBytes(""f""), qualifier, timestamp,
      KeyValue.Type.Delete);
    sdt.add(kv);
    sdt.isDeleted(kv);
    assertEquals(false, sdt.isEmpty());
  }",Eager Test
"@Test
  public void DisabledTestCheckColumnWrongOrder() {
    ScanWildcardColumnTracker tracker =
      new ScanWildcardColumnTracker(0, VERSIONS, Long.MIN_VALUE, CellComparatorImpl.COMPARATOR);

    // Create list of qualifiers
    List<byte[]> qualifiers = new ArrayList<>(2);
    qualifiers.add(Bytes.toBytes(""qualifier2""));
    qualifiers.add(Bytes.toBytes(""qualifier1""));

    try {
      for (byte[] qualifier : qualifiers) {
        ScanQueryMatcher.checkColumn(tracker, qualifier, 0, qualifier.length, 1,
          KeyValue.Type.Put.getCode(), false);
      }",Eager Test
"@Test
  public void testMatch_Wildcard() throws IOException {
    // Moving up from the Tracker by using Gets and List<KeyValue> instead
    // of just byte []

    // Expected result
    List<MatchCode> expected = new ArrayList<>(6);
    expected.add(ScanQueryMatcher.MatchCode.INCLUDE);
    expected.add(ScanQueryMatcher.MatchCode.INCLUDE);
    expected.add(ScanQueryMatcher.MatchCode.INCLUDE);
    expected.add(ScanQueryMatcher.MatchCode.INCLUDE);
    expected.add(ScanQueryMatcher.MatchCode.INCLUDE);
    expected.add(ScanQueryMatcher.MatchCode.DONE);

    long now = EnvironmentEdgeManager.currentTime();
    UserScanQueryMatcher qm = UserScanQueryMatcher.create(scan, new ScanInfo(this.conf, fam2, 0, 1,
      ttl, KeepDeletedCells.FALSE, HConstants.DEFAULT_BLOCKSIZE, 0, rowComparator, false), null,
      now - ttl, now, null);

    List<KeyValue> memstore = new ArrayList<>(6);
    memstore.add(new KeyValue(row1, fam2, col1, 1, data));
    memstore.add(new KeyValue(row1, fam2, col2, 1, data));
    memstore.add(new KeyValue(row1, fam2, col3, 1, data));
    memstore.add(new KeyValue(row1, fam2, col4, 1, data));
    memstore.add(new KeyValue(row1, fam2, col5, 1, data));
    memstore.add(new KeyValue(row2, fam1, col1, 1, data));

    List<ScanQueryMatcher.MatchCode> actual = new ArrayList<>(memstore.size());

    KeyValue k = memstore.get(0);
    qm.setToNewRow(k);

    for (KeyValue kv : memstore) {
      actual.add(qm.match(kv));
    }",Eager Test
"@Test
  public void testMatchWhenFilterReturnsIncludeAndSeekNextRow() throws IOException {
    List<MatchCode> expected = new ArrayList<>();
    expected.add(ScanQueryMatcher.MatchCode.INCLUDE_AND_SEEK_NEXT_ROW);
    expected.add(ScanQueryMatcher.MatchCode.DONE);

    Scan scanWithFilter = new Scan(scan).setFilter(new AlwaysIncludeAndSeekNextRowFilter());

    long now = EnvironmentEdgeManager.currentTime();

    // scan with column 2,4,5
    UserScanQueryMatcher qm = UserScanQueryMatcher.create(
      scanWithFilter, new ScanInfo(this.conf, fam2, 0, 1, ttl, KeepDeletedCells.FALSE,
        HConstants.DEFAULT_BLOCKSIZE, 0, rowComparator, false),
      get.getFamilyMap().get(fam2), now - ttl, now, null);

    List<KeyValue> memstore = new ArrayList<>();
    // ColumnTracker will return INCLUDE_AND_SEEK_NEXT_COL , and filter will return
    // INCLUDE_AND_SEEK_NEXT_ROW, so final match code will be INCLUDE_AND_SEEK_NEXT_ROW.
    memstore.add(new KeyValue(row1, fam2, col2, 1, data));
    memstore.add(new KeyValue(row2, fam1, col1, data));

    List<ScanQueryMatcher.MatchCode> actual = new ArrayList<>(memstore.size());
    KeyValue k = memstore.get(0);
    qm.setToNewRow(k);

    for (KeyValue kv : memstore) {
      actual.add(qm.match(kv));
    }",Eager Test
"@Test
  public void testRewritingClusterIdToPB() throws Exception {
    TEST_UTIL.startMiniZKCluster();
    TEST_UTIL.startMiniDFSCluster(1);
    TEST_UTIL.createRootDir();
    Path rootDir = CommonFSUtils.getRootDir(TEST_UTIL.getConfiguration());
    FileSystem fs = rootDir.getFileSystem(TEST_UTIL.getConfiguration());
    Path filePath = new Path(rootDir, HConstants.CLUSTER_ID_FILE_NAME);
    FSDataOutputStream s = null;
    try {
      s = fs.create(filePath);
      s.writeUTF(HBaseCommonTestingUtil.getRandomUUID().toString());
    }",Eager Test
"@Test
  public void testCompaction2Buckets() throws IOException {

    // set memstore to do basic structure flattening, the ""eager"" option is tested in
    // TestCompactingToCellFlatMapMemStore
    MemoryCompactionPolicy compactionType = MemoryCompactionPolicy.BASIC;
    memstore.getConfiguration().set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,
      String.valueOf(compactionType));
    memstore.getConfiguration().set(MemStoreCompactionStrategy.COMPACTING_MEMSTORE_THRESHOLD_KEY,
      String.valueOf(1));
    ((MyCompactingMemStore) memstore).initiateType(compactionType, memstore.getConfiguration());
    String[] keys1 = { ""A"", ""A"", ""B"", ""C"" }",Eager Test
"@Test
  public void testUpdateToTimeOfOldestEdit() throws Exception {
    try {
      EnvironmentEdgeForMemstoreTest edge = new EnvironmentEdgeForMemstoreTest();
      EnvironmentEdgeManager.injectEdge(edge);
      long t = memstore.timeOfOldestEdit();
      assertEquals(Long.MAX_VALUE, t);

      // test the case that the timeOfOldestEdit is updated after a KV add
      memstore.add(KeyValueTestUtil.create(""r"", ""f"", ""q"", 100, ""v""), null);
      t = memstore.timeOfOldestEdit();
      assertTrue(t == 1234);
      // The method will also assert
      // the value is reset to Long.MAX_VALUE
      t = runSnapshot(memstore, true);

      // test the case that the timeOfOldestEdit is updated after a KV delete
      memstore.add(KeyValueTestUtil.create(""r"", ""f"", ""q"", 100, KeyValue.Type.Delete, ""v""), null);
      t = memstore.timeOfOldestEdit();
      assertTrue(t == 1234);
      t = runSnapshot(memstore, true);

      // test the case that the timeOfOldestEdit is updated after a KV upsert
      List<ExtendedCell> l = new ArrayList<>();
      KeyValue kv1 = KeyValueTestUtil.create(""r"", ""f"", ""q"", 100, ""v"");
      kv1.setSequenceId(100);
      l.add(kv1);
      memstore.upsert(l, 1000, null);
      t = memstore.timeOfOldestEdit();
      assertTrue(t == 1234);
    }",Eager Test
"@Test
  public void testCreateKey() {
    byte[] row = Bytes.toBytes(""myRow"");
    byte[] qualifier = Bytes.toBytes(""myQualifier"");
    // Mimic what Storefile.createBloomKeyValue() does
    byte[] rowKey =
      KeyValueUtil.createFirstOnRow(row, 0, row.length, new byte[0], 0, 0, row, 0, 0).getKey();
    byte[] rowColKey = KeyValueUtil
      .createFirstOnRow(row, 0, row.length, new byte[0], 0, 0, qualifier, 0, qualifier.length)
      .getKey();
    KeyValue rowKV = KeyValueUtil.createKeyValueFromKey(rowKey);
    KeyValue rowColKV = KeyValueUtil.createKeyValueFromKey(rowColKey);
    assertEquals(rowKV.getTimestamp(), rowColKV.getTimestamp());
    assertEquals(
      Bytes.toStringBinary(rowKV.getRowArray(), rowKV.getRowOffset(), rowKV.getRowLength()), Bytes
        .toStringBinary(rowColKV.getRowArray(), rowColKV.getRowOffset(), rowColKV.getRowLength()));
    assertEquals(0, rowKV.getQualifierLength());
  }",Eager Test
"@Test
  public void testHFileAllCellsWithTags() throws IOException {
    testHFile(""1234567890"", true, true);
  }",No Smells
"@Test
  public void negativeForMajor() throws IOException {
    long[] minTimestamps =
      new long[] { -155, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100 }",No Smells
"@Test
  public void NotIncomingWindow() throws IOException {
    long[] minTimestamps = new long[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }",No Smells
"@Test
  public void RatioT2() throws IOException {
    long[] minTimestamps = new long[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }",No Smells
"@Test
  public void testGetWithDeleteColumn() throws IOException {
    byte[] row = Bytes.toBytes(""testrow"");
    byte[] fam = Bytes.toBytes(""testfamily"");
    byte[] qf1 = Bytes.toBytes(""testqualifier"");
    byte[] val = Bytes.toBytes(""testval"");

    long ts1 = System.nanoTime();
    KeyValue put1 = new KeyValue(row, fam, qf1, ts1, val);
    long ts2 = ts1 + 1;
    KeyValue put2 = new KeyValue(row, fam, qf1, ts2, val);
    long ts3 = ts2 + 1;
    KeyValue put3 = new KeyValue(row, fam, qf1, ts3, val);
    memstore.add(put1, null);
    memstore.add(put2, null);
    memstore.add(put3, null);

    assertEquals(3, memstore.getActive().getCellsCount());

    KeyValue del2 = new KeyValue(row, fam, qf1, ts2, KeyValue.Type.DeleteColumn, val);
    memstore.add(del2, null);

    List<Cell> expected = new ArrayList<>();
    expected.add(put3);
    expected.add(del2);
    expected.add(put2);
    expected.add(put1);

    assertEquals(4, memstore.getActive().getCellsCount());
    int i = 0;
    for (Cell cell : memstore.getActive().getCellSet()) {
      assertEquals(expected.get(i++), cell);
    }",Eager Test
"@Test
  public void testKeepDeleteInmemstore() {
    byte[] row = Bytes.toBytes(""testrow"");
    byte[] fam = Bytes.toBytes(""testfamily"");
    byte[] qf = Bytes.toBytes(""testqualifier"");
    byte[] val = Bytes.toBytes(""testval"");
    long ts = System.nanoTime();
    memstore.add(new KeyValue(row, fam, qf, ts, val), null);
    KeyValue delete = new KeyValue(row, fam, qf, ts, KeyValue.Type.Delete, val);
    memstore.add(delete, null);
    assertEquals(2, memstore.getActive().getCellsCount());
    assertEquals(delete, memstore.getActive().first());
  }",Eager Test
"@Test
  public void testMemstoreDeletesVisibilityWithSameKey() throws IOException {
    final byte[] row = Bytes.toBytes(1);
    final byte[] f = Bytes.toBytes(""family"");
    final byte[] q1 = Bytes.toBytes(""q1"");
    final byte[] q2 = Bytes.toBytes(""q2"");
    final byte[] v1 = Bytes.toBytes(""value1"");
    // INSERT 1: Write both columns val1
    MultiVersionConcurrencyControl.WriteEntry w = mvcc.begin();

    KeyValue kv11 = new KeyValue(row, f, q1, v1);
    kv11.setSequenceId(w.getWriteNumber());
    memstore.add(kv11, null);

    KeyValue kv12 = new KeyValue(row, f, q2, v1);
    kv12.setSequenceId(w.getWriteNumber());
    memstore.add(kv12, null);
    mvcc.completeAndWait(w);

    // BEFORE STARTING INSERT 2, SEE FIRST KVS
    KeyValueScanner s = this.memstore.getScanners(mvcc.getReadPoint()).get(0);
    assertScannerResults(s, new KeyValue[] { kv11, kv12 }",Eager Test
"@Test
  public void testReadOwnWritesUnderConcurrency() throws Throwable {
    int NUM_THREADS = 8;

    ReadOwnWritesTester threads[] = new ReadOwnWritesTester[NUM_THREADS];
    AtomicReference<Throwable> caught = new AtomicReference<>();

    for (int i = 0; i < NUM_THREADS; i++) {
      threads[i] = new ReadOwnWritesTester(i, memstore, mvcc, caught);
      threads[i].start();
    }",Eager Test
"@Test
  public void testRetainsDeleteFamily() throws IOException {
    // add a put to memstore
    memstore.add(KeyValueTestUtil.create(""row1"", ""fam"", ""a"", 100, ""dont-care""), null);

    // now process a specific delete:
    KeyValue delete =
      KeyValueTestUtil.create(""row1"", ""fam"", ""a"", 100, KeyValue.Type.DeleteFamily, ""dont-care"");
    memstore.add(delete, null);

    assertEquals(2, memstore.getActive().getCellsCount());
    assertEquals(delete, memstore.getActive().first());
  }",Eager Test
"@Test
  public void testShouldFlushMeta() throws Exception {
    // write an edit in the META and ensure the shouldFlush (that the periodic memstore
    // flusher invokes) returns true after SYSTEM_CACHE_FLUSH_INTERVAL (even though
    // the MEMSTORE_PERIODIC_FLUSH_INTERVAL is set to a higher value)
    Configuration conf = new Configuration();
    conf.setInt(HRegion.MEMSTORE_PERIODIC_FLUSH_INTERVAL, HRegion.SYSTEM_CACHE_FLUSH_INTERVAL * 10);
    HBaseTestingUtil hbaseUtility = new HBaseTestingUtil(conf);
    Path testDir = hbaseUtility.getDataTestDir();
    EnvironmentEdgeForMemstoreTest edge = new EnvironmentEdgeForMemstoreTest();
    EnvironmentEdgeManager.injectEdge(edge);
    edge.setCurrentTimeMillis(1234);
    WALFactory wFactory = new WALFactory(conf, ""1234"");
    TableDescriptors tds = new FSTableDescriptors(conf);
    FSTableDescriptors.tryUpdateMetaTableDescriptor(conf);
    HRegion meta = HRegion.createHRegion(RegionInfoBuilder.FIRST_META_REGIONINFO, testDir, conf,
      tds.get(TableName.META_TABLE_NAME), wFactory.getWAL(RegionInfoBuilder.FIRST_META_REGIONINFO));
    // parameterized tests add [#] suffix get rid of [ and ].
    TableDescriptor desc = TableDescriptorBuilder
      .newBuilder(TableName.valueOf(name.getMethodName().replaceAll(""[\\[\\]]"", ""_"")))
      .setColumnFamily(ColumnFamilyDescriptorBuilder.of(""foo"")).build();
    RegionInfo hri = RegionInfoBuilder.newBuilder(desc.getTableName())
      .setStartKey(Bytes.toBytes(""row_0200"")).setEndKey(Bytes.toBytes(""row_0300"")).build();
    HRegion r = HRegion.createHRegion(hri, testDir, conf, desc, wFactory.getWAL(hri));
    addRegionToMETA(meta, r);
    edge.setCurrentTimeMillis(1234 + 100);
    StringBuilder sb = new StringBuilder();
    assertTrue(meta.shouldFlush(sb) == false);
    edge.setCurrentTimeMillis(edge.currentTime() + HRegion.SYSTEM_CACHE_FLUSH_INTERVAL + 1);
    assertTrue(meta.shouldFlush(sb) == true);
  }",Eager Test
"@Test
  public void testUpdateToTimeOfOldestEdit() throws Exception {
    try {
      EnvironmentEdgeForMemstoreTest edge = new EnvironmentEdgeForMemstoreTest();
      EnvironmentEdgeManager.injectEdge(edge);
      DefaultMemStore memstore = new DefaultMemStore();
      long t = memstore.timeOfOldestEdit();
      assertEquals(Long.MAX_VALUE, t);

      // test the case that the timeOfOldestEdit is updated after a KV add
      memstore.add(KeyValueTestUtil.create(""r"", ""f"", ""q"", 100, ""v""), null);
      t = memstore.timeOfOldestEdit();
      assertTrue(t == 1234);
      // snapshot() will reset timeOfOldestEdit. The method will also assert the
      // value is reset to Long.MAX_VALUE
      t = runSnapshot(memstore);

      // test the case that the timeOfOldestEdit is updated after a KV delete
      memstore.add(KeyValueTestUtil.create(""r"", ""f"", ""q"", 100, KeyValue.Type.Delete, ""v""), null);
      t = memstore.timeOfOldestEdit();
      assertTrue(t == 1234);
      t = runSnapshot(memstore);

      // test the case that the timeOfOldestEdit is updated after a KV upsert
      List<ExtendedCell> l = new ArrayList<>();
      KeyValue kv1 = KeyValueTestUtil.create(""r"", ""f"", ""q"", 100, ""v"");
      kv1.setSequenceId(100);
      l.add(kv1);
      memstore.upsert(l, 1000, null);
      t = memstore.timeOfOldestEdit();
      assertTrue(t == 1234);
    }",Eager Test
"@Test
  public void testCustomParts() throws Exception {
    Configuration conf = HBaseConfiguration.create();
    conf.set(DefaultStoreEngine.DEFAULT_COMPACTOR_CLASS_KEY, DummyCompactor.class.getName());
    conf.set(DefaultStoreEngine.DEFAULT_COMPACTION_POLICY_CLASS_KEY,
      DummyCompactionPolicy.class.getName());
    conf.set(DefaultStoreEngine.DEFAULT_STORE_FLUSHER_CLASS_KEY, DummyStoreFlusher.class.getName());
    HRegion mockRegion = Mockito.mock(HRegion.class);
    HStore mockStore = Mockito.mock(HStore.class);
    mockStore.conf = conf;
    Mockito.when(mockStore.getRegionInfo()).thenReturn(RegionInfoBuilder.FIRST_META_REGIONINFO);
    Mockito.when(mockStore.getHRegion()).thenReturn(mockRegion);
    StoreEngine<?, ?, ?, ?> se = StoreEngine.create(mockStore, conf, CellComparatorImpl.COMPARATOR);
    Assert.assertTrue(se instanceof DefaultStoreEngine);
    Assert.assertTrue(se.getCompactionPolicy() instanceof DummyCompactionPolicy);
    Assert.assertTrue(se.getStoreFlusher() instanceof DummyStoreFlusher);
    Assert.assertTrue(se.getCompactor() instanceof DummyCompactor);
  }",Eager Test
"@Test
  public void testPluggingInHeapMemoryTuner() throws Exception {
    BlockCacheStub blockCache = new BlockCacheStub((long) (maxHeapSize * 0.4));
    MemstoreFlusherStub memStoreFlusher = new MemstoreFlusherStub((long) (maxHeapSize * 0.4));
    Configuration conf = HBaseConfiguration.create();
    conf.setFloat(HeapMemoryManager.MEMSTORE_SIZE_MAX_RANGE_KEY, 0.78f);
    conf.setFloat(HeapMemoryManager.MEMSTORE_SIZE_MIN_RANGE_KEY, 0.05f);
    conf.setFloat(HeapMemoryManager.BLOCK_CACHE_SIZE_MAX_RANGE_KEY, 0.75f);
    conf.setFloat(HeapMemoryManager.BLOCK_CACHE_SIZE_MIN_RANGE_KEY, 0.02f);
    conf.setLong(HeapMemoryManager.HBASE_RS_HEAP_MEMORY_TUNER_PERIOD, 1000);
    conf.setInt(DefaultHeapMemoryTuner.NUM_PERIODS_TO_IGNORE, 0);
    conf.setClass(HeapMemoryManager.HBASE_RS_HEAP_MEMORY_TUNER_CLASS, CustomHeapMemoryTuner.class,
      HeapMemoryTuner.class);
    // Let the system start with default values for memstore heap and block cache size.
    HeapMemoryManager heapMemoryManager = new HeapMemoryManager(blockCache, memStoreFlusher,
      new RegionServerStub(conf), new RegionServerAccountingStub(conf));
    final ChoreService choreService = new ChoreService(""TEST_SERVER_NAME"");
    heapMemoryManager.start(choreService);
    // Now we wants to be in write mode. Set bigger memstore size from CustomHeapMemoryTuner
    CustomHeapMemoryTuner.memstoreSize = 0.78f;
    CustomHeapMemoryTuner.blockCacheSize = 0.02f;
    // Allow the tuner to run once and do necessary memory up
    waitForTune(memStoreFlusher, memStoreFlusher.memstoreSize);
    assertHeapSpace(0.78f, memStoreFlusher.memstoreSize);// Memstore
    assertHeapSpace(0.02f, blockCache.maxSize);// BlockCache
    // Now we wants to be in read mode. Set bigger memstore size from CustomHeapMemoryTuner
    CustomHeapMemoryTuner.blockCacheSize = 0.75f;
    CustomHeapMemoryTuner.memstoreSize = 0.05f;
    // Allow the tuner to run once and do necessary memory up
    waitForTune(memStoreFlusher, memStoreFlusher.memstoreSize);
    assertHeapSpace(0.75f, blockCache.maxSize);// BlockCache
    assertHeapSpace(0.05f, memStoreFlusher.memstoreSize);// Memstore
  }",Eager Test
"@Test
  public void testWhenCombinedHeapSizesFromTunerGoesOutSideMaxLimit() throws Exception {
    BlockCacheStub blockCache = new BlockCacheStub((long) (maxHeapSize * 0.4));
    MemstoreFlusherStub memStoreFlusher = new MemstoreFlusherStub((long) (maxHeapSize * 0.4));
    Configuration conf = HBaseConfiguration.create();
    conf.setFloat(HeapMemoryManager.MEMSTORE_SIZE_MAX_RANGE_KEY, 0.7f);
    conf.setFloat(HeapMemoryManager.MEMSTORE_SIZE_MIN_RANGE_KEY, 0.1f);
    conf.setFloat(HeapMemoryManager.BLOCK_CACHE_SIZE_MAX_RANGE_KEY, 0.7f);
    conf.setFloat(HeapMemoryManager.BLOCK_CACHE_SIZE_MIN_RANGE_KEY, 0.1f);
    conf.setLong(HeapMemoryManager.HBASE_RS_HEAP_MEMORY_TUNER_PERIOD, 1000);
    conf.setInt(DefaultHeapMemoryTuner.NUM_PERIODS_TO_IGNORE, 0);
    conf.setClass(HeapMemoryManager.HBASE_RS_HEAP_MEMORY_TUNER_CLASS, CustomHeapMemoryTuner.class,
      HeapMemoryTuner.class);
    HeapMemoryManager heapMemoryManager = new HeapMemoryManager(blockCache, memStoreFlusher,
      new RegionServerStub(conf), new RegionServerAccountingStub(conf));
    long oldMemstoreSize = memStoreFlusher.memstoreSize;
    long oldBlockCacheSize = blockCache.maxSize;
    final ChoreService choreService = new ChoreService(""TEST_SERVER_NAME"");
    heapMemoryManager.start(choreService);
    CustomHeapMemoryTuner.memstoreSize = 0.7f;
    CustomHeapMemoryTuner.blockCacheSize = 0.3f;
    // Allow the tuner to run once and do necessary memory up
    Thread.sleep(1500);
    assertEquals(oldMemstoreSize, memStoreFlusher.memstoreSize);
    assertEquals(oldBlockCacheSize, blockCache.maxSize);
  }",Eager Test
"@Test
  public void testGetFromMemStore() throws IOException {
    final Configuration conf = HBaseConfiguration.create();
    init(name.getMethodName(), conf, false);

    // Put data in memstore
    this.store.add(new KeyValue(row, family, qf1, 1, value), null);
    this.store.add(new KeyValue(row, family, qf2, 1, value), null);
    this.store.add(new KeyValue(row, family, qf3, 1, value), null);
    this.store.add(new KeyValue(row, family, qf4, 1, value), null);
    this.store.add(new KeyValue(row, family, qf5, 1, value), null);
    this.store.add(new KeyValue(row, family, qf6, 1, value), null);

    Scan scan = new Scan(get);
    InternalScanner scanner = (InternalScanner) store.getScanner(scan,
      scan.getFamilyMap().get(store.getColumnFamilyDescriptor().getName()), 0);

    List<Cell> results = new ArrayList<>();
    scanner.next(results);
    Collections.sort(results, CellComparatorImpl.COMPARATOR);
    scanner.close();

    // Compare
    Assert.assertEquals(expected.size(), results.size());
    for (int i = 0; i < results.size(); i++) {
      // Verify the values
      Assert.assertEquals(expected.get(i), results.get(i));
    }",Eager Test
"@Test
  public void testMOBStoreEncryption() throws Exception {
    final Configuration conf = TEST_UTIL.getConfiguration();

    conf.set(HConstants.CRYPTO_KEYPROVIDER_CONF_KEY, MockAesKeyProvider.class.getName());
    conf.set(HConstants.CRYPTO_MASTERKEY_NAME_CONF_KEY, ""hbase"");
    byte[] keyBytes = new byte[AES.KEY_LENGTH];
    Bytes.secureRandom(keyBytes);
    String algorithm = conf.get(HConstants.CRYPTO_KEY_ALGORITHM_CONF_KEY, HConstants.CIPHER_AES);
    Key cfKey = new SecretKeySpec(keyBytes, algorithm);

    ColumnFamilyDescriptor cfd = ColumnFamilyDescriptorBuilder.newBuilder(family)
      .setMobEnabled(true).setMobThreshold(100).setMaxVersions(4).setEncryptionType(algorithm)
      .setEncryptionKey(EncryptionUtil.wrapKey(conf,
        conf.get(HConstants.CRYPTO_MASTERKEY_NAME_CONF_KEY, User.getCurrent().getShortName()),
        cfKey))
      .build();
    init(name.getMethodName(), conf, cfd, false);

    this.store.add(new KeyValue(row, family, qf1, 1, value), null);
    this.store.add(new KeyValue(row, family, qf2, 1, value), null);
    this.store.add(new KeyValue(row, family, qf3, 1, value), null);
    flush(1);

    this.store.add(new KeyValue(row, family, qf4, 1, value), null);
    this.store.add(new KeyValue(row, family, qf5, 1, value), null);
    this.store.add(new KeyValue(row, family, qf6, 1, value), null);
    flush(2);

    Collection<HStoreFile> storefiles = this.store.getStorefiles();
    checkMobHFileEncrytption(storefiles);

    // Scan the values
    Scan scan = new Scan(get);
    InternalScanner scanner = (InternalScanner) store.getScanner(scan,
      scan.getFamilyMap().get(store.getColumnFamilyDescriptor().getName()), 0);

    List<Cell> results = new ArrayList<>();
    scanner.next(results);
    Collections.sort(results, CellComparatorImpl.COMPARATOR);
    scanner.close();
    Assert.assertEquals(expected.size(), results.size());
    for (int i = 0; i < results.size(); i++) {
      Assert.assertEquals(expected.get(i), results.get(i));
    }",Eager Test
"@Test
  public void testResolve() throws Exception {
    final Configuration conf = HBaseConfiguration.create();
    init(name.getMethodName(), conf, true);
    String targetPathName = MobUtils.formatDate(currentDate);
    Path targetPath = new Path(store.getPath(), targetPathName);
    store.commitFile(mobFilePath, targetPath);
    // resolve
    Cell resultCell1 = store.resolve(seekKey1, false).getCell();
    Cell resultCell2 = store.resolve(seekKey2, false).getCell();
    Cell resultCell3 = store.resolve(seekKey3, false).getCell();
    // compare
    Assert.assertEquals(Bytes.toString(value), Bytes.toString(CellUtil.cloneValue(resultCell1)));
    Assert.assertEquals(Bytes.toString(value), Bytes.toString(CellUtil.cloneValue(resultCell2)));
    Assert.assertEquals(Bytes.toString(value2), Bytes.toString(CellUtil.cloneValue(resultCell3)));
  }",Eager Test
"@Test
  public void testAppendWithReadOnlyTable() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    this.region = initHRegion(tableName, method, CONF, true, Bytes.toBytes(""somefamily""));
    boolean exceptionCaught = false;
    Append append = new Append(Bytes.toBytes(""somerow""));
    append.setDurability(Durability.SKIP_WAL);
    append.addColumn(Bytes.toBytes(""somefamily""), Bytes.toBytes(""somequalifier""),
      Bytes.toBytes(""somevalue""));
    try {
      region.append(append);
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testAtomicBatchPut() throws IOException {
    final Put[] puts = new Put[10];
    MetricsWALSource source = CompatibilitySingletonFactory.getInstance(MetricsWALSource.class);
    long syncs = prepareRegionForBachPut(puts, source, false);

    // 1. Straight forward case, should succeed
    OperationStatus[] codes = this.region.batchMutate(puts, true);
    assertEquals(10, codes.length);
    for (int i = 0; i < 10; i++) {
      assertEquals(OperationStatusCode.SUCCESS, codes[i].getOperationStatusCode());
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testBatchPut_whileNoRowLocksHeld() throws IOException {
    final Put[] puts = new Put[10];
    MetricsWALSource source = CompatibilitySingletonFactory.getInstance(MetricsWALSource.class);
    long syncs = prepareRegionForBachPut(puts, source, false);

    OperationStatus[] codes = this.region.batchMutate(puts);
    assertEquals(10, codes.length);
    for (int i = 0; i < 10; i++) {
      assertEquals(OperationStatusCode.SUCCESS, codes[i].getOperationStatusCode());
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testBatchPutWithTsSlop() throws Exception {
    // add data with a timestamp that is too recent for range. Ensure assert
    CONF.setInt(""hbase.hregion.keyvalue.timestamp.slop.millisecs"", 1000);
    final Put[] puts = new Put[10];
    MetricsWALSource source = CompatibilitySingletonFactory.getInstance(MetricsWALSource.class);

    long syncs = prepareRegionForBachPut(puts, source, true);

    OperationStatus[] codes = this.region.batchMutate(puts);
    assertEquals(10, codes.length);
    for (int i = 0; i < 10; i++) {
      assertEquals(OperationStatusCode.SANITY_CHECK_FAILURE, codes[i].getOperationStatusCode());
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testCellTTLs() throws IOException {
    IncrementingEnvironmentEdge edge = new IncrementingEnvironmentEdge();
    EnvironmentEdgeManager.injectEdge(edge);

    final byte[] row = Bytes.toBytes(""testRow"");
    final byte[] q1 = Bytes.toBytes(""q1"");
    final byte[] q2 = Bytes.toBytes(""q2"");
    final byte[] q3 = Bytes.toBytes(""q3"");
    final byte[] q4 = Bytes.toBytes(""q4"");

    // 10 seconds
    TableDescriptor tableDescriptor =
      TableDescriptorBuilder.newBuilder(TableName.valueOf(name.getMethodName()))
        .setColumnFamily(ColumnFamilyDescriptorBuilder.newBuilder(fam1).setTimeToLive(10).build())
        .build();

    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());
    conf.setInt(HFile.FORMAT_VERSION_KEY, HFile.MIN_FORMAT_VERSION_WITH_TAGS);

    region = HBaseTestingUtil.createRegionAndWAL(
      RegionInfoBuilder.newBuilder(tableDescriptor.getTableName()).build(),
      TEST_UTIL.getDataTestDir(), conf, tableDescriptor);
    assertNotNull(region);
    long now = EnvironmentEdgeManager.currentTime();
    // Add a cell that will expire in 5 seconds via cell TTL
    region.put(new Put(row).add(new KeyValue(row, fam1, q1, now, HConstants.EMPTY_BYTE_ARRAY,
      new ArrayBackedTag[] {
        // TTL tags specify ts in milliseconds
        new ArrayBackedTag(TagType.TTL_TAG_TYPE, Bytes.toBytes(5000L)) }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testCheckAndMutateTimestampsAreMonotonic() throws IOException {
    region = initHRegion(tableName, method, CONF, fam1);
    ManualEnvironmentEdge edge = new ManualEnvironmentEdge();
    EnvironmentEdgeManager.injectEdge(edge);

    edge.setValue(10);
    Put p = new Put(row);
    p.setDurability(Durability.SKIP_WAL);
    p.addColumn(fam1, qual1, qual1);
    region.put(p);

    Result result = region.get(new Get(row));
    Cell c = result.getColumnLatestCell(fam1, qual1);
    assertNotNull(c);
    assertEquals(10L, c.getTimestamp());

    edge.setValue(1); // clock goes back
    p = new Put(row);
    p.setDurability(Durability.SKIP_WAL);
    p.addColumn(fam1, qual1, qual2);
    region.checkAndMutate(row, fam1, qual1, CompareOperator.EQUAL, new BinaryComparator(qual1), p);
    result = region.get(new Get(row));
    c = result.getColumnLatestCell(fam1, qual1);
    assertEquals(10L, c.getTimestamp());

    assertTrue(Bytes.equals(c.getValueArray(), c.getValueOffset(), c.getValueLength(), qual2, 0,
      qual2.length));
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testCloseWithFailingFlush() throws Exception {
    final Configuration conf = HBaseConfiguration.create(CONF);
    final WAL wal = createWALCompatibleWithFaultyFileSystem(method, conf, tableName);
    // Only retry once.
    conf.setInt(""hbase.hstore.flush.retries.number"", 1);
    final User user = User.createUserForTesting(conf, this.method, new String[] { ""foo"" }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testDataInMemoryWithoutWAL() throws IOException {
    FileSystem fs = FileSystem.get(CONF);
    Path rootDir = new Path(dir + ""testDataInMemoryWithoutWAL"");
    FSHLog hLog = new FSHLog(fs, rootDir, ""testDataInMemoryWithoutWAL"", CONF);
    hLog.init();
    // This chunk creation is done throughout the code base. Do we want to move it into core?
    // It is missing from this test. W/o it we NPE.
    region = initHRegion(tableName, null, null, CONF, false, Durability.SYNC_WAL, hLog,
      COLUMN_FAMILY_BYTES);

    Cell originalCell = ExtendedCellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row)
      .setFamily(COLUMN_FAMILY_BYTES).setQualifier(qual1)
      .setTimestamp(EnvironmentEdgeManager.currentTime()).setType(KeyValue.Type.Put.getCode())
      .setValue(value1).build();
    final long originalSize = originalCell.getSerializedSize();

    Cell addCell = ExtendedCellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row)
      .setFamily(COLUMN_FAMILY_BYTES).setQualifier(qual1)
      .setTimestamp(EnvironmentEdgeManager.currentTime()).setType(KeyValue.Type.Put.getCode())
      .setValue(Bytes.toBytes(""xxxxxxxxxx"")).build();
    final long addSize = addCell.getSerializedSize();

    LOG.info(""originalSize:"" + originalSize + "", addSize:"" + addSize);
    // start test. We expect that the addPut's durability will be replaced
    // by originalPut's durability.

    // case 1:
    testDataInMemoryWithoutWAL(region,
      new Put(row).add(originalCell).setDurability(Durability.SKIP_WAL),
      new Put(row).add(addCell).setDurability(Durability.SKIP_WAL), originalSize + addSize);

    // case 2:
    testDataInMemoryWithoutWAL(region,
      new Put(row).add(originalCell).setDurability(Durability.SKIP_WAL),
      new Put(row).add(addCell).setDurability(Durability.SYNC_WAL), originalSize + addSize);

    // case 3:
    testDataInMemoryWithoutWAL(region,
      new Put(row).add(originalCell).setDurability(Durability.SYNC_WAL),
      new Put(row).add(addCell).setDurability(Durability.SKIP_WAL), 0);

    // case 4:
    testDataInMemoryWithoutWAL(region,
      new Put(row).add(originalCell).setDurability(Durability.SYNC_WAL),
      new Put(row).add(addCell).setDurability(Durability.SYNC_WAL), 0);
  }",No Smells
"@Test
  public void testDelete_CheckTimestampUpdated() throws IOException {
    byte[] row1 = Bytes.toBytes(""row1"");
    byte[] col1 = Bytes.toBytes(""col1"");
    byte[] col2 = Bytes.toBytes(""col2"");
    byte[] col3 = Bytes.toBytes(""col3"");

    byte[] forUnitTestsOnly = Bytes.toBytes(""ForUnitTestsOnly"");

    // Setting up region
    this.region = initHRegion(tableName, method, CONF, fam1);
    // Building checkerList
    List<Cell> kvs = new ArrayList<>();
    kvs.add(new KeyValue(row1, fam1, col1, null));
    kvs.add(new KeyValue(row1, fam1, col2, null));
    kvs.add(new KeyValue(row1, fam1, col3, null));

    NavigableMap<byte[], List<Cell>> deleteMap = new TreeMap<>(Bytes.BYTES_COMPARATOR);
    deleteMap.put(fam1, kvs);
    region.delete(new Delete(forUnitTestsOnly, HConstants.LATEST_TIMESTAMP, deleteMap));

    // extract the key values out the memstore:
    // This is kinda hacky, but better than nothing...
    long now = EnvironmentEdgeManager.currentTime();
    AbstractMemStore memstore = (AbstractMemStore) region.getStore(fam1).memstore;
    Cell firstCell = memstore.getActive().first();
    assertTrue(firstCell.getTimestamp() <= now);
    now = firstCell.getTimestamp();
    for (Cell cell : memstore.getActive().getCellSet()) {
      assertTrue(cell.getTimestamp() <= now);
      now = cell.getTimestamp();
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testFlushResult() throws IOException {
    byte[] family = Bytes.toBytes(""family"");

    this.region = initHRegion(tableName, method, family);

    // empty memstore, flush doesn't run
    HRegion.FlushResult fr = region.flush(true);
    assertFalse(fr.isFlushSucceeded());
    assertFalse(fr.isCompactionNeeded());

    // Flush enough files to get up to the threshold, doesn't need compactions
    for (int i = 0; i < 2; i++) {
      Put put = new Put(tableName.toBytes()).addColumn(family, family, tableName.toBytes());
      region.put(put);
      fr = region.flush(true);
      assertTrue(fr.isFlushSucceeded());
      assertFalse(fr.isCompactionNeeded());
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testFlushSizeAccounting() throws Exception {
    final Configuration conf = HBaseConfiguration.create(CONF);
    final WAL wal = createWALCompatibleWithFaultyFileSystem(method, conf, tableName);
    // Only retry once.
    conf.setInt(""hbase.hstore.flush.retries.number"", 1);
    final User user = User.createUserForTesting(conf, method, new String[] { ""foo"" }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testGet_Empty() throws IOException {
    byte[] row = Bytes.toBytes(""row"");
    byte[] fam = Bytes.toBytes(""fam"");

    this.region = initHRegion(tableName, method, CONF, fam);
    Get get = new Get(row);
    get.addFamily(fam);
    Result r = region.get(get);

    assertTrue(r.isEmpty());
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testGet_FamilyChecker() throws IOException {
    byte[] row1 = Bytes.toBytes(""row1"");
    byte[] fam1 = Bytes.toBytes(""fam1"");
    byte[] fam2 = Bytes.toBytes(""False"");
    byte[] col1 = Bytes.toBytes(""col1"");

    // Setting up region
    this.region = initHRegion(tableName, method, CONF, fam1);
    Get get = new Get(row1);
    get.addColumn(fam2, col1);

    // Test
    try {
      region.get(get);
      fail(""Expecting DoNotRetryIOException in get but did not get any"");
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testGetScanner_WithNoFamilies() throws IOException {
    byte[] row1 = Bytes.toBytes(""row1"");
    byte[] fam1 = Bytes.toBytes(""fam1"");
    byte[] fam2 = Bytes.toBytes(""fam2"");
    byte[] fam3 = Bytes.toBytes(""fam3"");
    byte[] fam4 = Bytes.toBytes(""fam4"");

    byte[][] families = { fam1, fam2, fam3, fam4 }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testGetScanner_WithRegionClosed() throws IOException {
    byte[] fam1 = Bytes.toBytes(""fam1"");
    byte[] fam2 = Bytes.toBytes(""fam2"");

    byte[][] families = { fam1, fam2 }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testGetWhileRegionClose() throws IOException {
    Configuration hc = initSplit();
    int numRows = 100;
    byte[][] families = { fam1, fam2, fam3 }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testRecoveredEditsReplayCompaction() throws Exception {
    testRecoveredEditsReplayCompaction(false);
    testRecoveredEditsReplayCompaction(true);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testReverseScanner_FromMemStore_SingleCF_FullScan() throws IOException {
    byte[] rowC = Bytes.toBytes(""rowC"");
    byte[] rowA = Bytes.toBytes(""rowA"");
    byte[] rowB = Bytes.toBytes(""rowB"");
    byte[] cf = Bytes.toBytes(""CF"");
    byte[][] families = { cf }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testReverseScanner_FromMemStoreAndHFiles_MultiCFs1() throws IOException {
    byte[] row0 = Bytes.toBytes(""row0""); // 1 kv
    byte[] row1 = Bytes.toBytes(""row1""); // 2 kv
    byte[] row2 = Bytes.toBytes(""row2""); // 4 kv
    byte[] row3 = Bytes.toBytes(""row3""); // 2 kv
    byte[] row4 = Bytes.toBytes(""row4""); // 5 kv
    byte[] row5 = Bytes.toBytes(""row5""); // 2 kv
    byte[] cf1 = Bytes.toBytes(""CF1"");
    byte[] cf2 = Bytes.toBytes(""CF2"");
    byte[] cf3 = Bytes.toBytes(""CF3"");
    byte[][] families = { cf1, cf2, cf3 }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testReverseScanner_FromMemStoreAndHFiles_MultiCFs2() throws IOException {
    byte[] row1 = Bytes.toBytes(""row1"");
    byte[] row2 = Bytes.toBytes(""row2"");
    byte[] row3 = Bytes.toBytes(""row3"");
    byte[] row4 = Bytes.toBytes(""row4"");
    byte[] cf1 = Bytes.toBytes(""CF1"");
    byte[] cf2 = Bytes.toBytes(""CF2"");
    byte[] cf3 = Bytes.toBytes(""CF3"");
    byte[] cf4 = Bytes.toBytes(""CF4"");
    byte[][] families = { cf1, cf2, cf3, cf4 }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testReverseScanShouldNotScanMemstoreIfReadPtLesser() throws Exception {
    byte[] cf1 = Bytes.toBytes(""CF1"");
    byte[][] families = { cf1 }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testScanner_DeleteOneFamilyNotAnother() throws IOException {
    byte[] fam1 = Bytes.toBytes(""columnA"");
    byte[] fam2 = Bytes.toBytes(""columnB"");
    this.region = initHRegion(tableName, method, CONF, fam1, fam2);
    byte[] rowA = Bytes.toBytes(""rowA"");
    byte[] rowB = Bytes.toBytes(""rowB"");

    byte[] value = Bytes.toBytes(""value"");

    Delete delete = new Delete(rowA);
    delete.addFamily(fam1);

    region.delete(delete);

    // now create data.
    Put put = new Put(rowA);
    put.addColumn(fam2, null, value);
    region.put(put);

    put = new Put(rowB);
    put.addColumn(fam1, null, value);
    put.addColumn(fam2, null, value);
    region.put(put);

    Scan scan = new Scan();
    scan.addFamily(fam1).addFamily(fam2);
    try (InternalScanner s = region.getScanner(scan)) {
      List<Cell> results = new ArrayList<>();
      s.next(results);
      assertTrue(CellUtil.matchingRows(results.get(0), rowA));

      results.clear();
      s.next(results);
      assertTrue(CellUtil.matchingRows(results.get(0), rowB));
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testScanner_Wildcard_FromMemStore_EnforceVersions() throws IOException {
    byte[] row1 = Bytes.toBytes(""row1"");
    byte[] qf1 = Bytes.toBytes(""qualifier1"");
    byte[] qf2 = Bytes.toBytes(""qualifier2"");
    byte[] fam1 = Bytes.toBytes(""fam1"");
    byte[][] families = { fam1 }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testSequenceId() throws IOException {
    region = initHRegion(tableName, method, CONF, COLUMN_FAMILY_BYTES);
    assertEquals(HConstants.NO_SEQNUM, region.getMaxFlushedSeqId());
    // Weird. This returns 0 if no store files or no edits. Afraid to change it.
    assertEquals(0, (long) region.getMaxStoreSeqId().get(COLUMN_FAMILY_BYTES));
    HBaseTestingUtil.closeRegionAndWAL(this.region);
    assertEquals(HConstants.NO_SEQNUM, region.getMaxFlushedSeqId());
    assertEquals(0, (long) region.getMaxStoreSeqId().get(COLUMN_FAMILY_BYTES));
    HRegion oldRegion = region;
    try {
      // Open region again.
      region = initHRegion(tableName, method, CONF, COLUMN_FAMILY_BYTES);
      byte[] value = Bytes.toBytes(method);
      // Make a random put against our cf.
      Put put = new Put(value);
      put.addColumn(COLUMN_FAMILY_BYTES, null, value);
      region.put(put);
      // No flush yet so init numbers should still be in place.
      assertEquals(HConstants.NO_SEQNUM, region.getMaxFlushedSeqId());
      assertEquals(0, (long) region.getMaxStoreSeqId().get(COLUMN_FAMILY_BYTES));
      region.flush(true);
      long max = region.getMaxFlushedSeqId();
      HBaseTestingUtil.closeRegionAndWAL(this.region);
      assertEquals(max, region.getMaxFlushedSeqId());
      this.region = null;
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testSkipRecoveredEditsReplayTheLastFileIgnored() throws Exception {
    byte[] family = Bytes.toBytes(""family"");
    this.region = initHRegion(tableName, method, CONF, family);
    final WALFactory wals = new WALFactory(CONF, method);
    try {
      Path regiondir = region.getRegionFileSystem().getRegionDir();
      FileSystem fs = region.getRegionFileSystem().getFileSystem();
      byte[] regionName = region.getRegionInfo().getEncodedNameAsBytes();
      byte[][] columns = region.getTableDescriptor().getColumnFamilyNames().toArray(new byte[0][]);

      assertEquals(0, region.getStoreFileList(columns).size());

      Path recoveredEditsDir = WALSplitUtil.getRegionDirRecoveredEditsDir(regiondir);

      long maxSeqId = 1050;
      long minSeqId = 1000;

      for (long i = minSeqId; i <= maxSeqId; i += 10) {
        Path recoveredEdits = new Path(recoveredEditsDir, String.format(""%019d"", i));
        fs.create(recoveredEdits);
        WALProvider.Writer writer = wals.createRecoveredEditsWriter(fs, recoveredEdits);

        long time = System.nanoTime();
        WALEdit edit = null;
        if (i == maxSeqId) {
          edit = WALEdit.createCompaction(region.getRegionInfo(),
            CompactionDescriptor.newBuilder().setTableName(ByteString.copyFrom(tableName.getName()))
              .setFamilyName(ByteString.copyFrom(regionName))
              .setEncodedRegionName(ByteString.copyFrom(regionName))
              .setStoreHomeDirBytes(ByteString.copyFrom(Bytes.toBytes(regiondir.toString())))
              .setRegionName(ByteString.copyFrom(region.getRegionInfo().getRegionName())).build());
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testStatusSettingToAbortIfAnyExceptionDuringRegionInitilization() throws Exception {
    RegionInfo info;
    try {
      FileSystem fs = mock(FileSystem.class);
      when(fs.exists(any())).thenThrow(new IOException());
      TableDescriptorBuilder tableDescriptorBuilder = TableDescriptorBuilder.newBuilder(tableName);
      ColumnFamilyDescriptor columnFamilyDescriptor =
        ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(""cf"")).build();
      tableDescriptorBuilder.setColumnFamily(columnFamilyDescriptor);
      info = RegionInfoBuilder.newBuilder(tableName).build();
      Path path = new Path(dir + ""testStatusSettingToAbortIfAnyExceptionDuringRegionInitilization"");
      region = HRegion.newHRegion(path, null, fs, CONF, info, tableDescriptorBuilder.build(), null);
      // region initialization throws IOException and set task state to ABORTED.
      region.initialize();
      fail(""Region initialization should fail due to IOException"");
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testToShowNPEOnRegionScannerReseek() throws Exception {
    byte[] family = Bytes.toBytes(""family"");
    this.region = initHRegion(tableName, method, CONF, family);

    Put put = new Put(Bytes.toBytes(""r1""));
    put.addColumn(family, Bytes.toBytes(""q1""), Bytes.toBytes(""v1""));
    region.put(put);
    put = new Put(Bytes.toBytes(""r2""));
    put.addColumn(family, Bytes.toBytes(""q1""), Bytes.toBytes(""v1""));
    region.put(put);
    region.flush(true);

    Scan scan = new Scan();
    scan.readVersions(3);
    // open the first scanner
    try (RegionScanner scanner1 = region.getScanner(scan)) {
      LOG.info(""Smallest read point:"" + region.getSmallestReadPoint());

      region.compact(true);

      scanner1.reseek(Bytes.toBytes(""r2""));
      List<Cell> results = new ArrayList<>();
      scanner1.next(results);
      Cell keyValue = results.get(0);
      assertTrue(Bytes.compareTo(CellUtil.cloneRow(keyValue), Bytes.toBytes(""r2"")) == 0);
      scanner1.close();
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testCreateWriter() throws Exception {
    Configuration conf = HBaseConfiguration.create();
    FileSystem fs = FileSystem.get(conf);

    ColumnFamilyDescriptor hcd =
      ColumnFamilyDescriptorBuilder.newBuilder(family).setCompressionType(Compression.Algorithm.GZ)
        .setDataBlockEncoding(DataBlockEncoding.DIFF).build();
    init(name.getMethodName(), conf, hcd);

    // Test createWriter
    StoreFileWriter writer = store.getStoreEngine()
      .createWriter(CreateStoreFileWriterParams.create().maxKeyCount(4)
        .compression(hcd.getCompressionType()).isCompaction(false).includeMVCCReadpoint(true)
        .includesTag(false).shouldDropBehind(false));
    Path path = writer.getPath();
    writer.append(new KeyValue(row, family, qf1, Bytes.toBytes(1)));
    writer.append(new KeyValue(row, family, qf2, Bytes.toBytes(2)));
    writer.append(new KeyValue(row2, family, qf1, Bytes.toBytes(3)));
    writer.append(new KeyValue(row2, family, qf2, Bytes.toBytes(4)));
    writer.close();

    // Verify that compression and encoding settings are respected
    HFile.Reader reader = HFile.createReader(fs, path, new CacheConfig(conf), true, conf);
    assertEquals(hcd.getCompressionType(), reader.getTrailer().getCompressionCodec());
    assertEquals(hcd.getDataBlockEncoding(), reader.getDataBlockEncoding());
    reader.close();
  }",Eager Test
"@Test
  public void testReclaimChunkWhenScaning() throws IOException {
    init(""testReclaimChunkWhenScaning"");
    long ts = EnvironmentEdgeManager.currentTime();
    long seqId = 100;
    byte[] value = Bytes.toBytes(""value"");
    // older data whihc shouldn't be ""seen"" by client
    store.add(createCell(qf1, ts, seqId, value), null);
    store.add(createCell(qf2, ts, seqId, value), null);
    store.add(createCell(qf3, ts, seqId, value), null);
    TreeSet<byte[]> quals = new TreeSet<>(Bytes.BYTES_COMPARATOR);
    quals.add(qf1);
    quals.add(qf2);
    quals.add(qf3);
    try (InternalScanner scanner =
      (InternalScanner) store.getScanner(new Scan(new Get(row)), quals, seqId)) {
      List<Cell> results = new MyList<>(size -> {
        switch (size) {
          // 1) we get the first cell (qf1)
          // 2) flush the data to have StoreScanner update inner scanners
          // 3) the chunk will be reclaimed after updaing
          case 1:
            try {
              flushStore(store, id++);
            }",Eager Test
"@Test
  public void testRefreshStoreFilesNotChanged() throws IOException {
    init(name.getMethodName());

    assertEquals(0, this.store.getStorefilesCount());

    // add some data, flush
    this.store.add(new KeyValue(row, family, qf1, 1, (byte[]) null), null);
    flush(1);
    // add one more file
    addStoreFile();

    StoreEngine<?, ?, ?, ?> spiedStoreEngine = spy(store.getStoreEngine());

    // call first time after files changed
    spiedStoreEngine.refreshStoreFiles();
    assertEquals(2, this.store.getStorefilesCount());
    verify(spiedStoreEngine, times(1)).replaceStoreFiles(any(), any(), any(), any());

    // call second time
    spiedStoreEngine.refreshStoreFiles();

    // ensure that replaceStoreFiles is not called, i.e, the times does not change, if files are not
    // refreshed,
    verify(spiedStoreEngine, times(1)).replaceStoreFiles(any(), any(), any(), any());
  }",Eager Test
"@Test
  public void testStoreUsesSearchEngineOverride() throws Exception {
    Configuration conf = HBaseConfiguration.create();
    conf.set(StoreEngine.STORE_ENGINE_CLASS_KEY, DummyStoreEngine.class.getName());
    init(this.name.getMethodName(), conf);
    assertEquals(DummyStoreEngine.lastCreatedCompactor, this.store.storeEngine.getCompactor());
  }",No Smells
"@Test
  public void testSwitchingPreadtoStreamParallelyWithCompactionDischarger() throws Exception {
    Configuration conf = HBaseConfiguration.create();
    conf.set(""hbase.hstore.engine.class"", DummyStoreEngine.class.getName());
    conf.setLong(StoreScanner.STORESCANNER_PREAD_MAX_BYTES, 0);
    // Set the lower threshold to invoke the ""MERGE"" policy
    MyStore store = initMyStore(name.getMethodName(), conf, new MyStoreHook() {
    }",Eager Test + Mystery Guest
"@Test
  public void testBloomFilter() throws Exception {
    conf.setFloat(BloomFilterFactory.IO_STOREFILE_BLOOM_ERROR_RATE, (float) 0.01);
    conf.setBoolean(BloomFilterFactory.IO_STOREFILE_BLOOM_ENABLED, true);

    // write the file
    if (!fs.exists(ROOT_DIR)) {
      fs.mkdirs(ROOT_DIR);
    }",Eager Test + Mystery Guest
"@Test
  public void testEmptyStoreFileRestrictKeyRanges() throws Exception {
    StoreFileReader reader = mock(StoreFileReader.class);
    HStore store = mock(HStore.class);
    byte[] cf = Bytes.toBytes(""ty"");
    ColumnFamilyDescriptor cfd = ColumnFamilyDescriptorBuilder.of(cf);
    when(store.getColumnFamilyDescriptor()).thenReturn(cfd);
    try (StoreFileScanner scanner =
      new StoreFileScanner(reader, mock(HFileScanner.class), false, false, 0, 0, true, false)) {
      Scan scan = new Scan();
      scan.setColumnFamilyTimeRange(cf, 0, 1);
      assertFalse(scanner.shouldUseScanner(scan, store, 0));
    }",Eager Test
"@Test
  public void testSeqIdComparator() {
    assertOrdering(StoreFileComparators.SEQ_ID, mockStoreFile(true, 100, 1000, -1, ""/foo/123""),
      mockStoreFile(true, 100, 1000, -1, ""/foo/124""), mockStoreFile(true, 99, 1000, -1, ""/foo/126""),
      mockStoreFile(true, 98, 2000, -1, ""/foo/126""), mockStoreFile(false, 3453, -1, 1, ""/foo/1""),
      mockStoreFile(false, 2, -1, 3, ""/foo/2""), mockStoreFile(false, 1000, -1, 5, ""/foo/2""),
      mockStoreFile(false, 76, -1, 5, ""/foo/3""));
  }",No Smells
"@Test
  public void testStoreFileReference() throws Exception {
    final RegionInfo hri =
      RegionInfoBuilder.newBuilder(TableName.valueOf(""testStoreFileReference"")).build();
    HRegionFileSystem regionFs = HRegionFileSystem.createRegionOnFileSystem(conf, fs,
      new Path(testDir, hri.getTable().getNameAsString()), hri);
    HFileContext meta = new HFileContextBuilder().withBlockSize(8 * 1024).build();

    // Make a store file and write data to it.
    StoreFileWriter writer = new StoreFileWriter.Builder(conf, cacheConf, this.fs)
      .withFilePath(regionFs.createTempName()).withFileContext(meta).build();
    writeStoreFile(writer);
    Path hsfPath = regionFs.commitStoreFile(TEST_FAMILY, writer.getPath());
    writer.close();
    StoreFileTracker sft = StoreFileTrackerFactory.create(conf, false,
      StoreContext.getBuilder()
        .withFamilyStoreDirectoryPath(new Path(regionFs.getRegionDir(), TEST_FAMILY))
        .withRegionFileSystem(regionFs).build());
    HStoreFile file = new HStoreFile(this.fs, hsfPath, conf, cacheConf, BloomType.NONE, true, sft);
    file.initReader();
    StoreFileReader r = file.getReader();
    assertNotNull(r);
    StoreFileScanner scanner =
      new StoreFileScanner(r, mock(HFileScanner.class), false, false, 0, 0, false, false);

    // Verify after instantiating scanner refCount is increased
    assertTrue(""Verify file is being referenced"", file.isReferencedInReads());
    scanner.close();
    // Verify after closing scanner refCount is decreased
    assertFalse(""Verify file is not being referenced"", file.isReferencedInReads());
  }",Eager Test
"@Test
  public void testSorted() throws IOException {
    // Cases that need to be checked are:
    // 1. The ""smallest"" Cell is in the same scanners as current
    // 2. Current scanner gets empty

    List<Cell> expected =
      Arrays.asList(kv111, kv112, kv113, kv114, kv115, kv121, kv122, kv211, kv212, kv213);

    List<Cell> actual = assertCells(expected, scanners);

    // Check if result is sorted according to Comparator
    for (int i = 0; i < actual.size() - 1; i++) {
      int ret = CellComparatorImpl.COMPARATOR.compare(actual.get(i), actual.get(i + 1));
      assertTrue(ret < 0);
    }",Eager Test
"@Test
  public void testRegionWrapperMetrics() {
    MetricsRegion mr = new MetricsRegion(new MetricsRegionWrapperStub(), new Configuration());
    MetricsRegionAggregateSource agg = mr.getSource().getAggregateSource();

    HELPER.assertGauge(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_storeCount"", 101,
      agg);
    HELPER.assertGauge(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_storeFileCount"",
      102, agg);
    HELPER.assertGauge(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_maxStoreFileAge"",
      2, agg);
    HELPER.assertGauge(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_minStoreFileAge"",
      2, agg);
    HELPER.assertGauge(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_avgStoreFileAge"",
      2, agg);
    HELPER.assertGauge(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_numReferenceFiles"",
      2, agg);
    HELPER.assertGauge(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_memstoreSize"", 103,
      agg);
    HELPER.assertCounter(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_cpRequestCount"",
      108, agg);
    HELPER
      .assertCounter(""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_""
        + ""filteredReadRequestCount"", 107, agg);
    HELPER.assertCounter(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_replicaid"", 0,
      agg);
    mr.close();

    // test region with replica id > 0
    mr = new MetricsRegion(new MetricsRegionWrapperStub(1), new Configuration());
    agg = mr.getSource().getAggregateSource();
    HELPER.assertGauge(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001"" + ""_metric_storeCount"",
      101, agg);
    HELPER.assertGauge(""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001""
      + ""_metric_storeFileCount"", 102, agg);
    HELPER.assertGauge(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001"" + ""_metric_memstoreSize"",
      103, agg);
    HELPER.assertCounter(""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001""
      + ""_metric_cpRequestCount"", 108, agg);
    HELPER.assertCounter(""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001""
      + ""_metric_filteredReadRequestCount"", 107, agg);
    HELPER.assertCounter(
      ""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001"" + ""_metric_replicaid"", 1,
      agg);
    HELPER.assertCounter(""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001""
      + ""_metric_compactionsQueuedCount"", 4, agg);
    HELPER.assertCounter(""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001""
      + ""_metric_flushesQueuedCount"", 6, agg);
    HELPER.assertCounter(""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001""
      + ""_metric_maxCompactionQueueSize"", 4, agg);
    HELPER.assertCounter(""namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001""
      + ""_metric_maxFlushQueueSize"", 6, agg);
    mr.close();
  }",Eager Test
"@Test
  public void testPauseMonitor() {
    Configuration conf = new Configuration();
    conf.setLong(JvmPauseMonitor.INFO_THRESHOLD_KEY, 1000L);
    conf.setLong(JvmPauseMonitor.WARN_THRESHOLD_KEY, 10000L);
    JvmPauseMonitor monitor = new JvmPauseMonitor(conf, serverSource);
    monitor.updateMetrics(1500, false);
    HELPER.assertCounter(""pauseInfoThresholdExceeded"", 1, serverSource);
    HELPER.assertCounter(""pauseWarnThresholdExceeded"", 0, serverSource);
    HELPER.assertCounter(""pauseTimeWithoutGc_num_ops"", 1, serverSource);
    HELPER.assertCounter(""pauseTimeWithGc_num_ops"", 0, serverSource);
    monitor.updateMetrics(15000, true);
    HELPER.assertCounter(""pauseInfoThresholdExceeded"", 1, serverSource);
    HELPER.assertCounter(""pauseWarnThresholdExceeded"", 1, serverSource);
    HELPER.assertCounter(""pauseTimeWithoutGc_num_ops"", 1, serverSource);
    HELPER.assertCounter(""pauseTimeWithGc_num_ops"", 1, serverSource);
  }",Eager Test
"@Test
  public void testGetInstance() {
    MetricsRegionServerSourceFactory metricsRegionServerSourceFactory =
      CompatibilitySingletonFactory.getInstance(MetricsRegionServerSourceFactory.class);
    MetricsRegionServerSource serverSource = metricsRegionServerSourceFactory.createServer(null);
    assertTrue(serverSource instanceof MetricsRegionServerSourceImpl);
    assertSame(metricsRegionServerSourceFactory,
      CompatibilitySingletonFactory.getInstance(MetricsRegionServerSourceFactory.class));
  }",No Smells
"@Test
  public void testGetMassive() throws Exception {
    setUp(defaultThreshold, TableName.valueOf(name.getMethodName()));

    // Put some data 5 10, 15, 20 mb ok (this would be right below protobuf
    // default max size of 64MB.
    // 25, 30, 40 fail. these is above protobuf max size of 64MB
    byte[] bigValue = new byte[25 * 1024 * 1024];

    Put put = new Put(row1);
    Bytes.random(bigValue);
    put.addColumn(family, qf1, bigValue);
    table.put(put);
    put = new Put(row1);
    Bytes.random(bigValue);
    put.addColumn(family, qf2, bigValue);
    table.put(put);
    put = new Put(row1);
    Bytes.random(bigValue);
    put.addColumn(family, qf3, bigValue);
    table.put(put);

    Get g = new Get(row1);
    table.get(g);
    // should not have blown up.
  }",No Smells
"@Test
  public void testMobStoreScanner() throws Exception {
    testGetFromFiles(false);
    testGetFromMemStore(false);
    testGetReferences(false);
    testMobThreshold(false);
    testGetFromArchive(false);
  }",Eager Test
"@Test
  public void testMobStoreScanner() throws Exception {
    testGetFromFiles(false);
    testGetFromMemStore(false);
    testGetReferences(false);
    testMobThreshold(false);
    testGetFromArchive(false);
  }",No Smells
"@Test
  public void testReadFromCorruptMobFilesWithReadEmptyValueOnMobCellMiss() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    setUp(0, tableName);
    createRecordAndCorruptMobFile(tableName, row1, family, qf1, Bytes.toBytes(""value1""));
    Get get = new Get(row1);
    get.setAttribute(MobConstants.EMPTY_VALUE_ON_MOBCELL_MISS, Bytes.toBytes(true));
    Result result = table.get(get);
    Cell cell = result.getColumnLatestCell(family, qf1);
    Assert.assertEquals(0, cell.getValueLength());
  }",No Smells
"@Test
  public void testBuilder() {
    TableName tn = TableName.valueOf(""test"");
    RegionInfoBuilder builder = RegionInfoBuilder.newBuilder(tn);
    byte[] startKey = Bytes.toBytes(""a"");
    builder.setStartKey(startKey);
    byte[] endKey = Bytes.toBytes(""z"");
    builder.setEndKey(endKey);
    int regionId = 1;
    builder.setRegionId(1);
    int replicaId = 2;
    builder.setReplicaId(replicaId);
    boolean offline = true;
    builder.setOffline(offline);
    boolean isSplit = true;
    builder.setSplit(isSplit);
    RegionInfo ri = builder.build();

    assertEquals(tn, ri.getTable());
    assertArrayEquals(startKey, ri.getStartKey());
    assertArrayEquals(endKey, ri.getEndKey());
    assertEquals(regionId, ri.getRegionId());
    assertEquals(replicaId, ri.getReplicaId());
    assertEquals(offline, ri.isOffline());
    assertEquals(isSplit, ri.isSplit());
  }",Eager Test
"@Test
  public void testMetaTables() {
    assertTrue(RegionInfoBuilder.FIRST_META_REGIONINFO.isMetaRegion());
  }",No Smells
"@Test
  public void testRegionNameForRegionReplicas() throws Exception {
    final TableName tn = name.getTableName();
    String startKey = ""startkey"";
    final byte[] sk = Bytes.toBytes(startKey);
    String id = ""id"";

    // assert with only the region name without encoding

    // primary, replicaId = 0
    byte[] name = RegionInfo.createRegionName(tn, sk, Bytes.toBytes(id), 0, false);
    String nameStr = Bytes.toString(name);
    assertEquals(tn + "","" + startKey + "","" + id, nameStr);

    // replicaId = 1
    name = RegionInfo.createRegionName(tn, sk, Bytes.toBytes(id), 1, false);
    nameStr = Bytes.toString(name);
    assertEquals(
      tn + "","" + startKey + "","" + id + ""_"" + String.format(RegionInfo.REPLICA_ID_FORMAT, 1),
      nameStr);

    // replicaId = max
    name = RegionInfo.createRegionName(tn, sk, Bytes.toBytes(id), 0xFFFF, false);
    nameStr = Bytes.toString(name);
    assertEquals(
      tn + "","" + startKey + "","" + id + ""_"" + String.format(RegionInfo.REPLICA_ID_FORMAT, 0xFFFF),
      nameStr);
  }",Eager Test
"@Test
  public void testConstantSizePolicy() throws IOException {
    TableDescriptor td = TableDescriptorBuilder.newBuilder(TABLENAME).setMaxFileSize(1024L).build();
    doReturn(td).when(mockRegion).getTableDescriptor();
    ConstantSizeRegionSplitPolicy policy =
      (ConstantSizeRegionSplitPolicy) RegionSplitPolicy.create(mockRegion, conf);
    doConstantSizePolicyTests(policy);
  }",No Smells
"@Test
  public void testDelimitedKeyPrefixRegionSplitPolicy() throws IOException {
    TableDescriptor td = TableDescriptorBuilder.newBuilder(TABLENAME)
      .setRegionSplitPolicyClassName(DelimitedKeyPrefixRegionSplitPolicy.class.getName())
      .setValue(DelimitedKeyPrefixRegionSplitPolicy.DELIMITER_KEY, "","").build();

    doReturn(td).when(mockRegion).getTableDescriptor();
    doReturn(stores).when(mockRegion).getStores();

    HStore mockStore = mock(HStore.class);
    doReturn(2000L).when(mockStore).getSize();
    doReturn(true).when(mockStore).canSplit();
    doReturn(Optional.of(Bytes.toBytes(""ab,cd""))).when(mockStore).getSplitPoint();
    stores.add(mockStore);

    DelimitedKeyPrefixRegionSplitPolicy policy =
      (DelimitedKeyPrefixRegionSplitPolicy) RegionSplitPolicy.create(mockRegion, conf);

    assertEquals(""ab"", Bytes.toString(policy.getSplitPoint()));

    doReturn(Optional.of(Bytes.toBytes(""ijk""))).when(mockStore).getSplitPoint();
    assertEquals(""ijk"", Bytes.toString(policy.getSplitPoint()));
  }",No Smells
"@Test
  public void testNoEndWithoutStart() {
    ServerNonceManager nm = createManager();
    try {
      nm.endOperation(NO_NONCE, 1, true);
      throw new Error(""Should have thrown"");
    }",No Smells
"@Test
  public void testPreemptTask() throws Exception {
    LOG.info(""testPreemptTask"");
    SplitLogCounters.resetCounters();
    final ServerName SRV = ServerName.valueOf(""tpt_svr,1,1"");
    final String PATH = ZKSplitLog.getEncodedNodeName(zkw, ""tpt_task"");
    RegionServerServices mockedRS = getRegionServer(SRV);
    SplitLogWorker slw =
      new SplitLogWorker(ds, TEST_UTIL.getConfiguration(), mockedRS, neverEndingTask);
    slw.start();
    try {
      Thread.yield(); // let the worker start
      Thread.sleep(1000);
      waitForCounter(SplitLogCounters.tot_wkr_task_grabing, 0, 1, WAIT_TIME);

      // this time create a task node after starting the splitLogWorker
      zkw.getRecoverableZooKeeper().create(PATH, new SplitLogTask.Unassigned(MANAGER).toByteArray(),
        Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);

      waitForCounter(SplitLogCounters.tot_wkr_task_acquired, 0, 1, WAIT_TIME);
      assertEquals(1, slw.getTaskReadySeq());
      byte[] bytes = ZKUtil.getData(zkw, PATH);
      SplitLogTask slt = SplitLogTask.parseFrom(bytes);
      assertTrue(slt.isOwned(SRV));
      slt = new SplitLogTask.Owned(MANAGER);
      ZKUtil.setData(zkw, PATH, slt.toByteArray());
      waitForCounter(SplitLogCounters.tot_wkr_preempt_task, 0, 1, WAIT_TIME);
    }",Eager Test + Mystery Guest
"@Test
  public void testRescan() throws Exception {
    LOG.info(""testRescan"");
    SplitLogCounters.resetCounters();
    final ServerName SRV = ServerName.valueOf(""svr,1,1"");
    RegionServerServices mockedRS = getRegionServer(SRV);
    slw = new SplitLogWorker(ds, TEST_UTIL.getConfiguration(), mockedRS, neverEndingTask);
    slw.start();
    Thread.yield(); // let the worker start
    Thread.sleep(100);

    String task = ZKSplitLog.getEncodedNodeName(zkw, ""task"");
    SplitLogTask slt = new SplitLogTask.Unassigned(MANAGER);
    zkw.getRecoverableZooKeeper().create(task, slt.toByteArray(), Ids.OPEN_ACL_UNSAFE,
      CreateMode.PERSISTENT);

    waitForCounter(SplitLogCounters.tot_wkr_task_acquired, 0, 1, WAIT_TIME);
    // now the worker is busy doing the above task

    // preempt the task, have it owned by another worker
    ZKUtil.setData(zkw, task, slt.toByteArray());
    waitForCounter(SplitLogCounters.tot_wkr_preempt_task, 0, 1, WAIT_TIME);

    // create a RESCAN node
    String rescan = ZKSplitLog.getEncodedNodeName(zkw, ""RESCAN"");
    rescan = zkw.getRecoverableZooKeeper().create(rescan, slt.toByteArray(), Ids.OPEN_ACL_UNSAFE,
      CreateMode.PERSISTENT_SEQUENTIAL);

    waitForCounter(SplitLogCounters.tot_wkr_task_acquired, 1, 2, WAIT_TIME);
    // RESCAN node might not have been processed if the worker became busy
    // with the above task. preempt the task again so that now the RESCAN
    // node is processed
    ZKUtil.setData(zkw, task, slt.toByteArray());
    waitForCounter(SplitLogCounters.tot_wkr_preempt_task, 1, 2, WAIT_TIME);
    waitForCounter(SplitLogCounters.tot_wkr_task_acquired_rescan, 0, 1, WAIT_TIME);

    List<String> nodes = ZKUtil.listChildrenNoWatch(zkw, zkw.getZNodePaths().splitLogZNode);
    LOG.debug(Objects.toString(nodes));
    int num = 0;
    for (String node : nodes) {
      num++;
      if (node.startsWith(""RESCAN"")) {
        String name = ZKSplitLog.getEncodedNodeName(zkw, node);
        String fn = ZKSplitLog.getFileName(name);
        byte[] data =
          ZKUtil.getData(zkw, ZNodePaths.joinZNode(zkw.getZNodePaths().splitLogZNode, fn));
        slt = SplitLogTask.parseFrom(data);
        assertTrue(slt.toString(), slt.isDone(SRV));
      }",Eager Test
"@Test
  public void testEqualsWithLink() throws IOException {
    Path origin = new Path(""/origin"");
    Path tmp = TEST_UTIL.getDataTestDir();
    Path mob = new Path(""/mob"");
    Path archive = new Path(""/archive"");
    HFileLink link1 = new HFileLink(new Path(origin, ""f1""), new Path(tmp, ""f1""),
      new Path(mob, ""f1""), new Path(archive, ""f1""));
    HFileLink link2 = new HFileLink(new Path(origin, ""f1""), new Path(tmp, ""f1""),
      new Path(mob, ""f1""), new Path(archive, ""f1""));

    StoreFileInfo info1 =
      new StoreFileInfo(TEST_UTIL.getConfiguration(), TEST_UTIL.getTestFileSystem(), null, link1);
    StoreFileInfo info2 =
      new StoreFileInfo(TEST_UTIL.getConfiguration(), TEST_UTIL.getTestFileSystem(), null, link2);

    assertEquals(info1, info2);
    assertEquals(info1.hashCode(), info2.hashCode());
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testDeletedRowThenGoodRow() throws IOException {
    KeyValue[] kvs = new KeyValue[] { create(""R1"", ""cf"", ""a"", 1, KeyValue.Type.Put, ""dont-care""),
      create(""R1"", ""cf"", ""a"", 1, KeyValue.Type.Delete, ""dont-care""),
      create(""R2"", ""cf"", ""a"", 20, KeyValue.Type.Put, ""dont-care"") }",No Smells
"@Test
  public void testDeleteFamily() throws IOException {
    KeyValue[] kvs =
      new KeyValue[] { create(""R1"", ""cf"", ""a"", 100, KeyValue.Type.DeleteFamily, ""dont-care""),
        create(""R1"", ""cf"", ""b"", 11, KeyValue.Type.Put, ""dont-care""),
        create(""R1"", ""cf"", ""c"", 11, KeyValue.Type.Put, ""dont-care""),
        create(""R1"", ""cf"", ""d"", 11, KeyValue.Type.Put, ""dont-care""),
        create(""R1"", ""cf"", ""e"", 11, KeyValue.Type.Put, ""dont-care""),
        create(""R1"", ""cf"", ""e"", 11, KeyValue.Type.DeleteColumn, ""dont-care""),
        create(""R1"", ""cf"", ""f"", 11, KeyValue.Type.Put, ""dont-care""),
        create(""R1"", ""cf"", ""g"", 11, KeyValue.Type.Put, ""dont-care""),
        create(""R1"", ""cf"", ""g"", 11, KeyValue.Type.Delete, ""dont-care""),
        create(""R1"", ""cf"", ""h"", 11, KeyValue.Type.Put, ""dont-care""),
        create(""R1"", ""cf"", ""i"", 11, KeyValue.Type.Put, ""dont-care""),
        create(""R2"", ""cf"", ""a"", 11, KeyValue.Type.Put, ""dont-care""), }",No Smells
"@Test
  public void testDeleteMarkerLongevity() throws Exception {
    try {
      final long now = EnvironmentEdgeManager.currentTime();
      EnvironmentEdgeManagerTestHelper.injectEdge(new EnvironmentEdge() {
        @Override
        public long currentTime() {
          return now;
        }",No Smells
"@Test
  public void testSkipColumn() throws IOException {
    List<KeyValueScanner> scanners = scanFixture(kvs);
    try (StoreScanner scan = new StoreScanner(new Scan(), scanInfo, getCols(""a"", ""d""), scanners)) {
      List<Cell> results = new ArrayList<>();
      assertEquals(true, scan.next(results));
      assertEquals(2, results.size());
      assertEquals(kvs[0], results.get(0));
      assertEquals(kvs[3], results.get(1));
      results.clear();

      assertEquals(true, scan.next(results));
      assertEquals(1, results.size());
      assertEquals(kvs[kvs.length - 1], results.get(0));

      results.clear();
      assertEquals(false, scan.next(results));
    }",No Smells
"@Test
  public void testWildCardScannerUnderDeletes() throws IOException {
    KeyValue[] kvs = new KeyValue[] {
      // inc
      create(""R1"", ""cf"", ""a"", 2, KeyValue.Type.Put, ""dont-care""),
      // orphaned delete column.
      create(""R1"", ""cf"", ""a"", 1, KeyValue.Type.DeleteColumn, ""dont-care""),
      // column b
      // inc
      create(""R1"", ""cf"", ""b"", 2, KeyValue.Type.Put, ""dont-care""),
      // inc
      create(""R1"", ""cf"", ""b"", 1, KeyValue.Type.Put, ""dont-care""),
      // column c
      create(""R1"", ""cf"", ""c"", 10, KeyValue.Type.Delete, ""dont-care""),
      // no
      create(""R1"", ""cf"", ""c"", 10, KeyValue.Type.Put, ""dont-care""),
      // inc
      create(""R1"", ""cf"", ""c"", 9, KeyValue.Type.Put, ""dont-care""),
      // column d
      // inc
      create(""R1"", ""cf"", ""d"", 11, KeyValue.Type.Put, ""dont-care""),
      create(""R1"", ""cf"", ""d"", 10, KeyValue.Type.DeleteColumn, ""dont-care""),
      // no
      create(""R1"", ""cf"", ""d"", 9, KeyValue.Type.Put, ""dont-care""),
      // no
      create(""R1"", ""cf"", ""d"", 8, KeyValue.Type.Put, ""dont-care""),

    }",No Smells
"@Test
  public void testCreateBasedOnConfig() throws Exception {
    Configuration conf = HBaseConfiguration.create();
    conf.set(StoreEngine.STORE_ENGINE_CLASS_KEY, TestStoreEngine.class.getName());
    StripeStoreEngine se = createEngine(conf);
    assertTrue(se.getCompactionPolicy() instanceof StripeCompactionPolicy);
  }",No Smells
"@Test
  public void testCompactionAndFlushConflict() throws Exception {
    // Add file flush into stripes
    StripeStoreFileManager sfm = createManager();
    assertEquals(0, sfm.getStripeCount());
    HStoreFile sf_i2c = createFile(OPEN_KEY, KEY_C), sf_c2i = createFile(KEY_C, OPEN_KEY);
    sfm.insertNewFiles(al(sf_i2c, sf_c2i));
    assertEquals(2, sfm.getStripeCount());
    // Now try to add conflicting flush - should throw.
    HStoreFile sf_i2d = createFile(OPEN_KEY, KEY_D), sf_d2i = createFile(KEY_D, OPEN_KEY);
    sfm.insertNewFiles(al(sf_i2d, sf_d2i));
    assertEquals(2, sfm.getStripeCount());
    assertEquals(2, sfm.getLevel0Files().size());
    verifyGetAndScanScenario(sfm, KEY_C, KEY_C, sf_i2d, sf_d2i, sf_c2i);
    // Remove these files.
    sfm.addCompactionResults(al(sf_i2d, sf_d2i), al());
    sfm.removeCompactedFiles(al(sf_i2d, sf_d2i));
    assertEquals(0, sfm.getLevel0Files().size());
    // Add another file to stripe; then ""rebalance"" stripes w/o it - the file, which was
    // presumably flushed during compaction, should go to L0.
    HStoreFile sf_i2c_2 = createFile(OPEN_KEY, KEY_C);
    sfm.insertNewFiles(al(sf_i2c_2));
    sfm.addCompactionResults(al(sf_i2c, sf_c2i), al(sf_i2d, sf_d2i));
    sfm.removeCompactedFiles(al(sf_i2c, sf_c2i));
    assertEquals(1, sfm.getLevel0Files().size());
    verifyGetAndScanScenario(sfm, KEY_C, KEY_C, sf_i2d, sf_i2c_2);
  }",Eager Test
"@Test
  public void testEmptyResultsForStripes() throws Exception {
    // Test that we can compact L0 into a subset of stripes.
    StripeStoreFileManager manager = createManager();
    HStoreFile sf0a = createFile();
    HStoreFile sf0b = createFile();
    manager.insertNewFiles(al(sf0a));
    manager.insertNewFiles(al(sf0b));
    ArrayList<HStoreFile> compacted =
      al(createFile(OPEN_KEY, KEY_B), createFile(KEY_B, KEY_C), createFile(KEY_C, OPEN_KEY));
    manager.addCompactionResults(al(sf0a), compacted);
    manager.removeCompactedFiles(al(sf0a));
    // Next L0 compaction only produces file for the first and last stripe.
    ArrayList<HStoreFile> compacted2 = al(createFile(OPEN_KEY, KEY_B), createFile(KEY_C, OPEN_KEY));
    manager.addCompactionResults(al(sf0b), compacted2);
    manager.removeCompactedFiles(al(sf0b));
    compacted.addAll(compacted2);
    verifyAllFiles(manager, compacted);
  }",No Smells
"@Test
  public void testGetStripeBoundarySplits() throws Exception {
    /* First number - split must be after this stripe; further numbers - stripes */
    verifySplitPointScenario(5, false, 0f, 2, 1, 1, 1, 1, 1, 10);
    verifySplitPointScenario(0, false, 0f, 6, 3, 1, 1, 2);
    verifySplitPointScenario(2, false, 0f, 1, 1, 1, 1, 2);
    verifySplitPointScenario(0, false, 0f, 5, 4);
    verifySplitPointScenario(2, false, 0f, 5, 2, 5, 5, 5);
  }",No Smells
"@Test
  public void testLoadFilesWithGaps() throws Exception {
    // Stripes must not have gaps. If they do, everything goes to L0.
    StripeStoreFileManager manager =
      createManager(al(createFile(OPEN_KEY, KEY_B), createFile(KEY_C, OPEN_KEY)));
    assertEquals(2, manager.getLevel0Files().size());
    // Just one open stripe should be ok.
    manager = createManager(al(createFile(OPEN_KEY, OPEN_KEY)));
    assertEquals(0, manager.getLevel0Files().size());
    assertEquals(1, manager.getStorefileCount());
  }",No Smells
"@Test
  public void testPreparePutCounter() throws Exception {

    ExecutorService executorService = Executors.newFixedThreadPool(10);

    Configuration conf = new Configuration();
    conf.setInt(PARALLEL_PUT_STORE_THREADS_LIMIT_MIN_COLUMN_COUNT, 0);
    conf.setInt(PARALLEL_PUT_STORE_THREADS_LIMIT, 10);
    conf.setInt(PARALLEL_PREPARE_PUT_STORE_MULTIPLIER, 3);
    Region mockRegion = mock(Region.class);
    StoreHotnessProtector storeHotnessProtector = new StoreHotnessProtector(mockRegion, conf);

    Store mockStore1 = mock(Store.class);
    RegionInfo mockRegionInfo = mock(RegionInfo.class);
    byte[] family = Bytes.toBytes(""testF1"");

    when(mockRegion.getStore(family)).thenReturn(mockStore1);
    when(mockRegion.getRegionInfo()).thenReturn(mockRegionInfo);
    when(mockRegionInfo.getRegionNameAsString()).thenReturn(""test_region_1"");

    when(mockStore1.getCurrentParallelPutCount()).thenReturn(1);
    when(mockStore1.getColumnFamilyName()).thenReturn(""test_Family_1"");

    final Map<byte[], List<Cell>> familyMaps = new HashMap<>();
    familyMaps.put(family, Lists.newArrayList(mock(Cell.class), mock(Cell.class)));

    final AtomicReference<Exception> exception = new AtomicReference<>();

    // PreparePutCounter not access limit

    int threadCount = conf.getInt(PARALLEL_PUT_STORE_THREADS_LIMIT, 10)
      * conf.getInt(PARALLEL_PREPARE_PUT_STORE_MULTIPLIER, 3);
    CountDownLatch countDownLatch = new CountDownLatch(threadCount);

    for (int i = 0; i < threadCount; i++) {
      executorService.execute(() -> {
        try {
          storeHotnessProtector.start(familyMaps);
        }",Eager Test
"@Test
  public void testWALComparator() throws Exception {
    AbstractFSWAL<?> wal1 = null;
    AbstractFSWAL<?> walMeta = null;
    try {
      wal1 = newWAL(FS, CommonFSUtils.getWALRootDir(CONF), DIR.toString(),
        HConstants.HREGION_OLDLOGDIR_NAME, CONF, null, true, null, null);
      LOG.debug(""Log obtained is: "" + wal1);
      Comparator<Path> comp = wal1.LOG_NAME_COMPARATOR;
      Path p1 = wal1.computeFilename(11);
      Path p2 = wal1.computeFilename(12);
      // comparing with itself returns 0
      assertTrue(comp.compare(p1, p1) == 0);
      // comparing with different filenum.
      assertTrue(comp.compare(p1, p2) < 0);
      walMeta = newWAL(FS, CommonFSUtils.getWALRootDir(CONF), DIR.toString(),
        HConstants.HREGION_OLDLOGDIR_NAME, CONF, null, true, null,
        AbstractFSWALProvider.META_WAL_PROVIDER_ID);
      Comparator<Path> compMeta = walMeta.LOG_NAME_COMPARATOR;

      Path p1WithMeta = walMeta.computeFilename(11);
      Path p2WithMeta = walMeta.computeFilename(12);
      assertTrue(compMeta.compare(p1WithMeta, p1WithMeta) == 0);
      assertTrue(compMeta.compare(p1WithMeta, p2WithMeta) < 0);
      // mixing meta and non-meta logs gives error
      boolean ex = false;
      try {
        comp.compare(p1WithMeta, p2);
      }",Eager Test
"@Test
  public void testWriteEntryCanBeNull() throws IOException {
    String testName = currentTest.getMethodName();
    AbstractFSWAL<?> wal = newWAL(FS, CommonFSUtils.getWALRootDir(CONF), DIR.toString(), testName,
      CONF, null, true, null, null);
    wal.close();
    TableDescriptor td = TableDescriptorBuilder.newBuilder(TableName.valueOf(""table""))
      .setColumnFamily(ColumnFamilyDescriptorBuilder.of(""row"")).build();
    RegionInfo ri = RegionInfoBuilder.newBuilder(td.getTableName()).build();
    MultiVersionConcurrencyControl mvcc = new MultiVersionConcurrencyControl();
    NavigableMap<byte[], Integer> scopes = new TreeMap<>(Bytes.BYTES_COMPARATOR);
    for (byte[] fam : td.getColumnFamilyNames()) {
      scopes.put(fam, 0);
    }",Eager Test
"@Test
  public void testAreAllLower() {
    SequenceIdAccounting sida = new SequenceIdAccounting();
    sida.getOrCreateLowestSequenceIds(ENCODED_REGION_NAME);
    Map<byte[], Long> m = new HashMap<>();
    m.put(ENCODED_REGION_NAME, HConstants.NO_SEQNUM);
    assertTrue(sida.areAllLower(m, null));
    long sequenceid = 1;
    sida.update(ENCODED_REGION_NAME, FAMILIES, sequenceid, true);
    sida.update(ENCODED_REGION_NAME, FAMILIES, sequenceid++, true);
    sida.update(ENCODED_REGION_NAME, FAMILIES, sequenceid++, true);
    assertTrue(sida.areAllLower(m, null));
    m.put(ENCODED_REGION_NAME, sequenceid);
    assertFalse(sida.areAllLower(m, null));
    ArrayList<byte[]> regions = new ArrayList<>();
    assertFalse(sida.areAllLower(m, regions));
    assertEquals(1, regions.size());
    assertArrayEquals(ENCODED_REGION_NAME, regions.get(0));
    long lowest = sida.getLowestSequenceId(ENCODED_REGION_NAME);
    assertEquals(""Lowest should be first sequence id inserted"", 1, lowest);
    m.put(ENCODED_REGION_NAME, lowest);
    assertFalse(sida.areAllLower(m, null));
    // Now make sure above works when flushing.
    sida.startCacheFlush(ENCODED_REGION_NAME, FAMILIES);
    assertFalse(sida.areAllLower(m, null));
    m.put(ENCODED_REGION_NAME, HConstants.NO_SEQNUM);
    assertTrue(sida.areAllLower(m, null));
    // Let the flush complete and if we ask if the sequenceid is lower, should be yes since no edits
    sida.completeCacheFlush(ENCODED_REGION_NAME, HConstants.NO_SEQNUM);
    m.put(ENCODED_REGION_NAME, sequenceid);
    assertTrue(sida.areAllLower(m, null));
    // Flush again but add sequenceids while we are flushing.
    sida.update(ENCODED_REGION_NAME, FAMILIES, sequenceid++, true);
    sida.update(ENCODED_REGION_NAME, FAMILIES, sequenceid++, true);
    sida.update(ENCODED_REGION_NAME, FAMILIES, sequenceid++, true);
    lowest = sida.getLowestSequenceId(ENCODED_REGION_NAME);
    m.put(ENCODED_REGION_NAME, lowest);
    assertFalse(sida.areAllLower(m, null));
    sida.startCacheFlush(ENCODED_REGION_NAME, FAMILIES);
    // The cache flush will clear out all sequenceid accounting by region.
    assertEquals(HConstants.NO_SEQNUM, sida.getLowestSequenceId(ENCODED_REGION_NAME));
    sida.completeCacheFlush(ENCODED_REGION_NAME, HConstants.NO_SEQNUM);
    // No new edits have gone in so no sequenceid to work with.
    assertEquals(HConstants.NO_SEQNUM, sida.getLowestSequenceId(ENCODED_REGION_NAME));
    // Make an edit behind all we'll put now into sida.
    m.put(ENCODED_REGION_NAME, sequenceid);
    sida.update(ENCODED_REGION_NAME, FAMILIES, ++sequenceid, true);
    sida.update(ENCODED_REGION_NAME, FAMILIES, ++sequenceid, true);
    sida.update(ENCODED_REGION_NAME, FAMILIES, ++sequenceid, true);
    assertTrue(sida.areAllLower(m, null));
    m.put(ENCODED_REGION_NAME, sequenceid);
    assertFalse(sida.areAllLower(m, null));

    // Test the METAFAMILY is filtered in SequenceIdAccounting.lowestUnflushedSequenceIds
    SequenceIdAccounting meta_sida = new SequenceIdAccounting();
    Map<byte[], Long> meta_m = new HashMap<>();
    meta_sida.getOrCreateLowestSequenceIds(ENCODED_REGION_NAME);
    meta_m.put(ENCODED_REGION_NAME, sequenceid);
    meta_sida.update(ENCODED_REGION_NAME, META_FAMILY_SET, ++sequenceid, true);
    meta_sida.update(ENCODED_REGION_NAME, META_FAMILY_SET, ++sequenceid, true);
    meta_sida.update(ENCODED_REGION_NAME, META_FAMILY_SET, ++sequenceid, true);
    assertTrue(meta_sida.areAllLower(meta_m, null));
    meta_m.put(ENCODED_REGION_NAME, sequenceid);
    assertTrue(meta_sida.areAllLower(meta_m, null));
  }",Eager Test
"@Test
  public void testActionListener() throws Exception {
    DummyWALActionsListener observer = new DummyWALActionsListener();
    final WALFactory wals = new WALFactory(conf, ""testActionListener"");
    wals.getWALProvider().addWALActionsListener(observer);
    DummyWALActionsListener laterobserver = new DummyWALActionsListener();
    RegionInfo hri = RegionInfoBuilder.newBuilder(TableName.valueOf(SOME_BYTES))
      .setStartKey(SOME_BYTES).setEndKey(SOME_BYTES).build();
    final WAL wal = wals.getWAL(hri);
    MultiVersionConcurrencyControl mvcc = new MultiVersionConcurrencyControl();
    for (int i = 0; i < 20; i++) {
      byte[] b = Bytes.toBytes(i + """");
      KeyValue kv = new KeyValue(b, b, b);
      WALEdit edit = new WALEdit();
      WALEditInternalHelper.addExtendedCell(edit, kv);
      NavigableMap<byte[], Integer> scopes = new TreeMap<>(Bytes.BYTES_COMPARATOR);
      scopes.put(b, 0);
      long txid = wal.appendData(hri,
        new WALKeyImpl(hri.getEncodedNameAsBytes(), TableName.valueOf(b), 0, mvcc, scopes), edit);
      wal.sync(txid);
      if (i == 10) {
        wal.registerWALActionsListener(laterobserver);
      }",Eager Test
"@Test
  public void testGetInstance() {
    MetricsReplicationSourceFactory rms =
      CompatibilitySingletonFactory.getInstance(MetricsReplicationSourceFactory.class);
    assertTrue(rms instanceof MetricsReplicationSourceFactoryImpl);
  }",No Smells
"@Test
  public void testGetInstance() throws Exception {
    MetricsReplicationSource rms =
      CompatibilitySingletonFactory.getInstance(MetricsReplicationSource.class);
    assertTrue(rms instanceof MetricsReplicationSourceImpl);
  }",No Smells
"@Test
  public void testBatchSink() throws Exception {
    List<WALEntry> entries = new ArrayList<>(BATCH_SIZE);
    List<ExtendedCell> cells = new ArrayList<>();
    for (int i = 0; i < BATCH_SIZE; i++) {
      entries.add(createEntry(TABLE_NAME1, i, KeyValue.Type.Put, cells));
    }",Eager Test
"@Test
  public void testThrottling() {
    LOG.info(""testThrottling"");

    // throttle bandwidth is 100 and 10 bytes/cycle respectively
    ReplicationThrottler throttler1 = new ReplicationThrottler(100);
    ReplicationThrottler throttler2 = new ReplicationThrottler(10);

    long ticks1 = throttler1.getNextSleepInterval(1000);
    long ticks2 = throttler2.getNextSleepInterval(1000);

    // 1. the first push size is 1000, though 1000 bytes exceeds 100/10
    // bandwidthes, but no sleep since it's the first push of current
    // cycle, amortizing occurs when next push arrives
    assertEquals(0, ticks1);
    assertEquals(0, ticks2);

    throttler1.addPushSize(1000);
    throttler2.addPushSize(1000);

    ticks1 = throttler1.getNextSleepInterval(5);
    ticks2 = throttler2.getNextSleepInterval(5);

    // 2. when the second push(5) arrives and throttling(5) is called, the
    // current cyclePushSize is 1000 bytes, this should make throttler1
    // sleep 1000/100 = 10 cycles = 1s and make throttler2 sleep 1000/10
    // = 100 cycles = 10s before the second push occurs -- amortize case
    // after amortizing, both cycleStartTick and cyclePushSize are reset
    //
    // Note: in a slow machine, the sleep interval might be less than ideal ticks.
    // If it is 75% of expected value, its is still acceptable.
    if (ticks1 != 1000 && ticks1 != 999) {
      assertTrue(ticks1 >= 750 && ticks1 <= 1000);
    }",Eager Test
"@Test
  public void testInterClusterReplication() throws Exception {
    final String id = ""testInterClusterReplication"";

    List<HRegion> regions = UTIL1.getHBaseCluster().getRegions(tableName);
    int totEdits = 0;

    // Make sure edits are spread across regions because we do region based batching
    // before shipping edits.
    for (HRegion region : regions) {
      RegionInfo hri = region.getRegionInfo();
      byte[] row = hri.getStartKey();
      for (int i = 0; i < 100; i++) {
        if (row.length > 0) {
          Put put = new Put(row);
          put.addColumn(famName, row, row);
          region.put(put);
          totEdits++;
        }",Eager Test
"@Test
  public void testMetricsSourceBaseSourcePassThrough() {
    /*
     * The replication MetricsSource wraps a MetricsReplicationTableSourceImpl,
     * MetricsReplicationSourceSourceImpl and a MetricsReplicationGlobalSourceSource, so that
     * metrics get written to both namespaces. Both of those classes wrap a
     * MetricsReplicationSourceImpl that implements BaseSource, which allows for custom JMX metrics.
     * This test checks to make sure the BaseSource decorator logic on MetricsSource actually calls
     * down through the two layers of wrapping to the actual BaseSource.
     */
    String id = ""id"";
    DynamicMetricsRegistry mockRegistry = mock(DynamicMetricsRegistry.class);
    MetricsReplicationSourceImpl singleRms = mock(MetricsReplicationSourceImpl.class);
    when(singleRms.getMetricsRegistry()).thenReturn(mockRegistry);
    MetricsReplicationSourceImpl globalRms = mock(MetricsReplicationSourceImpl.class);
    when(globalRms.getMetricsRegistry()).thenReturn(mockRegistry);

    MetricsReplicationSourceSource singleSourceSource =
      new MetricsReplicationSourceSourceImpl(singleRms, id);
    MetricsReplicationGlobalSourceSource globalSourceSource =
      new MetricsReplicationGlobalSourceSourceImpl(globalRms);
    MetricsReplicationGlobalSourceSource spyglobalSourceSource = spy(globalSourceSource);
    doNothing().when(spyglobalSourceSource).incrFailedRecoveryQueue();

    Map<String, MetricsReplicationTableSource> singleSourceSourceByTable = new HashMap<>();
    MetricsSource source =
      new MetricsSource(id, singleSourceSource, spyglobalSourceSource, singleSourceSourceByTable);

    String gaugeName = ""gauge"";
    String singleGaugeName = ""source.id."" + gaugeName;
    String globalGaugeName = ""source."" + gaugeName;
    long delta = 1;
    String counterName = ""counter"";
    String singleCounterName = ""source.id."" + counterName;
    String globalCounterName = ""source."" + counterName;
    long count = 2;
    source.decGauge(gaugeName, delta);
    source.getMetricsContext();
    source.getMetricsDescription();
    source.getMetricsJmxContext();
    source.getMetricsName();
    source.incCounters(counterName, count);
    source.incGauge(gaugeName, delta);
    source.init();
    source.removeMetric(gaugeName);
    source.setGauge(gaugeName, delta);
    source.updateHistogram(counterName, count);
    source.incrFailedRecoveryQueue();

    verify(singleRms).decGauge(singleGaugeName, delta);
    verify(globalRms).decGauge(globalGaugeName, delta);
    verify(globalRms).getMetricsContext();
    verify(globalRms).getMetricsJmxContext();
    verify(globalRms).getMetricsName();
    verify(singleRms).incCounters(singleCounterName, count);
    verify(globalRms).incCounters(globalCounterName, count);
    verify(singleRms).incGauge(singleGaugeName, delta);
    verify(globalRms).incGauge(globalGaugeName, delta);
    verify(globalRms).init();
    verify(singleRms).removeMetric(singleGaugeName);
    verify(globalRms).removeMetric(globalGaugeName);
    verify(singleRms).setGauge(singleGaugeName, delta);
    verify(globalRms).setGauge(globalGaugeName, delta);
    verify(singleRms).updateHistogram(singleCounterName, count);
    verify(globalRms).updateHistogram(globalCounterName, count);
    verify(spyglobalSourceSource).incrFailedRecoveryQueue();

    // check singleSourceSourceByTable metrics.
    // singleSourceSourceByTable map entry will be created only
    // after calling #setAgeOfLastShippedOpByTable
    boolean containsRandomNewTable =
      source.getSingleSourceSourceByTable().containsKey(""RandomNewTable"");
    Assert.assertEquals(false, containsRandomNewTable);
    source.updateTableLevelMetrics(createWALEntriesWithSize(""RandomNewTable""));
    containsRandomNewTable = source.getSingleSourceSourceByTable().containsKey(""RandomNewTable"");
    Assert.assertEquals(true, containsRandomNewTable);
    MetricsReplicationTableSource msr = source.getSingleSourceSourceByTable().get(""RandomNewTable"");

    // age should be greater than zero we created the entry with time in the past
    Assert.assertTrue(msr.getLastShippedAge() > 0);
    Assert.assertTrue(msr.getShippedBytes() > 0);

  }",Eager Test
"@Test
  public void testReplicationStatus() throws Exception {
    // This test wants two RS's up. We only run one generally so add one.
    UTIL1.getMiniHBaseCluster().startRegionServer();
    Waiter.waitFor(UTIL1.getConfiguration(), 30000, new Waiter.Predicate<Exception>() {
      @Override
      public boolean evaluate() throws Exception {
        return UTIL1.getMiniHBaseCluster().getLiveRegionServerThreads().size() > 1;
      }",Eager Test + Mystery Guest
"@Test
  public void testExistingFilter() throws Exception {
    final String CORRECT_FILTER = ""{\""type\"": \""PrefixFilter\"", \""value\"": \""cg==\""}",No Smells
"@Test
  public void testResetBuffer() throws IOException {
    when(response.isCommitted()).thenReturn(false);
    ServletOutputStream out = mock(ServletOutputStream.class);
    when(response.getOutputStream()).thenReturn(out);

    ServletOutputStream servletOutput = wrapper.getOutputStream();
    assertEquals(GZIPResponseStream.class, servletOutput.getClass());
    wrapper.resetBuffer();
    verify(response).setHeader(""Content-Encoding"", null);

    when(response.isCommitted()).thenReturn(true);
    servletOutput = wrapper.getOutputStream();
    assertEquals(out.getClass(), servletOutput.getClass());
    assertNotNull(wrapper.getWriter());
  }",No Smells
"@Test
  public void testMultiCellGetJSON() throws IOException {
    String row_5_url = ""/"" + TABLE + ""/"" + ROW_1 + ""/"" + COLUMN_1;
    String row_6_url = ""/"" + TABLE + ""/"" + ROW_2 + ""/"" + COLUMN_2;

    StringBuilder path = new StringBuilder();
    path.append(""/"");
    path.append(TABLE);
    path.append(""/multiget/?row="");
    path.append(ROW_1);
    path.append(""&row="");
    path.append(ROW_2);

    if (csrfEnabled) {
      Response response = client.post(row_5_url, Constants.MIMETYPE_BINARY, Bytes.toBytes(VALUE_1));
      assertEquals(400, response.getCode());
    }",Eager Test
"@Test
  public void testMultiCellGetJSONNotFound() throws IOException {
    String row_5_url = ""/"" + TABLE + ""/"" + ROW_1 + ""/"" + COLUMN_1;

    StringBuilder path = new StringBuilder();
    path.append(""/"");
    path.append(TABLE);
    path.append(""/multiget/?row="");
    path.append(ROW_1);
    path.append(""&row="");
    path.append(ROW_2);

    client.post(row_5_url, Constants.MIMETYPE_BINARY, Bytes.toBytes(VALUE_1), extraHdr);
    Response response = client.get(path.toString(), Constants.MIMETYPE_JSON);
    assertEquals(200, response.getCode());
    ObjectMapper mapper = new JacksonJaxbJsonProvider().locateMapper(CellSetModel.class,
      MediaType.APPLICATION_JSON_TYPE);
    CellSetModel cellSet = (CellSetModel) mapper.readValue(response.getBody(), CellSetModel.class);
    assertEquals(1, cellSet.getRows().size());
    assertEquals(ROW_1, Bytes.toString(cellSet.getRows().get(0).getKey()));
    assertEquals(VALUE_1, Bytes.toString(cellSet.getRows().get(0).getCells().get(0).getValue()));
    client.delete(row_5_url, extraHdr);
  }",No Smells
"@Test
  public void testMultiCellGetWithColsJSON() throws IOException {
    String row_5_url = ""/"" + TABLE + ""/"" + ROW_1 + ""/"" + COLUMN_1;
    String row_6_url = ""/"" + TABLE + ""/"" + ROW_2 + ""/"" + COLUMN_2;

    StringBuilder path = new StringBuilder();
    path.append(""/"");
    path.append(TABLE);
    path.append(""/multiget"");
    path.append(""/"" + COLUMN_1 + "","" + CFB);
    path.append(""?row="");
    path.append(ROW_1);
    path.append(""&row="");
    path.append(ROW_2);

    client.post(row_5_url, Constants.MIMETYPE_BINARY, Bytes.toBytes(VALUE_1), extraHdr);
    client.post(row_6_url, Constants.MIMETYPE_BINARY, Bytes.toBytes(VALUE_2), extraHdr);

    Response response = client.get(path.toString(), Constants.MIMETYPE_JSON);
    assertEquals(200, response.getCode());
    ObjectMapper mapper = new JacksonJaxbJsonProvider().locateMapper(CellSetModel.class,
      MediaType.APPLICATION_JSON_TYPE);
    CellSetModel cellSet = mapper.readValue(response.getBody(), CellSetModel.class);
    assertEquals(2, cellSet.getRows().size());
    assertEquals(ROW_1, Bytes.toString(cellSet.getRows().get(0).getKey()));
    assertEquals(VALUE_1, Bytes.toString(cellSet.getRows().get(0).getCells().get(0).getValue()));
    assertEquals(ROW_2, Bytes.toString(cellSet.getRows().get(1).getKey()));
    assertEquals(VALUE_2, Bytes.toString(cellSet.getRows().get(1).getCells().get(0).getValue()));

    client.delete(row_5_url, extraHdr);
    client.delete(row_6_url, extraHdr);
  }",No Smells
"@Test
  public void testTableListText() throws IOException {
    Response response = client.get(""/"", Constants.MIMETYPE_TEXT);
    assertEquals(200, response.getCode());
    assertEquals(Constants.MIMETYPE_TEXT, response.getHeader(""content-type""));
  }",No Smells
"@Test
  public void testGetStargateVersionPB() throws IOException {
    Response response = client.get(""/version"", Constants.MIMETYPE_PROTOBUF);
    assertEquals(200, response.getCode());
    assertEquals(Constants.MIMETYPE_PROTOBUF, response.getHeader(""content-type""));
    VersionModel model = new VersionModel();
    model.getObjectFromMessage(response.getBody());
    validate(model);
    response = client.get(""/version"", Constants.MIMETYPE_PROTOBUF_IETF);
    assertEquals(200, response.getCode());
    assertEquals(Constants.MIMETYPE_PROTOBUF_IETF, response.getHeader(""content-type""));
    model = new VersionModel();
    model.getObjectFromMessage(response.getBody());
    validate(model);
  }",No Smells
"@Test
  public void testAccessControlRevokeOnlyFewPermission() throws Throwable {
    TableName tname = TableName.valueOf(""revoke"");
    try {
      TEST_UTIL.createTable(tname, TEST_FAMILY);
      User testUserPerms = User.createUserForTesting(conf, ""revokePerms"", new String[0]);
      Permission.Action[] actions = { Action.READ, Action.WRITE }",Eager Test
"@Test
  public void testBalanceSwitch() throws Exception {
    AccessTestAction action = new AccessTestAction() {
      @Override
      public Object run() throws Exception {
        ACCESS_CONTROLLER.preBalanceSwitch(ObserverContextImpl.createAndPrepare(CP_ENV), true);
        return null;
      }",No Smells
"@Test
  public void testCompact() throws Exception {
    AccessTestAction action = new AccessTestAction() {
      @Override
      public Object run() throws Exception {
        ACCESS_CONTROLLER.preCompact(ObserverContextImpl.createAndPrepare(RCP_ENV), null, null,
          ScanType.COMPACT_RETAIN_DELETES, null, null);
        return null;
      }",No Smells
"@Test
  public void testEnableReplicationPeer() throws Exception {
    AccessTestAction action = new AccessTestAction() {
      @Override
      public Object run() throws Exception {
        ACCESS_CONTROLLER.preEnableReplicationPeer(ObserverContextImpl.createAndPrepare(CP_ENV),
          ""test"");
        return null;
      }",No Smells
"@Test
  public void testGetLocks() throws Exception {
    AccessTestAction action = new AccessTestAction() {
      @Override
      public Object run() throws Exception {
        ACCESS_CONTROLLER.preGetLocks(ObserverContextImpl.createAndPrepare(CP_ENV));
        return null;
      }",No Smells
"@Test
  public void testGetProcedures() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final ProcedureExecutor<MasterProcedureEnv> procExec =
      TEST_UTIL.getHBaseCluster().getMaster().getMasterProcedureExecutor();
    Procedure proc = new TestTableDDLProcedure(procExec.getEnvironment(), tableName);
    proc.setOwner(USER_OWNER);
    procExec.submitProcedure(proc);
    final List<Procedure<MasterProcedureEnv>> procList = procExec.getProcedures();

    AccessTestAction getProceduresAction = new AccessTestAction() {
      @Override
      public Object run() throws Exception {
        ACCESS_CONTROLLER.postGetProcedures(ObserverContextImpl.createAndPrepare(CP_ENV));
        return null;
      }",Eager Test
"@Test
  public void testGetUserPermissions() throws Throwable {
    Connection conn = null;
    try {
      conn = ConnectionFactory.createConnection(conf);
      User nSUser1 = User.createUserForTesting(conf, ""nsuser1"", new String[0]);
      User nSUser2 = User.createUserForTesting(conf, ""nsuser2"", new String[0]);
      User nSUser3 = User.createUserForTesting(conf, ""nsuser3"", new String[0]);

      // Global access groups
      User globalGroupUser1 =
        User.createUserForTesting(conf, ""globalGroupUser1"", new String[] { ""group_admin"" }",Eager Test
"@Test
  public void testHasPermission() throws Throwable {
    Connection conn = null;
    try {
      conn = ConnectionFactory.createConnection(conf);
      // Create user and set namespace ACL
      User user1 = User.createUserForTesting(conf, ""testHasPermissionUser1"", new String[0]);
      // Grant namespace permission
      grantOnNamespaceUsingAccessControlClient(TEST_UTIL, conn, user1.getShortName(),
        NamespaceDescriptor.DEFAULT_NAMESPACE.getName(), Permission.Action.ADMIN,
        Permission.Action.CREATE, Permission.Action.READ);

      // Create user and set table ACL
      User user2 = User.createUserForTesting(conf, ""testHasPermissionUser2"", new String[0]);
      // Grant namespace permission
      grantOnTableUsingAccessControlClient(TEST_UTIL, conn, user2.getShortName(), TEST_TABLE,
        TEST_FAMILY, TEST_QUALIFIER, Permission.Action.READ, Permission.Action.WRITE);

      // Verify action privilege
      AccessTestAction hasPermissionActionCP = new AccessTestAction() {
        @Override
        public Object run() throws Exception {
          try (Connection conn = ConnectionFactory.createConnection(conf);
            Table acl = conn.getTable(PermissionStorage.ACL_TABLE_NAME)) {
            BlockingRpcChannel service = acl.coprocessorService(TEST_TABLE.getName());
            AccessControlService.BlockingInterface protocol =
              AccessControlService.newBlockingStub(service);
            Permission.Action[] actions = { Permission.Action.READ, Permission.Action.WRITE }",Eager Test
"@Test
  public void testPostGrantRevokeAtQualifierLevel() throws Exception {
    final TableName tableName = TableName.valueOf(name.getMethodName());
    final byte[] family1 = Bytes.toBytes(""f1"");
    final byte[] family2 = Bytes.toBytes(""f2"");
    final byte[] qualifier = Bytes.toBytes(""q"");

    // create table
    Admin admin = TEST_UTIL.getAdmin();
    if (admin.tableExists(tableName)) {
      deleteTable(TEST_UTIL, tableName);
    }",Eager Test
"@Test
  public void testReadWrite() throws Exception {
    // action for checkAndDelete
    AccessTestAction checkAndDeleteAction = new AccessTestAction() {
      @Override
      public Object run() throws Exception {
        Delete d = new Delete(TEST_ROW);
        d.addFamily(TEST_FAMILY);
        try (Connection conn = ConnectionFactory.createConnection(conf);
          Table t = conn.getTable(TEST_TABLE)) {
          t.checkAndMutate(TEST_ROW, TEST_FAMILY).qualifier(TEST_QUALIFIER)
            .ifEquals(Bytes.toBytes(""test_value"")).thenDelete(d);
        }",Eager Test
"@Test
  public void testRemoteLocks() throws Exception {
    String namespace = ""preQueueNs"";
    final TableName tableName = TableName.valueOf(namespace, name.getMethodName());
    RegionInfo[] regionInfos = new RegionInfo[] { RegionInfoBuilder.newBuilder(tableName).build() }",Eager Test
"@Test
  public void testSetSplitOrMergeEnabled() throws Exception {
    AccessTestAction action = new AccessTestAction() {
      @Override
      public Object run() throws Exception {
        ACCESS_CONTROLLER.preSetSplitOrMergeEnabled(ObserverContextImpl.createAndPrepare(CP_ENV),
          true, MasterSwitchType.MERGE);
        return null;
      }",No Smells
"@Test
  public void testTableDelete() throws Exception {
    AccessTestAction deleteTable = new AccessTestAction() {
      @Override
      public Object run() throws Exception {
        ACCESS_CONTROLLER.preDeleteTable(ObserverContextImpl.createAndPrepare(CP_ENV), TEST_TABLE);
        return null;
      }",No Smells
"@Test
  public void testTableTruncate() throws Exception {
    AccessTestAction truncateTable = new AccessTestAction() {
      @Override
      public Object run() throws Exception {
        ACCESS_CONTROLLER.preTruncateTable(ObserverContextImpl.createAndPrepare(CP_ENV),
          TEST_TABLE);
        return null;
      }",No Smells
"@Test
  public void testTransitSyncReplicationPeerState() throws Exception {
    AccessTestAction action = new AccessTestAction() {
      @Override
      public Object run() throws Exception {
        ACCESS_CONTROLLER.preTransitReplicationPeerSyncReplicationState(
          ObserverContextImpl.createAndPrepare(CP_ENV), ""test"", SyncReplicationState.NONE);
        return null;
      }",No Smells
"@Test
  public void testTruncatePerms() throws Exception {
    try {
      List<UserPermission> existingPerms =
        AccessControlClient.getUserPermissions(systemUserConnection, TEST_TABLE.getNameAsString());
      assertTrue(existingPerms != null);
      assertTrue(existingPerms.size() > 1);
      TEST_UTIL.getAdmin().disableTable(TEST_TABLE);
      TEST_UTIL.truncateTable(TEST_TABLE);
      TEST_UTIL.waitTableAvailable(TEST_TABLE);
      List<UserPermission> perms =
        AccessControlClient.getUserPermissions(systemUserConnection, TEST_TABLE.getNameAsString());
      assertTrue(perms != null);
      assertEquals(existingPerms.size(), perms.size());
    }",No Smells
"@Test
  public void testUnassign() throws Exception {
    List<HRegionLocation> regions;
    try (RegionLocator locator = systemUserConnection.getRegionLocator(TEST_TABLE)) {
      regions = locator.getAllRegionLocations();
    }",Eager Test
"@Test
  public void testBlanketWhitelist() throws Exception {
    negativeTestCase(new String[] { ""*"" }",No Smells
"@Test
  public void testDifferentFileSystemNonWhitelisted() throws Exception {
    positiveTestCase(new String[] { ""hdfs://foo/bar"" }",No Smells
"@Test
  public void testSchemeWhitelisted() throws Exception {
    negativeTestCase(new String[] { ""file:///"" }",No Smells
"@Test
  public void testPermissionsWatcher() throws Exception {
    Configuration conf = UTIL.getConfiguration();
    User george = User.createUserForTesting(conf, ""george"", new String[] {}",Eager Test
"@Test
  public void testKeyWrappingUsingHashAlgDefault() throws Exception {
    testKeyWrapping(DEFAULT_HASH_ALGORITHM);
  }",Eager Test
"@Test
  public void testRunAs() throws Exception {
    Configuration conf = HBaseConfiguration.create();
    final User user = User.createUserForTesting(conf, ""testuser"", new String[] { ""foo"" }",Eager Test
"@Test
  public void testKeyUpdate() throws Exception {
    // sanity check
    assertTrue(KEY_MASTER.isMaster());
    assertFalse(KEY_SLAVE.isMaster());
    int maxKeyId = 0;

    KEY_MASTER.rollCurrentKey();
    AuthenticationKey key1 = KEY_MASTER.getCurrentKey();
    assertNotNull(key1);
    LOG.debug(""Master current key (key1) {}",Eager Test
"@Test
  public void testNegativeCases() throws Exception {
    executeNegativeCase(""("");
    executeNegativeCase("")"");
    executeNegativeCase(""()"");
    executeNegativeCase(""(a"");
    executeNegativeCase(""a&"");
    executeNegativeCase(""a&|b"");
    executeNegativeCase(""!"");
    executeNegativeCase(""a!"");
    executeNegativeCase(""a!&"");
    executeNegativeCase(""&"");
    executeNegativeCase(""|"");
    executeNegativeCase(""!(a|(b&c)&!b"");
    executeNegativeCase(""!!a"");
    executeNegativeCase(""( a & b ) | ( c & d e)"");
    executeNegativeCase(""! a"");
  }",No Smells
"@Test
  public void testNonAsciiCases() throws Exception {
    ExpressionNode node =
      parser.parse(CellVisibility.quote(""\u0027"") + ""&"" + CellVisibility.quote(""\u002b"") + ""|""
        + CellVisibility.quote(""\u002d"") + ""&"" + CellVisibility.quote(""\u003f""));
    assertTrue(node instanceof NonLeafExpressionNode);
    NonLeafExpressionNode nlNode = (NonLeafExpressionNode) node;
    assertEquals(Operator.AND, nlNode.getOperator());
    assertEquals(2, nlNode.getChildExps().size());
    assertEquals(""\u003f"", ((LeafExpressionNode) nlNode.getChildExps().get(1)).getIdentifier());
    assertTrue(nlNode.getChildExps().get(0) instanceof NonLeafExpressionNode);
    nlNode = (NonLeafExpressionNode) nlNode.getChildExps().get(0);
    assertEquals(Operator.OR, nlNode.getOperator());
    assertEquals(2, nlNode.getChildExps().size());
    assertEquals(""\u002d"", ((LeafExpressionNode) nlNode.getChildExps().get(1)).getIdentifier());
    assertTrue(nlNode.getChildExps().get(0) instanceof NonLeafExpressionNode);
    nlNode = (NonLeafExpressionNode) nlNode.getChildExps().get(0);
    assertEquals(Operator.AND, nlNode.getOperator());
    assertEquals(2, nlNode.getChildExps().size());
    assertEquals(""\u002b"", ((LeafExpressionNode) nlNode.getChildExps().get(1)).getIdentifier());
    assertEquals(""\u0027"", ((LeafExpressionNode) nlNode.getChildExps().get(0)).getIdentifier());

    node = parser.parse(CellVisibility.quote(""\u0027"") + ""&"" + CellVisibility.quote(""\u002b"") + ""|""
      + CellVisibility.quote(""\u002d"") + ""&"" + CellVisibility.quote(""\u003f""));
    assertTrue(node instanceof NonLeafExpressionNode);
    nlNode = (NonLeafExpressionNode) node;
    assertEquals(Operator.AND, nlNode.getOperator());
    assertEquals(2, nlNode.getChildExps().size());
    assertEquals(""\u003f"", ((LeafExpressionNode) nlNode.getChildExps().get(1)).getIdentifier());
    assertTrue(nlNode.getChildExps().get(0) instanceof NonLeafExpressionNode);
    nlNode = (NonLeafExpressionNode) nlNode.getChildExps().get(0);
    assertEquals(Operator.OR, nlNode.getOperator());
    assertEquals(2, nlNode.getChildExps().size());
    assertEquals(""\u002d"", ((LeafExpressionNode) nlNode.getChildExps().get(1)).getIdentifier());
    assertTrue(nlNode.getChildExps().get(0) instanceof NonLeafExpressionNode);
    nlNode = (NonLeafExpressionNode) nlNode.getChildExps().get(0);
    assertEquals(Operator.AND, nlNode.getOperator());
    assertEquals(2, nlNode.getChildExps().size());
    assertEquals(""\u002b"", ((LeafExpressionNode) nlNode.getChildExps().get(1)).getIdentifier());
    assertEquals(""\u0027"", ((LeafExpressionNode) nlNode.getChildExps().get(0)).getIdentifier());
  }",No Smells
"@Test
  public void testIncrement() throws IOException {

    MutationProto proto = getIncrementMutation(111111L);
    // default fields
    assertEquals(MutationProto.Durability.USE_DEFAULT, proto.getDurability());

    // set the default value for equal comparison
    MutationProto.Builder mutateBuilder = MutationProto.newBuilder(proto);
    mutateBuilder.setDurability(MutationProto.Durability.USE_DEFAULT);

    Increment increment = ProtobufUtil.toIncrement(proto, null);
    mutateBuilder.setTimestamp(increment.getTimestamp());
    mutateBuilder.setTimeRange(ProtobufUtil.toTimeRange(increment.getTimeRange()));
    assertEquals(mutateBuilder.build(), ProtobufUtil.toMutation(MutationType.INCREMENT, increment));
  }",Eager Test
"@Test
  public void testNamespaceLockInfo() {
    LockServiceProtos.LockedResource resource =
      createLockedResource(LockServiceProtos.LockedResourceType.NAMESPACE, ""ns"",
        LockServiceProtos.LockType.EXCLUSIVE, createProcedure(2), 0);

    String lockJson = ProtobufUtil.toLockJson(Lists.newArrayList(resource));
    assertEquals(""[{"" + ""\""resourceType\"":\""NAMESPACE\"","" + ""\""resourceName\"":\""ns\"",""
      + ""\""lockType\"":\""EXCLUSIVE\"","" + ""\""exclusiveLockOwnerProcedure\"":{""
      + ""\""className\"":\""java.lang.Object\"","" + ""\""procId\"":\""2\"","" + ""\""submittedTime\"":\""0\"",""
      + ""\""state\"":\""RUNNABLE\"","" + ""\""lastUpdate\"":\""0\"""" + ""}",No Smells
"@Test
  public void testPut() throws IOException {
    MutationProto.Builder mutateBuilder = MutationProto.newBuilder();
    mutateBuilder.setRow(ByteString.copyFromUtf8(""row""));
    mutateBuilder.setMutateType(MutationType.PUT);
    mutateBuilder.setTimestamp(111111);
    ColumnValue.Builder valueBuilder = ColumnValue.newBuilder();
    valueBuilder.setFamily(ByteString.copyFromUtf8(""f1""));
    QualifierValue.Builder qualifierBuilder = QualifierValue.newBuilder();
    qualifierBuilder.setQualifier(ByteString.copyFromUtf8(""c1""));
    qualifierBuilder.setValue(ByteString.copyFromUtf8(""v1""));
    valueBuilder.addQualifierValue(qualifierBuilder.build());
    qualifierBuilder.setQualifier(ByteString.copyFromUtf8(""c2""));
    qualifierBuilder.setValue(ByteString.copyFromUtf8(""v2""));
    qualifierBuilder.setTimestamp(222222);
    valueBuilder.addQualifierValue(qualifierBuilder.build());
    mutateBuilder.addColumnValue(valueBuilder.build());

    MutationProto proto = mutateBuilder.build();
    // default fields
    assertEquals(MutationProto.Durability.USE_DEFAULT, proto.getDurability());

    // set the default value for equal comparison
    mutateBuilder = MutationProto.newBuilder(proto);
    mutateBuilder.setDurability(MutationProto.Durability.USE_DEFAULT);

    Put put = ProtobufUtil.toPut(proto);

    // put value always use the default timestamp if no
    // value level timestamp specified,
    // add the timestamp to the original mutate
    long timestamp = put.getTimestamp();
    for (ColumnValue.Builder column : mutateBuilder.getColumnValueBuilderList()) {
      for (QualifierValue.Builder qualifier : column.getQualifierValueBuilderList()) {
        if (!qualifier.hasTimestamp()) {
          qualifier.setTimestamp(timestamp);
        }",Eager Test
"@Test
  public void testServerLockInfo() {
    LockServiceProtos.LockedResource resource =
      createLockedResource(LockServiceProtos.LockedResourceType.SERVER, ""server"",
        LockServiceProtos.LockType.SHARED, null, 2);

    String lockJson = ProtobufUtil.toLockJson(Lists.newArrayList(resource));
    assertEquals(""[{"" + ""\""resourceType\"":\""SERVER\"","" + ""\""resourceName\"":\""server\"",""
      + ""\""lockType\"":\""SHARED\"","" + ""\""sharedLockCount\"":2"" + ""}",No Smells
"@Test
  public void testToCell() {
    KeyValue kv1 =
      new KeyValue(Bytes.toBytes(""aaa""), Bytes.toBytes(""f1""), Bytes.toBytes(""q1""), new byte[30]);
    KeyValue kv2 =
      new KeyValue(Bytes.toBytes(""bbb""), Bytes.toBytes(""f1""), Bytes.toBytes(""q1""), new byte[30]);
    KeyValue kv3 =
      new KeyValue(Bytes.toBytes(""ccc""), Bytes.toBytes(""f1""), Bytes.toBytes(""q1""), new byte[30]);
    byte[] arr = new byte[kv1.getLength() + kv2.getLength() + kv3.getLength()];
    System.arraycopy(kv1.getBuffer(), kv1.getOffset(), arr, 0, kv1.getLength());
    System.arraycopy(kv2.getBuffer(), kv2.getOffset(), arr, kv1.getLength(), kv2.getLength());
    System.arraycopy(kv3.getBuffer(), kv3.getOffset(), arr, kv1.getLength() + kv2.getLength(),
      kv3.getLength());
    ByteBuffer dbb = ByteBuffer.allocateDirect(arr.length);
    dbb.put(arr);
    ByteBufferKeyValue offheapKV = new ByteBufferKeyValue(dbb, kv1.getLength(), kv2.getLength());
    CellProtos.Cell cell = ProtobufUtil.toCell(offheapKV, false);
    Cell newOffheapKV = ProtobufUtil
      .toCell(ExtendedCellBuilderFactory.create(CellBuilderType.SHALLOW_COPY), cell, false);
    assertTrue(CellComparatorImpl.COMPARATOR.compare(offheapKV, newOffheapKV) == 0);
  }",Eager Test
"@Test
  public void testExportFileSystemStateWithSkipTmp() throws Exception {
    TEST_UTIL.getConfiguration().setBoolean(ExportSnapshot.CONF_SKIP_TMP, true);
    try {
      testExportFileSystemState(tableName, snapshotName, snapshotName, tableNumFiles);
    }",No Smells
"@Test
  public void testRestore() throws IOException {
    restoreAndVerify(""snapshot"", ""testRestore"");
  }",No Smells
"@Test
  public void testCompleteSnapshotWithNoSnapshotDirectoryFailure() throws Exception {
    Path snapshotDir = new Path(root, HConstants.SNAPSHOT_DIR_NAME);
    Path tmpDir = new Path(snapshotDir, "".tmp"");
    Path workingDir = new Path(tmpDir, ""not_a_snapshot"");
    Configuration conf = new Configuration();
    FileSystem workingFs = workingDir.getFileSystem(conf);
    assertFalse(
      ""Already have working snapshot dir: "" + workingDir + "" but shouldn't. Test file leak?"",
      fs.exists(workingDir));
    SnapshotDescription snapshot = SnapshotDescription.newBuilder().setName(""snapshot"").build();
    Path finishedDir = SnapshotDescriptionUtils.getCompletedSnapshotDir(snapshot, snapshotDir);

    try {
      SnapshotDescriptionUtils.completeSnapshot(finishedDir, workingDir, fs, workingFs, conf);
      fail(""Shouldn't successfully complete move of a non-existent directory."");
    }",Eager Test + Mystery Guest
"@Test
  public void testCompare() {
    Cell cell1 = getOffheapCell(row1, fam1, qual1);
    Cell cell2 = getOffheapCell(row1, fam1, qual2);
    assertTrue(CellComparatorImpl.COMPARATOR.compare(cell1, cell2) < 0);
    Cell cell3 = getOffheapCell(row1, Bytes.toBytes(""wide_family""), qual2);
    assertTrue(CellComparatorImpl.COMPARATOR.compare(cell1, cell3) < 0);
    Cell cell4 = getOffheapCell(row1, Bytes.toBytes(""f""), qual2);
    assertTrue(CellComparatorImpl.COMPARATOR.compare(cell1, cell4) > 0);
    CellComparator comparator = CellComparator.getInstance();
    assertTrue(comparator.compare(cell1, cell2) < 0);
    assertTrue(comparator.compare(cell1, cell3) < 0);
    assertTrue(comparator.compare(cell1, cell4) > 0);
    ByteBuffer buf = ByteBuffer.allocate(row1.length);
    ByteBufferUtils.copyFromArrayToBuffer(buf, row1, 0, row1.length);

    ConcurrentSkipListMap<ByteBufferKeyValue, ByteBufferKeyValue> map =
      new ConcurrentSkipListMap<>(comparator);
    map.put((ByteBufferKeyValue) cell1, (ByteBufferKeyValue) cell1);
    map.put((ByteBufferKeyValue) cell2, (ByteBufferKeyValue) cell2);
    map.put((ByteBufferKeyValue) cell3, (ByteBufferKeyValue) cell3);
    map.put((ByteBufferKeyValue) cell1, (ByteBufferKeyValue) cell1);
    map.put((ByteBufferKeyValue) cell1, (ByteBufferKeyValue) cell4);
    assertEquals(3, map.size());
    assertTrue(map.containsKey(cell1));
    assertTrue(map.containsKey(cell2));
    assertTrue(map.containsKey(cell3));
    assertEquals(cell4, map.get(cell1));
    assertEquals(cell2, map.get(cell2));
    assertEquals(cell3, map.get(cell3));
  }",Eager Test
"@Test
  public void testExtendedCellBuilderWithDeepCopy() {
    byte[] row = new byte[] { OLD_DATA }",Eager Test
"@Test
  public void testMetaComparisons() throws Exception {
    long now = EnvironmentEdgeManager.currentTime();

    // Meta compares
    Cell aaa = createByteBufferKeyValueFromKeyValue(
      new KeyValue(Bytes.toBytes(""TestScanMultipleVersions,row_0500,1236020145502""), now));
    Cell bbb = createByteBufferKeyValueFromKeyValue(
      new KeyValue(Bytes.toBytes(""TestScanMultipleVersions,,99999999999999""), now));
    CellComparator c = MetaCellComparator.META_COMPARATOR;
    assertTrue(c.compare(bbb, aaa) < 0);

    Cell ccc = createByteBufferKeyValueFromKeyValue(
      new KeyValue(Bytes.toBytes(""TestScanMultipleVersions,,1236023996656""), Bytes.toBytes(""info""),
        Bytes.toBytes(""regioninfo""), 1236024396271L, (byte[]) null));
    assertTrue(c.compare(ccc, bbb) < 0);

    Cell x = createByteBufferKeyValueFromKeyValue(
      new KeyValue(Bytes.toBytes(""TestScanMultipleVersions,row_0500,1236034574162""),
        Bytes.toBytes(""info""), Bytes.toBytes(""""), 9223372036854775807L, (byte[]) null));
    Cell y = createByteBufferKeyValueFromKeyValue(
      new KeyValue(Bytes.toBytes(""TestScanMultipleVersions,row_0500,1236034574162""),
        Bytes.toBytes(""info""), Bytes.toBytes(""regioninfo""), 1236034574912L, (byte[]) null));
    assertTrue(c.compare(x, y) < 0);
  }",Eager Test
"@Test
  public void testCloneCellFieldsFromByteBufferedCell() {
    byte[] r = Bytes.toBytes(""row1"");
    byte[] f = Bytes.toBytes(""cf1"");
    byte[] q = Bytes.toBytes(""qual1"");
    byte[] v = Bytes.toBytes(""val1"");
    byte[] tags = Bytes.toBytes(""tag1"");
    KeyValue kv =
      new KeyValue(r, f, q, 0, q.length, 1234L, KeyValue.Type.Put, v, 0, v.length, tags);
    ByteBuffer buffer = ByteBuffer.wrap(kv.getBuffer());
    ExtendedCell bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
    byte[] rDest = CellUtil.cloneRow(bbCell);
    assertTrue(Bytes.equals(r, rDest));
    byte[] fDest = CellUtil.cloneFamily(bbCell);
    assertTrue(Bytes.equals(f, fDest));
    byte[] qDest = CellUtil.cloneQualifier(bbCell);
    assertTrue(Bytes.equals(q, qDest));
    byte[] vDest = CellUtil.cloneValue(bbCell);
    assertTrue(Bytes.equals(v, vDest));
    byte[] tDest = new byte[tags.length];
    PrivateCellUtil.copyTagsTo(bbCell, tDest, 0);
    assertTrue(Bytes.equals(tags, tDest));
  }",Eager Test
"@Test
  public void testMatchingCellFieldsFromByteBufferedCell() {
    byte[] r = Bytes.toBytes(""row1"");
    byte[] f = Bytes.toBytes(""cf1"");
    byte[] q1 = Bytes.toBytes(""qual1"");
    byte[] q2 = Bytes.toBytes(""qual2"");
    byte[] v = Bytes.toBytes(""val1"");
    byte[] tags = Bytes.toBytes(""tag1"");
    KeyValue kv =
      new KeyValue(r, f, q1, 0, q1.length, 1234L, KeyValue.Type.Put, v, 0, v.length, tags);
    ByteBuffer buffer = ByteBuffer.wrap(kv.getBuffer());
    Cell bbCell1 = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
    kv = new KeyValue(r, f, q2, 0, q2.length, 1234L, KeyValue.Type.Put, v, 0, v.length, tags);
    buffer = ByteBuffer.wrap(kv.getBuffer());
    Cell bbCell2 = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
    assertTrue(CellUtil.matchingRows(bbCell1, bbCell2));
    assertTrue(CellUtil.matchingRows(kv, bbCell2));
    assertTrue(CellUtil.matchingRows(bbCell1, r));
    assertTrue(CellUtil.matchingFamily(bbCell1, bbCell2));
    assertTrue(CellUtil.matchingFamily(kv, bbCell2));
    assertTrue(CellUtil.matchingFamily(bbCell1, f));
    assertFalse(CellUtil.matchingQualifier(bbCell1, bbCell2));
    assertTrue(CellUtil.matchingQualifier(kv, bbCell2));
    assertTrue(CellUtil.matchingQualifier(bbCell1, q1));
    assertTrue(CellUtil.matchingQualifier(bbCell2, q2));
    assertTrue(CellUtil.matchingValue(bbCell1, bbCell2));
    assertTrue(CellUtil.matchingValue(kv, bbCell2));
    assertTrue(CellUtil.matchingValue(bbCell1, v));
    assertFalse(CellUtil.matchingColumn(bbCell1, bbCell2));
    assertTrue(CellUtil.matchingColumn(kv, bbCell2));
    assertTrue(CellUtil.matchingColumn(bbCell1, f, q1));
    assertTrue(CellUtil.matchingColumn(bbCell2, f, q2));
  }",Eager Test
"@Test
  public void testForceTrigger() throws InterruptedException {
    final int period = 100;
    final int delta = period / 10;
    final CountingChore chore = new CountingChore(""countingChore"", period);
    service.scheduleChore(chore);
    Thread.sleep(10 * period + delta);

    assertEquals(""10 periods have elapsed."", 11, chore.getCountOfChoreCalls());

    // Force five runs of the chore to occur, sleeping between triggers to ensure the
    // chore has time to run
    chore.triggerNow();
    Thread.sleep(delta);
    chore.triggerNow();
    Thread.sleep(delta);
    chore.triggerNow();
    Thread.sleep(delta);
    chore.triggerNow();
    Thread.sleep(delta);
    chore.triggerNow();
    Thread.sleep(delta);

    assertEquals(""Trigger was called 5 times after 10 periods."", 16, chore.getCountOfChoreCalls());

    Thread.sleep(10 * period + delta);

    // Be loosey-goosey. It used to be '26' but it was a big flakey relying on timing.
    assertTrue(""Expected at least 16 invocations, instead got "" + chore.getCountOfChoreCalls(),
      chore.getCountOfChoreCalls() > 16);
  }",Eager Test
"@Test
  public void testScheduledChoreConstruction() {
    final String NAME = ""chore"";
    final int PERIOD = 100;
    final long VALID_DELAY = 0;
    final long INVALID_DELAY = -100;
    final TimeUnit UNIT = TimeUnit.NANOSECONDS;

    ScheduledChore chore1 =
      new ScheduledChore(NAME, new SampleStopper(), PERIOD, VALID_DELAY, UNIT) {
        @Override
        protected void chore() {
          // DO NOTHING
        }",Eager Test
"@Test
  public void testClassFinderFiltersByPathInDirs() throws Exception {
    final String hardcodedThisSubdir = ""hbase-common"";
    final ClassFinder.ResourcePathFilter notExcJarFilter =
      (resourcePath, isJar) -> isJar || !resourcePath.contains(hardcodedThisSubdir);
    String thisPackage = this.getClass().getPackage().getName();
    ClassFinder notThisClassFinder = new ClassFinder(notExcJarFilter, null, null, classLoader);
    Set<Class<?>> notAllClasses = notThisClassFinder.findClasses(thisPackage, false);
    assertFalse(notAllClasses.contains(this.getClass()));
  }",Eager Test
"@Test
  public void testClassFinderHandlesNestedPackages() throws Exception {
    final String NESTED = "".nested"";
    final String CLASSNAME1 = name.getMethodName() + ""1"";
    final String CLASSNAME2 = name.getMethodName() + ""2"";
    long counter = testCounter.incrementAndGet();
    FileAndPath c1 = compileTestClass(counter, """", ""c1"");
    FileAndPath c2 = compileTestClass(counter, NESTED, CLASSNAME1);
    FileAndPath c3 = compileTestClass(counter, NESTED, CLASSNAME2);
    packageAndLoadJar(c1, c2);
    packageAndLoadJar(c3);

    ClassFinder allClassesFinder = new ClassFinder(classLoader);
    Set<Class<?>> nestedClasses =
      allClassesFinder.findClasses(makePackageName(NESTED, counter), false);
    assertEquals(2, nestedClasses.size());
    Class<?> nestedClass1 = makeClass(NESTED, CLASSNAME1, counter);
    assertTrue(nestedClasses.contains(nestedClass1));
    Class<?> nestedClass2 = makeClass(NESTED, CLASSNAME2, counter);
    assertTrue(nestedClasses.contains(nestedClass2));
  }",Eager Test
"@Test
  public void testLaterConfigsOverrideEarlier() {
    Map<String, String> map1 = new HashMap<>();
    map1.put(""A"", ""2"");
    map1.put(""D"", ""5"");
    Map<String, String> map2 = new HashMap<>();
    String newValueForA = ""3"", newValueForB = ""4"";
    map2.put(""A"", newValueForA);
    map2.put(""B"", newValueForB);

    CompoundConfiguration compoundConf =
      new CompoundConfiguration().addStringMap(map1).add(baseConf);
    assertEquals(""1"", compoundConf.get(""A""));
    assertEquals(""5"", compoundConf.get(""D""));
    compoundConf.addStringMap(map2);
    assertEquals(newValueForA, compoundConf.get(""A""));
    assertEquals(newValueForB, compoundConf.get(""B""));
    assertEquals(""5"", compoundConf.get(""D""));

    int cnt = 0;
    for (Map.Entry<String, String> entry : compoundConf) {
      cnt++;
      if (entry.getKey().equals(""A"")) {
        assertEquals(newValueForA, entry.getValue());
      }",Eager Test
"@Test
  public void testPut() {
    CompoundConfiguration compoundConf = new CompoundConfiguration().add(baseConf);
    assertEquals(""1"", compoundConf.get(""A""));
    assertEquals(2, compoundConf.getInt(""B"", 0));
    assertEquals(3, compoundConf.getInt(""C"", 0));
    assertEquals(0, compoundConf.getInt(""D"", 0));

    compoundConf.set(""A"", ""1337"");
    compoundConf.set(""string"", ""stringvalue"");
    assertEquals(1337, compoundConf.getInt(""A"", 0));
    assertEquals(""stringvalue"", compoundConf.get(""string""));

    // we didn't modify the base conf
    assertEquals(""1"", baseConf.get(""A""));
    assertNull(baseConf.get(""string""));

    // adding to the base shows up in the compound
    baseConf.set(""setInParent"", ""fromParent"");
    assertEquals(""fromParent"", compoundConf.get(""setInParent""));
  }",No Smells
"@Test
  public void testWithConfig() {
    Configuration conf = new Configuration();
    conf.set(""B"", ""2b"");
    conf.set(""C"", ""33"");
    conf.set(""D"", ""4"");

    CompoundConfiguration compoundConf = new CompoundConfiguration().add(baseConf).add(conf);
    assertEquals(""1"", compoundConf.get(""A""));
    assertEquals(""2b"", compoundConf.get(""B""));
    assertEquals(33, compoundConf.getInt(""C"", 0));
    assertEquals(""4"", compoundConf.get(""D""));
    assertEquals(4, compoundConf.getInt(""D"", 0));
    assertNull(compoundConf.get(""E""));
    assertEquals(6, compoundConf.getInt(""F"", 6));

    int cnt = 0;
    for (Map.Entry<String, String> entry : compoundConf) {
      cnt++;
      if (entry.getKey().equals(""B"")) {
        assertEquals(""2b"", entry.getValue());
      }",Eager Test
"@Test
  public void testWithIbwMap() {
    Map<Bytes, Bytes> map = new HashMap<>();
    map.put(strToIb(""B""), strToIb(""2b""));
    map.put(strToIb(""C""), strToIb(""33""));
    map.put(strToIb(""D""), strToIb(""4""));
    // unlike config, note that IBW Maps can accept null values
    map.put(strToIb(""G""), null);

    CompoundConfiguration compoundConf = new CompoundConfiguration().add(baseConf).addBytesMap(map);
    assertEquals(""1"", compoundConf.get(""A""));
    assertEquals(""2b"", compoundConf.get(""B""));
    assertEquals(33, compoundConf.getInt(""C"", 0));
    assertEquals(""4"", compoundConf.get(""D""));
    assertEquals(4, compoundConf.getInt(""D"", 0));
    assertNull(compoundConf.get(""E""));
    assertEquals(6, compoundConf.getInt(""F"", 6));
    assertNull(compoundConf.get(""G""));

    int cnt = 0;
    for (Map.Entry<String, String> entry : compoundConf) {
      cnt++;
      if (entry.getKey().equals(""B"")) {
        assertEquals(""2b"", entry.getValue());
      }",Eager Test
"@Test
  public void testStart() throws Exception {
    JMXConnector connector =
      JMXConnectorFactory.connect(JMXListener.buildJMXServiceURL(CONNECTOR_PORT, CONNECTOR_PORT));

    MBeanServerConnection mb = connector.getMBeanServerConnection();
    String domain = mb.getDefaultDomain();
    Assert.assertTrue(""default domain is not correct"", !domain.isEmpty());
    connector.close();

  }",Eager Test + Mystery Guest
"@Test
  public void testBasics() {
    LOG.info(""LOWKEY: "" + KeyValue.LOWESTKEY.toString());
    String name = ""testBasics"";
    check(Bytes.toBytes(name), Bytes.toBytes(name), Bytes.toBytes(name), 1, Bytes.toBytes(name));
    // Test empty value and empty column -- both should work. (not empty fam)
    check(Bytes.toBytes(name), Bytes.toBytes(name), null, 1, null);
    check(HConstants.EMPTY_BYTE_ARRAY, Bytes.toBytes(name), null, 1, null);
    // empty qual is equivalent to null qual
    assertEquals(new KeyValue(Bytes.toBytes(""rk""), Bytes.toBytes(""fam""), null, 1, (byte[]) null),
      new KeyValue(Bytes.toBytes(""rk""), Bytes.toBytes(""fam""), HConstants.EMPTY_BYTE_ARRAY, 1,
        (byte[]) null));
  }",Eager Test
"@Test
  public void testBinaryKeys() {
    Set<KeyValue> set = new TreeSet<>(CellComparatorImpl.COMPARATOR);
    final byte[] fam = Bytes.toBytes(""col"");
    final byte[] qf = Bytes.toBytes(""umn"");
    final byte[] nb = new byte[0];
    KeyValue[] keys = { new KeyValue(Bytes.toBytes(""aaaaa,\u0000\u0000,2""), fam, qf, 2, nb),
      new KeyValue(Bytes.toBytes(""aaaaa,\u0001,3""), fam, qf, 3, nb),
      new KeyValue(Bytes.toBytes(""aaaaa,,1""), fam, qf, 1, nb),
      new KeyValue(Bytes.toBytes(""aaaaa,\u1000,5""), fam, qf, 5, nb),
      new KeyValue(Bytes.toBytes(""aaaaa,a,4""), fam, qf, 4, nb),
      new KeyValue(Bytes.toBytes(""a,a,0""), fam, qf, 0, nb), }",Eager Test
"@Test
  public void testColumnCompare_prefix() {
    final byte[] a = Bytes.toBytes(""aaa"");
    byte[] family1 = Bytes.toBytes(""abc"");
    byte[] qualifier1 = Bytes.toBytes(""def"");
    byte[] family2 = Bytes.toBytes(""ab"");
    byte[] qualifier2 = Bytes.toBytes(""def"");

    KeyValue aaa = new KeyValue(a, family1, qualifier1, 0L, KeyValue.Type.Put, a);
    assertFalse(CellUtil.matchingColumn(aaa, family2, qualifier2));
  }",Eager Test
"@Test
  public void testEqualsAndHashCode() {
    KeyValue kvA1 = new KeyValue(Bytes.toBytes(""key""), Bytes.toBytes(""cf""), Bytes.toBytes(""qualA""),
      Bytes.toBytes(""1""));
    KeyValue kvA2 = new KeyValue(Bytes.toBytes(""key""), Bytes.toBytes(""cf""), Bytes.toBytes(""qualA""),
      Bytes.toBytes(""2""));
    // We set a different sequence id on kvA2 to demonstrate that the equals and hashCode also
    // don't take this into account.
    kvA2.setSequenceId(2);
    KeyValue kvB = new KeyValue(Bytes.toBytes(""key""), Bytes.toBytes(""cf""), Bytes.toBytes(""qualB""),
      Bytes.toBytes(""1""));

    assertEquals(kvA1, kvA2);
    assertNotEquals(kvA1, kvB);
    assertEquals(kvA1.hashCode(), kvA2.hashCode());
    assertNotEquals(kvA1.hashCode(), kvB.hashCode());
  }",No Smells
"@Test
  public void testGetTimestamp() {
    KeyValue kv = new KeyValue(Bytes.toBytes(""myRow""), Bytes.toBytes(""myCF""),
      Bytes.toBytes(""myQualifier""), HConstants.LATEST_TIMESTAMP, Bytes.toBytes(""myValue""));
    long time1 = kv.getTimestamp();
    kv.updateLatestStamp(Bytes.toBytes(12345L));
    long time2 = kv.getTimestamp();
    assertEquals(HConstants.LATEST_TIMESTAMP, time1);
    assertEquals(12345L, time2);
  }",No Smells
"@Test
  public void testKVsWithTags() {
    byte[] row = Bytes.toBytes(""myRow"");
    byte[] cf = Bytes.toBytes(""myCF"");
    byte[] q = Bytes.toBytes(""myQualifier"");
    byte[] value = Bytes.toBytes(""myValue"");
    byte[] metaValue1 = Bytes.toBytes(""metaValue1"");
    byte[] metaValue2 = Bytes.toBytes(""metaValue2"");
    KeyValue kv = new KeyValue(row, cf, q, HConstants.LATEST_TIMESTAMP, value, new Tag[] {
      new ArrayBackedTag((byte) 1, metaValue1), new ArrayBackedTag((byte) 2, metaValue2) }",Eager Test
"@Test
  public void testMetaComparatorTableKeysWithCommaOk() {
    CellComparator c = MetaCellComparator.META_COMPARATOR;
    long now = EnvironmentEdgeManager.currentTime();
    // meta keys values are not quite right. A users can enter illegal values
    // from shell when scanning meta.
    KeyValue a = new KeyValue(Bytes.toBytes(""table,key,with,commas1,1234""), now);
    KeyValue b = new KeyValue(Bytes.toBytes(""table,key,with,commas2,0123""), now);
    assertTrue(c.compare(a, b) < 0);
  }",No Smells
"@Test
  public void testStackedUpKeyValue() {
    // Test multiple KeyValues in a single blob.

    // TODO actually write this test!
  }",No Smells
"@Test
  public void testMetaLocationForRegionReplicasIsAddedAtTableCreation() throws IOException {
    long regionId = EnvironmentEdgeManager.currentTime();
    RegionInfo primary = RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName()))
      .setStartKey(HConstants.EMPTY_START_ROW).setEndKey(HConstants.EMPTY_END_ROW).setSplit(false)
      .setRegionId(regionId).setReplicaId(0).build();

    Table meta = MetaTableAccessor.getMetaHTable(connection);
    try {
      List<RegionInfo> regionInfos = Lists.newArrayList(primary);
      MetaTableAccessor.addRegionsToMeta(connection, regionInfos, 3);

      assertEmptyMetaLocation(meta, primary.getRegionName(), 1);
      assertEmptyMetaLocation(meta, primary.getRegionName(), 2);
    }",Eager Test
"@Test
  public void testParseOptsMultiPuts() {
    Queue<String> opts = new LinkedList<>();
    String cmdName = ""sequentialWrite"";
    opts.offer(""--multiPut=10"");
    opts.offer(cmdName);
    opts.offer(""64"");
    PerformanceEvaluation.TestOptions options = null;
    try {
      options = PerformanceEvaluation.parseOpts(opts);
      fail(""should fail"");
    }",Eager Test
"@Test
  public void testParseOptsWrongThreads() {
    Queue<String> opts = new LinkedList<>();
    String cmdName = ""sequentialWrite"";
    opts.offer(cmdName);
    opts.offer(""qq"");
    try {
      PerformanceEvaluation.parseOpts(opts);
    }",Eager Test
"@Test
  public void testSerialization() {
    PerformanceEvaluation.TestOptions options = new PerformanceEvaluation.TestOptions();
    assertFalse(options.isAutoFlush());
    options.setAutoFlush(true);
    Gson gson = GsonUtil.createGson().create();
    String optionsString = gson.toJson(options);
    PerformanceEvaluation.TestOptions optionsDeserialized =
      gson.fromJson(optionsString, PerformanceEvaluation.TestOptions.class);
    assertTrue(optionsDeserialized.isAutoFlush());
  }",Eager Test
"@Test
  public void testRegionLoadAggregation() {
    ServerMetrics metrics = ServerMetricsBuilder
      .toServerMetrics(ServerName.valueOf(""localhost,1,1""), createServerLoadProto());
    assertEquals(13,
      metrics.getRegionMetrics().values().stream().mapToInt(v -> v.getStoreCount()).sum());
    assertEquals(114,
      metrics.getRegionMetrics().values().stream().mapToInt(v -> v.getStoreFileCount()).sum());
    assertEquals(129, metrics.getRegionMetrics().values().stream()
      .mapToDouble(v -> v.getUncompressedStoreFileSize().get(Size.Unit.MEGABYTE)).sum(), 0);
    assertEquals(504, metrics.getRegionMetrics().values().stream()
      .mapToDouble(v -> v.getStoreFileRootLevelIndexSize().get(Size.Unit.KILOBYTE)).sum(), 0);
    assertEquals(820, metrics.getRegionMetrics().values().stream()
      .mapToDouble(v -> v.getStoreFileSize().get(Size.Unit.MEGABYTE)).sum(), 0);
    assertEquals(82, metrics.getRegionMetrics().values().stream()
      .mapToDouble(v -> v.getStoreFileIndexSize().get(Size.Unit.KILOBYTE)).sum(), 0);
    assertEquals(((long) Integer.MAX_VALUE) * 2,
      metrics.getRegionMetrics().values().stream().mapToLong(v -> v.getReadRequestCount()).sum());
    assertEquals(100,
      metrics.getRegionMetrics().values().stream().mapToLong(v -> v.getCpRequestCount()).sum());
    assertEquals(300, metrics.getRegionMetrics().values().stream()
      .mapToLong(v -> v.getFilteredReadRequestCount()).sum());
    assertEquals(2, metrics.getRegionMetrics().values().stream()
      .mapToLong(v -> (long) v.getCurrentRegionCachedRatio()).count());
    assertEquals(150, metrics.getRegionMetrics().values().stream()
      .mapToDouble(v -> v.getRegionSizeMB().get(Size.Unit.MEGABYTE)).sum(), 0);
  }",Eager Test
"@Test
  public void testMergeLocations() {
    RegionLocations list1, list2;

    // test merge empty lists
    list1 = new RegionLocations();
    list2 = new RegionLocations();

    assertTrue(list1 == list1.mergeLocations(list2));

    // test merge non-empty and empty
    list2 = hrll(hrl(info0, sn0));
    list1 = list1.mergeLocations(list2);
    assertEquals(sn0, list1.getRegionLocation(0).getServerName());

    // test merge empty and non empty
    list1 = hrll();
    list1 = list2.mergeLocations(list1);
    assertEquals(sn0, list1.getRegionLocation(0).getServerName());

    // test merge non intersecting
    list1 = hrll(hrl(info0, sn0), hrl(info1, sn1));
    list2 = hrll(hrl(info2, sn2));
    list1 = list2.mergeLocations(list1);
    assertEquals(sn0, list1.getRegionLocation(0).getServerName());
    assertEquals(sn1, list1.getRegionLocation(1).getServerName());
    assertEquals(2, list1.size()); // the size is taken from the argument list to merge

    // do the other way merge as well
    list1 = hrll(hrl(info0, sn0), hrl(info1, sn1));
    list2 = hrll(hrl(info2, sn2));
    list1 = list1.mergeLocations(list2);
    assertEquals(sn0, list1.getRegionLocation(0).getServerName());
    assertEquals(sn1, list1.getRegionLocation(1).getServerName());
    assertEquals(sn2, list1.getRegionLocation(2).getServerName());

    // test intersecting lists same seqNum
    list1 = hrll(hrl(info0, sn0), hrl(info1, sn1));
    list2 = hrll(hrl(info0, sn2), hrl(info1, sn2), hrl(info9, sn3));
    list1 = list2.mergeLocations(list1); // list1 should override
    assertEquals(2, list1.size());
    assertEquals(sn0, list1.getRegionLocation(0).getServerName());
    assertEquals(sn1, list1.getRegionLocation(1).getServerName());

    // do the other way
    list1 = hrll(hrl(info0, sn0), hrl(info1, sn1));
    list2 = hrll(hrl(info0, sn2), hrl(info1, sn2), hrl(info9, sn3));
    list1 = list1.mergeLocations(list2); // list2 should override
    assertEquals(10, list1.size());
    assertEquals(sn2, list1.getRegionLocation(0).getServerName());
    assertEquals(sn2, list1.getRegionLocation(1).getServerName());
    assertEquals(sn3, list1.getRegionLocation(9).getServerName());

    // test intersecting lists different seqNum
    list1 = hrll(hrl(info0, sn0, 10), hrl(info1, sn1, 10));
    list2 = hrll(hrl(info0, sn2, 11), hrl(info1, sn2, 11), hrl(info9, sn3, 11));
    list1 = list1.mergeLocations(list2); // list2 should override because of seqNum
    assertEquals(10, list1.size());
    assertEquals(sn2, list1.getRegionLocation(0).getServerName());
    assertEquals(sn2, list1.getRegionLocation(1).getServerName());
    assertEquals(sn3, list1.getRegionLocation(9).getServerName());

    // do the other way
    list1 = hrll(hrl(info0, sn0, 10), hrl(info1, sn1, 10));
    list2 = hrll(hrl(info0, sn2, 11), hrl(info1, sn2, 11), hrl(info9, sn3, 11));
    list1 = list1.mergeLocations(list2); // list2 should override
    assertEquals(10, list1.size());
    assertEquals(sn2, list1.getRegionLocation(0).getServerName());
    assertEquals(sn2, list1.getRegionLocation(1).getServerName());
    assertEquals(sn3, list1.getRegionLocation(9).getServerName());
  }",Eager Test
"@Test
  public void testUpdateLocation() {
    RegionLocations list;

    // test add to empty list
    list = new RegionLocations();
    list = list.updateLocation(hrl(info0, sn1), false, false);
    assertEquals(sn1, list.getRegionLocation(0).getServerName());

    // test add to non-empty list
    list = list.updateLocation(hrl(info9, sn3, 10), false, false);
    assertEquals(sn3, list.getRegionLocation(9).getServerName());
    assertEquals(10, list.size());
    list = list.updateLocation(hrl(info2, sn2, 10), false, false);
    assertEquals(sn2, list.getRegionLocation(2).getServerName());
    assertEquals(10, list.size());

    // test update greater SeqNum
    list = list.updateLocation(hrl(info2, sn3, 11), false, false);
    assertEquals(sn3, list.getRegionLocation(2).getServerName());
    assertEquals(sn3, list.getRegionLocation(9).getServerName());

    // test update equal SeqNum
    list = list.updateLocation(hrl(info2, sn1, 11), false, false); // should not update
    assertEquals(sn3, list.getRegionLocation(2).getServerName());
    assertEquals(sn3, list.getRegionLocation(9).getServerName());
    list = list.updateLocation(hrl(info2, sn1, 11), true, false); // should update
    assertEquals(sn1, list.getRegionLocation(2).getServerName());
    assertEquals(sn3, list.getRegionLocation(9).getServerName());

    // test force update
    list = list.updateLocation(hrl(info2, sn2, 9), false, true); // should update
    assertEquals(sn2, list.getRegionLocation(2).getServerName());
    assertEquals(sn3, list.getRegionLocation(9).getServerName());
  }",Eager Test
"@Test
  public void testRegionLoadWrapAroundAggregation() {
    ServerMetrics metrics = ServerMetricsBuilder
      .toServerMetrics(ServerName.valueOf(""localhost,1,1""), createServerLoadProto());
    long totalCount = ((long) Integer.MAX_VALUE) * 2;
    assertEquals(totalCount,
      metrics.getRegionMetrics().values().stream().mapToLong(v -> v.getReadRequestCount()).sum());
    assertEquals(totalCount,
      metrics.getRegionMetrics().values().stream().mapToLong(v -> v.getWriteRequestCount()).sum());
  }",No Smells
"@Test
  public void testHash() {
    ServerName sn1 = ServerName.parseServerName(""asf903.gq1.ygridcore.net,52690,1517835491385"");
    ServerName sn2 = ServerName.parseServerName(""asf903.gq1.ygridcore.net,42231,1517835491329"");
    Set<ServerName> sns = new HashSet<>();
    sns.add(sn2);
    sns.add(sn1);
    sns.add(sn1);
    assertEquals(2, sns.size());
  }",No Smells
"@Test
  public void testCarryForwardTTLTag() throws Exception {
    // No tags so far and the TTL tag must get added to the Tags list
    long ttl = 10 * 1000;
    List<Tag> tags = TagUtil.carryForwardTTLTag(null, ttl);
    assertEquals(1, tags.size());
    Tag ttlTag = tags.get(0);
    assertEquals(TagType.TTL_TAG_TYPE, ttlTag.getType());
    assertEquals(ttl, Tag.getValueAsLong(ttlTag));
    // Already having a TTL tag in the list. So the call must remove the old tag
    long ttl2 = 30 * 1000;
    tags = TagUtil.carryForwardTTLTag(tags, ttl2);
    assertEquals(1, tags.size());
    ttlTag = tags.get(0);
    assertEquals(TagType.TTL_TAG_TYPE, ttlTag.getType());
    assertEquals(ttl2, Tag.getValueAsLong(ttlTag));
  }",Eager Test
"@Test
  public void testAll() throws Exception {
    // Run all tests
    doTestTableCreateDrop();
    doTestThriftMetrics();
    doTestTableMutations();
    doTestTableTimestampsAndColumns();
    doTestTableScanners();
    doTestGetTableRegions();
    doTestFilterRegistration();
    doTestGetRegionInfo();
    doTestIncrements();
    doTestAppend();
    doTestCheckAndPut();
  }",No Smells
"@Test
  public void testAll() throws Exception {
    // Run all tests
    doTestTableCreateDrop();
    doTestThriftMetrics();
    doTestTableMutations();
    doTestTableTimestampsAndColumns();
    doTestTableScanners();
    doTestGetTableRegions();
    doTestFilterRegistration();
    doTestGetRegionInfo();
    doTestIncrements();
    doTestAppend();
    doTestCheckAndPut();
  }",No Smells
"@Test
  public void testAppend() throws Exception {
    ThriftHBaseServiceHandler handler = createHandler();
    byte[] rowName = Bytes.toBytes(""testAppend"");
    ByteBuffer table = wrap(tableAname);
    byte[] v1 = Bytes.toBytes(""42"");
    byte[] v2 = Bytes.toBytes(""23"");
    List<TColumnValue> columnValues = new ArrayList<>(1);
    columnValues.add(new TColumnValue(wrap(familyAname), wrap(qualifierAname), wrap(v1)));
    TPut put = new TPut(wrap(rowName), columnValues);
    put.setColumnValues(columnValues);
    handler.put(table, put);

    List<TColumnValue> appendColumns = new ArrayList<>(1);
    appendColumns.add(new TColumnValue(wrap(familyAname), wrap(qualifierAname), wrap(v2)));
    TAppend append = new TAppend(wrap(rowName), appendColumns);
    handler.append(table, append);

    TGet get = new TGet(wrap(rowName));
    TResult result = handler.get(table, get);

    assertArrayEquals(rowName, result.getRow());
    assertEquals(1, result.getColumnValuesSize());
    TColumnValue columnValue = result.getColumnValues().get(0);
    assertArrayEquals(Bytes.add(v1, v2), columnValue.getValue());
  }",Eager Test
"@Test
  public void testAttribute() throws Exception {
    byte[] rowName = Bytes.toBytes(""testAttribute"");
    byte[] attributeKey = Bytes.toBytes(""attribute1"");
    byte[] attributeValue = Bytes.toBytes(""value1"");
    Map<ByteBuffer, ByteBuffer> attributes = new HashMap<>();
    attributes.put(wrap(attributeKey), wrap(attributeValue));

    TGet tGet = new TGet(wrap(rowName));
    tGet.setAttributes(attributes);
    Get get = getFromThrift(tGet);
    assertArrayEquals(get.getAttribute(""attribute1""), attributeValue);

    List<TColumnValue> columnValues = new ArrayList<>(1);
    columnValues.add(new TColumnValue(wrap(familyAname), wrap(qualifierAname), wrap(valueAname)));
    TPut tPut = new TPut(wrap(rowName), columnValues);
    tPut.setAttributes(attributes);
    Put put = putFromThrift(tPut);
    assertArrayEquals(put.getAttribute(""attribute1""), attributeValue);

    TScan tScan = new TScan();
    tScan.setAttributes(attributes);
    Scan scan = scanFromThrift(tScan);
    assertArrayEquals(scan.getAttribute(""attribute1""), attributeValue);

    List<TColumnIncrement> incrementColumns = new ArrayList<>(1);
    incrementColumns.add(new TColumnIncrement(wrap(familyAname), wrap(qualifierAname)));
    TIncrement tIncrement = new TIncrement(wrap(rowName), incrementColumns);
    tIncrement.setAttributes(attributes);
    Increment increment = incrementFromThrift(tIncrement);
    assertArrayEquals(increment.getAttribute(""attribute1""), attributeValue);

    TDelete tDelete = new TDelete(wrap(rowName));
    tDelete.setAttributes(attributes);
    Delete delete = deleteFromThrift(tDelete);
    assertArrayEquals(delete.getAttribute(""attribute1""), attributeValue);
  }",Eager Test
"@Test
  public void testConsistency() throws Exception {
    byte[] rowName = Bytes.toBytes(""testConsistency"");
    TGet tGet = new TGet(wrap(rowName));
    tGet.setConsistency(TConsistency.STRONG);
    Get get = getFromThrift(tGet);
    assertEquals(Consistency.STRONG, get.getConsistency());

    tGet.setConsistency(TConsistency.TIMELINE);
    tGet.setTargetReplicaId(1);
    get = getFromThrift(tGet);
    assertEquals(Consistency.TIMELINE, get.getConsistency());
    assertEquals(1, get.getReplicaId());

    TScan tScan = new TScan();
    tScan.setConsistency(TConsistency.STRONG);
    Scan scan = scanFromThrift(tScan);
    assertEquals(Consistency.STRONG, scan.getConsistency());

    tScan.setConsistency(TConsistency.TIMELINE);
    tScan.setTargetReplicaId(1);
    scan = scanFromThrift(tScan);
    assertEquals(Consistency.TIMELINE, scan.getConsistency());
    assertEquals(1, scan.getReplicaId());

    TResult tResult = new TResult();
    assertFalse(tResult.isSetStale());
    tResult.setStale(true);
    assertTrue(tResult.isSetStale());
  }",Eager Test
"@Test
  public void testDeleteAllTimestamps() throws Exception {
    ThriftHBaseServiceHandler handler = createHandler();
    byte[] rowName = Bytes.toBytes(""testDeleteAllTimestamps"");
    ByteBuffer table = wrap(tableAname);

    List<TColumnValue> columnValues = new ArrayList<>(1);
    TColumnValue columnValueA =
      new TColumnValue(wrap(familyAname), wrap(qualifierAname), wrap(valueAname));
    columnValueA.setTimestamp(EnvironmentEdgeManager.currentTime() - 10);
    columnValues.add(columnValueA);
    TPut put = new TPut(wrap(rowName), columnValues);

    put.setColumnValues(columnValues);

    handler.put(table, put);
    columnValueA.setTimestamp(EnvironmentEdgeManager.currentTime());
    handler.put(table, put);

    TGet get = new TGet(wrap(rowName));
    get.setMaxVersions(2);
    TResult result = handler.get(table, get);
    assertEquals(2, result.getColumnValuesSize());

    TDelete delete = new TDelete(wrap(rowName));
    List<TColumn> deleteColumns = new ArrayList<>(1);
    TColumn deleteColumn = new TColumn(wrap(familyAname));
    deleteColumn.setQualifier(qualifierAname);
    deleteColumns.add(deleteColumn);
    delete.setColumns(deleteColumns);
    delete.setDeleteType(TDeleteType.DELETE_COLUMNS); // This is the default anyway.

    handler.deleteSingle(table, delete);

    get = new TGet(wrap(rowName));
    result = handler.get(table, get);
    assertNull(result.getRow());
    assertEquals(0, result.getColumnValuesSize());
  }",Eager Test
"@Test
  public void testDeleteMultiple() throws Exception {
    ThriftHBaseServiceHandler handler = createHandler();
    ByteBuffer table = wrap(tableAname);
    byte[] rowName1 = Bytes.toBytes(""testDeleteMultiple1"");
    byte[] rowName2 = Bytes.toBytes(""testDeleteMultiple2"");

    List<TColumnValue> columnValues = new ArrayList<>(2);
    columnValues.add(new TColumnValue(wrap(familyAname), wrap(qualifierAname), wrap(valueAname)));
    columnValues.add(new TColumnValue(wrap(familyBname), wrap(qualifierBname), wrap(valueBname)));
    List<TPut> puts = new ArrayList<>(2);
    puts.add(new TPut(wrap(rowName1), columnValues));
    puts.add(new TPut(wrap(rowName2), columnValues));

    handler.putMultiple(table, puts);

    List<TDelete> deletes = new ArrayList<>(2);
    deletes.add(new TDelete(wrap(rowName1)));
    deletes.add(new TDelete(wrap(rowName2)));

    List<TDelete> deleteResults = handler.deleteMultiple(table, deletes);
    // 0 means they were all successfully applies
    assertEquals(0, deleteResults.size());

    assertFalse(handler.exists(table, new TGet(wrap(rowName1))));
    assertFalse(handler.exists(table, new TGet(wrap(rowName2))));
  }",Eager Test
"@Test
  public void testIncrement() throws Exception {
    ThriftHBaseServiceHandler handler = createHandler();
    byte[] rowName = Bytes.toBytes(""testIncrement"");
    ByteBuffer table = wrap(tableAname);

    List<TColumnValue> columnValues = new ArrayList<>(1);
    columnValues
      .add(new TColumnValue(wrap(familyAname), wrap(qualifierAname), wrap(Bytes.toBytes(1L))));
    TPut put = new TPut(wrap(rowName), columnValues);
    put.setColumnValues(columnValues);
    handler.put(table, put);

    List<TColumnIncrement> incrementColumns = new ArrayList<>(1);
    incrementColumns.add(new TColumnIncrement(wrap(familyAname), wrap(qualifierAname)));
    TIncrement increment = new TIncrement(wrap(rowName), incrementColumns);
    handler.increment(table, increment);

    TGet get = new TGet(wrap(rowName));
    TResult result = handler.get(table, get);

    assertArrayEquals(rowName, result.getRow());
    assertEquals(1, result.getColumnValuesSize());
    TColumnValue columnValue = result.getColumnValues().get(0);
    assertArrayEquals(Bytes.toBytes(2L), columnValue.getValue());
  }",Eager Test
"@Test
  public void testMetrics() throws Exception {
    Configuration conf = UTIL.getConfiguration();
    ThriftMetrics metrics = getMetrics(conf);
    ThriftHBaseServiceHandler hbaseHandler = createHandler();
    THBaseService.Iface handler = HbaseHandlerMetricsProxy.newInstance(hbaseHandler, metrics, conf);
    byte[] rowName = Bytes.toBytes(""testMetrics"");
    ByteBuffer table = wrap(tableAname);

    TGet get = new TGet(wrap(rowName));
    assertFalse(handler.exists(table, get));

    List<TColumnValue> columnValues = new ArrayList<>(2);
    columnValues.add(new TColumnValue(wrap(familyAname), wrap(qualifierAname), wrap(valueAname)));
    columnValues.add(new TColumnValue(wrap(familyBname), wrap(qualifierBname), wrap(valueBname)));
    TPut put = new TPut(wrap(rowName), columnValues);
    put.setColumnValues(columnValues);

    handler.put(table, put);

    assertTrue(handler.exists(table, get));
    metricsHelper.assertCounter(""put_num_ops"", 1, metrics.getSource());
    metricsHelper.assertCounter(""exists_num_ops"", 2, metrics.getSource());
  }",Eager Test
"@Test
  public void testMetricsWithException() throws Exception {
    byte[] rowkey = Bytes.toBytes(""row1"");
    byte[] family = Bytes.toBytes(""f"");
    byte[] col = Bytes.toBytes(""c"");
    // create a table which will throw exceptions for requests
    TableName tableName = TableName.valueOf(name.getMethodName());
    TableDescriptor tableDesc = TableDescriptorBuilder.newBuilder(tableName)
      .setCoprocessor(ErrorThrowingGetObserver.class.getName())
      .setColumnFamily(ColumnFamilyDescriptorBuilder.of(family)).build();

    Table table = UTIL.createTable(tableDesc, null);
    table.put(new Put(rowkey).addColumn(family, col, Bytes.toBytes(""val1"")));

    ThriftHBaseServiceHandler hbaseHandler = createHandler();
    ThriftMetrics metrics = getMetrics(UTIL.getConfiguration());
    THBaseService.Iface handler = HbaseHandlerMetricsProxy.newInstance(hbaseHandler, metrics, null);
    ByteBuffer tTableName = wrap(tableName.getName());

    // check metrics increment with a successful get
    long preGetCounter = metricsHelper.checkCounterExists(""get_num_ops"", metrics.getSource())
      ? metricsHelper.getCounter(""get_num_ops"", metrics.getSource())
      : 0;
    TGet tGet = new TGet(wrap(rowkey));
    TResult tResult = handler.get(tTableName, tGet);

    List<TColumnValue> expectedColumnValues =
      Lists.newArrayList(new TColumnValue(wrap(family), wrap(col), wrap(Bytes.toBytes(""val1""))));
    assertArrayEquals(rowkey, tResult.getRow());
    List<TColumnValue> returnedColumnValues = tResult.getColumnValues();
    assertTColumnValuesEqual(expectedColumnValues, returnedColumnValues);

    metricsHelper.assertCounter(""get_num_ops"", preGetCounter + 1, metrics.getSource());

    // check metrics increment when the get throws each exception type
    for (ErrorThrowingGetObserver.ErrorType type : ErrorThrowingGetObserver.ErrorType.values()) {
      testExceptionType(handler, metrics, tTableName, rowkey, type);
    }",Eager Test
"@Test
  public void testMutateRow() throws Exception {
    ThriftHBaseServiceHandler handler = createHandler();
    byte[] rowName = Bytes.toBytes(""testMutateRow"");
    ByteBuffer table = wrap(tableAname);

    List<TColumnValue> columnValuesA = new ArrayList<>(1);
    TColumnValue columnValueA =
      new TColumnValue(wrap(familyAname), wrap(qualifierAname), wrap(valueAname));
    columnValuesA.add(columnValueA);
    TPut putA = new TPut(wrap(rowName), columnValuesA);
    putA.setColumnValues(columnValuesA);

    handler.put(table, putA);

    TGet get = new TGet(wrap(rowName));
    TResult result = handler.get(table, get);
    assertArrayEquals(rowName, result.getRow());
    List<TColumnValue> returnedColumnValues = result.getColumnValues();

    List<TColumnValue> expectedColumnValues = new ArrayList<>(1);
    expectedColumnValues.add(columnValueA);
    assertTColumnValuesEqual(expectedColumnValues, returnedColumnValues);

    List<TColumnValue> columnValuesB = new ArrayList<>(1);
    TColumnValue columnValueB =
      new TColumnValue(wrap(familyAname), wrap(qualifierBname), wrap(valueBname));
    columnValuesB.add(columnValueB);
    TPut putB = new TPut(wrap(rowName), columnValuesB);
    putB.setColumnValues(columnValuesB);

    TDelete delete = new TDelete(wrap(rowName));
    List<TColumn> deleteColumns = new ArrayList<>(1);
    TColumn deleteColumn = new TColumn(wrap(familyAname));
    deleteColumn.setQualifier(qualifierAname);
    deleteColumns.add(deleteColumn);
    delete.setColumns(deleteColumns);

    List<TMutation> mutations = new ArrayList<>(2);
    TMutation mutationA = TMutation.put(putB);
    mutations.add(mutationA);

    TMutation mutationB = TMutation.deleteSingle(delete);
    mutations.add(mutationB);

    TRowMutations tRowMutations = new TRowMutations(wrap(rowName), mutations);
    handler.mutateRow(table, tRowMutations);

    result = handler.get(table, get);
    assertArrayEquals(rowName, result.getRow());
    returnedColumnValues = result.getColumnValues();

    expectedColumnValues = new ArrayList<>(1);
    expectedColumnValues.add(columnValueB);
    assertTColumnValuesEqual(expectedColumnValues, returnedColumnValues);
  }",Eager Test
"@Test
  public void testPutTTL() throws Exception {
    ThriftHBaseServiceHandler handler = createHandler();
    byte[] rowName = Bytes.toBytes(""testPutTTL"");
    ByteBuffer table = wrap(tableAname);
    List<TColumnValue> columnValues = new ArrayList<>(1);

    // Add some dummy data
    columnValues
      .add(new TColumnValue(wrap(familyAname), wrap(qualifierAname), wrap(Bytes.toBytes(1L))));

    TPut put = new TPut(wrap(rowName), columnValues);
    put.setColumnValues(columnValues);

    Map<ByteBuffer, ByteBuffer> attributes = new HashMap<>();

    // Time in ms for the kv's to live.
    long ttlTimeMs = 2000L;

    // the _ttl attribute is a number of ms ttl for key values in this put.
    attributes.put(wrap(Bytes.toBytes(""_ttl"")), wrap(Bytes.toBytes(ttlTimeMs)));
    // Attach the attributes
    put.setAttributes(attributes);
    // Send it.
    handler.put(table, put);

    // Now get the data back
    TGet getOne = new TGet(wrap(rowName));
    TResult resultOne = handler.get(table, getOne);

    // It's there.
    assertArrayEquals(rowName, resultOne.getRow());
    assertEquals(1, resultOne.getColumnValuesSize());

    // Sleep 30 seconds just to make 100% sure that the key value should be expired.
    Thread.sleep(ttlTimeMs * 15);

    TGet getTwo = new TGet(wrap(rowName));
    TResult resultTwo = handler.get(table, getTwo);

    // Nothing should be there since it's ttl'd out.
    assertNull(resultTwo.getRow());
    assertEquals(0, resultTwo.getColumnValuesSize());
  }",Eager Test
"@Test
  public void testNoSuchClass() throws IOException {
    List<CoprocessorViolation> violations = validateClass(""NoSuchClass"");
    assertEquals(1, violations.size());

    CoprocessorViolation violation = violations.get(0);
    assertEquals(getFullClassName(""NoSuchClass""), violation.getClassName());
    assertEquals(Severity.ERROR, violation.getSeverity());

    String stackTrace = Throwables.getStackTraceAsString(violation.getThrowable());
    assertTrue(stackTrace.contains(""java.lang.ClassNotFoundException: ""
      + ""org.apache.hadoop.hbase.tool.coprocessor.CoprocessorValidatorTest$NoSuchClass""));
  }",Eager Test
"@Test
  public void testEncodedLength() {
    PositionedByteRange buff = new SimplePositionedMutableByteRange(20);
    for (final DataType<String> type : new OrderedString[] { new OrderedString(Order.ASCENDING),
      new OrderedString(Order.DESCENDING) }",Eager Test
"@Test
  public void testSkipNonSkippable() {
    PositionedByteRange buff = new SimplePositionedMutableByteRange(12);
    for (Order ord : new Order[] { Order.ASCENDING, Order.DESCENDING }",Eager Test
"@Test
  public void testAllOptionsSet() throws Exception {
    String[] args = new String[] { ""--required=foo"", ""--optional=bar"", ""--boolean"" }",No Smells
"@Test
  public void testNewOptionOverridesOldOption() throws Exception {
    String[] args = new String[] { ""--required=foo"", ""--optional=baz"", ""-opt"", ""bar"", ""-bool"" }",No Smells
"@Test
  public void testOldOptionsWork() throws Exception {
    String[] args = new String[] { ""--required=foo"", ""-opt"", ""bar"", ""-bool"" }",No Smells
"@Test
  public void testIfWeHaveNewReferenceFilesButOldStoreFiles() throws Exception {
    // this tests that reference files that are new, but have older timestamps for the files
    // they reference still will get compacted.
    TableName tableName = TableName.valueOf(""TestMajorCompactor"");
    TableDescriptor htd = UTILITY.createTableDescriptor(tableName, Bytes.toBytes(FAMILY));
    RegionInfo hri = RegionInfoBuilder.newBuilder(htd.getTableName()).build();
    HRegion region =
      HBaseTestingUtil.createRegionAndWAL(hri, rootRegionDir, UTILITY.getConfiguration(), htd);

    Connection connection = mock(Connection.class);
    // the reference file timestamp is newer
    List<StoreFileInfo> storeFiles = mockStoreFiles(regionStoreDir, 4, 101);
    List<Path> paths = storeFiles.stream().map(StoreFileInfo::getPath).collect(Collectors.toList());
    // the files that are referenced are older, thus we still compact.
    HRegionFileSystem fileSystem = mockFileSystem(region.getRegionInfo(), true, storeFiles, 50);
    MajorCompactionRequest majorCompactionRequest =
      spy(new MajorCompactionRequest(connection, region.getRegionInfo(), Sets.newHashSet(FAMILY)));
    doReturn(paths).when(majorCompactionRequest).getReferenceFilePaths(any(FileSystem.class),
      any(Path.class));
    StoreFileTrackerForTest sft = mockSFT(true, storeFiles);
    doReturn(fileSystem).when(majorCompactionRequest).getFileSystem();
    doReturn(sft).when(majorCompactionRequest).getStoreFileTracker(any(), any());
    doReturn(UTILITY.getConfiguration()).when(connection).getConfiguration();
    Set<String> result =
      majorCompactionRequest.getStoresRequiringCompaction(Sets.newHashSet(""a""), 100);
    assertEquals(FAMILY, Iterables.getOnlyElement(result));
  }",Eager Test
"@Test
  public void testAvlTreeIterSeekTo() {
    final int MIN_KEY = 1;
    final int MAX_KEY = 50;

    TestAvlNode root = null;
    for (int i = MIN_KEY; i < MAX_KEY; i += 2) {
      root = AvlTree.insert(root, new TestAvlNode(i));
    }",Eager Test
"@Test
  public void testFoldableByteSize() {
    assertEquals(128, BloomFilterUtil.computeFoldableByteSize(1000, 5));
    assertEquals(640, BloomFilterUtil.computeFoldableByteSize(5001, 4));
  }",No Smells
"@Test
  public void testSizing() {
    int bitSize = 8 * 128 * 1024; // 128 KB
    double errorRate = 0.025; // target false positive rate

    // How many keys can we store in a Bloom filter of this size maintaining
    // the given false positive rate, not taking into account that the n
    long maxKeys = BloomFilterUtil.idealMaxKeys(bitSize, errorRate);
    assertEquals(136570, maxKeys);

    // A reverse operation: how many bits would we need to store this many keys
    // and keep the same low false positive rate?
    long bitSize2 = BloomFilterUtil.computeBitSize(maxKeys, errorRate);

    // The bit size comes out a little different due to rounding.
    assertTrue(Math.abs(bitSize2 - bitSize) * 1.0 / bitSize < 1e-5);
  }",Eager Test
"@Test
  public void testPollInExecutor() throws InterruptedException {
    final TestObject testObj = new TestObject(0, 0);

    final CyclicBarrier threadsStarted = new CyclicBarrier(2);
    ExecutorService executor = Executors.newFixedThreadPool(2);
    executor.execute(new Runnable() {
      @Override
      public void run() {
        try {
          assertNull(queue.poll(1000, TimeUnit.MILLISECONDS));
          threadsStarted.await();
          assertSame(testObj, queue.poll(1000, TimeUnit.MILLISECONDS));
          assertTrue(queue.isEmpty());
        }",Eager Test
"@Test
  public void testByteBufferCreation() throws Exception {
    int capacity = 470 * 1021 * 1023;
    ByteBufferArray array = new ByteBufferArray(capacity, ALLOC);
    assertEquals(118, array.buffers.length);
    for (int i = 0; i < array.buffers.length; i++) {
      assertEquals(ByteBufferArray.DEFAULT_BUFFER_SIZE, array.buffers[i].capacity());
    }",Eager Test
"@Test
  public void testByteBufferCreation1() throws Exception {
    long cap = 7 * 1024L * 1024L;
    int bufferSize = ByteBufferArray.getBufferSize(cap), bufferCount = 25;
    ByteBufferArray array = new ByteBufferArray(bufferSize, bufferCount, 16, cap, ALLOC);
    for (int i = 0; i < array.buffers.length; i++) {
      assertEquals(458752, array.buffers[i].capacity());
    }",Eager Test
"@Test
  public void testCompareTo() {
    ByteBuffer bb1 = ByteBuffer.allocate(135);
    ByteBuffer bb2 = ByteBuffer.allocate(135);
    byte[] b = new byte[71];
    fillBB(bb1, (byte) 5);
    fillBB(bb2, (byte) 5);
    fillArray(b, (byte) 5);
    assertEquals(0, ByteBufferUtils.compareTo(bb1, 0, bb1.remaining(), bb2, 0, bb2.remaining()));
    assertTrue(ByteBufferUtils.compareTo(bb1, 0, bb1.remaining(), b, 0, b.length) > 0);
    bb2.put(134, (byte) 6);
    assertTrue(ByteBufferUtils.compareTo(bb1, 0, bb1.remaining(), bb2, 0, bb2.remaining()) < 0);
    bb2.put(6, (byte) 4);
    assertTrue(ByteBufferUtils.compareTo(bb1, 0, bb1.remaining(), bb2, 0, bb2.remaining()) > 0);
    // Assert reverse comparing BB and bytearray works.
    ByteBuffer bb3 = ByteBuffer.allocate(135);
    fillBB(bb3, (byte) 0);
    byte[] b3 = new byte[135];
    fillArray(b3, (byte) 1);
    int result = ByteBufferUtils.compareTo(b3, 0, b3.length, bb3, 0, bb3.remaining());
    assertTrue(result > 0);
    result = ByteBufferUtils.compareTo(bb3, 0, bb3.remaining(), b3, 0, b3.length);
    assertTrue(result < 0);
    byte[] b4 = Bytes.toBytes(""123"");
    ByteBuffer bb4 = ByteBuffer.allocate(10 + b4.length);
    for (int i = 10; i < bb4.capacity(); ++i) {
      bb4.put(i, b4[i - 10]);
    }",Eager Test
"@Test
  public void testEquals() {
    byte[] a = Bytes.toBytes(""http://A"");
    ByteBuffer bb = ByteBuffer.wrap(a);

    assertTrue(ByteBufferUtils.equals(HConstants.EMPTY_BYTE_BUFFER, 0, 0,
      HConstants.EMPTY_BYTE_BUFFER, 0, 0));

    assertFalse(ByteBufferUtils.equals(HConstants.EMPTY_BYTE_BUFFER, 0, 0, bb, 0, a.length));

    assertFalse(ByteBufferUtils.equals(bb, 0, 0, HConstants.EMPTY_BYTE_BUFFER, 0, a.length));

    assertTrue(ByteBufferUtils.equals(bb, 0, a.length, bb, 0, a.length));

    assertTrue(ByteBufferUtils.equals(HConstants.EMPTY_BYTE_BUFFER, 0, 0,
      HConstants.EMPTY_BYTE_ARRAY, 0, 0));

    assertFalse(ByteBufferUtils.equals(HConstants.EMPTY_BYTE_BUFFER, 0, 0, a, 0, a.length));

    assertFalse(ByteBufferUtils.equals(bb, 0, a.length, HConstants.EMPTY_BYTE_ARRAY, 0, 0));

    assertTrue(ByteBufferUtils.equals(bb, 0, a.length, a, 0, a.length));
  }",No Smells
"@Test
  public void testPutInt() {
    testPutInt(0);
    testPutInt(Integer.MAX_VALUE);

    for (int i = 0; i < 3; i++) {
      testPutInt((128 << i) - 1);
    }",Eager Test
"@Test
  public void testRelativeCopyFromBuffertoBuffer() {
    ByteBuffer bb1 = ByteBuffer.allocate(135);
    ByteBuffer bb2 = ByteBuffer.allocate(135);
    fillBB(bb1, (byte) 5);
    ByteBufferUtils.copyFromBufferToBuffer(bb1, bb2);
    assertTrue(bb1.position() == bb2.position());
    assertTrue(bb1.limit() == bb2.limit());
    bb1 = ByteBuffer.allocateDirect(135);
    bb2 = ByteBuffer.allocateDirect(135);
    fillBB(bb1, (byte) 5);
    ByteBufferUtils.copyFromBufferToBuffer(bb1, bb2);
    assertTrue(bb1.position() == bb2.position());
    assertTrue(bb1.limit() == bb2.limit());
  }",Eager Test
"@Test
  public void testToPrimitiveTypes() {
    ByteBuffer buffer = ByteBuffer.allocate(15);
    long l = 988L;
    int i = 135;
    short s = 7;
    buffer.putLong(l);
    buffer.putShort(s);
    buffer.putInt(i);
    assertEquals(l, ByteBufferUtils.toLong(buffer, 0));
    assertEquals(s, ByteBufferUtils.toShort(buffer, 8));
    assertEquals(i, ByteBufferUtils.toInt(buffer, 10));
  }",Eager Test
"@Test
  public void testIncrementBytes() {
    assertTrue(checkTestIncrementBytes(10, 1));
    assertTrue(checkTestIncrementBytes(12, 123435445));
    assertTrue(checkTestIncrementBytes(124634654, 1));
    assertTrue(checkTestIncrementBytes(10005460, 5005645));
    assertTrue(checkTestIncrementBytes(1, -1));
    assertTrue(checkTestIncrementBytes(10, -1));
    assertTrue(checkTestIncrementBytes(10, -5));
    assertTrue(checkTestIncrementBytes(1005435000, -5));
    assertTrue(checkTestIncrementBytes(10, -43657655));
    assertTrue(checkTestIncrementBytes(-1, 1));
    assertTrue(checkTestIncrementBytes(-26, 5034520));
    assertTrue(checkTestIncrementBytes(-10657200, 5));
    assertTrue(checkTestIncrementBytes(-12343250, 45376475));
    assertTrue(checkTestIncrementBytes(-10, -5));
    assertTrue(checkTestIncrementBytes(-12343250, -5));
    assertTrue(checkTestIncrementBytes(-12, -34565445));
    assertTrue(checkTestIncrementBytes(-1546543452, -34565445));
  }",Eager Test
"@Test
  public void testAdd() {
    byte[] a = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }",Eager Test
"@Test
  public void testBinarySearch() {
    byte[][] arr = { { 1 }",Eager Test
"@Test
  public void testFixedSizeString() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    DataOutputStream dos = new DataOutputStream(baos);
    Bytes.writeStringFixedSize(dos, ""Hello"", 5);
    Bytes.writeStringFixedSize(dos, ""World"", 18);
    Bytes.writeStringFixedSize(dos, """", 9);

    try {
      // Use a long dash which is three bytes in UTF-8. If encoding happens
      // using ISO-8859-1, this will fail.
      Bytes.writeStringFixedSize(dos, ""Too\u2013Long"", 9);
      fail(""Exception expected"");
    }",Eager Test
"@Test
  public void testGetBytesForByteBuffer() {
    byte[] array = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }",Eager Test
"@Test
  public void testIncrementBytes() {
    assertTrue(checkTestIncrementBytes(10, 1));
    assertTrue(checkTestIncrementBytes(12, 123435445));
    assertTrue(checkTestIncrementBytes(124634654, 1));
    assertTrue(checkTestIncrementBytes(10005460, 5005645));
    assertTrue(checkTestIncrementBytes(1, -1));
    assertTrue(checkTestIncrementBytes(10, -1));
    assertTrue(checkTestIncrementBytes(10, -5));
    assertTrue(checkTestIncrementBytes(1005435000, -5));
    assertTrue(checkTestIncrementBytes(10, -43657655));
    assertTrue(checkTestIncrementBytes(-1, 1));
    assertTrue(checkTestIncrementBytes(-26, 5034520));
    assertTrue(checkTestIncrementBytes(-10657200, 5));
    assertTrue(checkTestIncrementBytes(-12343250, 45376475));
    assertTrue(checkTestIncrementBytes(-10, -5));
    assertTrue(checkTestIncrementBytes(-12343250, -5));
    assertTrue(checkTestIncrementBytes(-12, -34565445));
    assertTrue(checkTestIncrementBytes(-1546543452, -34565445));
  }",No Smells
"@Test
  public void testNullHashCode() {
    byte[] b = null;
    Exception ee = null;
    try {
      Bytes.hashCode(b);
    }",No Smells
"@Test
  public void testShort() throws Exception {
    testShort(false);
  }",No Smells
"@Test
  public void testSplit() {
    byte[] lowest = Bytes.toBytes(""AAA"");
    byte[] middle = Bytes.toBytes(""CCC"");
    byte[] highest = Bytes.toBytes(""EEE"");
    byte[][] parts = Bytes.split(lowest, highest, 1);
    for (byte[] bytes : parts) {
      System.out.println(Bytes.toString(bytes));
    }",Eager Test
"@Test
  public void testSplit3() {
    // Test invalid split cases
    byte[] low = { 1, 1, 1 }",No Smells
"@Test
  public void testStartsWith() {
    assertTrue(Bytes.startsWith(Bytes.toBytes(""hello""), Bytes.toBytes(""h"")));
    assertTrue(Bytes.startsWith(Bytes.toBytes(""hello""), Bytes.toBytes("""")));
    assertTrue(Bytes.startsWith(Bytes.toBytes(""hello""), Bytes.toBytes(""hello"")));
    assertFalse(Bytes.startsWith(Bytes.toBytes(""hello""), Bytes.toBytes(""helloworld"")));
    assertFalse(Bytes.startsWith(Bytes.toBytes(""""), Bytes.toBytes(""hello"")));
  }",No Smells
"@Test
  public void testToBytesBinaryTrailingBackslashes() {
    try {
      Bytes.toBytesBinary(""abc\\x00\\x01\\"");
    }",No Smells
"@Test
  public void testToInt() {
    int[] ints = { -1, 123, Integer.MIN_VALUE, Integer.MAX_VALUE }",Eager Test
"@Test
  public void testToLong() {
    long[] longs = { -1L, 123L, Long.MIN_VALUE, Long.MAX_VALUE }",Eager Test
"@Test
  public void testUnsignedBinarySearch() {
    byte[] bytes = new byte[] { 0, 5, 123, 127, -128, -100, -1 }",No Smells
"@Test
  public void testMatchingTail() throws IOException {
    Path rootdir = htu.getDataTestDir();
    final FileSystem fs = rootdir.getFileSystem(conf);
    assertTrue(rootdir.depth() > 1);
    Path partPath = new Path(""a"", ""b"");
    Path fullPath = new Path(rootdir, partPath);
    Path fullyQualifiedPath = fs.makeQualified(fullPath);
    assertFalse(CommonFSUtils.isMatchingTail(fullPath, partPath));
    assertFalse(CommonFSUtils.isMatchingTail(fullPath, partPath.toString()));
    assertTrue(CommonFSUtils.isStartingWithPath(rootdir, fullPath.toString()));
    assertTrue(CommonFSUtils.isStartingWithPath(fullyQualifiedPath, fullPath.toString()));
    assertFalse(CommonFSUtils.isStartingWithPath(rootdir, partPath.toString()));
    assertFalse(CommonFSUtils.isMatchingTail(fullyQualifiedPath, partPath));
    assertTrue(CommonFSUtils.isMatchingTail(fullyQualifiedPath, fullPath));
    assertTrue(CommonFSUtils.isMatchingTail(fullyQualifiedPath, fullPath.toString()));
    assertTrue(CommonFSUtils.isMatchingTail(fullyQualifiedPath, fs.makeQualified(fullPath)));
    assertTrue(CommonFSUtils.isStartingWithPath(rootdir, fullyQualifiedPath.toString()));
    assertFalse(CommonFSUtils.isMatchingTail(fullPath, new Path(""x"")));
    assertFalse(CommonFSUtils.isMatchingTail(new Path(""x""), fullPath));
  }",Eager Test + Mystery Guest
"@Test
  public void testTestCompression() {
    assertTrue(CompressionTest.testCompression(""NONE""));
    assertTrue(CompressionTest.testCompression(""GZ""));

    if (NativeCodeLoader.isNativeCodeLoaded()) {
      // LZO is GPL so not included in hadoop install. You need to do an extra install to pick
      // up the needed support. This article is good on the steps needed to add LZO support:
      // https://stackoverflow.com/questions/23441142/class-com-hadoop-compression-lzo-lzocodec-not-found-for-spark-on-cdh-5
      // Its unlikely at test time that the extras are installed so this test is useless.
      // nativeCodecTest(""LZO"", ""lzo2"", ""com.hadoop.compression.lzo.LzoCodec"");
      nativeCodecTest(""LZ4"", null, ""org.apache.hadoop.io.compress.Lz4Codec"");
      nativeCodecTest(""SNAPPY"", ""snappy"", ""org.apache.hadoop.io.compress.SnappyCodec"");
      nativeCodecTest(""BZIP2"", ""bzip2"", ""org.apache.hadoop.io.compress.BZip2Codec"");
      nativeCodecTest(""ZSTD"", ""zstd"", ""org.apache.hadoop.io.compress.ZStandardCodec"");
    }",Eager Test + Mystery Guest
"@Test
  public void testConnectionChore() throws Exception {
    // 1s for clean interval & 5s for maxIdleTime
    ConnectionCache cache = new ConnectionCache(UTIL.getConfiguration(),
      UserProvider.instantiate(UTIL.getConfiguration()), 1000, 5000);
    ConnectionCache.ConnectionInfo info = cache.getCurrentConnection();

    assertEquals(false, info.connection.isClosed());

    Thread.sleep(7000);

    assertEquals(true, info.connection.isClosed());
  }",No Smells
"@Test
  public void testLoadClassFromAnotherPath() throws Exception {
    ClassLoader parent = TestDynamicClassLoader.class.getClassLoader();
    DynamicClassLoader classLoader = new DynamicClassLoader(conf, parent);

    String className = ""TestLoadClassFromAnotherPath"";
    deleteClass(className);
    try {
      classLoader.loadClass(className);
      fail(""Should not be able to load class "" + className);
    }",Eager Test
"@Test
  public void testLoadClassFromLocalPathWithDynamicDirOff() throws Exception {
    conf.setBoolean(""hbase.use.dynamic.jars"", false);
    ClassLoader parent = TestDynamicClassLoader.class.getClassLoader();
    DynamicClassLoader classLoader = new DynamicClassLoader(conf, parent);

    String className = ""TestLoadClassFromLocalPath"";
    deleteClass(className);

    try {
      String folder = TEST_UTIL.getDataTestDir().toString();
      ClassLoaderTestHelper.buildJar(folder, className, null,
        ClassLoaderTestHelper.localDirPath(conf));
      classLoader.loadClass(className);
      fail(""Should not be able to load class "" + className);
    }",Eager Test
"@Test
  public void testCurrentTimeInMillis() {
    EnvironmentEdge mock = mock(EnvironmentEdge.class);
    EnvironmentEdgeManager.injectEdge(mock);
    long expectation = 3456;
    when(mock.currentTime()).thenReturn(expectation);
    long result = EnvironmentEdgeManager.currentTime();
    verify(mock).currentTime();
    assertEquals(expectation, result);
  }",No Smells
"@Test
  public void testFormatTableInfoSequenceId() {
    Path p0 = assertWriteAndReadSequenceId(0);
    // Assert p0 has format we expect.
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < FSTableDescriptors.WIDTH_OF_SEQUENCE_ID; i++) {
      sb.append(""0"");
    }",Eager Test
"@Test
  public void testReadingHTDFromFS() throws IOException {
    FileSystem fs = FileSystem.get(UTIL.getConfiguration());
    TableDescriptor htd =
      TableDescriptorBuilder.newBuilder(TableName.valueOf(name.getMethodName())).build();
    FSTableDescriptors fstd = new FSTableDescriptors(fs, testDir);
    fstd.createTableDescriptor(htd);
    TableDescriptor td2 =
      FSTableDescriptors.getTableDescriptorFromFs(fs, testDir, htd.getTableName());
    assertTrue(htd.equals(td2));
  }",Eager Test + Mystery Guest
"@Test
  public void testTableInfoFileStatusComparator() {
    FileStatus bare = new FileStatus(0, false, 0, 0, -1,
      new Path(""/tmp"", FSTableDescriptors.TABLEINFO_FILE_PREFIX));
    FileStatus future = new FileStatus(0, false, 0, 0, -1,
      new Path(""/tmp/tablinfo."" + EnvironmentEdgeManager.currentTime()));
    FileStatus farFuture = new FileStatus(0, false, 0, 0, -1,
      new Path(""/tmp/tablinfo."" + EnvironmentEdgeManager.currentTime() + 1000));
    FileStatus[] alist = { bare, future, farFuture }",Eager Test + Mystery Guest
"@Test
  public void testCopyFilesParallel() throws Exception {
    MiniDFSCluster cluster = htu.startMiniDFSCluster(1);
    cluster.waitActive();
    FileSystem fs = cluster.getFileSystem();
    Path src = new Path(""/src"");
    fs.mkdirs(src);
    for (int i = 0; i < 50; i++) {
      WriteDataToHDFS(fs, new Path(src, String.valueOf(i)), 1024);
    }",Eager Test + Mystery Guest
"@Test
  public void testGetArchivePath() throws Exception {
    Configuration conf = new Configuration();
    CommonFSUtils.setRootDir(conf, new Path(""root""));
    assertNotNull(HFileArchiveUtil.getArchivePath(conf));
  }",Mystery Guest
"@Test
  public void testRegionArchiveDir() {
    Path regionDir = new Path(""region"");
    assertNotNull(HFileArchiveUtil.getRegionArchiveDir(rootDir,
      TableName.valueOf(name.getMethodName()), regionDir));
  }",No Smells
"@Test
  public void testEscape() {
    String jrubyString = JRubyFormat.print(""\\\'\n\r\t\f"");
    assertEquals(""'\\\\\\'\\n\\r\\t\\f'"", jrubyString);
  }",No Smells
"@Test
  public void testPrint() {
    Map<String, Object> map = new LinkedHashMap<>();
    map.put(""null"", null);
    map.put(""boolean"", true);
    map.put(""number"", 1);
    map.put(""string"", ""str"");
    map.put(""binary"", new byte[] { 1, 2, 3 }",No Smells
"@Test
  public void testBuildHashtable() {
    String[] keys = { ""type"", ""name"" }",Eager Test
"@Test
  public void testBucketSize() {
    LossyCounting<?> lossyCounting = new LossyCounting<>(""testBucketSize"", 0.01);
    assertEquals(100L, lossyCounting.getBucketSize());
    LossyCounting<?> lossyCounting2 = new LossyCounting<>(""testBucketSize2"", conf);
    assertEquals(50L, lossyCounting2.getBucketSize());
  }",No Smells
"@Test
  public void testBlobVarLencodedLength() {
    int[][] values = {
      /*
       * decoded length, encoded length ceil((n bytes * 8 bits/input byte) / 7 bits/encoded byte) +
       * 1 header
       */
      { 1, 3 }",Eager Test
"@Test
  public void testNumericIntRealCompatibility() {
    for (Order ord : new Order[] { Order.ASCENDING, Order.DESCENDING }",Eager Test
"@Test
  public void testString() {
    String[] vals = { ""foo"", ""baaaar"", ""bazz"" }",Eager Test
"@Test
  public void testBeginEndMarker() {
    RegionSplitCalculator<SimpleRange> sc = new RegionSplitCalculator<>(cmp);
    sc.add(new SimpleRange(Bytes.toBytes(""""), Bytes.toBytes(""A"")));
    sc.add(new SimpleRange(Bytes.toBytes(""A""), Bytes.toBytes(""B"")));
    sc.add(new SimpleRange(Bytes.toBytes(""B""), Bytes.toBytes("""")));

    Multimap<byte[], SimpleRange> regions = sc.calcCoverage();
    LOG.info(""Special cases -- empty"");
    String res = dump(sc.getSplits(), regions);
    checkDepths(sc.getSplits(), regions, 1, 1, 1, 0);
    assertEquals("":\t[, A]\t\n"" + ""A:\t[A, B]\t\n"" + ""B:\t[B, ]\t\n"" + ""null:\t\n"", res);
  }",Eager Test
"@Test
  public void testSplitCalculatorCeil() {
    SimpleRange a = new SimpleRange(Bytes.toBytes(""A""), Bytes.toBytes(""C""));
    SimpleRange b = new SimpleRange(Bytes.toBytes(""B""), Bytes.toBytes(""C""));
    RegionSplitCalculator<SimpleRange> sc = new RegionSplitCalculator<>(cmp);
    sc.add(a);
    sc.add(b);

    Multimap<byte[], SimpleRange> regions = sc.calcCoverage();
    LOG.info(""AC and BC overlap in the end"");
    String res = dump(sc.getSplits(), regions);
    checkDepths(sc.getSplits(), regions, 1, 2, 0);
    assertEquals(""A:\t[A, C]\t\n"" + ""B:\t[A, C]\t[B, C]\t\n"" + ""C:\t\n"", res);
  }",Eager Test
"@Test
  public void testSplitCalculatorDegenerateEdge() {
    SimpleRange a = new SimpleRange(Bytes.toBytes(""A""), Bytes.toBytes(""A""));
    RegionSplitCalculator<SimpleRange> sc = new RegionSplitCalculator<>(cmp);
    sc.add(a);

    Multimap<byte[], SimpleRange> regions = sc.calcCoverage();
    LOG.info(""Single empty edge"");
    String res = dump(sc.getSplits(), regions);
    checkDepths(sc.getSplits(), regions, 1);
    assertEquals(""A:\t[A, A]\t\n"", res);
  }",Eager Test
"@Test
  public void testSplitCalculatorEq() {
    SimpleRange a = new SimpleRange(Bytes.toBytes(""A""), Bytes.toBytes(""C""));
    SimpleRange b = new SimpleRange(Bytes.toBytes(""A""), Bytes.toBytes(""C""));

    LOG.info(a.tiebreaker + "" - "" + b.tiebreaker);
    RegionSplitCalculator<SimpleRange> sc = new RegionSplitCalculator<>(cmp);
    sc.add(a);
    sc.add(b);

    Multimap<byte[], SimpleRange> regions = sc.calcCoverage();
    LOG.info(""AC and AC overlap completely"");
    String res = dump(sc.getSplits(), regions);
    checkDepths(sc.getSplits(), regions, 2, 0);
    assertEquals(""A:\t[A, C]\t[A, C]\t\n"" + ""C:\t\n"", res);
  }",Eager Test
"@Test
  public void testSplitCalculatorSingleEdge() {
    SimpleRange a = new SimpleRange(Bytes.toBytes(""A""), Bytes.toBytes(""B""));
    RegionSplitCalculator<SimpleRange> sc = new RegionSplitCalculator<>(cmp);
    sc.add(a);

    Multimap<byte[], SimpleRange> regions = sc.calcCoverage();
    LOG.info(""Single edge"");
    String res = dump(sc.getSplits(), regions);
    checkDepths(sc.getSplits(), regions, 1, 0);
    assertEquals(""A:\t[A, B]\t\n"" + ""B:\t\n"", res);
  }",Eager Test
"@Test
  public void unitTestHexStringSplit() {
    HexStringSplit splitter = new HexStringSplit();
    // Check splitting while starting from scratch

    byte[][] twoRegionsSplits = splitter.split(2);
    assertEquals(1, twoRegionsSplits.length);
    assertArrayEquals(Bytes.toBytes(""80000000""), twoRegionsSplits[0]);

    byte[][] threeRegionsSplits = splitter.split(3);
    assertEquals(2, threeRegionsSplits.length);
    byte[] expectedSplit0 = Bytes.toBytes(""55555555"");
    assertArrayEquals(expectedSplit0, threeRegionsSplits[0]);
    byte[] expectedSplit1 = Bytes.toBytes(""aaaaaaaa"");
    assertArrayEquals(expectedSplit1, threeRegionsSplits[1]);

    // Check splitting existing regions that have start and end points
    byte[] splitPoint = splitter.split(Bytes.toBytes(""10000000""), Bytes.toBytes(""30000000""));
    assertArrayEquals(Bytes.toBytes(""20000000""), splitPoint);

    byte[] lastRow = Bytes.toBytes(""ffffffff"");
    assertArrayEquals(lastRow, splitter.lastRow());
    byte[] firstRow = Bytes.toBytes(""00000000"");
    assertArrayEquals(firstRow, splitter.firstRow());

    // Halfway between 00... and 20... should be 10...
    splitPoint = splitter.split(firstRow, Bytes.toBytes(""20000000""));
    assertArrayEquals(Bytes.toBytes(""10000000""), splitPoint);

    // Halfway between df... and ff... should be ef....
    splitPoint = splitter.split(Bytes.toBytes(""dfffffff""), lastRow);
    assertArrayEquals(Bytes.toBytes(""efffffff""), splitPoint);

    // Check splitting region with multiple mappers per region
    byte[][] splits =
      splitter.split(Bytes.toBytes(""00000000""), Bytes.toBytes(""30000000""), 3, false);
    assertEquals(2, splits.length);
    assertArrayEquals(Bytes.toBytes(""10000000""), splits[0]);
    assertArrayEquals(Bytes.toBytes(""20000000""), splits[1]);

    splits = splitter.split(Bytes.toBytes(""00000000""), Bytes.toBytes(""20000000""), 2, true);
    assertEquals(3, splits.length);
    assertArrayEquals(Bytes.toBytes(""10000000""), splits[1]);
  }",Eager Test
"@Test
  public void testBasics() throws InterruptedException {
    int maxAttempts = 10;
    RetryCounterFactory factory = new RetryCounterFactory(maxAttempts, 10, 1000);
    RetryCounter retryCounter = factory.create();
    while (retryCounter.shouldRetry()) {
      LOG.info(""Attempt={}",Eager Test
"@Test
  public void testOfferInStealQueueFromShouldUnblock() throws InterruptedException {
    final AtomicInteger taken = new AtomicInteger();
    Thread consumer = new Thread() {
      @Override
      public void run() {
        try {
          Integer n = stealJobQueue.take();
          taken.set(n);
        }",Eager Test + Redundent Print
"@Test
  public void testWeakReference() throws Exception {
    Object obj1 = pool.get(""a"");
    int hash1 = System.identityHashCode(obj1);

    System.gc();
    System.gc();
    System.gc();

    Thread.sleep(10);
    // Sleep a while because references newly becoming stale
    // may still remain when calling the {@code purge}",Eager Test
"@Test
  public void setMembershipDedups() throws IOException {
    Configuration localConf = new Configuration(conf);
    localConf.set(WALFactory.WAL_PROVIDER, FSHLogProvider.class.getName());
    WALFactory wals = new WALFactory(localConf, currentTest.getMethodName());
    try {
      final Set<WAL> seen = new HashSet<>(1);
      assertTrue(""first attempt to add WAL from default provider should work."",
        seen.add(wals.getWAL(null)));
      for (int i = 0; i < 1000; i++) {
        assertFalse(
          ""default wal provider is only supposed to return a single wal, which should ""
            + ""compare as .equals itself."",
          seen.add(wals.getWAL(RegionInfoBuilder
            .newBuilder(TableName.valueOf(""Table-"" + ThreadLocalRandom.current().nextInt()))
            .build())));
      }",Eager Test
"@Test
  public void testOnlySetWALProvider() throws IOException {
    Configuration conf = new Configuration();
    conf.set(WAL_PROVIDER, WALFactory.Providers.multiwal.name());
    WALFactory walFactory = new WALFactory(conf, this.currentServername.toString());
    // class of WALProvider and metaWALProvider are the same when metaWALProvider is not set
    assertEquals(WALFactory.Providers.multiwal.clazz, walFactory.getWALProvider().getClass());
    assertEquals(WALFactory.Providers.multiwal.clazz, walFactory.getMetaProvider().getClass());
  }",No Smells
"@Test
  public void testSplit() throws IOException {
    final TableName tableName = TableName.valueOf(currentTest.getMethodName());
    final byte[] rowName = tableName.getName();
    final MultiVersionConcurrencyControl mvcc = new MultiVersionConcurrencyControl(1);
    final int howmany = 3;
    RegionInfo[] infos = new RegionInfo[3];
    Path tableDataDir = CommonFSUtils.getTableDir(hbaseDir, tableName);
    fs.mkdirs(tableDataDir);
    Path tabledir = CommonFSUtils.getWALTableDir(conf, tableName);
    fs.mkdirs(tabledir);
    for (int i = 0; i < howmany; i++) {
      infos[i] = RegionInfoBuilder.newBuilder(tableName).setStartKey(Bytes.toBytes("""" + i))
        .setEndKey(Bytes.toBytes("""" + (i + 1))).build();
      fs.mkdirs(new Path(tabledir, infos[i].getEncodedName()));
      fs.mkdirs(new Path(tableDataDir, infos[i].getEncodedName()));
      LOG.info(""allo "" + new Path(tabledir, infos[i].getEncodedName()).toString());
    }",Eager Test + Mystery Guest
"@Test
  public void testWALCoprocessorLoaded() throws Exception {
    // test to see whether the coprocessor is loaded or not.
    WALCoprocessorHost host = wals.getWAL(null).getCoprocessorHost();
    Coprocessor c = host.findCoprocessor(SampleRegionWALCoprocessor.class);
    assertNotNull(c);
  }",No Smells
"@Test
  public void testWALProviders() throws IOException {
    Configuration conf = new Configuration();
    WALFactory walFactory = new WALFactory(conf, this.currentServername.toString());
    assertEquals(walFactory.getWALProvider().getClass(), walFactory.getMetaProvider().getClass());

    // if providers are not set and do not enable SyncReplicationWALProvider
    walFactory = new WALFactory(conf, this.currentServername, null);
    assertEquals(walFactory.getWALProvider().getClass(), walFactory.getMetaProvider().getClass());
  }",No Smells
"@Test
  public void testMakeZKProps() {
    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());
    conf.set(HConstants.ZOOKEEPER_DATA_DIR, this.dataDir.toString());
    Properties properties = ZKConfig.makeZKProps(conf);
    assertEquals(dataDir.toString(), (String) properties.get(""dataDir""));
    assertEquals(Integer.valueOf(PORT_NO), Integer.valueOf(properties.getProperty(""clientPort"")));
    assertEquals(""127.0.0.1:2888:3888"", properties.get(""server.0""));
    assertNull(properties.get(""server.1""));

    String oldValue = conf.get(HConstants.ZOOKEEPER_QUORUM);
    conf.set(HConstants.ZOOKEEPER_QUORUM, ""a.foo.bar,b.foo.bar,c.foo.bar"");
    properties = ZKConfig.makeZKProps(conf);
    assertEquals(dataDir.toString(), properties.get(""dataDir""));
    assertEquals(Integer.valueOf(PORT_NO), Integer.valueOf(properties.getProperty(""clientPort"")));
    assertEquals(""a.foo.bar:2888:3888"", properties.get(""server.0""));
    assertEquals(""b.foo.bar:2888:3888"", properties.get(""server.1""));
    assertEquals(""c.foo.bar:2888:3888"", properties.get(""server.2""));
    assertNull(properties.get(""server.3""));
    conf.set(HConstants.ZOOKEEPER_QUORUM, oldValue);
  }",Eager Test
"@Test
  public void testShouldAssignDefaultZookeeperClientPort() {
    Configuration config = HBaseConfiguration.create();
    config.clear();
    Properties p = ZKConfig.makeZKProps(config);
    assertNotNull(p);
    assertEquals(2181, p.get(""clientPort""));
  }",No Smells
"@Test
  public void testSetDataVersionMismatchInLoop() throws Exception {
    String znode = ""/hbase/splitWAL/9af7cfc9b15910a0b3d714bf40a3248f"";
    Configuration conf = TEST_UTIL.getConfiguration();
    ZKWatcher zkw = new ZKWatcher(conf, ""testSetDataVersionMismatchInLoop"", abortable, true);
    String ensemble = ZKConfig.getZKQuorumServersString(conf);
    RecoverableZooKeeper rzk = RecoverableZooKeeper.connect(conf, ensemble, zkw, null, null);
    rzk.create(znode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    rzk.setData(znode, Bytes.toBytes(""OPENING""), 0);
    Field zkField = RecoverableZooKeeper.class.getDeclaredField(""zk"");
    zkField.setAccessible(true);
    int timeout = conf.getInt(HConstants.ZK_SESSION_TIMEOUT, HConstants.DEFAULT_ZK_SESSION_TIMEOUT);
    ZookeeperStub zkStub = new ZookeeperStub(ensemble, timeout, zkw);
    zkStub.setThrowExceptionInNumOperations(1);
    zkField.set(rzk, zkStub);
    byte[] opened = Bytes.toBytes(""OPENED"");
    rzk.setData(znode, opened, 1);
    byte[] data = rzk.getData(znode, false, new Stat());
    assertTrue(Bytes.equals(opened, data));
  }",Eager Test + Mystery Guest
"@Test
  public void testClusterKey() throws Exception {
    testKey(""server"", 2181, ""/hbase"");
    testKey(""server1,server2,server3"", 2181, ""/hbase"");
    try {
      ZKConfig.validateClusterKey(""2181:/hbase"");
    }",No Smells
"@Test
  public void testClusterKeyWithMultiplePorts() throws Exception {
    // server has different port than the default port
    testKey(""server1:2182"", 2181, ""/hbase"", true);
    // multiple servers have their own port
    testKey(""server1:2182,server2:2183,server3:2184"", 2181, ""/hbase"", true);
    // one server has no specified port, should use default port
    testKey(""server1:2182,server2,server3:2184"", 2181, ""/hbase"", true);
    // the last server has no specified port, should use default port
    testKey(""server1:2182,server2:2183,server3"", 2181, ""/hbase"", true);
    // multiple servers have no specified port, should use default port for those servers
    testKey(""server1:2182,server2,server3:2184,server4"", 2181, ""/hbase"", true);
    // same server, different ports
    testKey(""server1:2182,server1:2183,server1"", 2181, ""/hbase"", true);
    // mix of same server/different port and different server
    testKey(""server1:2182,server2:2183,server1"", 2181, ""/hbase"", true);
  }",Mystery Guest
"@Test
  public void testHostPortParse() {
    ZKMainServer parser = new ZKMainServer();
    Configuration c = HBaseConfiguration.create();
    assertEquals(""127.0.0.1:"" + c.get(HConstants.ZOOKEEPER_CLIENT_PORT), parser.parse(c));
    final String port = ""1234"";
    c.set(HConstants.ZOOKEEPER_CLIENT_PORT, port);
    c.set(""hbase.zookeeper.quorum"", ""example.com"");
    assertEquals(""example.com:"" + port, parser.parse(c));
    c.set(""hbase.zookeeper.quorum"", ""example1.com,example2.com,example3.com"");
    String ensemble = parser.parse(c);
    assertTrue(port, ensemble.matches(""(example[1-3]\\.com:1234,){2}",Eager Test + Mystery Guest
"@Test
  public void testCleanZNode() throws Exception {
    ZKWatcher zkw = new ZKWatcher(TEST_UTIL.getConfiguration(), ""testNodeTracker"",
      new TestZKNodeTracker.StubAbortable());

    final ServerName sn = ServerName.valueOf(""127.0.0.1:52"", 45L);

    ZKUtil.createAndFailSilent(zkw, TEST_UTIL.getConfiguration()
      .get(HConstants.ZOOKEEPER_ZNODE_PARENT, HConstants.DEFAULT_ZOOKEEPER_ZNODE_PARENT));

    final String nodeName = zkw.getZNodePaths().masterAddressZNode;

    // Check that we manage the case when there is no data
    ZKUtil.createAndFailSilent(zkw, nodeName);
    MasterAddressTracker.deleteIfEquals(zkw, sn.toString());
    assertNotNull(ZKUtil.getData(zkw, nodeName));

    // Check that we don't delete if we're not supposed to
    ZKUtil.setData(zkw, nodeName, MasterAddressTracker.toByteArray(sn, 0));
    MasterAddressTracker.deleteIfEquals(zkw, ServerName.valueOf(""127.0.0.2:52"", 45L).toString());
    assertNotNull(ZKUtil.getData(zkw, nodeName));

    // Check that we delete when we're supposed to
    ZKUtil.setData(zkw, nodeName, MasterAddressTracker.toByteArray(sn, 0));
    MasterAddressTracker.deleteIfEquals(zkw, sn.toString());
    assertNull(ZKUtil.getData(zkw, nodeName));

    // Check that we support the case when the znode does not exist
    MasterAddressTracker.deleteIfEquals(zkw, sn.toString()); // must not throw an exception
  }",Eager Test
"@Test
  public void testNodeTracker() throws Exception {
    Abortable abortable = new StubAbortable();
    ZKWatcher zk = new ZKWatcher(TEST_UTIL.getConfiguration(), ""testNodeTracker"", abortable);
    ZKUtil.createAndFailSilent(zk, zk.getZNodePaths().baseZNode);

    final String node = ZNodePaths.joinZNode(zk.getZNodePaths().baseZNode,
      Long.toString(ThreadLocalRandom.current().nextLong()));

    final byte[] dataOne = Bytes.toBytes(""dataOne"");
    final byte[] dataTwo = Bytes.toBytes(""dataTwo"");

    // Start a ZKNT with no node currently available
    TestTracker localTracker = new TestTracker(zk, node, abortable);
    localTracker.start();
    zk.registerListener(localTracker);

    // Make sure we don't have a node
    assertNull(localTracker.getData(false));

    // Spin up a thread with another ZKNT and have it block
    WaitToGetDataThread thread = new WaitToGetDataThread(zk, node);
    thread.start();

    // Verify the thread doesn't have a node
    assertFalse(thread.hasData);

    // Now, start a new ZKNT with the node already available
    TestTracker secondTracker = new TestTracker(zk, node, null);
    secondTracker.start();
    zk.registerListener(secondTracker);

    // Put up an additional zk listener so we know when zk event is done
    TestingZKListener zkListener = new TestingZKListener(zk, node);
    zk.registerListener(zkListener);
    assertEquals(0, zkListener.createdLock.availablePermits());

    // Create a completely separate zk connection for test triggers and avoid
    // any weird watcher interactions from the test
    final ZooKeeper zkconn = ZooKeeperHelper.getConnectedZooKeeper(
      ZKConfig.getZKQuorumServersString(TEST_UTIL.getConfiguration()), 60000);

    // Add the node with data one
    zkconn.create(node, dataOne, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);

    // Wait for the zk event to be processed
    zkListener.waitForCreation();
    thread.join();

    // Both trackers should have the node available with data one
    assertNotNull(localTracker.getData(false));
    assertNotNull(localTracker.blockUntilAvailable());
    assertTrue(Bytes.equals(localTracker.getData(false), dataOne));
    assertTrue(thread.hasData);
    assertTrue(Bytes.equals(thread.tracker.getData(false), dataOne));
    LOG.info(""Successfully got data one"");

    // Make sure it's available and with the expected data
    assertNotNull(secondTracker.getData(false));
    assertNotNull(secondTracker.blockUntilAvailable());
    assertTrue(Bytes.equals(secondTracker.getData(false), dataOne));
    LOG.info(""Successfully got data one with the second tracker"");

    // Drop the node
    zkconn.delete(node, -1);
    zkListener.waitForDeletion();

    // Create a new thread but with the existing thread's tracker to wait
    TestTracker threadTracker = thread.tracker;
    thread = new WaitToGetDataThread(threadTracker);
    thread.start();

    // Verify other guys don't have data
    assertFalse(thread.hasData);
    assertNull(secondTracker.getData(false));
    assertNull(localTracker.getData(false));
    LOG.info(""Successfully made unavailable"");

    // Create with second data
    zkconn.create(node, dataTwo, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);

    // Wait for the zk event to be processed
    zkListener.waitForCreation();
    thread.join();

    // All trackers should have the node available with data two
    assertNotNull(localTracker.getData(false));
    assertNotNull(localTracker.blockUntilAvailable());
    assertTrue(Bytes.equals(localTracker.getData(false), dataTwo));
    assertNotNull(secondTracker.getData(false));
    assertNotNull(secondTracker.blockUntilAvailable());
    assertTrue(Bytes.equals(secondTracker.getData(false), dataTwo));
    assertTrue(thread.hasData);
    assertTrue(Bytes.equals(thread.tracker.getData(false), dataTwo));
    LOG.info(""Successfully got data two on all trackers and threads"");

    // Change the data back to data one
    zkconn.setData(node, dataOne, -1);

    // Wait for zk event to be processed
    zkListener.waitForDataChange();

    // All trackers should have the node available with data one
    assertNotNull(localTracker.getData(false));
    assertNotNull(localTracker.blockUntilAvailable());
    assertTrue(Bytes.equals(localTracker.getData(false), dataOne));
    assertNotNull(secondTracker.getData(false));
    assertNotNull(secondTracker.blockUntilAvailable());
    assertTrue(Bytes.equals(secondTracker.getData(false), dataOne));
    assertTrue(thread.hasData);
    assertTrue(Bytes.equals(thread.tracker.getData(false), dataOne));
    LOG.info(""Successfully got data one following a data change on all trackers and threads"");
  }",Eager Test
"@Test
  public void testSetDataWithVersion() throws Exception {
    ZKUtil.createWithParents(ZKW, ""/s1/s2/s3"");
    int v0 = getZNodeDataVersion(""/s1/s2/s3"");
    assertEquals(0, v0);

    ZKUtil.setData(ZKW, ""/s1/s2/s3"", Bytes.toBytes(12L));
    int v1 = getZNodeDataVersion(""/s1/s2/s3"");
    assertEquals(1, v1);

    ZKUtil.multiOrSequential(ZKW,
      ImmutableList.of(ZKUtilOp.setData(""/s1/s2/s3"", Bytes.toBytes(13L), v1)), false);
    int v2 = getZNodeDataVersion(""/s1/s2/s3"");
    assertEquals(2, v2);
  }",Eager Test
"@Test
  public void testNamespaceExists() throws Exception {
    final String NONEXISTENT_NAMESPACE = ""xyzpdq_nonexistent"";
    final String EXISTING_NAMESPACE = ""pdqxyz_myExistingNamespace"";
    boolean exists;
    Admin admin = TEST_UTIL.getAdmin();

    exists = HelloHBase.namespaceExists(admin, NONEXISTENT_NAMESPACE);
    assertEquals(""#namespaceExists failed: found nonexistent namespace."", false, exists);

    admin.createNamespace(NamespaceDescriptor.create(EXISTING_NAMESPACE).build());
    exists = HelloHBase.namespaceExists(admin, EXISTING_NAMESPACE);
    assertEquals(""#namespaceExists failed: did NOT find existing namespace."", true, exists);
    admin.deleteNamespace(EXISTING_NAMESPACE);
  }",Eager Test
"@Test
  public void testDeleteRow() throws IOException {
    Admin admin = TEST_UTIL.getAdmin();
    admin.createNamespace(NamespaceDescriptor.create(HelloHBase.MY_NAMESPACE_NAME).build());
    Table table = TEST_UTIL.createTable(HelloHBase.MY_TABLE_NAME, HelloHBase.MY_COLUMN_FAMILY_NAME);

    table.put(new Put(HelloHBase.MY_ROW_ID).addColumn(HelloHBase.MY_COLUMN_FAMILY_NAME,
      HelloHBase.MY_FIRST_COLUMN_QUALIFIER, Bytes.toBytes(""xyz"")));
    HelloHBase.deleteRow(table);
    Result row = table.get(new Get(HelloHBase.MY_ROW_ID));
    assertEquals(""#deleteRow failed to delete row."", true, row.isEmpty());

    TEST_UTIL.deleteTable(HelloHBase.MY_TABLE_NAME);
    admin.deleteNamespace(HelloHBase.MY_NAMESPACE_NAME);
  }",Eager Test
"@Test
  public void testNamespaceExists() throws Exception {
    final String NONEXISTENT_NAMESPACE = ""xyzpdq_nonexistent"";
    final String EXISTING_NAMESPACE = ""pdqxyz_myExistingNamespace"";
    boolean exists;
    Admin admin = TEST_UTIL.getAdmin();

    exists = HelloHBase.namespaceExists(admin, NONEXISTENT_NAMESPACE);
    assertEquals(""#namespaceExists failed: found nonexistent namespace."", false, exists);

    admin.createNamespace(NamespaceDescriptor.create(EXISTING_NAMESPACE).build());
    exists = HelloHBase.namespaceExists(admin, EXISTING_NAMESPACE);
    assertEquals(""#namespaceExists failed: did NOT find existing namespace."", true, exists);
    admin.deleteNamespace(EXISTING_NAMESPACE);
  }",Eager Test
"@Test
	public void testEchoGrepNoMatch() {
		unix4j.echo(""Hello WORLD"").grep(""world"");
	}",No Smells
"@Test
	public void testLs() {
		unix4j.ls();
	}",No Smells
"@Test
	public void testLsFile() {
		unix4j.ls(""src"");
	}",No Smells
"@Test
	public void testLsSortReverse() {
		unix4j.ls().sort(Sort.Options.reverse);
	}",No Smells
"@Test
	public void testLsStarStarStarJava() {
		unix4j.ls(""src/*/*/*/*/*.java"", ""src/*/*/*/*/*/*.java"", ""src/*/*/*/*/*/*/*.java"");
//		unix4j.ls(""src/*/*/*/*/*.java"");
	}",No Smells
"@Test
	public void testOptionSetDefinition() throws Exception {
		final Object ls = new OptionSetDefinitionDataLoader().load(null, Collections.singletonList(""/ls.xml""));
		System.out.println(ls);
		final Object uniq = new OptionSetDefinitionDataLoader().load(null, Collections.singletonList(""/uniq.xml""));
		System.out.println(uniq);
		final Object cut = new OptionSetDefinitionDataLoader().load(null, Collections.singletonList(""/cut.xml""));
		System.out.println(cut);
		final Object sort = new OptionSetDefinitionDataLoader().load(null, Collections.singletonList(""/sort.xml""));
		System.out.println(sort);
	}",Eager Test + Mystery Guest + Resource Optimism
"@Test
	public void testUnixLine() {
		final SingleCharSequenceLine line = new SingleCharSequenceLine(""Hello world\n"", 1);
		testLine(line, ""Hello world"", ""\n"");
	}",No Smells
"@Test
	public void testOnlyEvenLines() {
		final LineOperation op = new LineOperation() {
			int count = 0;
			@Override
			public void operate(ExecutionContext context, Line input, LineProcessor output) {
				if (count % 2 == 0) {
					output.processLine(input);
				}",Eager Test
"@Test
	public void testCat_numberLines() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput.appendLine(makeCountLine(1, LINE1));
		expectedOutput.appendLine(makeCountLine(2, LINE2));
		expectedOutput.appendLine(makeCountLine(3, LINE3));
		expectedOutput.appendLine(makeCountLine(4, LINE4));
		expectedOutput.appendLine(makeCountLine(5, LINE5));
		expectedOutput.appendLine(makeCountLine(6, LINE6));
		expectedOutput.appendLine(makeCountLine(7, LINE7));
		expectedOutput.appendLine(makeCountLine(8, LINE8));
		expectedOutput.appendLine(makeCountLine(9, LINE9));
		expectedOutput.appendLine(makeCountLine(10, LINE10));
		expectedOutput.appendLine(makeCountLine(11, LINE11));
		expectedOutput.appendLine(makeCountLine(12, LINE12));
		expectedOutput.appendLine(makeCountLine(13, LINE13));
		expectedOutput.appendLine(makeCountLine(14, LINE14));
		expectedOutput.appendLine(makeCountLine(15, LINE15));
		assertCat(input, Cat.Options.numberLines, expectedOutput);
	}",No Smells
"@Test
	public void testCat_numberNonBlankLines() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput.appendLine(makeCountLine(1, LINE1));
		expectedOutput.appendLine(makeCountLine(2, LINE2));
		expectedOutput.appendLine(makeCountLine(3, LINE3));
		expectedOutput.appendLine(LINE4);
		expectedOutput.appendLine(LINE5);
		expectedOutput.appendLine(LINE6);
		expectedOutput.appendLine(makeCountLine(4, LINE7));
		expectedOutput.appendLine(makeCountLine(5, LINE8));
		expectedOutput.appendLine(makeCountLine(6, LINE9));
		expectedOutput.appendLine(makeCountLine(7, LINE10));
		expectedOutput.appendLine(LINE11);
		expectedOutput.appendLine(makeCountLine(8, LINE12));
		expectedOutput.appendLine(makeCountLine(9, LINE13));
		expectedOutput.appendLine(LINE14);
		expectedOutput.appendLine(LINE15);
		assertCat(input, Cat.Options.numberNonBlankLines, expectedOutput);
	}",No Smells
"@Test
	public void testCat_squeezeEmptyLines() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput.appendLine(LINE1);
		expectedOutput.appendLine(LINE2);
		expectedOutput.appendLine(LINE3);
		expectedOutput.appendLine(LINE4);
//		expectedOutput.appendLine(LINE5);
//		expectedOutput.appendLine(LINE6);
		expectedOutput.appendLine(LINE7);
		expectedOutput.appendLine(LINE8);
		expectedOutput.appendLine(LINE9);
		expectedOutput.appendLine(LINE10);
		expectedOutput.appendLine(LINE11);
		expectedOutput.appendLine(LINE12);
		expectedOutput.appendLine(LINE13);
		expectedOutput.appendLine(LINE14);
//		expectedOutput.appendLine(LINE15);
		assertCat(input, Cat.Options.squeezeEmptyLines, expectedOutput);
	}",No Smells
"@Test
	public void testCat_squeezeEmptyLines_numberLines() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput.appendLine(makeCountLine(1, LINE1));
		expectedOutput.appendLine(makeCountLine(2, LINE2));
		expectedOutput.appendLine(makeCountLine(3, LINE3));
		expectedOutput.appendLine(makeCountLine(4, LINE4));
//		expectedOutput.appendLine(makeCountLine(-, LINE5));
//		expectedOutput.appendLine(makeCountLine(-, LINE6));
		expectedOutput.appendLine(makeCountLine(5, LINE7));
		expectedOutput.appendLine(makeCountLine(6, LINE8));
		expectedOutput.appendLine(makeCountLine(7, LINE9));
		expectedOutput.appendLine(makeCountLine(8, LINE10));
		expectedOutput.appendLine(makeCountLine(9, LINE11));
		expectedOutput.appendLine(makeCountLine(10, LINE12));
		expectedOutput.appendLine(makeCountLine(11, LINE13));
		expectedOutput.appendLine(makeCountLine(12, LINE14));
//		expectedOutput.appendLine(makeCountLine(LINE15));
		assertCat(input, Cat.Options.squeezeEmptyLines.numberLines, expectedOutput);
	}",No Smells
"@Test
	public void testCat_squeezeEmptyLines_numberNonBlankLines() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput.appendLine(makeCountLine(1, LINE1));
		expectedOutput.appendLine(makeCountLine(2, LINE2));
		expectedOutput.appendLine(makeCountLine(3, LINE3));
		expectedOutput.appendLine(LINE4);
//		expectedOutput.appendLine(makeCountLine(-, LINE5));
//		expectedOutput.appendLine(makeCountLine(-, LINE6));
		expectedOutput.appendLine(makeCountLine(4, LINE7));
		expectedOutput.appendLine(makeCountLine(5, LINE8));
		expectedOutput.appendLine(makeCountLine(6, LINE9));
		expectedOutput.appendLine(makeCountLine(7, LINE10));
		expectedOutput.appendLine(LINE11);
		expectedOutput.appendLine(makeCountLine(8, LINE12));
		expectedOutput.appendLine(makeCountLine(9, LINE13));
		expectedOutput.appendLine(LINE14);
//		expectedOutput.appendLine(makeCountLine(LINE15));
		assertCat(input, Cat.Options.squeezeEmptyLines.numberNonBlankLines, expectedOutput);
	}",No Smells
"@Test
	public void testCharacterCut1() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""r"")
				.appendLine(""r"")
				.appendLine(""r"")
				.appendLine("","")
				.appendLine(""r"")
				.appendLine("","")
				.appendLine("""")
				.appendLine(""r"");
		assertCharacterCut(input, expectedOutput, 1);
	}",No Smells
"@Test
	public void testCharacterCut2() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""ro"")
				.appendLine(""ro"")
				.appendLine(""ro"")
				.appendLine("",r"")
				.appendLine(""ro"")
				.appendLine("",,"")
				.appendLine("""")
				.appendLine(""ro"");
		assertCharacterCut(input, expectedOutput, 1, 2);
	}",No Smells
"@Test
	public void testRangeCut1() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""r"")
				.appendLine(""r"")
				.appendLine(""r"")
				.appendLine("","")
				.appendLine(""r"")
				.appendLine("","")
				.appendLine("""")
				.appendLine(""r"");
		assertRangeCut(input, expectedOutput, 1, 1);
	}",No Smells
"@Test
	public void testRangeCut3() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""ow1co"")
				.appendLine(""ow2co"")
				.appendLine(""ow3co"")
				.appendLine(""row4c"")
				.appendLine(""ow5co"")
				.appendLine("",,,"")
				.appendLine("""")
				.appendLine(""ow8co"");
		assertRangeCut(input, expectedOutput, 2, 6);
	}",No Smells
"@Test
	public void testEchoEmpty() {
		assertEquals("""", Unix4j.builder().echo("""").toStringResult());
	}",No Smells
"@Test
	public void testTwoMessages() {
		assertEquals(""one\ntwo three\nfour"", Unix4j.builder().echo(""one\ntwo"", ""three\nfour"").toStringResult());
	}",No Smells
"@Test
    public void testCountOnRelativeFilesWithCd(){
        assertEquals2(""118: commuting.txt"", ""7: commuting2.txt"", Unix4j.cd(outputDir).grep(Grep.Options.count, ""the"", ""*.txt"").sort());
    }",No Smells
"@Test
    public void testGrepFileThenDelete() throws IOException {
        //given
        final String[] lines = {""Hello"", ""World"", ""These are 3 lines""}",Eager Test + Mystery Guest
"@Test
    public void testGrepWholeLine(){
        final String lineRegex = ""the cistern .* the dishwasher hot-rinsing, and the kettle being"";
        final String actualLine = ""the cistern refilling, the dishwasher hot-rinsing, and the kettle being"";

        final File testFile = new File(outputDir.getPath() + ""/commuting.txt"" );
        assertEquals(actualLine, Unix4j.use(contextFactory).grep(Grep.Options.wholeLine, lineRegex, testFile).toStringResult());
    }",Eager Test + Mystery Guest
"@Test
	public void testHead_6() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput.appendLine(LINE1)
				.appendLine(LINE2)
				.appendLine(LINE3)
				.appendLine(LINE4)
				.appendLine(LINE5)
				.appendLine(LINE6);
		assertHead(input, 6, expectedOutput);
	}",No Smells
"@Test
	public void testHead_noInput_1() {
		final MultilineString expectedOutput = new MultilineString();
		assertHead(MultilineString.EMPTY, 1, expectedOutput);
	}",Redundent Print
"@Test
	public void testLsALH() {
		unix4j.ls(Ls.Options.l.a.h, FileUtil.getUserDir());
	}",No Smells
"@Test
	public void testSed_delete() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""This is a test one two three"")
				.appendLine(""one"")
				.appendLine(""a"")
				.appendLine("""")
				.appendLine(""two"")
				.appendLine(""def\\d123"");
		
		assertSed(input, ""blah"", expectedOutput, Sed.Options.delete);
		assertSed(input, ""blah"", expectedOutput, Sed.Options.d);
		assertSed(input, ""BLAH"", expectedOutput, Sed.Options.delete.ignoreCase);
		assertStringArgs(input, expectedOutput, ""-dI"", ""--regexp"", ""bLaH"");
		assertStringArgs(input, expectedOutput, ""--delete"", ""--regexp"", ""blah"");
		
		assertScript(input, ""/blah/ d"", expectedOutput );
		assertScript(input, ""/blah/d"", expectedOutput );
		assertScript(input, ""/BLAH/dI"", expectedOutput );
		assertStringArgs(input, expectedOutput, ""/blah/ d"");
		assertStringArgs(input, expectedOutput, ""/bLaH/Id"");
		assertStringArgs(input, expectedOutput, ""/bLaH/dI"");
	}",No Smells
"@Test
	public void testSed_printQuietCaseInsensitive() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
			.appendLine(""This is a test blah blah blah"")
			.appendLine(""This is a test blah blah"");

		assertSed(input, ""Blah"", expectedOutput, Sed.Options.quiet.ignoreCase);//should be the default command here
		assertSed(input, ""Blah"", expectedOutput, Sed.Options.n.p.I);
		assertSed(input, ""Blah"", expectedOutput, Sed.Options.print.quiet.ignoreCase);
		assertStringArgs(input, expectedOutput, ""--quiet"", ""--ignoreCase"", ""--regexp"", ""Blah"");
		assertStringArgs(input, expectedOutput, ""--quiet"", ""--print"", ""--ignoreCase"", ""--regexp"", ""Blah"");
		assertStringArgs(input, expectedOutput, ""-n"", ""-p"", ""-I"", ""--regexp"", ""Blah"");
		assertStringArgs(input, expectedOutput, ""-npI"", ""--regexp"", ""Blah"");

		assertStringArgs( input, expectedOutput, ""-n"", ""/Blah/I p"");
		assertStringArgs( input, expectedOutput, ""/Blah/I p"", ""--quiet"");

		assertStringArgs( input, expectedOutput, ""-n"", ""/Blah/Ip"");
		assertStringArgs( input, expectedOutput, ""-n"", ""/Blah/pI"");
		assertStringArgs( input, expectedOutput, ""/Blah/Ip"", ""--quiet"");
	}",No Smells
"@Test
	public void testSed_searchAndReplaceGlobalIgnoreCase() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""This is a test hasblah hasblah hasblah"")
				.appendLine(""This is a test hasblah hasblah"")
				.appendLine(""This is a test one two three"")
				.appendLine(""one"")
				.appendLine(""a"")
				.appendLine("""")
				.appendLine(""two"")
				.appendLine(""def\\d123"");

		assertSubstitute(input, ""bLaH"", ""hasblah"", expectedOutput, Sed.Options.g.I);
		assertStringArgs(input, expectedOutput, ""--ignoreCase"", ""--global"", ""--regexp"", ""bLaH"", ""--replacement"", ""hasblah"");
		assertStringArgs(input, expectedOutput, ""-gI"", ""--string1"", ""bLaH"", ""--string2"", ""hasblah"");

		assertScript( input, ""s/bLaH/hasblah/gI"", expectedOutput );
		assertStringArgs(input, expectedOutput, ""s/bLaH/hasblah/Ig"");
		assertStringArgs(input, expectedOutput, ""--script"", ""s/bLaH/hasblah/gI"");
	}",No Smells
"@Test
	public void testSed_searchAndReplaceIgnoreCase() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""This is a test hasblah blah blah"")
				.appendLine(""This is a test hasblah blah"")
				.appendLine(""This is a test one two three"")
				.appendLine(""one"")
				.appendLine(""a"")
				.appendLine("""")
				.appendLine(""two"")
				.appendLine(""def\\d123"");

		assertSubstitute(input, ""Blah"", ""hasblah"", expectedOutput, Sed.Options.ignoreCase);
		assertStringArgs(input, expectedOutput, ""--ignoreCase"", ""--regexp"", ""Blah"", ""--replacement"", ""hasblah"");
		assertStringArgs(input, expectedOutput, ""--ignoreCase"", ""--string1"", ""Blah"", ""--string2"", ""hasblah"");

		assertScript( input, ""s/Blah/hasblah/I"", expectedOutput );
		assertStringArgs(input, expectedOutput, ""s/Blah/hasblah/I"");
		assertStringArgs(input, expectedOutput, ""--script"", ""s/Blah/hasblah/I"");
	}",No Smells
"@Test
	public void testSed_searchAndReplaceOccurrence12() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""This is a test hasblah hasblah blah"")
				.appendLine(""This is a test hasblah hasblah"")
				.appendLine(""This is a test one two three"")
				.appendLine(""one"")
				.appendLine(""a"")
				.appendLine("""")
				.appendLine(""two"")
				.appendLine(""def\\d123"");

		assertSubstitute(input, ""blah"", ""hasblah"", expectedOutput, 1, 2);
		//TODO add converter for int[]
		//assertStringArgs(input, expectedOutput, ""--regexp"", ""blah"", ""--replacement"", ""hasblah"", ""--occurrence"", ""1"", ""2"");
	}",No Smells
"@Test
	public void testSed_searchAndReplaceOccurrence2() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""This is a test blah hasblah blah"")
				.appendLine(""This is a test blah hasblah"")
				.appendLine(""This is a test one two three"")
				.appendLine(""one"")
				.appendLine(""a"")
				.appendLine("""")
				.appendLine(""two"")
				.appendLine(""def\\d123"");

		assertSubstitute(input, ""blah"", ""hasblah"", expectedOutput, 2);
		//TODO add converter for int[]
		//assertStringArgs(input, expectedOutput, ""--regexp"", ""blah"", ""--replacement"", ""hasblah"", ""--occurrence"", ""2"");

		assertScript(input, ""s/blah/hasblah/2"", expectedOutput);
		assertStringArgs(input, expectedOutput, ""s/blah/hasblah/2"");
	}",No Smells
"@Test
	public void testSed_searchAndReplaceOccurrence3() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""This is a test blah blah hasblah"")
				.appendLine(""This is a test blah blah"")
				.appendLine(""This is a test one two three"")
				.appendLine(""one"")
				.appendLine(""a"")
				.appendLine("""")
				.appendLine(""two"")
				.appendLine(""def\\d123"");

		assertSubstitute(input, ""blah"", ""hasblah"", expectedOutput, 3);
		//TODO add converter for int[]
		//assertStringArgs(input, expectedOutput, ""--regexp"", ""blah"", ""--replacement"", ""hasblah"", ""--occurrence"", ""3"");

		assertScript(input, ""s/blah/hasblah/3"", expectedOutput);
		assertStringArgs(input, expectedOutput, ""s/blah/hasblah/3"");
	}",No Smells
"@Test
	public void testSortIgnoreBlanks() {
		final MultilineString input = new MultilineString();
		input
			.appendLine(""   Abc"")
			.appendLine(""  Abc"")
			.appendLine("" Abc"")
			.appendLine(""Abc"")
			.appendLine(""AAA"")
			.appendLine("" AAb"")
			.appendLine(""  Abz"")
			.appendLine(""   ZZZ"")
			.appendLine(""\t\tZZZ"")
		;

		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
			.appendLine(""AAA"")
			.appendLine("" AAb"")
			.appendLine(""   Abc"")
			.appendLine(""  Abc"")
			.appendLine("" Abc"")
			.appendLine(""Abc"")
			.appendLine(""  Abz"")
			.appendLine(""   ZZZ"")
			.appendLine(""\t\tZZZ"")
		;
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(Sort.Options.ignoreLeadingBlanks).toStringResult());
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(""--ignoreLeadingBlanks"").toStringResult());
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(""-b"").toStringResult());
	}",No Smells
"@Test
	public void testSortNumbersReverse() {
		final MultilineString input = new MultilineString();
		input
				.appendLine(""1000 To be or not to be"")
				.appendLine(""10 That is the question"")
				.appendLine(""1 Whether tis nobler in the mind"")
				.appendLine(""999 To suffer the"")
				.appendLine(""8888 10 slings and arrows"")
				.appendLine(""7 of outrageous fortune"")
				.appendLine(""6 or to bear"")
				.appendLine(""5 arms against a sea of troubles."");

		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""999 To suffer the"")
				.appendLine(""8888 10 slings and arrows"")
				.appendLine(""7 of outrageous fortune"")
				.appendLine(""6 or to bear"")
				.appendLine(""5 arms against a sea of troubles."")
				.appendLine(""1 Whether tis nobler in the mind"")
				.appendLine(""10 That is the question"")
				.appendLine(""1000 To be or not to be"");

		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(Sort.Options.reverse).toStringResult());
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(Sort.Options.r).toStringResult());
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(Sort.Options.r.u).toStringResult());
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(""-ru"").toStringResult());
	}",No Smells
"@Test
	public void testSortNumericReverse() {
		final MultilineString input = new MultilineString();
		input
				.appendLine(""1111"")
				.appendLine(""2222"")
				.appendLine(""3333"")
				.appendLine(""44"")
				.appendLine(""555"")
				.appendLine(""-1111"")
				.appendLine(""66666"")
				.appendLine(""88"")
				.appendLine(""9"")
		;

		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""66666"")
				.appendLine(""3333"")
				.appendLine(""2222"")
				.appendLine(""1111"")
				.appendLine(""555"")
				.appendLine(""88"")
				.appendLine(""44"")
				.appendLine(""9"")
				.appendLine(""-1111"")
		;

		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(Sort.Options.numericSort.reverse).toStringResult());
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(Sort.Options.n.r).toStringResult());
	}",No Smells
"@Test
	public void testSortOneLine() {
		assertEquals(""blah"", Unix4j.fromString(""blah"").sort().toStringResult());
		assertEquals(""blah"", Unix4j.fromString(""blah"").sort(Sort.Options.reverse).toStringResult());
		assertEquals(""blah"", Unix4j.fromString(""blah"").sort(Sort.Options.unique).toStringResult());
		assertEquals(""blah"", Unix4j.fromString(""blah"").sort(Sort.Options.unique.reverse).toStringResult());
		assertEquals(""blah"", Unix4j.fromString(""blah"").sort(""-ur"").toStringResult());
		assertEquals(""blah"", Unix4j.fromString(""blah"").sort(""--unique"").toStringResult());
		assertEquals(""blah"", Unix4j.fromString(""blah"").sort(""--reverse"").toStringResult());
		assertEquals(""blah"", Unix4j.fromString(""blah"").sort(""--reverse"", ""--unique"").toStringResult());
	}",No Smells
"@Test
	public void testSortUniqueIgnoreBlanks() {
		final MultilineString input = new MultilineString();
		input
			.appendLine(""   Abc"")
			.appendLine(""  Abc"")
			.appendLine("" Abc"")
			.appendLine(""Abc"")
			.appendLine(""AAA"")
			.appendLine("" AAb"")
			.appendLine(""  Abz"")
			.appendLine(""   ZZZ"")
			.appendLine(""\t\tZZZ"")
		;

		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
			.appendLine(""AAA"")
			.appendLine("" AAb"")
			.appendLine(""   Abc"")
			.appendLine(""  Abz"")
			.appendLine(""   ZZZ"")
		;
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(Sort.Options.unique.ignoreLeadingBlanks).toStringResult());
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(""-ub"").toStringResult());
	}",No Smells
"@Test
	public void testSortWithDuplicatesIgnoreCase() {
		final MultilineString input = new MultilineString();
		input
			.appendLine(""To be or not to BE"")
			.appendLine(""That is the question"")
			.appendLine(""To be or not to be"")
			.appendLine(""To suffer the"")
			.appendLine(""10 slings and arrows"")
			.appendLine(""10 slings and ARROWS"")
			.appendLine(""or to bear"")
			.appendLine(""10 slings and arrows"")
		;

		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""10 slings and arrows"")
				.appendLine(""10 slings and ARROWS"")
				.appendLine(""10 slings and arrows"")
				.appendLine(""or to bear"")
				.appendLine(""That is the question"")
				.appendLine(""To be or not to BE"")
				.appendLine(""To be or not to be"")
				.appendLine(""To suffer the"")
		;

		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(Sort.Options.ignoreCase).toStringResult());
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(""-f"").toStringResult());
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(""--ignoreCase"").toStringResult());
	}",No Smells
"@Test
	public void testSortWithDuplicateUniques() {
		final MultilineString input = new MultilineString();
		input
				.appendLine(""To be or not to BE"")
				.appendLine(""That is the question"")
				.appendLine(""To be or not to be"")
				.appendLine(""To suffer the"")
				.appendLine(""10 slings and arrows"")
				.appendLine(""10 slings and ARROWS"")
				.appendLine(""or to bear"")
				.appendLine(""10 slings and arrows"")
		;

		final MultilineString expectedOutput = new MultilineString();
		expectedOutput
				.appendLine(""10 slings and arrows"")
				.appendLine(""10 slings and ARROWS"")
				.appendLine(""or to bear"")
				.appendLine(""That is the question"")
				.appendLine(""To be or not to be"")
				.appendLine(""To be or not to BE"")
				.appendLine(""To suffer the"")
		;

		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(Sort.Options.unique).toStringResult());
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(""-u"").toStringResult());
		assertEquals(expectedOutput.toString(), Unix4j.fromString(input.toString()).sort(""--unique"").toStringResult());
	}",No Smells
"@Test
	public void testTail_1() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput.appendLine(LINE12);
		assertTail(input, 1, expectedOutput);
	}",No Smells
"@Test
	public void testUniq_Global() {
		final MultilineString expectedOutput = new MultilineString();
		expectedOutput.appendLine(LINE1);
		expectedOutput.appendLine(LINE2);
		expectedOutput.appendLine(LINE3);
		expectedOutput.appendLine(LINE4);
		expectedOutput.appendLine(LINE6);
		expectedOutput.appendLine(LINE7);
		expectedOutput.appendLine(LINE10);
		expectedOutput.appendLine(LINE16);
		assertUniq(expectedOutput, input, Uniq.Options.global);
		assertUniq(expectedOutput, input, ""--global"");
		assertUniq(expectedOutput, input, ""-g"");
	}",No Smells
"@Test
	public void testEmptyInput() {
		assertWc("""", ""  0  0  0"");
	}",No Smells
"@Test
	public void testMultipleOutputs() {
		assertWc(input.toInput(), ""   5   8  "" + (41 + 5 * LEL), Wc.Options.lines.words.chars);
		assertWc(input.toInput(), ""  5  8"", Wc.Options.lines.words);
		assertWc(input.toInput(), ""  5  8"", ""--lines"", ""--words"");
		assertWc(input.toInput(), ""  5  8"", ""-lw"");
		assertWc(input.toInput(), ""  5  8"", ""-wl"");
	}",No Smells
"@Test
	public void testSingleLine() {
		assertWc(""blah"", ""  1  1  4"");
	}",No Smells
"@Test
	public void testWcCountChars() {
//		assertEquals("""" + (41 + 5 * LEL), Unix4j.from(input.toInput()).wcCountChars().toStringResult());
		assertEquals("""" + (41 + 5 * LEL), Unix4j.from(input.toInput()).wc(Wc.Options.chars).toStringResult());
		assertEquals("""" + (41 + 5 * LEL), Unix4j.from(input.toInput()).wc(""--chars"").toStringResult());
		assertEquals("""" + (41 + 5 * LEL), Unix4j.from(input.toInput()).wc(""-m"").toStringResult());
	}",No Smells
"@Test
	public void testWcLines() {
		assertWc(input.toInput(), ""5"", Wc.Options.lines);
		assertWc(input.toInput(), ""5"", ""--lines"");
		assertWc(input.toInput(), ""5"", ""-l"");
	}",No Smells
"@Test
	public void testXargsWithDefaultCommand() {
		expect(""hello world"");
		expect(""line one"");
		expect(""tabs and spaces Bla"");
		expect(""A\0B\0C\0\0D"");
		actual(Unix4j.from(input).cat().xargs().toStringList());
	}",No Smells
"@Test
	public void testXargsWithEchoAndArgsFrom0Variable() {
		expect(""hello world"");
		expect(""line one"");
		expect(""tabs and spaces Bla"");
		expect(""A\0B\0C\0\0D"");
		actual(Unix4j.from(input).cat().xargs().echo(Arg.argsFrom(0)).toStringList());
	}",No Smells
"@Test
	public void testXargsWithEchoAndArgsFrom1Variable() {
		expect(""world"");
		expect(""one"");
		expect(""and spaces Bla"");
		expect("""");
		actual(Unix4j.from(input).cat().xargs().echo(Arg.argsFrom(1)).toStringList());
	}",No Smells
"@Test
	public void testEchoWithLongOptionAndMessage() {
		expect(""message"", ""hello"", ""world"");
		expect(OPTIONS, ""noNewline"");
		actual(""--noNewline"", ""--message"", ""hello"", ""world"");
	}",No Smells
"@Test
	public void testGrepWithLongOptionAndTwoDelimitedDefaultOperands() {
		expect(OPTIONS, ""ignoreCase"");
		expect(PATTERN, ""error"");
		expect(PATHS, ""*"");
		actualGrep(""--ignoreCase"", ""--"", ""error"", ""*"");
	}",No Smells
"@Test
	public void testGrepWithLongOptionNamedOperandAndDefaultDelimitedOperand() {
		expect(OPTIONS, ""ignoreCase"");
		expect(PATTERN, ""error"");
		expect(PATHS, ""*"");
		actualGrep(""--ignoreCase"", ""--"" + PATHS, ""*"", ""--"", ""error"");
	}",No Smells
"@Test
	public void testGrepWithTwoDefaultOperands() {
		expect(PATTERN, ""myword"");
		expect(PATHS, ""myfile.txt"");
		actualGrep(""myword"", ""myfile.txt"");
	}",No Smells
"@Test
	public void testLsWithShortOptionsAndLongAndFiles() {
		expect(OPTIONS, ""a"", ""longFormat"");
		expect(""files"", ""*"");
		actual(""-a"", ""--longFormat"", ""--files"", ""*"");
	}",No Smells
"@Test
	public void testDoubleMinMaxValue() {
		assertSmaller(decimal(Double.MAX_VALUE / 2), decimal(Double.MAX_VALUE));
		assertSmaller(decimal(Double.MIN_VALUE / 2), decimal(Double.MIN_VALUE));
		assertSmaller(""0"", decimal(Double.MIN_VALUE));

		assertGreater(decimal(-Double.MAX_VALUE / 2), decimal(-Double.MAX_VALUE));
		assertGreater(decimal(-Double.MIN_VALUE / 2), decimal(-Double.MIN_VALUE));
		assertGreater(""0"", decimal(-Double.MIN_VALUE));
		
		assertGreater("""" + Double.NaN, ""Na"");
		assertSmaller("""" + Double.NaN, ""NaNa"");
		assertGreater(""ReallyNotANumber"", ""ReallyNotANumbaaaaaaaaaa"");
		assertGreater(""2.00ReallyNotANumber"", ""2.00ReallyNotANumbaaaaaaaaaa"");
	}",No Smells
"@Test
	public void testLargeIntegers() {
		assertSmaller(""873948723948192384791283491283749812374981273948170984320548739845"", ""873948723948192384791283491283749812374981273948170984320548739846"");
		assertSmaller(""-873948723948192384791283491283749812374981273948170984320548739845"", ""-873948723948192384791283491283749812374981273948170984320548739844"");
	}",No Smells
"@Test
	public void testRandomDoublePairs() {
		super.testRandomDoublePairs(false);
	}",No Smells
"@Test
	public void testRelativePath_5_noCommonAncestor() {
		final String actual = FileUtil.getRelativePath(new File(FileUtil.ROOT + ""home/john""), new File(FileUtil.ROOT + ""var/tmp/test.out""));
		Assert.assertEquals(FileUtil.ROOT.replace('\\', '/') + ""var/tmp/test.out"", actual);
	}",Mystery Guest
"@Test
	public void testCompareUS() {
		final String[] lMonths = {""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December""}",Eager Test
"@Test
	public void testRelativePath_3_indirectParent() {
		final String actual = new RelativePathBase(""/home/john"").getRelativePathFor(""/home/john/documents/important"");
		Assert.assertEquals(""./documents/important"", actual);
	}",Mystery Guest
"@Test
	public void testDoubleMinMaxValue() {
		assertSmaller("""" + Double.MAX_VALUE, """" + Double.POSITIVE_INFINITY);
		assertSmaller("""" + (Double.MAX_VALUE / 2), """" + Double.MAX_VALUE);
		assertSmaller("""" + Double.MIN_VALUE / 2, """" + Double.MIN_VALUE);
		assertSmaller(""0"", """" + Double.MIN_VALUE);

		assertGreater("""" + -Double.MAX_VALUE, """" + -Double.POSITIVE_INFINITY);
		assertGreater("""" + (-Double.MAX_VALUE / 2), """" + -Double.MAX_VALUE);
		assertGreater("""" + -Double.MIN_VALUE / 2, """" + -Double.MIN_VALUE);
		assertGreater(""0"", """" + -Double.MIN_VALUE);
		
		assertEqual("""" + Double.NaN, """" + Double.NaN);
		assertGreater("""" + Double.NaN, """" + Double.POSITIVE_INFINITY);
		assertSmaller(""ReallyNotANumber"", """" + Double.NEGATIVE_INFINITY);
		assertGreater(""ReallyNotANumber"", ""ReallyNotANumbaaaaaaaaaa"");
	}",No Smells
"@Test
	public void testLargeDecimals() {
		assertSmaller(""0005968.48739845"", ""05968.48739846"");
		assertSmaller(""-0005968.48739845"", ""-05968.48739844"");
	}",No Smells
"@Test
	public void testRandomVeryLongIntegerPairs() {
		final int runs = 10000;
		final int maxDigits = DOUBLE_DIGITS;
		super.testRandomVeryLongIntegerPairs(runs, maxDigits);
	}",No Smells
"@Test
	public void findStartAndEndTrimNewlineChars() {
		final String s = ""\n\r\n\r  hello \r\r\n\n"";
		Assert.assertEquals(3, StringUtil.findStartTrimNewlineChars(s));
		Assert.assertEquals(s.length() - 3, StringUtil.findEndTrimNewlineChars(s));
		for (int i = 0; i < s.length(); i++) {
			final int expected = i <= 3 ? 3 : i < s.length() - 3 ? i : s.length();
			Assert.assertEquals(expected, StringUtil.findStartTrimNewlineChars(s, i));
		}",Eager Test
"@Test
	public void testFixedLengthWithIntValue() {
		final boolean[] left = {true, true, false, false, false}",Eager Test
"@Test
	public void testFixedLengthWithStringValueAndFiller() {
		final boolean[] left = {true, true, false, false, false}",Eager Test
"@Test
	public void testSplitLines() {
		final String[] input = {
				""hello\nworld"",	
				""hello\r\nworld"", 
				""hello\n\r\r\nworld"",
				""hello\n\r\r\nworld\n"",
				""hello\n\r\r\nworld\n\n"",
			}",Eager Test
"@Test
	public void testEqual() {
		assertEqual(""V1"", ""V1"");
		assertEqual(""V1.1"", ""V1.1"");
		assertEqual(""V1:1"", ""V1:1"");
		assertEqual(""V-1"", ""V-1"");

		assertEqual("" V1"", ""V1"");
		assertEqual(""V1.1"", ""V1.1 "");
		assertEqual(""V1:1\n"", ""V1:1\t"");
		assertEqual(""    V-1  "", ""   V-1 "");
	}",No Smells
"@Test
	public void testPrefixedVersionStrings() {
		assertGreater(""V:1.23.456"", ""V:1.23.455"");
		assertGreater(""V:1.23.456"", ""V:1.22.457"");
		assertGreater(""V:1.23.456"", ""V:0.23.456"");
		assertGreater(""Z:1.23.456"", ""V:1.23.456"");

		assertGreater(""V_1.2.456"", ""V_1.01.456"");
		assertGreater(""V_1.22.456"", ""V_1.11.456"");
		assertGreater(""V_1.22.456"", ""V_0.22.456"");
		assertGreater(""V_9.22.456"", ""V_8.22.456"");
		assertGreater(""V_11.22.456"", ""V_9.22.456"");
	}",No Smells
"@Test
    public void testIsUtility() {
        Asserts.assertIsUtilityClass(Actions.class);
    }",No Smells
"@Test
    public void testSetToTrue() throws Exception {
        AtomicBoolean b = new AtomicBoolean();
        Actions.setToTrue(b).run();
        assertTrue(b.get());
    }",No Smells
"@Test
    public void testConstant() throws Exception {
        Assert.assertEquals(1, (int) BiFunctions.constant(1).apply(new Object(), new Object()));
    }",No Smells
"@Test
    public void testByteArrays() {
        byte[] bytes = new byte[] { 1, 2, 3 }",No Smells
"@Test
    public void testCancelObservable() throws InterruptedException {
        System.out.println(""testCancelObservable"");
        for (int i = 0; i < 50; i++) {
            // System.out.println(i);
            long n = 5000L;
            File pageFile = new File(""target/cancelObs"" + i + "".obj"");
            pageFile.delete();
            byte[] bytes = new byte[40];
            Observable.just(bytes) //
                    .repeat(n) //
                    .to(com.github.davidmoten.rx2.observable.Transformers //
                            .onBackpressureBufferToFile() //
                            .fileFactory(Callables.constant(pageFile)) //
                            .pageSizeBytes(20000000) //
                            .serializerBytes()) //
                    .take(5) //
                    .count() //
                    .test() //
                    .awaitDone(500L, TimeUnit.SECONDS) //
                    .assertNoErrors() //
                    .assertComplete() //
                    .assertValue((long) 5);
            long t = TimeUnit.SECONDS.toMillis(5);
            while (t > 0 && pageFile.exists()) {
                long waitMs = 10;
                TimeUnit.MILLISECONDS.sleep(waitMs);
                t -= waitMs;
            }",Eager Test
"@Test
    public void testCloseQueue() {
        PagedQueue queue = Mockito.mock(PagedQueue.class);
        Mockito.doNothing().when(queue).close();
        FlowableOnBackpressureBufferToFile.close(queue);
        Mockito.verify(queue, Mockito.atLeastOnce()).close();
    }",No Smells
"@Test
    public void testError() {
        IOException e = new IOException();
        Flowable.<Integer>error(e) //
                .compose(onBackpressureBufferToFile() //
                        .<Integer>serializerJavaIO())
                .test() //
                .awaitDone(5L, TimeUnit.SECONDS) //
                .assertNoValues() //
                .assertError(e); //
    }",No Smells
"@Test
    public void testJavaIOSerializableObservableSource() {
        Observable.just(1, 2, 3) //
                .to(onBackpressureBufferToFileObservable() //
                        .pageSizeBytes(1000000) //
                        .<Integer>serializerJavaIO())
                .test() //
                .awaitDone(5000000000L, TimeUnit.SECONDS) //
                .assertValues(1, 2, 3)//
                .assertComplete();
    }",No Smells
"@Test
    public void testPollQueueThrowsExceptionEmitsError() {
        PagedQueue queue = Mockito.mock(PagedQueue.class);
        RuntimeException err = new RuntimeException();
        Mockito.doThrow(err).when(queue).poll();
        Worker worker = Schedulers.trampoline().createWorker();
        TestSubscriber<String> ts = TestSubscriber.create(1);
        BufferToFileSubscriberFlowable<String> b = new BufferToFileSubscriberFlowable<String>(ts, queue,
                Serializers.utf8(), worker);
        b.onSubscribe(IGNORE);
        b.request(1);
        b.run();
        Mockito.verify(queue, Mockito.atLeastOnce()).poll();
        ts.assertError(err);
    }",No Smells
"@Test
    public void testVeryManyByteArrays() {
        long n = N;
        byte[] bytes = new byte[40];
        new Random().nextBytes(bytes);
        long t = System.currentTimeMillis();
        Flowables.repeat(bytes, n) //
                .compose(onBackpressureBufferToFile() //
                        .pageSizeBytes(20000000) //
                        .serializerBytes()) //
                .count() //
                .test() //
                .awaitDone(500L, TimeUnit.SECONDS) //
                .assertNoErrors() //
                .assertComplete() //
                .assertValue((long) n);
        t = (System.currentTimeMillis() - t);
        DecimalFormat df = new DecimalFormat(""0.000"");
        System.out.println(""byte arrays async rate = "" + df.format((1000.0 * bytes.length * n / 1024.0 / 1024.0 / t))
                + ""MB/s, "" + ""msgs/sec = "" + df.format(n * 1000.0 / t));
    }",Eager Test
"@Test
    public void testVeryManyByteArraysObservableSource() {
        long n = N;
        byte[] bytes = new byte[40];
        new Random().nextBytes(bytes);
        long t = System.currentTimeMillis();
        Observable.just(bytes) //
                .repeat(n) //
                .to(onBackpressureBufferToFileObservable() //
                        .pageSizeBytes(20000000) //
                        .serializerBytes()) //
                .count() //
                .test() //
                .awaitDone(500L, TimeUnit.SECONDS) //
                .assertNoErrors() //
                .assertComplete() //
                .assertValue((long) n);
        t = (System.currentTimeMillis() - t);
        DecimalFormat df = new DecimalFormat(""0.000"");
        System.out
                .println(""byte arrays async rate obs = "" + df.format((1000.0 * bytes.length * n / 1024.0 / 1024.0 / t))
                        + ""MB/s, "" + ""msgs/sec = "" + df.format(n * 1000.0 / t));
    }",Eager Test
"@Test
    public void testDataSerializer() {
        // Demonstrates DataSerializer usage
        DataSerializer<Integer> ds = new DataSerializer<Integer>() {

            @Override
            public void serialize(Integer t, DataOutput out) throws IOException {
                out.writeInt(t);
            }",Eager Test
"@Test
    public void testBytesFromFileLowBufferSize() throws IOException {
        File file = new File(""target/testFromFile"");
        file.delete();
        FileOutputStream out = new FileOutputStream(file);
        out.write(""abcdefg"".getBytes());
        out.close();
        final ByteArrayOutputStream bytes = new ByteArrayOutputStream();
        Bytes //
                .from(file, 4) //
                .doOnNext(new Consumer<byte[]>() {
                    @Override
                    public void accept(byte[] b) {
                        try {
                            bytes.write(b);
                        }",Mystery Guest
"@Test
    public void testCollect() {
        byte[] a = { 1, 2, 3 }",No Smells
"@Test
    public void testCollectWithEmpty() {
        byte[] a = { 1, 2, 3 }",No Smells
"@Test
    public void testUnzipExtractSpecificFile() {
        List<String> list = Bytes.unzip(new File(""src/test/resources/test.zip"")).filter(new Predicate<ZippedEntry>() {

            @Override
            public boolean test(ZippedEntry entry) {
                return entry.getName().equals(""document2.txt"");
            }",Eager Test + Mystery Guest
"@Test
    public void testIsUtilityClass() {
        Asserts.assertIsUtilityClass(Consumers.class);
    }",No Smells
"@Test
    public void testIsUtilityClass() {
        Asserts.assertIsUtilityClass(Functions.class);
    }",No Smells
"@Test
    public void testPagePrintln() {
        Page.println(""boo"");
    }",No Smells
"@Test
    public void testPageSize() {
        Page page = new Page(new File(""target/p1""), 100);
        assertEquals(100, page.length());
        page.close();
    }",Mystery Guest
"@Test
    public void testFindsFirst() {
        DelimitedStringLinkedList s = new DelimitedStringLinkedList("":"");
        s.add(""boo:and"");
        assertEquals(""boo"", s.next());
        assertEquals(4, s.searchPosition());
        assertNull(s.next());
        assertEquals(""and"", s.remaining());
    }",No Smells
"@Test
    public void testFindsFirstLongDelimiter() {
        DelimitedStringLinkedList s = new DelimitedStringLinkedList(""::"");
        s.add(""boo::and"");
        assertEquals(""boo"", s.next());
        assertEquals(5, s.searchPosition());
        assertNull(s.next());
        assertEquals(""and"", s.remaining());
    }",No Smells
"@Test
    public void testFindsOneAcrossThree() {
        DelimitedStringLinkedList s = new DelimitedStringLinkedList("":"");
        s.add(""bo"");
        s.add(""o"");
        s.add("":and"");
        assertEquals(""boo"", s.next());
        assertNull(s.next());
        assertEquals(""and"", s.remaining());
    }",No Smells
"@Test
    public void testFindsOneEndsWithDelimiter() {
        DelimitedStringLinkedList s = new DelimitedStringLinkedList("":"");
        s.add(""boo:"");
        assertEquals(""boo"", s.next());
        assertNull(s.next());
        assertNull(s.remaining());
    }",No Smells
"@Test
    public void testNotEmptyNotFound() {
        DelimitedStringLinkedList s = new DelimitedStringLinkedList("":"");
        s.add(""boo"");
        assertNull(s.next());
        assertEquals(""boo"", s.remaining());
    }",No Smells
"@Test
    public void testAddThrows() {
        Flowable.just(3) //
                .compose(Transformers. //
                        collectWhile( //
                                Callables.<List<Integer>>constant(Lists.<Integer>newArrayList()),
                                BiFunctions.<List<Integer>, Integer, List<Integer>>throwing(), //
                                BUFFER_TWO)) //
                .test() //
                .assertNoValues() //
                .assertError(ThrowingException.class);
    }",No Smells
"@Test
    public void testBackpressureAndCancel() {

        TestSubscriber<List<Integer>> ts = Flowable.just(3, 4, 5, 6, 7, 8) //
                .compose(Transformers. //
                        toListWhile(BUFFER_TWO)) //
                .test(1) //
                .assertValue(list(3, 4)) //
                .assertNotTerminated();
        ts.cancel(); //
        ts.requestMore(Long.MAX_VALUE) //
                .assertValueCount(1) //
                .assertNotTerminated();
    }",No Smells
"@Test
    public void testConditionThrows() {
        Flowable.just(3) //
                .compose(Transformers. //
                        collectWhile( //
                                Callables.<List<Integer>>constant(Lists.<Integer>newArrayList()), ADD, //
                                BiPredicates.throwing())) //
                .test() //
                .assertNoValues() //
                .assertError(ThrowingException.class);
    }",No Smells
"@Test
    public void testRequestWhileProcessingOnNext() {
        final List<List<Integer>> list = new ArrayList<List<Integer>>();
        Subscriber<List<Integer>> subscriber = new Subscriber<List<Integer>>() {

            private Subscription parent;

            @Override
            public void onSubscribe(Subscription s) {
                this.parent = s;
                parent.request(1);
            }",No Smells
"@Test
    public void subscriberStateTest() {
        // final AtomicInteger counter = new AtomicInteger(0);
        //
        // final AtomicInteger callCount = new AtomicInteger(0);
        //
        // Flowable<Integer> o = Flowable.defer(new Func0<Flowable<Integer>>() {
        // @Override
        // public Flowable<Integer> call() {
        // return Flowable.range(1, counter.getAndIncrement() % 2);
        // }",No Smells
"@Test
    public void testFetchCompletesIfReturnsLessThanRequested() {
        Flowables.fetchPagesByRequest(FETCH_LESS) //
                .test(100) //
                .assertValueCount(99) //
                .assertComplete();
    }",No Smells
"@Test
    public void testMapLastHandlesNonFatalError() {
        final RuntimeException e = new RuntimeException();
        Flowable.range(1, 5) //
                .compose(Transformers.mapLast(new Function<Integer, Integer>() {
                    @Override
                    public Integer apply(Integer x) {
                        throw e;
                    }",No Smells
"@Test
    public void test3() {
        Flowable<Integer> a = Flowable.just(1, 2, 3);
        Flowable<Integer> b = Flowable.just(3, 2, 1);
        match(a, b, 3, 2, 1);
    }",No Smells
"@Test
    public void testCombinerFunctionBThrowsResultsInErrorEmission() {
        Flowable<Integer> a = Flowable.just(1, 2);
        Flowable<Integer> b = Flowable.just(2, 1);
        Flowables
                .match(a, b, Functions.identity(), Functions.identity(),
                        BiFunctions.<Integer, Integer, Integer> throwing())
                .test() //
                .assertNoValues() //
                .assertError(ThrowingException.class);
    }",No Smells
"@Test
    public void testEmpties() {
        Flowable<Integer> a = Flowable.empty();
        Flowable<Integer> b = Flowable.empty();
        match(a, b);
    }",No Smells
"@Test
    public void testError() {
        RuntimeException e = new RuntimeException();
        Flowable<Integer> a = Flowable.just(1, 2).concatWith(Flowable.<Integer> error(e));
        Flowable<Integer> b = Flowable.just(1, 2, 3);
        match(a, b).assertNoValues().assertError(e);
    }",No Smells
"@Test
    public void testKeyFunctionBThrowsResultsInErrorEmission() {
        Flowable<Integer> a = Flowable.just(1);
        Flowable<Integer> b = Flowable.just(1);
        Flowables.match(a, b, Functions.identity(), Functions.throwing(), COMBINER).test() //
                .assertNoValues() //
                .assertError(ThrowingException.class);
    }",No Smells
"@Test
    public void testNoMatchExistsForAtLeastOneSecondLonger() {
        Flowable<Integer> a = Flowable.just(1);
        Flowable<Integer> b = Flowable.just(1, 2);
        match(a, b, 1);
    }",No Smells
"@Test
    public void testOneDoesNotCompleteAndOtherMatchedAllShouldFinishSwitched2() {
        Flowable<Integer> a = Flowable.just(1, 2);
        Flowable<Integer> b = Flowable.just(1, 3).concatWith(Flowable.<Integer> never());
        match(a, b).assertValues(1).assertNotTerminated();
    }",No Smells
"@Test
    public void testOneDoesNotCompleteAndOtherMatchedAllShouldFinishSwitched2() {
        Flowable<Integer> a = Flowable.just(1, 2);
        Flowable<Integer> b = Flowable.just(1, 3).concatWith(Flowable.<Integer> never());
        match(a, b).assertValues(1).assertNotTerminated();
    }",No Smells
"@Test
    public void testUnsubscribe() {
        AtomicBoolean unsubA = new AtomicBoolean(false);
        AtomicBoolean unsubB = new AtomicBoolean(false);
        Flowable<Integer> a = Flowable.just(1, 2, 5, 7, 6, 8).doOnCancel(Actions.setToTrue(unsubA));
        Flowable<Integer> b = Flowable.just(3, 4, 5, 6, 7).doOnCancel(Actions.setToTrue(unsubB));
        final List<Integer> list = new ArrayList<Integer>();
        final AtomicBoolean terminal = new AtomicBoolean();
        matchThem(a, b) //
                .doOnTerminate(Actions.setToTrue(terminal)) //
                .doOnNext(Consumers.println()) //
                .subscribe(new Subscriber<Integer>() {

                    private Subscription s;

                    @Override
                    public void onSubscribe(Subscription s) {
                        this.s = s;
                        s.request(Long.MAX_VALUE);
                    }",Eager Test
"@Test
    public void checkEmptyMaxRequestOneDownstreamRequestsMaxValue() {
        List<Long> requests = new CopyOnWriteArrayList<Long>();
        Flowable.<Integer>empty() //
                .doOnRequest(Consumers.addLongTo(requests)) //
                .compose(Transformers.maxRequest(1)) //
                .test() //
                .assertNoValues() //
                .assertComplete();
        assertEquals(Arrays.asList(1L), requests);
    }",No Smells
"@Test
    public void checkMaxRequestOneDownstreamRequestMaxValue() {
        checkMaxRequestDownstreamRequestMaxValue(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L);
    }",No Smells
"@Test
    public void checkMaxRequestThreeDownstreamRequestMaxValue() {
        checkMaxRequestDownstreamRequestMaxValue(3L, 3L, 3L, 3L, 3L);
    }",No Smells
"@Test
    public void checkMaxRequestTwoDownstreamRequestMaxValue() {
        checkMaxRequestDownstreamRequestMaxValue(2L, 2L, 2L, 2L, 2L, 2L, 2L);
    }",No Smells
"@Test
    public void checkSingleMaxRequestMaxValueDownstreamRequestsMaxValue() {
        List<Long> requests = new CopyOnWriteArrayList<Long>();
        Flowable.just(1) //
                .doOnRequest(Consumers.addLongTo(requests)) //
                .compose(Transformers.maxRequest(Long.MAX_VALUE)) //
                .test() //
                .assertValue(1) //
                .assertComplete();
        assertEquals(Arrays.asList(Long.MAX_VALUE), requests);
    }",No Smells
"@Test
    public void testAsyncMaxRequestIsMax() {
        int N = 10000;
        Flowable.range(1, N) //
                .compose(Transformers.maxRequest(Long.MAX_VALUE)) //
                .observeOn(Schedulers.computation()) //
                .test(N + 10) //
                .awaitDone(1, TimeUnit.MINUTES) //
                .assertValueCount(N) //
                .assertComplete(); //
    }",No Smells
"@Test
    public void testMinWhenRequestIsMaxValue() {
        List<Long> requests = new CopyOnWriteArrayList<Long>();
        Flowable.range(1, 10) //
                .doOnRequest(Consumers.addLongTo(requests)) //
                .compose(Transformers.minRequest(2)) //
                .test() //
                .assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) //
                .assertComplete();
        assertEquals(Lists.newArrayList(Long.MAX_VALUE), requests);
    }",No Smells
"@Test
    public void testRebatchRequestsMinEqualsMaxDontConstrainFirstUsesRxJavaCoreRebatchRequests() {
        List<Long> requests = new CopyOnWriteArrayList<Long>();
        Flowable.range(1, 10) //
                .doOnRequest(Consumers.addLongTo(requests)) //
                .compose(Transformers.rebatchRequests(5, 5)) //
                .test() //
                .assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) //
                .assertComplete();
        assertEquals(Lists.newArrayList(5L, 4L, 4L), requests);
    }",No Smells
"@Test
    public void testBackpressureOnErrorNoRequests() {
        Flowable.<Integer>error(new ThrowingException())//
                .to(Transformers.reduce(plusOne, 2, 3)) //
                .test(0) //
                .assertNoValues() //
                .assertError(ThrowingException.class);
    }",No Smells
"@Test
    public void testCompletesFirstLevel() {
        check(2, 2);
    }",No Smells
"@Test
    public void testCompletesThirdLevelWithOneLeftOver() {
        check(5, 2);
    }",No Smells
"@Test
    public void testDematerialize() {
        Flowable.just(Notification.createOnNext(1)).dematerialize().count().blockingGet();
        Flowable.empty().dematerialize().count().blockingGet();
    }",No Smells
"@Test
    public void testEmpty() {
        int result = Flowable.<Integer>empty() //
                .to(Transformers.reduce(reducer, 2)) //
                .single(-1) //
                .blockingGet();
        Assert.assertEquals(-1, result);
    }",No Smells
"@Test
    public void testErrorPostChaining() {
        Flowable.range(1, 100) //
                .concatWith(Flowable.<Integer>error(new ThrowingException())) //
                .to(Transformers.reduce(reducer, 2)) //
                .test() //
                .assertNoValues() //
                .assertError(ThrowingException.class);
    }",No Smells
"@Test
    public void testMaxIterationsOne() {
        Function<Observable<Integer>, Observable<?>> tester = new Function<Observable<Integer>, Observable<?>>() {
            @Override
            public Observable<?> apply(Observable<Integer> o) throws Exception {
                return o.concatWith(Observable.<Integer>never());
            }",No Smells
"@Test
    public void testOneAsync() {
        checkAsync(1, 2);
    }",No Smells
"@Test
    public void testStackOverflowDoesNotHappen() {
        Flowable.range(1, 3) //
        .to(Transformers.reduce(plusOne, 2, 10000)) //
        .test();
    }",No Smells
"@Test
    public void testIsUtilityClass() {
        Asserts.assertIsUtilityClass(FlowableReverse.class);
    }",No Smells
"@Test
    public void testCloserWhenDoesNotThrow() throws Exception {
        final AtomicBoolean called = new AtomicBoolean();
        Closeable c = new Closeable() {

            @Override
            public void close() throws IOException {
                called.set(true);
            }",No Smells
"@Test
    public void testAsync() {
        final AtomicInteger n = new AtomicInteger(0);
        final int N = 1000000;
        Flowable.range(1, N) //
                .compose(passThrough(1)) //
                .observeOn(Schedulers.computation()) //
                .rebatchRequests(100) //
                .doOnNext(new Consumer<Integer>() {
                    @Override
                    public void accept(Integer value) throws Exception {
                        if (!n.compareAndSet(value - 1, value)) {
                            throw new RuntimeException();
                        }",No Smells
"@Test
    public void testCancelFromTransition() {
        FlowableTransformer<Integer, Integer> sm = StateMachine2.builder() //
                .initialState("""") //
                .transition(new Transition2<String, Integer, Integer>() {

                    @Override
                    public String apply(String state, Integer value, Emitter<Integer> emitter) {
                       emitter.cancel_();
                       return state;
                    }",No Smells
"@Test
    public void testErrorPassThrough() {
        RuntimeException e = new RuntimeException();
        Flowable.<Integer> error(e) //
                .compose(passThrough(1)) //
                .test() //
                .assertNoValues() //
                .assertError(e);
    }",No Smells
"@Test
    public void testOnNextThrowsWithBurstSource() {
        FlowableTransformer<Integer, Integer> sm = StateMachine2.builder() //
                .initialState("""") //
                .transition(new Transition2<String, Integer, Integer>() {

                    @Override
                    public String apply(String state, Integer value, Emitter<Integer> emitter) {
                        throw new ThrowingException();
                    }",No Smells
"@Test
    public void testOnNextThrowsWithBurstSourceThatTerminatesWithError() {
        List<Throwable> list = new CopyOnWriteArrayList<Throwable>();
        try {
            RxJavaPlugins.setErrorHandler(Consumers.addTo(list));
            FlowableTransformer<Integer, Integer> sm = StateMachine2.builder() //
                    .initialState("""") //
                    .transition(new Transition2<String, Integer, Integer>() {

                        @Override
                        public String apply(String state, Integer value, Emitter<Integer> emitter) {
                            throw new ThrowingException();
                        }",Eager Test
"@Test
    public void testStateFactoryReturnsNull() {
        FlowableTransformer<Integer, Integer> sm = StateMachine2.builder() //
                .initialStateFactory(new Callable<String>() {
                    @Override
                    public String call() throws Exception {
                        return null;
                    }",No Smells
"@Test
    public void assertIsUtilityClass() {
        Asserts.assertIsUtilityClass(FlowableStringInputStream.class);
    }",No Smells
"@Test
    public void simple() throws Exception {

        //defaults to utf-8
        InputStream is = Strings.toInputStream(Flowable.just(""abc"", ""def"", ""ghi"", ""jkl"", ""mno""));
        byte[] buf = new byte[4];

        assertEquals(3, is.available());

        assertEquals('a', is.read());

        assertEquals(2, is.available());

        assertEquals(2, is.read(buf));

        assertEquals('b', buf[0]);
        assertEquals('c', buf[1]);

        assertEquals(1, is.read(buf, 2, 1));

        assertEquals('d', buf[2]);

        assertEquals(1, is.read(buf, 3, 1));

        assertEquals('e', buf[3]);

        assertEquals(1, is.read(buf));

        assertEquals('f', buf[0]);

        buf = new byte[9];

        DataInputStream bin = new DataInputStream(is);

        bin.readFully(buf, 0, 9);

        assertArrayEquals(""ghijklmno"".getBytes(utf8), buf);

        assertEquals(-1, is.read());

        assertEquals(-1, is.read(buf));

        assertEquals(0, is.available());
    }",No Smells
"@Test
    public void testDecreasing() {
        List<Integer> list = Flowable.just(4, 3, 2, 1).compose(Transformers.<Integer>windowMin(2)).toList()
                .blockingGet();
        assertEquals(Arrays.asList(3, 2, 1), list);
    }",No Smells
"@Test
    public void testWindowMax() {
        List<Integer> list = Flowable.just(4, 3, 2, 1).compose(Transformers.<Integer>windowMax(2)).toList()
                .blockingGet();
        assertEquals(Arrays.asList(4, 3, 2), list);
    }",No Smells
"@Test
    public void testIsUtilClass() {
        Asserts.assertIsUtilityClass(TransformerDecode.class);
    }",No Smells
"@Test
    public void testExponentialBackoff() {
        Exception ex = new IllegalArgumentException(""boo"");
        TestSubscriber<Integer> ts = TestSubscriber.create();
        final AtomicInteger logCalls = new AtomicInteger();
        Consumer<ErrorAndDuration> log = new Consumer<ErrorAndDuration>() {

            @Override
            public void accept(ErrorAndDuration e) {
                System.out.println(""WARN: "" + e.throwable().getMessage());
                System.out.println(""waiting for "" + e.durationMs() + ""ms"");
                logCalls.incrementAndGet();
            }",Eager Test
"@Test
    public void testRetryWhenMultipleRetriesWorkOnSingleDelay() {
        AtomicInteger count = new AtomicInteger();
        TestSubscriber<Object> ts = TestSubscriber.create();
        Exception exception = new Exception(""boo"");
        Flowable.error(exception) //
                .doOnSubscribe(Consumers.increment(count)) //
                .retryWhen(RetryWhen //
                        .delay(1, TimeUnit.MILLISECONDS) //
                        .scheduler(Schedulers.trampoline()) //
                        .maxRetries(10).build()) //
                .subscribe(ts);
        ts.assertTerminated();
        assertFalse(ts.errors().isEmpty());
        assertEquals(exception, ts.errors().get(0));
        assertEquals(11, count.get());
    }",Eager Test
"@Test
    public void testRetryWhenSpecificExceptionAllowedUsePredicateReturnsTrue() {
        Exception ex = new IllegalArgumentException(""boo"");
        TestSubscriber<Integer> ts = TestSubscriber.create();
        TestScheduler scheduler = new TestScheduler();
        Predicate<Throwable> predicate = new Predicate<Throwable>() {
            @Override
            public boolean test(Throwable t) {
                return t instanceof IllegalArgumentException;
            }",Eager Test
"@Test
    public void testRetryWhenSpecificExceptionFailsBecauseIsNotInstanceOf() {
        Exception ex = new IllegalArgumentException(""boo"");
        TestSubscriber<Integer> ts = TestSubscriber.create();
        TestScheduler scheduler = new TestScheduler();
        Flowable.just(1, 2)
                // force error after 3 emissions
                .concatWith(Flowable.<Integer>error(ex))
                // retry with backoff
                .retryWhen(RetryWhen.maxRetries(2).action(log).exponentialBackoff(1, TimeUnit.MINUTES)
                        .scheduler(scheduler).retryWhenInstanceOf(SQLException.class).build())
                // go
                .subscribe(ts);
        ts.assertValues(1, 2);
        ts.assertError(ex);
    }",Eager Test
"@Test
    public void testIsUtilityClass() {
        Asserts.assertIsUtilityClass(SchedulerHelper.class);
    }",No Smells
"@Test
    public void testWithCallSite() {
        Scheduler s = SchedulerHelper.withThreadIdFromCallSite(Schedulers.trampoline());
        final StringBuilder b = new StringBuilder();
        String main = Thread.currentThread().getName();
        s.createWorker().schedule(new Runnable() {

            @Override
            public void run() {
                b.append(Thread.currentThread().getName());
            }",Eager Test
"@Test
    public void testWithId() {
        Scheduler s = SchedulerHelper.withThreadId(Schedulers.trampoline(), ""boo"");
        final StringBuilder b = new StringBuilder();
        String main = Thread.currentThread().getName();
        s.createWorker().schedule(new Runnable() {

            @Override
            public void run() {
                b.append(Thread.currentThread().getName());
            }",Eager Test
"@Test
    public void testConcatTransformer() {
        Flowable.just(""hello "", ""there"") //
                .to(Strings.concat()) //
                .test() //
                .assertValue(""hello there"") //
                .assertComplete();
    }",No Smells
"@Test
    public void testConcatTransformer() {
        Flowable.just(""hello "", ""there"") //
                .to(Strings.concat()) //
                .test() //
                .assertValue(""hello there"") //
                .assertComplete();
    }",No Smells
"@Test
    public void testJoinTransformer() {
        Flowable.just(""hello "", ""there"") //
                .to(Strings.join()) //
                .test() //
                .assertValue(""hello there"") //
                .assertComplete();
    }",No Smells
"@Test
    public void testMalformedInTheMiddleReplace() {
        Flowable<byte[]> src = Flowable.just(new byte[] { (byte) 0xc2, 65 }",No Smells
"@Test
    public void testHashcode() {
        CategoryLineAnnotation a1 = new CategoryLineAnnotation(""Category 1"", 
                1.0, ""Category 2"", 2.0, Color.RED, new BasicStroke(1.0f));
        CategoryLineAnnotation a2 = new CategoryLineAnnotation(""Category 1"", 
                1.0, ""Category 2"", 2.0, Color.RED, new BasicStroke(1.0f));
        assertEquals(a1, a2);
        int h1 = a1.hashCode();
        int h2 = a2.hashCode();
        assertEquals(h1, h2);
    }",No Smells
"@Test
    public void testPublicCloneable() {
        CategoryTextAnnotation a1 = new CategoryTextAnnotation(
                ""Test"", ""Category"", 1.0);
        assertTrue(a1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testSerialization() {
        CategoryTextAnnotation a1 = new CategoryTextAnnotation(""Test"", 
                ""Category"", 1.0);
        CategoryTextAnnotation a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testChangeEvents() {
        TextAnnotation a = new CategoryTextAnnotation(""Test"", ""A"", 1.0);
        a.addChangeListener(this);
        this.lastEvent = null;
        a.setText(""B"");
        assertNotNull(this.lastEvent);
                this.lastEvent = null;
        a.setText(""B"");
        assertNotNull(this.lastEvent);
        
        this.lastEvent = null;
        a.setFont(new Font(""SansSerif"", Font.PLAIN, 12));
        assertNotNull(this.lastEvent);

        this.lastEvent = null;
        a.setPaint(Color.BLUE);
        assertNotNull(this.lastEvent);
        
        this.lastEvent = null;
        a.setTextAnchor(TextAnchor.CENTER_LEFT);
        assertNotNull(this.lastEvent);
        
        this.lastEvent = null;
        a.setRotationAnchor(TextAnchor.CENTER_LEFT);
        assertNotNull(this.lastEvent);

        this.lastEvent = null;
        a.setRotationAngle(123.4);
        assertNotNull(this.lastEvent);
   }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        XYBoxAnnotation a1 = new XYBoxAnnotation(1.0, 2.0, 3.0, 4.0,
                new BasicStroke(1.2f), Color.RED, Color.BLUE);
        XYBoxAnnotation a2 = CloneUtils.clone(a1);
        assertNotSame(a1, a2);
        assertSame(a1.getClass(), a2.getClass());
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testDrawWithNullInfo() {
        try {
            DefaultTableXYDataset<String> dataset = new DefaultTableXYDataset<>();

            XYSeries<String> s1 = new XYSeries<>(""Series 1"", true, false);
            s1.add(5.0, 5.0);
            s1.add(10.0, 15.5);
            s1.add(15.0, 9.5);
            s1.add(20.0, 7.5);
            dataset.addSeries(s1);

            XYSeries<String> s2 = new XYSeries<>(""Series 2"", true, false);
            s2.add(5.0, 5.0);
            s2.add(10.0, 15.5);
            s2.add(15.0, 9.5);
            s2.add(20.0, 3.5);
            dataset.addSeries(s2);
            XYPlot<String> plot = new XYPlot<>(dataset,
                    new NumberAxis(""X""), new NumberAxis(""Y""),
                    new XYLineAndShapeRenderer());
            plot.addAnnotation(new XYBoxAnnotation(10.0, 12.0, 3.0, 4.0,
                    new BasicStroke(1.2f), Color.RED, Color.BLUE));
            JFreeChart chart = new JFreeChart(plot);
            /* BufferedImage image = */ chart.createBufferedImage(300, 200,
                    null);
        }",Eager Test
"@Test
    public void testEquals() {
        XYBoxAnnotation a1 = new XYBoxAnnotation(1.0, 2.0, 3.0, 4.0,
                new BasicStroke(1.2f), Color.RED, Color.BLUE);
        XYBoxAnnotation a2 = new XYBoxAnnotation(1.0, 2.0, 3.0, 4.0,
                new BasicStroke(1.2f), Color.RED, Color.BLUE);
        assertEquals(a1, a2);
        assertEquals(a2, a1);

        // x0
        a1 = new XYBoxAnnotation(2.0, 2.0, 3.0, 4.0, new BasicStroke(1.2f),
                Color.RED, Color.BLUE);
        assertNotEquals(a1, a2);
        a2 = new XYBoxAnnotation(2.0, 2.0, 3.0, 4.0, new BasicStroke(1.2f),
                Color.RED, Color.BLUE);
        assertEquals(a1, a2);

        // stroke
        a1 = new XYBoxAnnotation(1.0, 2.0, 3.0, 4.0, new BasicStroke(2.3f),
                Color.RED, Color.BLUE);
        assertNotEquals(a1, a2);
        a2 = new XYBoxAnnotation(1.0, 2.0, 3.0, 4.0, new BasicStroke(2.3f),
                Color.RED, Color.BLUE);
        assertEquals(a1, a2);

        GradientPaint gp1a = new GradientPaint(1.0f, 2.0f, Color.BLUE,
                3.0f, 4.0f, Color.RED);
        GradientPaint gp1b = new GradientPaint(1.0f, 2.0f, Color.BLUE,
                3.0f, 4.0f, Color.RED);
        GradientPaint gp2a = new GradientPaint(5.0f, 6.0f, Color.pink,
                7.0f, 8.0f, Color.WHITE);
        GradientPaint gp2b = new GradientPaint(5.0f, 6.0f, Color.pink,
                7.0f, 8.0f, Color.WHITE);

        // outlinePaint
        a1 = new XYBoxAnnotation(1.0, 2.0, 3.0, 4.0, new BasicStroke(2.3f),
                gp1a, Color.BLUE);
        assertNotEquals(a1, a2);
        a2 = new XYBoxAnnotation(1.0, 2.0, 3.0, 4.0, new BasicStroke(2.3f),
                gp1b, Color.BLUE);
        assertEquals(a1, a2);

        // fillPaint
        a1 = new XYBoxAnnotation(1.0, 2.0, 3.0, 4.0, new BasicStroke(2.3f),
                gp1a, gp2a);
        assertNotEquals(a1, a2);
        a2 = new XYBoxAnnotation(1.0, 2.0, 3.0, 4.0, new BasicStroke(2.3f),
                gp1b, gp2b);
        assertEquals(a1, a2);
    }",Eager Test
"@Test
    public void testSerialization() {
        XYBoxAnnotation a1 = new XYBoxAnnotation(1.0, 2.0, 3.0, 4.0,
                new BasicStroke(1.2f), Color.RED, Color.BLUE);
        XYBoxAnnotation a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testEquals() {
        XYDrawableAnnotation a1 = new XYDrawableAnnotation(10.0, 20.0, 100.0,
                200.0, new TestDrawable());
        XYDrawableAnnotation a2 = new XYDrawableAnnotation(10.0, 20.0, 100.0,
                200.0, new TestDrawable());
        assertEquals(a1, a2);

        a1 = new XYDrawableAnnotation(11.0, 20.0, 100.0, 200.0,
                new TestDrawable());
        assertNotEquals(a1, a2);
        a2 = new XYDrawableAnnotation(11.0, 20.0, 100.0, 200.0,
                new TestDrawable());
        assertEquals(a1, a2);

        a1 = new XYDrawableAnnotation(11.0, 22.0, 100.0, 200.0,
                new TestDrawable());
        assertNotEquals(a1, a2);
        a2 = new XYDrawableAnnotation(11.0, 22.0, 100.0, 200.0,
                new TestDrawable());
        assertEquals(a1, a2);

        a1 = new XYDrawableAnnotation(11.0, 22.0, 101.0, 200.0,
                new TestDrawable());
        assertNotEquals(a1, a2);
        a2 = new XYDrawableAnnotation(11.0, 22.0, 101.0, 200.0,
                new TestDrawable());
        assertEquals(a1, a2);

        a1 = new XYDrawableAnnotation(11.0, 22.0, 101.0, 202.0,
                new TestDrawable());
        assertNotEquals(a1, a2);
        a2 = new XYDrawableAnnotation(11.0, 22.0, 101.0, 202.0,
                new TestDrawable());
        assertEquals(a1, a2);

        a1 = new XYDrawableAnnotation(11.0, 22.0, 101.0, 202.0, 2.0,
                new TestDrawable());
        assertNotEquals(a1, a2);
        a2 = new XYDrawableAnnotation(11.0, 22.0, 101.0, 202.0, 2.0,
                new TestDrawable());
        assertEquals(a1, a2);
    }",Eager Test
"@Test
    public void testSerialization() {
        XYDrawableAnnotation a1 = new XYDrawableAnnotation(10.0, 20.0, 100.0,
                200.0, new TestDrawable());
        XYDrawableAnnotation a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testHashCode() {
        XYPointerAnnotation a1 = new XYPointerAnnotation(""Label"", 10.0, 20.0,
                Math.PI);
        XYPointerAnnotation a2 = new XYPointerAnnotation(""Label"", 10.0, 20.0,
                Math.PI);
        assertEquals(a1, a2);
        int h1 = a1.hashCode();
        int h2 = a2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        Stroke stroke1 = new BasicStroke(2.0f);
        XYPolygonAnnotation a1 = new XYPolygonAnnotation(new double[] {1.0,
                2.0, 3.0, 4.0, 5.0, 6.0}",Eager Test
"@Test
    public void testEquals() {
        Stroke stroke1 = new BasicStroke(2.0f);
        Stroke stroke2 = new BasicStroke(2.5f);
        XYPolygonAnnotation a1 = new XYPolygonAnnotation(new double[] {1.0,
                2.0, 3.0, 4.0, 5.0, 6.0}",Eager Test
"@Test
    public void testSerialization() {
        Stroke stroke1 = new BasicStroke(2.0f);
        XYPolygonAnnotation a1 = new XYPolygonAnnotation(new double[] {1.0,
                2.0, 3.0, 4.0, 5.0, 6.0}",No Smells
"@Test
    public void testEquals() {

        XYShapeAnnotation a1 = new XYShapeAnnotation(
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0),
                new BasicStroke(1.2f), Color.RED, Color.BLUE);
        XYShapeAnnotation a2 = new XYShapeAnnotation(
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0),
                new BasicStroke(1.2f), Color.RED, Color.BLUE);
        assertEquals(a1, a2);
        assertEquals(a2, a1);

        // shape
        a1 = new XYShapeAnnotation(
                new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(1.2f), Color.RED, Color.BLUE);
        assertNotEquals(a1, a2);
        a2 = new XYShapeAnnotation(
                new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(1.2f), Color.RED, Color.BLUE);
        assertEquals(a1, a2);

        // stroke
        a1 = new XYShapeAnnotation(
                new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(2.3f), Color.RED, Color.BLUE);
        assertNotEquals(a1, a2);
        a2 = new XYShapeAnnotation(
                new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(2.3f), Color.RED, Color.BLUE);
        assertEquals(a1, a2);

        GradientPaint gp1a = new GradientPaint(1.0f, 2.0f, Color.BLUE,
                3.0f, 4.0f, Color.RED);
        GradientPaint gp1b = new GradientPaint(1.0f, 2.0f, Color.BLUE,
                3.0f, 4.0f, Color.RED);
        GradientPaint gp2a = new GradientPaint(5.0f, 6.0f, Color.pink,
                7.0f, 8.0f, Color.WHITE);
        GradientPaint gp2b = new GradientPaint(5.0f, 6.0f, Color.pink,
                7.0f, 8.0f, Color.WHITE);

        // outlinePaint
        a1 = new XYShapeAnnotation(
                new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(2.3f), gp1a, Color.BLUE);
        assertNotEquals(a1, a2);
        a2 = new XYShapeAnnotation(
                new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(2.3f), gp1b, Color.BLUE);
        assertEquals(a1, a2);

        // fillPaint
        a1 = new XYShapeAnnotation(
                new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(2.3f), gp1a, gp2a);
        assertNotEquals(a1, a2);
        a2 = new XYShapeAnnotation(
                new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(2.3f), gp1b, gp2b);
        assertEquals(a1, a2);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        XYTextAnnotation a1 = new XYTextAnnotation(""Text"", 10.0, 20.0);
        XYTextAnnotation a2 = (XYTextAnnotation) a1.clone();
        assertNotSame(a1, a2);
        assertSame(a1.getClass(), a2.getClass());
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testSerialization() {
        XYTextAnnotation a1 = new XYTextAnnotation(""Text"", 10.0, 20.0);
        a1.setOutlinePaint(new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f, 4.0f,
                Color.BLUE));
        XYTextAnnotation a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testEquals() {
        TextTitle t = new TextTitle(""Title"");
        XYTitleAnnotation a1 = new XYTitleAnnotation(1.0, 2.0, t);
        XYTitleAnnotation a2 = new XYTitleAnnotation(1.0, 2.0, t);
        assertEquals(a1, a2);
        
        a1 = new XYTitleAnnotation(1.1, 2.0, t);
        assertNotEquals(a1, a2);
        a2 = new XYTitleAnnotation(1.1, 2.0, t);
        assertEquals(a1, a2);

        a1 = new XYTitleAnnotation(1.1, 2.2, t);
        assertNotEquals(a1, a2);
        a2 = new XYTitleAnnotation(1.1, 2.2, t);
        assertEquals(a1, a2);
        
        TextTitle t2 = new TextTitle(""Title 2"");
        a1 = new XYTitleAnnotation(1.1, 2.2, t2);
        assertNotEquals(a1, a2);
        a2 = new XYTitleAnnotation(1.1, 2.2, t2);
        assertEquals(a1, a2);
    }",Eager Test
"@Test
    public void testSerialization() {
        TextTitle t = new TextTitle(""Title"");
        XYTitleAnnotation a1 = new XYTitleAnnotation(1.0, 2.0, t);
        XYTitleAnnotation a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);
    }",Eager Test
"@Test
    public void testSerialization() {
        AxisLocation location1 = AxisLocation.BOTTOM_OR_RIGHT;
        AxisLocation location2 = TestUtils.serialised(location1);
        assertEquals(location1, location2);
        boolean same = location1 == location2;
        assertTrue(same);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        AxisSpace s1 = new AxisSpace();
        AxisSpace s2 = (AxisSpace) s1.clone();
        assertNotSame(s1, s2);
        assertSame(s1.getClass(), s2.getClass());
        assertEquals(s1, s2);
    }",No Smells
"@Test
    public void testHashCode() {
        CategoryAnchor a1 = CategoryAnchor.START;
        CategoryAnchor a2 = CategoryAnchor.START;
        assertEquals(a1, a2);
        int h1 = a1.hashCode();
        int h2 = a2.hashCode();
        assertEquals(h1, h2);
    }",No Smells
"@Test
    public void testCloning2() throws CloneNotSupportedException {
        CategoryAxis a1 = new CategoryAxis(""Test"");
        a1.setTickLabelFont(""C1"", new Font(""Dialog"", Font.PLAIN, 15));
        a1.setTickLabelPaint(""C1"", new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.WHITE));
        CategoryAxis a2 = (CategoryAxis) a1.clone();
        assertNotSame(a1, a2);
        assertSame(a1.getClass(), a2.getClass());
        assertEquals(a1, a2);

        // check that changing a tick label font in a1 doesn't change a2
        a1.setTickLabelFont(""C1"", null);
        assertNotEquals(a1, a2);
        a2.setTickLabelFont(""C1"", null);
        assertEquals(a1, a2);

        // check that changing a tick label paint in a1 doesn't change a2
        a1.setTickLabelPaint(""C1"", Color.YELLOW);
        assertNotEquals(a1, a2);
        a2.setTickLabelPaint(""C1"", Color.YELLOW);
        assertEquals(a1, a2);

        // check that changing a category label tooltip in a1 doesn't change a2
        a1.addCategoryLabelToolTip(""C1"", ""XYZ"");
        assertNotEquals(a1, a2);
        a2.addCategoryLabelToolTip(""C1"", ""XYZ"");
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testHashCode() {
        CategoryAxis a1 = new CategoryAxis(""Test"");
        CategoryAxis a2 = new CategoryAxis(""Test"");
        assertEquals(a1, a2);
        int h1 = a1.hashCode();
        int h2 = a2.hashCode();
        assertEquals(h1, h2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        CategoryTick t1 = new CategoryTick(""C1"", new TextBlock(), 
                TextBlockAnchor.CENTER, TextAnchor.CENTER, 1.5f);
        CategoryTick t2 = (CategoryTick) t1.clone();
        assertNotSame(t1, t2);
        assertSame(t1.getClass(), t2.getClass());
        assertEquals(t1, t2);
    }",No Smells
"@Test
    public void testHashCode() {
        Comparable<String> c1 = ""C1"";
        TextBlock tb1 = new TextBlock();
        tb1.addLine(new TextLine(""Block 1""));
        tb1.addLine(new TextLine(""Block 2""));
        TextBlockAnchor tba1 = TextBlockAnchor.CENTER;
        TextAnchor ta1 = TextAnchor.CENTER;

        CategoryTick t1 = new CategoryTick(c1, tb1, tba1, ta1, 1.0f);
        CategoryTick t2 = new CategoryTick(c1, tb1, tba1, ta1, 1.0f);
        assertEquals(t1, t2);
        int h1 = t1.hashCode();
        int h2 = t2.hashCode();
        assertEquals(h1, h2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        CyclicNumberAxis a1 = new CyclicNumberAxis(10, 0, ""Test"");
        CyclicNumberAxis a2 = (CyclicNumberAxis) a1.clone();
        assertNotSame(a1, a2);
        assertSame(a1.getClass(), a2.getClass());
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testHashCode() {
        CyclicNumberAxis a1 = new CyclicNumberAxis(10, 0, ""Test"");
        CyclicNumberAxis a2 = new CyclicNumberAxis(10, 0, ""Test"");
        assertEquals(a1, a2);
        int h1 = a1.hashCode();
        int h2 = a2.hashCode();
        assertEquals(h1, h2);
    }",No Smells
"@Test
    public void testSerialization() {
        CyclicNumberAxis a1 = new CyclicNumberAxis(10, 0, ""Test Axis"");
        CyclicNumberAxis a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testPreviousStandardDateDayB() {
        MyDateAxis axis = new MyDateAxis(""Day"");
        Day apr12007 = new Day(1, 4, 2007);
        Day apr22007 = new Day(2, 4, 2007);

        // five dates to check...
        Date d0 = new Date(apr12007.getFirstMillisecond());
        Date d1 = new Date(apr12007.getFirstMillisecond() + 500L);
        Date d2 = new Date(apr12007.getMiddleMillisecond());
        Date d3 = new Date(apr12007.getMiddleMillisecond() + 500L);
        Date d4 = new Date(apr12007.getLastMillisecond());

        Date end = new Date(apr22007.getLastMillisecond());

        DateTickUnit unit = new DateTickUnit(DateTickUnitType.DAY, 7);
        axis.setTickUnit(unit);

        // START: check d0 and d1
        axis.setTickMarkPosition(DateTickMarkPosition.START);

        axis.setRange(d0, end);
        Date psd = axis.previousStandardDate(d0, unit);
        Date nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d0.getTime());
        assertTrue(nsd.getTime() >= d0.getTime());

        axis.setRange(d1, end);
        psd = axis.previousStandardDate(d1, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d1.getTime());
        assertTrue(nsd.getTime() >= d1.getTime());

        // MIDDLE: check d1, d2 and d3
        axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);

        axis.setRange(d1, end);
        psd = axis.previousStandardDate(d1, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d1.getTime());
        assertTrue(nsd.getTime() >= d1.getTime());

        axis.setRange(d2, end);
        psd = axis.previousStandardDate(d2, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d2.getTime());
        assertTrue(nsd.getTime() >= d2.getTime());

        axis.setRange(d3, end);
        psd = axis.previousStandardDate(d3, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d3.getTime());
        assertTrue(nsd.getTime() >= d3.getTime());

        // END: check d3 and d4
        axis.setTickMarkPosition(DateTickMarkPosition.END);

        axis.setRange(d3, end);
        psd = axis.previousStandardDate(d3, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d3.getTime());
        assertTrue(nsd.getTime() >= d3.getTime());

        axis.setRange(d4, end);
        psd = axis.previousStandardDate(d4, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d4.getTime());
        assertTrue(nsd.getTime() >= d4.getTime());
    }",Eager Test
"@Test
    public void testPreviousStandardDateMillisecondA() {
        MyDateAxis axis = new MyDateAxis(""Millisecond"");
        Millisecond m0 = new Millisecond(458, 58, 31, 12, 1, 4, 2007);
        Millisecond m1 = new Millisecond(459, 58, 31, 12, 1, 4, 2007);

        Date d0 = new Date(m0.getFirstMillisecond());
        Date end = new Date(m1.getLastMillisecond());

        DateTickUnit unit = new DateTickUnit(DateTickUnitType.MILLISECOND, 1);
        axis.setTickUnit(unit);

        // START: check d0
        axis.setTickMarkPosition(DateTickMarkPosition.START);

        axis.setRange(d0, end);
        Date psd = axis.previousStandardDate(d0, unit);
        Date nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d0.getTime());
        assertTrue(nsd.getTime() >= d0.getTime());

        // MIDDLE: check d0
        axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);

        axis.setRange(d0, end);
        psd = axis.previousStandardDate(d0, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d0.getTime());
        assertTrue(nsd.getTime() >= d0.getTime());

        // END: check d0
        axis.setTickMarkPosition(DateTickMarkPosition.END);

        axis.setRange(d0, end);
        psd = axis.previousStandardDate(d0, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d0.getTime());
        assertTrue(nsd.getTime() >= d0.getTime());
    }",Eager Test
"@Test
    public void testPreviousStandardDateMonthA() {
        MyDateAxis axis = new MyDateAxis(""Month"");
        Month nov2006 = new Month(11, 2006);
        Month dec2006 = new Month(12, 2006);

        // five dates to check...
        Date d0 = new Date(nov2006.getFirstMillisecond());
        Date d1 = new Date(nov2006.getFirstMillisecond() + 500L);
        Date d2 = new Date(nov2006.getMiddleMillisecond());
        Date d3 = new Date(nov2006.getMiddleMillisecond() + 500L);
        Date d4 = new Date(nov2006.getLastMillisecond());

        Date end = new Date(dec2006.getLastMillisecond());

        DateTickUnit unit = new DateTickUnit(DateTickUnitType.MONTH, 1);
        axis.setTickUnit(unit);

        // START: check d0 and d1
        axis.setTickMarkPosition(DateTickMarkPosition.START);

        axis.setRange(d0, end);
        Date psd = axis.previousStandardDate(d0, unit);
        Date nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d0.getTime());
        assertTrue(nsd.getTime() >= d0.getTime());

        axis.setRange(d1, end);
        psd = axis.previousStandardDate(d1, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d1.getTime());
        assertTrue(nsd.getTime() >= d1.getTime());

        // MIDDLE: check d1, d2 and d3
        axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);

        axis.setRange(d1, end);
        psd = axis.previousStandardDate(d1, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d1.getTime());
        assertTrue(nsd.getTime() >= d1.getTime());

        axis.setRange(d2, end);
        psd = axis.previousStandardDate(d2, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d2.getTime());
        assertTrue(nsd.getTime() >= d2.getTime());

        axis.setRange(d3, end);
        psd = axis.previousStandardDate(d3, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d3.getTime());
        assertTrue(nsd.getTime() >= d3.getTime());

        // END: check d3 and d4
        axis.setTickMarkPosition(DateTickMarkPosition.END);

        axis.setRange(d3, end);
        psd = axis.previousStandardDate(d3, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d3.getTime());
        assertTrue(nsd.getTime() >= d3.getTime());

        axis.setRange(d4, end);
        psd = axis.previousStandardDate(d4, unit);
        nsd = unit.addToDate(psd, TimeZone.getDefault());
        assertTrue(psd.getTime() < d4.getTime());
        assertTrue(nsd.getTime() >= d4.getTime());
    }",Eager Test
"@Test
    public void testHashCode() {
        Date d1 = new Date(0L);
        String l1 = ""Label 1"";
        TextAnchor ta1 = TextAnchor.CENTER;

        DateTick t1 = new DateTick(d1, l1, ta1, ta1, Math.PI / 2.0);
        DateTick t2 = new DateTick(d1, l1, ta1, ta1, Math.PI / 2.0);
        assertEquals(t1, t2);
        int h1 = t1.hashCode();
        int h2 = t2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testSerialization() {
        ExtendedCategoryAxis a1 = new ExtendedCategoryAxis(""Test"");
        a1.setSubLabelPaint(new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f,
                4.0f, Color.BLUE));
        ExtendedCategoryAxis a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);
    }",Eager Test
"@Test
    public void testSerialization() {
        LogAxis a1 = new LogAxis(""Test Axis"");
        LogAxis a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testTranslateJava2DToValue() {
        LogAxis axis = new LogAxis();
        axis.setRange(50.0, 100.0);
        Rectangle2D dataArea = new Rectangle2D.Double(10.0, 50.0, 400.0, 300.0);
        double y1 = axis.java2DToValue(75.0, dataArea, RectangleEdge.LEFT);
        assertEquals(94.3874312681693, y1, EPSILON);
        double y2 = axis.java2DToValue(75.0, dataArea, RectangleEdge.RIGHT);
        assertEquals(94.3874312681693, y2, EPSILON);
        double x1 = axis.java2DToValue(75.0, dataArea, RectangleEdge.TOP);
        assertEquals(55.961246381405, x1, EPSILON);
        double x2 = axis.java2DToValue(75.0, dataArea, RectangleEdge.BOTTOM);
        assertEquals(55.961246381405, x2, EPSILON);
        axis.setInverted(true);
        double y3 = axis.java2DToValue(75.0, dataArea, RectangleEdge.LEFT);
        assertEquals(52.9731547179647, y3, EPSILON);
        double y4 = axis.java2DToValue(75.0, dataArea, RectangleEdge.RIGHT);
        assertEquals(52.9731547179647, y4, EPSILON);
        double x3 = axis.java2DToValue(75.0, dataArea, RectangleEdge.TOP);
        assertEquals(89.3475453695651, x3, EPSILON);
        double x4 = axis.java2DToValue(75.0, dataArea, RectangleEdge.BOTTOM);
        assertEquals(89.3475453695651, x4, EPSILON);
    }",Eager Test
"@Test
    public void testHashCode() {
        Font font1 = new Font(""SansSerif"", Font.PLAIN, 12);

        MarkerAxisBand a1 = new MarkerAxisBand(null, 1.0, 1.0, 1.0, 1.0, font1);
        MarkerAxisBand a2 = new MarkerAxisBand(null, 1.0, 1.0, 1.0, 1.0, font1);
        assertEquals(a1, a2);
        int h1 = a1.hashCode();
        int h2 = a2.hashCode();
        assertEquals(h1, h2);
    }",No Smells
"@Test
    public void testSerialization() {
        MarkerAxisBand a1 = new MarkerAxisBand(null, 1.0, 1.0, 1.0, 1.0, null);
        MarkerAxisBand a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testEquals() {
        MonthDateFormat mf1 = new MonthDateFormat();
        MonthDateFormat mf2 = new MonthDateFormat();
        assertEquals(mf1, mf2);
        assertEquals(mf2, mf1);

        boolean[] showYear1 = new boolean [12];
        showYear1[0] = true;
        boolean[] showYear2 = new boolean [12];
        showYear1[1] = true;

        // time zone
        mf1 = new MonthDateFormat(TimeZone.getTimeZone(""PST""), Locale.US, 1,
            showYear1, new SimpleDateFormat(""yy""));
        assertNotEquals(mf1, mf2);
        mf2 = new MonthDateFormat(TimeZone.getTimeZone(""PST""), Locale.US, 1,
            showYear1, new SimpleDateFormat(""yy""));
        assertEquals(mf1, mf2);

        // locale
        mf1 = new MonthDateFormat(TimeZone.getTimeZone(""PST""), Locale.FRANCE, 1,
            showYear1, new SimpleDateFormat(""yy""));
        assertNotEquals(mf1, mf2);
        mf2 = new MonthDateFormat(TimeZone.getTimeZone(""PST""), Locale.FRANCE, 1,
            showYear1, new SimpleDateFormat(""yy""));
        assertEquals(mf1, mf2);

        // chars
        mf1 = new MonthDateFormat(TimeZone.getTimeZone(""PST""), Locale.FRANCE, 2,
            showYear1, new SimpleDateFormat(""yy""));
        assertNotEquals(mf1, mf2);
        mf2 = new MonthDateFormat(TimeZone.getTimeZone(""PST""), Locale.FRANCE, 2,
            showYear1, new SimpleDateFormat(""yy""));
        assertEquals(mf1, mf2);

        // showYear[]
        mf1 = new MonthDateFormat(TimeZone.getTimeZone(""PST""), Locale.FRANCE, 2,
            showYear2, new SimpleDateFormat(""yy""));
        assertNotEquals(mf1, mf2);
        mf2 = new MonthDateFormat(TimeZone.getTimeZone(""PST""), Locale.FRANCE, 2,
            showYear2, new SimpleDateFormat(""yy""));
        assertEquals(mf1, mf2);

        // yearFormatter
        mf1 = new MonthDateFormat(TimeZone.getTimeZone(""PST""), Locale.FRANCE, 2,
            showYear2, new SimpleDateFormat(""yyyy""));
        assertNotEquals(mf1, mf2);
        mf2 = new MonthDateFormat(TimeZone.getTimeZone(""PST""), Locale.FRANCE, 2,
            showYear2, new SimpleDateFormat(""yyyy""));
        assertEquals(mf1, mf2);

    }",Eager Test
"@Test
    public void testSerialization() {
        MonthDateFormat mf1 = new MonthDateFormat();
        MonthDateFormat mf2 = TestUtils.serialised(mf1);
        assertEquals(mf1, mf2);
    }",No Smells
"@Test
    public void testAutoRange2() {
        DefaultCategoryDataset<String,String> dataset = new DefaultCategoryDataset<>();
        dataset.setValue(100.0, ""Row 1"", ""Column 1"");
        dataset.setValue(200.0, ""Row 1"", ""Column 2"");
        JFreeChart chart = ChartFactory.createLineChart(""Test"", ""Categories"",
                ""Value"", dataset, PlotOrientation.VERTICAL, false, false,
                false);
        CategoryPlot<?, ?> plot = (CategoryPlot) chart.getPlot();
        NumberAxis axis = (NumberAxis) plot.getRangeAxis();
        axis.setAutoRangeIncludesZero(false);
        assertEquals(axis.getLowerBound(), 95.0, EPSILON);
        assertEquals(axis.getUpperBound(), 205.0, EPSILON);
    }",Eager Test
"@Test
    public void testAutoRange4() {
        DefaultCategoryDataset<String,String> dataset = new DefaultCategoryDataset<>();
        dataset.setValue(100.0, ""Row 1"", ""Column 1"");
        dataset.setValue(200.0, ""Row 1"", ""Column 2"");
        JFreeChart chart = ChartFactory.createBarChart(""Test"", ""Categories"",
                ""Value"", dataset, PlotOrientation.VERTICAL, false, false,
                false);
        @SuppressWarnings(""unchecked"")
        CategoryPlot<String, String> plot = (CategoryPlot) chart.getPlot(); 
        NumberAxis axis = (NumberAxis) plot.getRangeAxis();
        axis.setAutoRangeIncludesZero(false);
        BarRenderer br = (BarRenderer) plot.getRenderer();
        br.setIncludeBaseInRange(false);
        assertEquals(95.0, axis.getLowerBound(), EPSILON);
        assertEquals(205.0, axis.getUpperBound(), EPSILON);

        br.setIncludeBaseInRange(true);
        assertEquals(0.0, axis.getLowerBound(), EPSILON);
        assertEquals(210.0, axis.getUpperBound(), EPSILON);

        axis.setAutoRangeIncludesZero(true);
        assertEquals(0.0, axis.getLowerBound(), EPSILON);
        assertEquals(210.0, axis.getUpperBound(), EPSILON);

        br.setIncludeBaseInRange(true);
        assertEquals(0.0, axis.getLowerBound(), EPSILON);
        assertEquals(210.0, axis.getUpperBound(), EPSILON);

        // now replacing the dataset should update the axis range...
        DefaultCategoryDataset<String,String> dataset2 = new DefaultCategoryDataset<>();
        dataset2.setValue(900.0, ""Row 1"", ""Column 1"");
        dataset2.setValue(1000.0, ""Row 1"", ""Column 2"");
        plot.setDataset(dataset2);
        assertEquals(0.0, axis.getLowerBound(), EPSILON);
        assertEquals(1050.0, axis.getUpperBound(), EPSILON);

        br.setIncludeBaseInRange(false);
        assertEquals(0.0, axis.getLowerBound(), EPSILON);
        assertEquals(1050.0, axis.getUpperBound(), EPSILON);

        axis.setAutoRangeIncludesZero(false);
        assertEquals(895.0, axis.getLowerBound(), EPSILON);
        assertEquals(1005.0, axis.getUpperBound(), EPSILON);
    }",Eager Test
"@Test
    public void testSetLowerBound() {
        NumberAxis axis = new NumberAxis(""X"");
        axis.setRange(0.0, 10.0);
        axis.setLowerBound(5.0);
        assertEquals(5.0, axis.getLowerBound(), EPSILON);
        axis.setLowerBound(10.0);
        assertEquals(10.0, axis.getLowerBound(), EPSILON);
        assertEquals(11.0, axis.getUpperBound(), EPSILON);

        //axis.setRangeType(RangeType.POSITIVE);
        //axis.setLowerBound(-5.0);
        //assertEquals(0.0, axis.getLowerBound(), EPSILON);
    }",No Smells
"@Test
    public void testCloning() {
        NumberTickUnit t1 = new NumberTickUnit(1.23, new DecimalFormat(""0.00""));
        assertFalse(t1 instanceof Cloneable);
    }",No Smells
"@Test
    public void testEquals() {
        PeriodAxisLabelInfo info1 = new PeriodAxisLabelInfo(Day.class,
                new SimpleDateFormat(""d""));
        PeriodAxisLabelInfo info2 = new PeriodAxisLabelInfo(Day.class,
                new SimpleDateFormat(""d""));
        assertEquals(info1, info2);
        assertEquals(info2, info1);

        Class c1 = Day.class;
        Class c2 = Month.class;
        DateFormat df1 = new SimpleDateFormat(""d"");
        DateFormat df2 = new SimpleDateFormat(""MMM"");
        RectangleInsets sp1 = new RectangleInsets(1, 1, 1, 1);
        RectangleInsets sp2 = new RectangleInsets(2, 2, 2, 2);
        Font lf1 = new Font(""SansSerif"", Font.PLAIN, 10);
        Font lf2 = new Font(""SansSerif"", Font.BOLD, 9);
        Paint lp1 = Color.BLACK;
        Paint lp2 = Color.BLUE;
        boolean b1 = true;
        boolean b2 = false;
        Stroke s1 = new BasicStroke(0.5f);
        Stroke s2 = new BasicStroke(0.25f);
        Paint dp1 = Color.RED;
        Paint dp2 = Color.GREEN;

        info1 = new PeriodAxisLabelInfo(c2, df1, sp1, lf1, lp1, b1, s1, dp1);
        info2 = new PeriodAxisLabelInfo(c1, df1, sp1, lf1, lp1, b1, s1, dp1);
        assertNotEquals(info1, info2);
        info2 = new PeriodAxisLabelInfo(c2, df1, sp1, lf1, lp1, b1, s1, dp1);
        assertEquals(info1, info2);

        info1 = new PeriodAxisLabelInfo(c2, df2, sp1, lf1, lp1, b1, s1, dp1);
        assertNotEquals(info1, info2);
        info2 = new PeriodAxisLabelInfo(c2, df2, sp1, lf1, lp1, b1, s1, dp1);
        assertEquals(info1, info2);

        info1 = new PeriodAxisLabelInfo(c2, df2, sp2, lf1, lp1, b1, s1, dp1);
        assertNotEquals(info1, info2);
        info2 = new PeriodAxisLabelInfo(c2, df2, sp2, lf1, lp1, b1, s1, dp1);
        assertEquals(info1, info2);

        info1 = new PeriodAxisLabelInfo(c2, df2, sp2, lf2, lp1, b1, s1, dp1);
        assertNotEquals(info1, info2);
        info2 = new PeriodAxisLabelInfo(c2, df2, sp2, lf2, lp1, b1, s1, dp1);
        assertEquals(info1, info2);

        info1 = new PeriodAxisLabelInfo(c2, df2, sp2, lf2, lp2, b1, s1, dp1);
        assertNotEquals(info1, info2);
        info2 = new PeriodAxisLabelInfo(c2, df2, sp2, lf2, lp2, b1, s1, dp1);
        assertEquals(info1, info2);

        info1 = new PeriodAxisLabelInfo(c2, df2, sp2, lf2, lp2, b2, s1, dp1);
        assertNotEquals(info1, info2);
        info2 = new PeriodAxisLabelInfo(c2, df2, sp2, lf2, lp2, b2, s1, dp1);
        assertEquals(info1, info2);

        info1 = new PeriodAxisLabelInfo(c2, df2, sp2, lf2, lp2, b2, s2, dp1);
        assertNotEquals(info1, info2);
        info2 = new PeriodAxisLabelInfo(c2, df2, sp2, lf2, lp2, b2, s2, dp1);
        assertEquals(info1, info2);

        info1 = new PeriodAxisLabelInfo(c2, df2, sp2, lf2, lp2, b2, s2, dp2);
        assertNotEquals(info1, info2);
        info2 = new PeriodAxisLabelInfo(c2, df2, sp2, lf2, lp2, b2, s2, dp2);
        assertEquals(info1, info2);

    }",Eager Test
"@Test
    public void testSerialization() {
        PeriodAxisLabelInfo info1 = new PeriodAxisLabelInfo(Day.class,
                new SimpleDateFormat(""d""));
        PeriodAxisLabelInfo info2 = TestUtils.serialised(info1);
        assertEquals(info1, info2);
    }",No Smells
"@Test
    public void test1932146() {
        PeriodAxis axis = new PeriodAxis(""TestAxis"");
        axis.addChangeListener(this);
        this.lastEvent = null;
        axis.setRange(new DateRange(0L, 1000L));
        assertNotNull(this.lastEvent);
    }",No Smells
"@Test
    public void testEquals() {
        PeriodAxis a1 = new PeriodAxis(""Test"");
        PeriodAxis a2 = new PeriodAxis(""Test"");
        assertEquals(a1, a2);
        assertEquals(a2, a1);

        a1.setFirst(new Year(2000));
        assertNotEquals(a1, a2);
        a2.setFirst(new Year(2000));
        assertEquals(a1, a2);

        a1.setLast(new Year(2004));
        assertNotEquals(a1, a2);
        a2.setLast(new Year(2004));
        assertEquals(a1, a2);

        a1.setTimeZone(TimeZone.getTimeZone(""Pacific/Auckland""));
        assertNotEquals(a1, a2);
        a2.setTimeZone(TimeZone.getTimeZone(""Pacific/Auckland""));
        assertEquals(a1, a2);

        a1.setAutoRangeTimePeriodClass(Quarter.class);
        assertNotEquals(a1, a2);
        a2.setAutoRangeTimePeriodClass(Quarter.class);
        assertEquals(a1, a2);

        PeriodAxisLabelInfo[] info = new PeriodAxisLabelInfo[1];
        info[0] = new PeriodAxisLabelInfo(Month.class,
                new SimpleDateFormat(""MMM""));

        a1.setLabelInfo(info);
        assertNotEquals(a1, a2);
        a2.setLabelInfo(info);
        assertEquals(a1, a2);

        a1.setMajorTickTimePeriodClass(Minute.class);
        assertNotEquals(a1, a2);
        a2.setMajorTickTimePeriodClass(Minute.class);
        assertEquals(a1, a2);

        a1.setMinorTickMarksVisible(!a1.isMinorTickMarksVisible());
        assertNotEquals(a1, a2);
        a2.setMinorTickMarksVisible(a1.isMinorTickMarksVisible());
        assertEquals(a1, a2);

        a1.setMinorTickTimePeriodClass(Minute.class);
        assertNotEquals(a1, a2);
        a2.setMinorTickTimePeriodClass(Minute.class);
        assertEquals(a1, a2);

        Stroke s = new BasicStroke(1.23f);
        a1.setMinorTickMarkStroke(s);
        assertNotEquals(a1, a2);
        a2.setMinorTickMarkStroke(s);
        assertEquals(a1, a2);

        a1.setMinorTickMarkPaint(Color.BLUE);
        assertNotEquals(a1, a2);
        a2.setMinorTickMarkPaint(Color.BLUE);
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testCloning() {
        QuarterDateFormat qf1 = new QuarterDateFormat(TimeZone.getTimeZone(
                ""GMT""), new String[] {""1"", ""2"", ""3"", ""4""}",No Smells
"@Test
    public void testHashCode() {
        QuarterDateFormat qf1 = new QuarterDateFormat(TimeZone.getTimeZone(
                ""GMT""), new String[] {""1"", ""2"", ""3"", ""4""}",No Smells
"@Test
    public void testSerialization() {
        QuarterDateFormat qf1 = new QuarterDateFormat(TimeZone.getTimeZone(
                ""GMT""), new String[] {""1"", ""2"", ""3"", ""4""}",No Smells
"@Test
    public void test2275695() {
        JFreeChart chart = ChartFactory.createStackedBarChart(""Test"",
                ""Category"", ""Value"", null, PlotOrientation.VERTICAL,
                true, false, false);
        CategoryPlot<?, ?> plot = (CategoryPlot) chart.getPlot();
        plot.setDomainAxis(new SubCategoryAxis(""SubCategoryAxis""));
        try {
            BufferedImage image = new BufferedImage(200 , 100,
                    BufferedImage.TYPE_INT_RGB);
            Graphics2D g2 = image.createGraphics();
            chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null);
            g2.dispose();
        }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        SubCategoryAxis a1 = new SubCategoryAxis(""Test"");
        a1.addSubCategory(""SubCategoryA"");
        SubCategoryAxis a2 = CloneUtils.clone(a1);
        assertNotSame(a1, a2);
        assertSame(a1.getClass(), a2.getClass());
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testHashCode() {
        SubCategoryAxis a1 = new SubCategoryAxis(""Test"");
        SubCategoryAxis a2 = new SubCategoryAxis(""Test"");
        assertEquals(a1, a2);
        int h1 = a1.hashCode();
        int h2 = a2.hashCode();
        assertEquals(h1, h2);
    }",No Smells
"@Test
    public void testSerialization() {
        SubCategoryAxis a1 = new SubCategoryAxis(""Test Axis"");
        a1.addSubCategory(""SubCategoryA"");
        SubCategoryAxis a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        TickUnits t1 = new TickUnits();
        t1.add(new NumberTickUnit(10, new DecimalFormat(""0.00"")));
        TickUnits t2 = CloneUtils.clone(t1);
        assertNotSame(t1, t2);
        assertSame(t1.getClass(), t2.getClass());
        assertEquals(t1, t2);
    }",No Smells
"@Test
    public void testCloning() {
        BlockBorder b1 = new BlockBorder();
        assertFalse(b1 instanceof Cloneable);
    }",No Smells
"@Test
    public void testEquals() {
        BlockBorder b1 = new BlockBorder(new RectangleInsets(1.0, 2.0, 3.0,
                4.0), Color.RED);
        BlockBorder b2 = new BlockBorder(new RectangleInsets(1.0, 2.0, 3.0,
                4.0), Color.RED);
        assertEquals(b1, b2);
        assertEquals(b2, b2);

        // insets
        b1 = new BlockBorder(new RectangleInsets(UnitType.RELATIVE, 1.0, 2.0,
                3.0, 4.0), Color.RED);
        assertNotEquals(b1, b2);
        b2 = new BlockBorder(new RectangleInsets(UnitType.RELATIVE, 1.0, 2.0,
                3.0, 4.0), Color.RED);
        assertEquals(b1, b2);

        // paint
        b1 = new BlockBorder(new RectangleInsets(1.0, 2.0, 3.0, 4.0),
                Color.BLUE);
        assertNotEquals(b1, b2);
        b2 = new BlockBorder(new RectangleInsets(1.0, 2.0, 3.0, 4.0),
                Color.BLUE);
        assertEquals(b1, b2);
    }",No Smells
"@Test
    public void testSerialization() {
        BlockBorder b1 = new BlockBorder(new RectangleInsets(1.0, 2.0, 3.0,
                4.0), new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f, 4.0f,
                Color.YELLOW));
        BlockBorder b2 = TestUtils.serialised(b1);
        assertEquals(b1, b2);
    }",No Smells
"@Test
    public void testEquals() {
        BlockContainer c1 = new BlockContainer(new FlowArrangement());
        BlockContainer c2 = new BlockContainer(new FlowArrangement());
        assertEquals(c1, c2);
        assertEquals(c2, c2);

        c1.setArrangement(new ColumnArrangement());
        assertNotEquals(c1, c2);
        c2.setArrangement(new ColumnArrangement());
        assertEquals(c1, c2);

        c1.add(new EmptyBlock(1.2, 3.4));
        assertNotEquals(c1, c2);
        c2.add(new EmptyBlock(1.2, 3.4));
        assertEquals(c1, c2);
    }",No Smells
"@Test
    public void testSerialization() {
        BorderArrangement b1 = new BorderArrangement();
        BorderArrangement b2 = TestUtils.serialised(b1);
        assertEquals(b1, b2);
    }",No Smells
"@Test
    public void testCloning() {
        ColumnArrangement f1 = new ColumnArrangement();
        assertFalse(f1 instanceof Cloneable);
    }",No Smells
"@Test
    public void testSerialization() {
        ColumnArrangement c1 = new ColumnArrangement(HorizontalAlignment.LEFT,
                VerticalAlignment.TOP, 1.0, 2.0);
        ColumnArrangement c2 = TestUtils.serialised(c1);
        assertEquals(c1, c2);
    }",No Smells
"@Test
    public void testEquals() {
        FlowArrangement f1 = new FlowArrangement(HorizontalAlignment.LEFT,
                VerticalAlignment.TOP, 1.0, 2.0);
        FlowArrangement f2 = new FlowArrangement(HorizontalAlignment.LEFT,
                VerticalAlignment.TOP, 1.0, 2.0);
        assertEquals(f1, f2);
        assertEquals(f2, f1);

        f1 = new FlowArrangement(HorizontalAlignment.RIGHT,
                VerticalAlignment.TOP, 1.0, 2.0);
        assertNotEquals(f1, f2);
        f2 = new FlowArrangement(HorizontalAlignment.RIGHT,
                VerticalAlignment.TOP, 1.0, 2.0);
        assertEquals(f1, f2);

        f1 = new FlowArrangement(HorizontalAlignment.RIGHT,
                VerticalAlignment.BOTTOM, 1.0, 2.0);
        assertNotEquals(f1, f2);
        f2 = new FlowArrangement(HorizontalAlignment.RIGHT,
                VerticalAlignment.BOTTOM, 1.0, 2.0);
        assertEquals(f1, f2);

        f1 = new FlowArrangement(HorizontalAlignment.RIGHT,
                VerticalAlignment.BOTTOM, 1.1, 2.0);
        assertNotEquals(f1, f2);
        f2 = new FlowArrangement(HorizontalAlignment.RIGHT,
                VerticalAlignment.BOTTOM, 1.1, 2.0);
        assertEquals(f1, f2);

        f1 = new FlowArrangement(HorizontalAlignment.RIGHT,
                VerticalAlignment.BOTTOM, 1.1, 2.2);
        assertNotEquals(f1, f2);
        f2 = new FlowArrangement(HorizontalAlignment.RIGHT,
                VerticalAlignment.BOTTOM, 1.1, 2.2);
        assertEquals(f1, f2);

    }",Eager Test
"@Test
    public void testNN() {
        BlockContainer c = createTestContainer1();
        Size2D s = c.arrange(null, RectangleConstraint.NONE);
        assertEquals(90.0, s.width, EPSILON);
        assertEquals(33.0, s.height, EPSILON);
    }",No Smells
"@Test
    public void testCloning() {
        GridArrangement f1 = new GridArrangement(1, 2);
        assertFalse(f1 instanceof Cloneable);
    }",No Smells
"@Test
    public void testGridNotFull_FF() {
        Block b1 = new EmptyBlock(5, 5);
        BlockContainer c = new BlockContainer(new GridArrangement(2, 3));
        c.add(b1);
        Size2D s = c.arrange(null, new RectangleConstraint(200, 100));
        assertEquals(200.0, s.getWidth(), EPSILON);
        assertEquals(100.0, s.getHeight(), EPSILON);
    }",No Smells
"@Test
    public void testNN() {
        BlockContainer c = createTestContainer1();
        Size2D s = c.arrange(null, RectangleConstraint.NONE);
        assertEquals(90.0, s.width, EPSILON);
        assertEquals(33.0, s.height, EPSILON);
    }",No Smells
"@Test
    public void testNullBlock_FR() {
        BlockContainer c = new BlockContainer(new GridArrangement(1, 1));
        c.add(null);
        Size2D s = c.arrange(null, new RectangleConstraint(30.0, new Range(5.0,
                10.0)));
        assertEquals(30.0, s.getWidth(), EPSILON);
        assertEquals(5.0, s.getHeight(), EPSILON);
    }",No Smells
"@Test
    public void testNullBlock_NN() {
        BlockContainer c = new BlockContainer(new GridArrangement(1, 1));
        c.add(null);
        Size2D s = c.arrange(null, RectangleConstraint.NONE);
        assertEquals(0.0, s.getWidth(), EPSILON);
        assertEquals(0.0, s.getHeight(), EPSILON);
    }",No Smells
"@Test
    public void testRF() {
        BlockContainer c = createTestContainer1();
        RectangleConstraint constraint = new RectangleConstraint(new Range(40.0,
                60.0), 100.0);
        Size2D s = c.arrange(null, constraint);
        assertEquals(60.0, s.width, EPSILON);
        assertEquals(100.0, s.height, EPSILON);
    }",Eager Test
"@Test
    public void testSerialization() {
        GradientPaint gp = new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f, 4.0f,
                Color.BLUE);
        LabelBlock b1 = new LabelBlock(""ABC"", new Font(""Dialog"",
                Font.PLAIN, 12), gp);
        LabelBlock b2 = TestUtils.serialised(b1);
        assertEquals(b1, b2);
    }",Eager Test
"@Test
    public void test2502355_restoreAutoDomainBounds() {
        DefaultXYDataset<String> dataset = new DefaultXYDataset<>();
        JFreeChart chart = ChartFactory.createXYLineChart(""TestChart"", ""X"",
                ""Y"", dataset, PlotOrientation.VERTICAL, false, false, false);
        XYPlot<?> plot = (XYPlot<?>) chart.getPlot();
        plot.setDomainAxis(1, new NumberAxis(""X2""));
        ChartPanel panel = new ChartPanel(chart);
        chart.addChangeListener(this);
        this.chartChangeEvents.clear();
        panel.restoreAutoDomainBounds();
        assertEquals(1, this.chartChangeEvents.size());
    }",Eager Test
"@Test
    public void test2502355_zoomInDomain() {
        DefaultXYDataset<String> dataset = new DefaultXYDataset<>();
        JFreeChart chart = ChartFactory.createXYLineChart(""TestChart"", ""X"",
                ""Y"", dataset, PlotOrientation.VERTICAL, false, false, false);
        XYPlot<?> plot = (XYPlot<?>) chart.getPlot();
        plot.setDomainAxis(1, new NumberAxis(""X2""));
        ChartPanel panel = new ChartPanel(chart);
        chart.addChangeListener(this);
        this.chartChangeEvents.clear();
        panel.zoomInDomain(1.0, 2.0);
        assertEquals(1, this.chartChangeEvents.size());
    }",Eager Test
"@Test
    public void test2502355_zoomOutBoth() {
        DefaultXYDataset<String> dataset = new DefaultXYDataset<>();
        JFreeChart chart = ChartFactory.createXYLineChart(""TestChart"", ""X"",
                ""Y"", dataset, PlotOrientation.VERTICAL, false, false, false);
        ChartPanel panel = new ChartPanel(chart);
        chart.addChangeListener(this);
        this.chartChangeEvents.clear();
        panel.zoomOutBoth(1.0, 2.0);
        assertEquals(1, this.chartChangeEvents.size());
    }",Eager Test
"@Test
    public void testGetListeners() {
        ChartPanel p = new ChartPanel(null);
        p.addChartMouseListener(this);
        EventListener[] listeners = p.getListeners(ChartMouseListener.class);
        assertEquals(1, listeners.length);
        assertEquals(this, listeners[0]);
        // try a listener type that isn't registered
        listeners = p.getListeners(CaretListener.class);
        assertEquals(0, listeners.length);
        p.removeChartMouseListener(this);
        listeners = p.getListeners(ChartMouseListener.class);
        assertEquals(0, listeners.length);
        // try a null argument
        assertThrows(NullPointerException.class, () -> p.getListeners(null));
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        ChartRenderingInfo i1 = new ChartRenderingInfo();
        ChartRenderingInfo i2 = CloneUtils.clone(i1);

        assertNotSame(i1, i2);
        assertSame(i1.getClass(), i2.getClass());
        assertEquals(i1, i2);

        // check independence
        i1.getChartArea().setRect(4.0, 3.0, 2.0, 1.0);
        assertNotEquals(i1, i2);
        i2.getChartArea().setRect(4.0, 3.0, 2.0, 1.0);
        assertEquals(i1, i2);

        i1.getEntityCollection().add(new ChartEntity(new Rectangle(1, 2, 2,
                1)));
        assertNotEquals(i1, i2);
        i2.getEntityCollection().add(new ChartEntity(new Rectangle(1, 2, 2,
                1)));
        assertEquals(i1, i2);

    }",No Smells
"@Test
    public void testEquals() {
        ChartRenderingInfo i1 = new ChartRenderingInfo();
        ChartRenderingInfo i2 = new ChartRenderingInfo();
        assertEquals(i1, i2);

        i1.setChartArea(new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0));
        assertNotEquals(i1, i2);
        i2.setChartArea(new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0));
        assertEquals(i1, i2);

        i1.getPlotInfo().setDataArea(new Rectangle(1, 2, 3, 4));
        assertNotEquals(i1, i2);
        i2.getPlotInfo().setDataArea(new Rectangle(1, 2, 3, 4));
        assertEquals(i1, i2);

        StandardEntityCollection e1 = new StandardEntityCollection();
        e1.add(new ChartEntity(new Rectangle(1, 2, 3, 4)));
        i1.setEntityCollection(e1);
        assertNotEquals(i1, i2);
        StandardEntityCollection e2 = new StandardEntityCollection();
        e2.add(new ChartEntity(new Rectangle(1, 2, 3, 4)));
        i2.setEntityCollection(e2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        DefaultCategoryDataset<String, String> d = new DefaultCategoryDataset<>();
        d.addValue(1.0, ""R1"", ""C1"");
        d.addValue(2.0, ""R1"", ""C2"");
        d.addValue(3.0, ""R2"", ""C1"");
        d.addValue(4.0, ""R2"", ""C2"");
        CategoryItemEntity<String, String> e1 = new CategoryItemEntity<>(
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), ""ToolTip"", ""URL"", d, 
                ""R2"", ""C2"");
        CategoryItemEntity<String, String> e2 = CloneUtils.clone(e1);
        assertNotSame(e1, e2);
        assertSame(e1.getClass(), e2.getClass());
        assertEquals(e1, e2);
    }",No Smells
"@Test
    public void testEquals() {
        DefaultCategoryDataset<String, String> d = new DefaultCategoryDataset<>();
        d.addValue(1.0, ""R1"", ""C1"");
        d.addValue(2.0, ""R1"", ""C2"");
        d.addValue(3.0, ""R2"", ""C1"");
        d.addValue(4.0, ""R2"", ""C2"");
        CategoryItemEntity<String, String> e1 = new CategoryItemEntity<>(
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), ""ToolTip"", ""URL"", d, 
                ""R2"", ""C2"");
        CategoryItemEntity<String, String> e2 = new CategoryItemEntity<>(
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), ""ToolTip"", ""URL"", d, 
                ""R2"", ""C2"");
        assertEquals(e1, e2);

        e1.setArea(new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0));
        assertNotEquals(e1, e2);
        e2.setArea(new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0));
        assertEquals(e1, e2);

        e1.setToolTipText(""New ToolTip"");
        assertNotEquals(e1, e2);
        e2.setToolTipText(""New ToolTip"");
        assertEquals(e1, e2);

        e1.setURLText(""New URL"");
        assertNotEquals(e1, e2);
        e2.setURLText(""New URL"");
        assertEquals(e1, e2);
    }",No Smells
"@Test
    public void testEquals() {
        CategoryLabelEntity<String> e1 = new CategoryLabelEntity<>(""A"",
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), ""ToolTip"", ""URL"");
        CategoryLabelEntity<String> e2 = new CategoryLabelEntity<>(""A"",
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), ""ToolTip"", ""URL"");
        assertEquals(e1, e2);

        e1 = new CategoryLabelEntity<>(""B"", new Rectangle2D.Double(1.0, 2.0,
                3.0, 4.0), ""ToolTip"", ""URL"");
        assertNotEquals(e1, e2);
        e2 = new CategoryLabelEntity<>(""B"", new Rectangle2D.Double(1.0, 2.0,
                3.0, 4.0), ""ToolTip"", ""URL"");
        assertEquals(e1, e2);

        e1.setArea(new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0));
        assertNotEquals(e1, e2);
        e2.setArea(new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0));
        assertEquals(e1, e2);

        e1.setToolTipText(""New ToolTip"");
        assertNotEquals(e1, e2);
        e2.setToolTipText(""New ToolTip"");
        assertEquals(e1, e2);

        e1.setURLText(""New URL"");
        assertNotEquals(e1, e2);
        e2.setURLText(""New URL"");
        assertEquals(e1, e2);
    }",No Smells
"@Test
    public void testSerialization() {
        CategoryLabelEntity<String> e1 = new CategoryLabelEntity<>(""A"",
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), ""ToolTip"", ""URL"");
        CategoryLabelEntity<String> e2 = TestUtils.serialised(e1);
        assertEquals(e1, e2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        PieSectionEntity<String> e1 = new PieSectionEntity<>(
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), 
                new DefaultPieDataset<String>(), 1, 2, ""Key"", ""ToolTip"", ""URL"");
        PieSectionEntity<String> e2 = CloneUtils.clone(e1);
        assertNotSame(e1, e2);
        assertSame(e1.getClass(), e2.getClass());
        assertEquals(e1, e2);
    }",No Smells
"@Test
    public void testEquals() {
        PieSectionEntity<String> e1 = new PieSectionEntity<>(
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), 
                new DefaultPieDataset<String>(), 1, 2, ""Key"", ""ToolTip"", ""URL"");
        PieSectionEntity<String> e2 = new PieSectionEntity<>(
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), 
                new DefaultPieDataset<String>(), 1, 2, ""Key"", ""ToolTip"", ""URL"");
        assertEquals(e1, e2);

        e1.setArea(new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0));
        assertNotEquals(e1, e2);
        e2.setArea(new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0));
        assertEquals(e1, e2);

        e1.setToolTipText(""New ToolTip"");
        assertNotEquals(e1, e2);
        e2.setToolTipText(""New ToolTip"");
        assertEquals(e1, e2);

        e1.setURLText(""New URL"");
        assertNotEquals(e1, e2);
        e2.setURLText(""New URL"");
        assertEquals(e1, e2);

        e1.setDataset(null);
        assertNotEquals(e1, e2);
        e2.setDataset(null);
        assertEquals(e1, e2);

        e1.setPieIndex(99);
        assertNotEquals(e1, e2);
        e2.setPieIndex(99);
        assertEquals(e1, e2);

        e1.setSectionIndex(66);
        assertNotEquals(e1, e2);
        e2.setSectionIndex(66);
        assertEquals(e1, e2);

        e1.setSectionKey(""ABC"");
        assertNotEquals(e1, e2);
        e2.setSectionKey(""ABC"");
        assertEquals(e1, e2);
    }",Eager Test
"@Test
    public void testSerialization() {
        PieSectionEntity<String> e1 = new PieSectionEntity<>(
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), 
                new DefaultPieDataset<String>(), 0, 1, ""Key"", ""ToolTip"", ""URL"");
        StandardEntityCollection c1 = new StandardEntityCollection();
        c1.add(e1);
        StandardEntityCollection c2 = TestUtils.serialised(c1);
        assertEquals(c1, c2);
    }",Eager Test
"@Test
    public void testSerialization() {
        XYItemEntity e1 = new XYItemEntity(new Rectangle2D.Double(1.0, 2.0,
                3.0, 4.0), new TimeSeriesCollection<String>(), 1, 9, ""ToolTip"", 
                ""URL"");
        XYItemEntity e2 = TestUtils.serialised(e1);
        assertEquals(e1, e2);
    }",Eager Test
"@Test
    public void testGenerateURLFragment() {
        StandardURLTagFragmentGenerator g
                = new StandardURLTagFragmentGenerator();
        assertEquals("" href=\""abc\"""", g.generateURLFragment(""abc""));
        assertEquals("" href=\""images/abc.png\"""",
                g.generateURLFragment(""images/abc.png""));
        assertEquals("" href=\""http://www.jfree.org/images/abc.png\"""",
                g.generateURLFragment(""http://www.jfree.org/images/abc.png""));
    }",Mystery Guest
"@Test
    public void testBug942() throws Exception {
        final String title = ""Pie Chart Demo 1\n\n\ntestnew line"";
        assertEquals(title, ChartFactory.createPieChart(title, 
                new DefaultPieDataset<String>()).getTitle().getText());
    }",No Smells
"@Test
    public void testGetSubtitle() {
        DefaultPieDataset<String> dataset = new DefaultPieDataset<>();
        JFreeChart chart = ChartFactory.createPieChart(""title"", dataset);
        Title t = chart.getSubtitle(0);
        assertTrue(t instanceof LegendTitle);

        try {
            chart.getSubtitle(-1);
            fail(""Should have thrown an IllegalArgumentException on negative number"");
        }",No Smells
"@Test
    public void testSerialization1() {
        DefaultPieDataset<String> data = new DefaultPieDataset<>();
        data.setValue(""Type 1"", 54.5);
        data.setValue(""Type 2"", 23.9);
        data.setValue(""Type 3"", 45.8);

        JFreeChart c1 = ChartFactory.createPieChart(""Test"", data);
        JFreeChart c2 = TestUtils.serialised(c1);
        assertEquals(c1, c2);
        LegendTitle lt2 = c2.getLegend();
        assertSame(lt2.getSources()[0], c2.getPlot());
    }",No Smells
"@Test
    public void testSerialization2() {

        // row keys...
        String series1 = ""First"";
        String series2 = ""Second"";
        String series3 = ""Third"";

        // column keys...
        String category1 = ""Category 1"";
        String category2 = ""Category 2"";
        String category3 = ""Category 3"";
        String category4 = ""Category 4"";
        String category5 = ""Category 5"";
        String category6 = ""Category 6"";
        String category7 = ""Category 7"";
        String category8 = ""Category 8"";

        // create the dataset...
        DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>();

        dataset.addValue(1.0, series1, category1);
        dataset.addValue(4.0, series1, category2);
        dataset.addValue(3.0, series1, category3);
        dataset.addValue(5.0, series1, category4);
        dataset.addValue(5.0, series1, category5);
        dataset.addValue(7.0, series1, category6);
        dataset.addValue(7.0, series1, category7);
        dataset.addValue(8.0, series1, category8);

        dataset.addValue(5.0, series2, category1);
        dataset.addValue(7.0, series2, category2);
        dataset.addValue(6.0, series2, category3);
        dataset.addValue(8.0, series2, category4);
        dataset.addValue(4.0, series2, category5);
        dataset.addValue(4.0, series2, category6);
        dataset.addValue(2.0, series2, category7);
        dataset.addValue(1.0, series2, category8);

        dataset.addValue(4.0, series3, category1);
        dataset.addValue(3.0, series3, category2);
        dataset.addValue(2.0, series3, category3);
        dataset.addValue(3.0, series3, category4);
        dataset.addValue(6.0, series3, category5);
        dataset.addValue(3.0, series3, category6);
        dataset.addValue(4.0, series3, category7);
        dataset.addValue(3.0, series3, category8);

        // create the chart...
        JFreeChart c1 = ChartFactory.createBarChart(""Vertical Bar Chart"",
                ""Category"", ""Value"", dataset);
        JFreeChart c2 = TestUtils.serialised(c1);
        assertEquals(c1, c2);
    }",No Smells
"@Test
    public void testEquals() {

        // standard test
        BoxAndWhiskerXYToolTipGenerator g1
                = new BoxAndWhiskerXYToolTipGenerator();
        BoxAndWhiskerXYToolTipGenerator g2
                = new BoxAndWhiskerXYToolTipGenerator();
        assertEquals(g1, g2);
        assertEquals(g2, g1);

        // tooltip format
        g1 = new BoxAndWhiskerXYToolTipGenerator(""{0}",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        BubbleXYItemLabelGenerator g1 = new BubbleXYItemLabelGenerator();
        BubbleXYItemLabelGenerator g2 = CloneUtils.clone(g1);
        assertNotSame(g1, g2);
        assertSame(g1.getClass(), g2.getClass());
        assertEquals(g1, g2);
    }",No Smells
"@Test
    public void testSerialization() {
        BubbleXYItemLabelGenerator g1 = new BubbleXYItemLabelGenerator();
        BubbleXYItemLabelGenerator g2 = TestUtils.serialised(g1);
        assertEquals(g1, g2);
    }",No Smells
"@Test
    public void testSerialization() {
        HighLowItemLabelGenerator g1 = new HighLowItemLabelGenerator();
        HighLowItemLabelGenerator g2 = TestUtils.serialised(g1);
        assertEquals(g1, g2);
    }",No Smells
"@Test
    public void testHashCode() {
        IntervalCategoryItemLabelGenerator g1
                = new IntervalCategoryItemLabelGenerator();
        IntervalCategoryItemLabelGenerator g2
                = new IntervalCategoryItemLabelGenerator();
        assertEquals(g1, g2);
        assertEquals(g1.hashCode(), g2.hashCode());
    }",No Smells
"@Test
    public void testPublicCloneable() {
        IntervalCategoryItemLabelGenerator g1
                = new IntervalCategoryItemLabelGenerator();
        assertTrue(g1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testHashCode() {
        IntervalCategoryToolTipGenerator g1
                = new IntervalCategoryToolTipGenerator();
        IntervalCategoryToolTipGenerator g2
                = new IntervalCategoryToolTipGenerator();
        assertEquals(g1, g2);
        assertEquals(g1.hashCode(), g2.hashCode());
    }",No Smells
"@Test
    public void testSerialization() {
        IntervalCategoryToolTipGenerator g1
                = new IntervalCategoryToolTipGenerator(""{3}",No Smells
"@Test
    public void testSerialization() {
        ItemLabelAnchor a1 = ItemLabelAnchor.INSIDE1;
        ItemLabelAnchor a2 = TestUtils.serialised(a1);
        assertSame(a1, a2);
    }",No Smells
"@Test
    public void testEquals() {
        ItemLabelPosition p1 = new ItemLabelPosition();
        ItemLabelPosition p2 = new ItemLabelPosition();
        assertEquals(p1, p2);
    }",No Smells
"@Test
    public void testPublicCloneable() {
        MultipleXYSeriesLabelGenerator g1 = new MultipleXYSeriesLabelGenerator();
        assertTrue(g1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testSerialization() {
        MultipleXYSeriesLabelGenerator g1 = new MultipleXYSeriesLabelGenerator();
        g1.addSeriesLabel(0, ""Add0"");
        g1.addSeriesLabel(0, ""Add0b"");
        g1.addSeriesLabel(1, ""Add1"");
        MultipleXYSeriesLabelGenerator g2 = TestUtils.serialised(g1);
        assertEquals(g1, g2);
    }",No Smells
"@Test
    public void testEquals1481087() {
        StandardCategoryItemLabelGenerator g1
                = new StandardCategoryItemLabelGenerator(""{0}",No Smells
"@Test
    public void testPublicCloneable() {
        StandardCategoryItemLabelGenerator g1
                = new StandardCategoryItemLabelGenerator();
        assertTrue(g1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        StandardCategorySeriesLabelGenerator g1
                = new StandardCategorySeriesLabelGenerator(""{1}",No Smells
"@Test
    public void testEquals() {
        StandardCategorySeriesLabelGenerator g1
                = new StandardCategorySeriesLabelGenerator();
        StandardCategorySeriesLabelGenerator g2
                = new StandardCategorySeriesLabelGenerator();
        assertEquals(g1, g2);
        assertEquals(g2, g1);

        g1 = new StandardCategorySeriesLabelGenerator(""{1}",No Smells
"@Test
    public void testHashCode() {
        StandardCategorySeriesLabelGenerator g1
                = new StandardCategorySeriesLabelGenerator();
        StandardCategorySeriesLabelGenerator g2
                = new StandardCategorySeriesLabelGenerator();
        assertEquals(g1, g2);
        assertEquals(g1.hashCode(), g2.hashCode());
    }",No Smells
"@Test
    public void testHashCode() {
        StandardPieSectionLabelGenerator g1
                = new StandardPieSectionLabelGenerator();
        StandardPieSectionLabelGenerator g2
                = new StandardPieSectionLabelGenerator();
        assertEquals(g1, g2);
        assertEquals(g1.hashCode(), g2.hashCode());
    }",No Smells
"@Test
    public void testEquals() {
        StandardPieToolTipGenerator g1 = new StandardPieToolTipGenerator();
        StandardPieToolTipGenerator g2 = new StandardPieToolTipGenerator();
        assertEquals(g1, g2);
        assertEquals(g2, g1);

        g1 = new StandardPieToolTipGenerator(""{0}",Eager Test
"@Test
    public void testHashCode() {
        StandardPieToolTipGenerator g1
                = new StandardPieToolTipGenerator();
        StandardPieToolTipGenerator g2
                = new StandardPieToolTipGenerator();
        assertEquals(g1, g2);
        assertEquals(g1.hashCode(), g2.hashCode());
    }",No Smells
"@Test
    public void testPublicCloneable() {
        StandardPieToolTipGenerator g1 = new StandardPieToolTipGenerator();
        assertTrue(g1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        StandardXYItemLabelGenerator g1 = new StandardXYItemLabelGenerator();
        StandardXYItemLabelGenerator g2 = CloneUtils.clone(g1);
        assertNotSame(g1, g2);
        assertSame(g1.getClass(), g2.getClass());
        assertEquals(g1, g2);

        // check independence
        g1.getXFormat().setMinimumIntegerDigits(2);
        assertNotEquals(g1, g2);
        g2.getXFormat().setMinimumIntegerDigits(2);
        assertEquals(g1, g2);

        g1.getYFormat().setMinimumIntegerDigits(2);
        assertNotEquals(g1, g2);
        g2.getYFormat().setMinimumIntegerDigits(2);
        assertEquals(g1, g2);

        // another test...
        g1 = new StandardXYItemLabelGenerator(""{0}",Eager Test
"@Test
    public void testGenerateLabel() {
        StandardXYSeriesLabelGenerator g
                = new StandardXYSeriesLabelGenerator(""Series {0}",No Smells
"@Test
    public void testHashCode() {
        StandardXYSeriesLabelGenerator g1
                = new StandardXYSeriesLabelGenerator();
        StandardXYSeriesLabelGenerator g2
                = new StandardXYSeriesLabelGenerator();
        assertEquals(g1, g2);
        assertEquals(g1.hashCode(), g2.hashCode());
    }",No Smells
"@Test
    public void testHashCode() {
        StandardXYToolTipGenerator g1
                = new StandardXYToolTipGenerator();
        StandardXYToolTipGenerator g2
                = new StandardXYToolTipGenerator();
        assertEquals(g1, g2);
        assertEquals(g1.hashCode(), g2.hashCode());
    }",No Smells
"@Test
    public void testSerialization() {
        StandardXYToolTipGenerator g1 = new StandardXYToolTipGenerator();
        StandardXYToolTipGenerator g2 = TestUtils.serialised(g1);
        assertEquals(g1, g2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        StandardXYZToolTipGenerator g1 = new StandardXYZToolTipGenerator();
        StandardXYZToolTipGenerator g2 = CloneUtils.clone(g1);
        assertNotSame(g1, g2);
        assertSame(g1.getClass(), g2.getClass());
        assertEquals(g1, g2);
    }",No Smells
"@Test
    public void testHashCode() {
        StandardXYZToolTipGenerator g1
                = new StandardXYZToolTipGenerator();
        StandardXYZToolTipGenerator g2
                = new StandardXYZToolTipGenerator();
        assertEquals(g1, g2);
        assertEquals(g1.hashCode(), g2.hashCode());
    }",No Smells
"@Test
    public void testSerialization() {
        StandardXYZToolTipGenerator g1 = new StandardXYZToolTipGenerator();
        StandardXYZToolTipGenerator g2 = TestUtils.serialised(g1);
        assertEquals(g1, g2);
    }",No Smells
"@Test
    public void testSerialization() {
        LegendItemCollection c1 = new LegendItemCollection();
        c1.add(new LegendItem(""Item"", ""Description"", ""ToolTip"", ""URL"",
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), Color.RED));
        LegendItemCollection c2 = TestUtils.serialised(c1);
        assertEquals(c1, c2);
    }",No Smells
"@Test
    public void testEquals() {

        LegendItem item1 = new LegendItem(""Label"", ""Description"",
                ""ToolTip"", ""URL"", true,
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), true, Color.RED,
                true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0),
                new BasicStroke(2.1f), Color.GREEN);
        LegendItem item2 = new LegendItem(""Label"", ""Description"",
                ""ToolTip"", ""URL"", true,
                new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0),
                true, Color.RED, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertEquals(item1, item2);
        assertEquals(item2, item1);

        item1 = new LegendItem(""Label2"", ""Description"", ""ToolTip"", ""URL"",
                true, new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), true,
                Color.RED, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description"", ""ToolTip"", ""URL"",
                true, new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0),
                true, Color.RED, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", true, new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0),
                true, Color.RED, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", true, new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0),
                true, Color.RED, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0),
                true, Color.RED, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0),
                true, Color.RED, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                true, Color.RED, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                true, Color.RED, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                false, Color.RED, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                false, Color.RED, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"", ""URL"",
                false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0), false,
                Color.BLACK, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"", ""URL"",
                false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0), false,
                Color.BLACK, true, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                false, Color.BLACK, false, Color.BLUE, new BasicStroke(1.2f),
                true, new Line2D.Double(1.0, 2.0, 3.0, 4.0),
                new BasicStroke(2.1f), Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"", ""URL"",
                false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0), false,
                Color.BLACK, false, Color.BLUE, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"", ""URL"",
                false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0), false,
                Color.BLACK, false, Color.YELLOW, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"", ""URL"",
                false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0), false,
                Color.BLACK, false, Color.YELLOW, new BasicStroke(1.2f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"", ""URL"",
                false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0), false,
                Color.BLACK, false, Color.YELLOW, new BasicStroke(2.1f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"", ""URL"",
                false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0), false,
                Color.BLACK, false, Color.YELLOW, new BasicStroke(2.1f), true,
                new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(2.1f),
                Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                false, Color.BLACK, false, Color.YELLOW, new BasicStroke(2.1f),
                false, new Line2D.Double(1.0, 2.0, 3.0, 4.0),
                new BasicStroke(2.1f), Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                false, Color.BLACK, false, Color.YELLOW, new BasicStroke(2.1f),
                false, new Line2D.Double(1.0, 2.0, 3.0, 4.0),
                new BasicStroke(2.1f), Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                false, Color.BLACK, false, Color.YELLOW, new BasicStroke(2.1f),
                false, new Line2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(2.1f), Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                false, Color.BLACK, false, Color.YELLOW, new BasicStroke(2.1f),
                false, new Line2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(2.1f), Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                false, Color.BLACK, false, Color.YELLOW, new BasicStroke(2.1f),
                false, new Line2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(3.3f), Color.GREEN);
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                false, Color.BLACK, false, Color.YELLOW, new BasicStroke(2.1f),
                false, new Line2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(3.3f), Color.GREEN);
        assertEquals(item1, item2);

        item1 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"", ""URL"",
                false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0), false,
                Color.BLACK, false, Color.YELLOW, new BasicStroke(2.1f), false,
            new Line2D.Double(4.0, 3.0, 2.0, 1.0), new BasicStroke(3.3f),
            Color.WHITE
        );
        assertNotEquals(item1, item2);
        item2 = new LegendItem(""Label2"", ""Description2"", ""ToolTip"",
                ""URL"", false, new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0),
                false, Color.BLACK, false, Color.YELLOW, new BasicStroke(2.1f),
                false, new Line2D.Double(4.0, 3.0, 2.0, 1.0),
                new BasicStroke(3.3f),
                Color.WHITE);
        assertEquals(item1, item2);

        // fillPaintTransformer
        item1.setFillPaintTransformer(new StandardGradientPaintTransformer(
                GradientPaintTransformType.CENTER_VERTICAL));
        assertNotEquals(item1, item2);
        item2.setFillPaintTransformer(new StandardGradientPaintTransformer(
                GradientPaintTransformType.CENTER_VERTICAL));
        assertEquals(item1, item2);

        // labelFont
        item1.setLabelFont(new Font(""Dialog"", Font.PLAIN, 13));
        assertNotEquals(item1, item2);
        item2.setLabelFont(new Font(""Dialog"", Font.PLAIN, 13));
        assertEquals(item1, item2);

        // labelPaint
        item1.setLabelPaint(Color.RED);
        assertNotEquals(item1, item2);
        item2.setLabelPaint(Color.RED);
        assertEquals(item1, item2);

        // fillPaint
        item1.setFillPaint(new GradientPaint(1.0f, 2.0f, Color.GREEN, 3.0f,
                4.0f, Color.BLUE));
        assertNotEquals(item1, item2);
        item2.setFillPaint(new GradientPaint(1.0f, 2.0f, Color.GREEN, 3.0f,
                4.0f, Color.BLUE));
        assertEquals(item1, item2);

        // outlinePaint
        item1.setOutlinePaint(new GradientPaint(1.1f, 2.2f, Color.GREEN, 3.3f,
                4.4f, Color.BLUE));
        assertNotEquals(item1, item2);
        item2.setOutlinePaint(new GradientPaint(1.1f, 2.2f, Color.GREEN, 3.3f,
                4.4f, Color.BLUE));
        assertEquals(item1, item2);

        // linePaint
        item1.setLinePaint(new GradientPaint(0.1f, 0.2f, Color.GREEN, 0.3f,
                0.4f, Color.BLUE));
        assertNotEquals(item1, item2);
        item2.setLinePaint(new GradientPaint(0.1f, 0.2f, Color.GREEN, 0.3f,
                0.4f, Color.BLUE));
        assertEquals(item1, item2);
    }",Eager Test
"@Test
    public void testSerialization() {
        LineNeedle n1 = new LineNeedle();
        LineNeedle n2 = TestUtils.serialised(n1);
        assertEquals(n1, n2);
    }",No Smells
"@Test
    public void testSerialization() {
        LongNeedle n1 = new LongNeedle();
        LongNeedle n2 = TestUtils.serialised(n1);
        assertEquals(n1, n2);
    }",No Smells
"@Test
    public void testEquals() {
       PlumNeedle n1 = new PlumNeedle();
       PlumNeedle n2 = new PlumNeedle();
        assertEquals(n1, n2);
        assertEquals(n2, n1);
    }",No Smells
"@Test
    public void testEquals() {
       ShipNeedle n1 = new ShipNeedle();
       ShipNeedle n2 = new ShipNeedle();
        assertEquals(n1, n2);
        assertEquals(n2, n1);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        WindNeedle n1 = new WindNeedle();
        WindNeedle n2 = CloneUtils.clone(n1);
        assertNotSame(n1, n2);
        assertSame(n1.getClass(), n2.getClass());
        assertEquals(n1, n2);
    }",No Smells
"@Test
    public void testEquals() {
       WindNeedle n1 = new WindNeedle();
       WindNeedle n2 = new WindNeedle();
        assertEquals(n1, n2);
        assertEquals(n2, n1);
    }",No Smells
"@Test
    public void testGetSetKey() {
        CategoryMarker m = new CategoryMarker(""X"");
        m.addChangeListener(this);
        this.lastEvent = null;
        assertEquals(""X"", m.getKey());
        m.setKey(""Y"");
        assertEquals(""Y"", m.getKey());
        assertEquals(m, this.lastEvent.getMarker());

        // check null argument...
        try {
            m.setKey(null);
            fail(""Expected an IllegalArgumentException for null."");
        }",Eager Test
"@Test
    public void test1169972() {
        CategoryPlot<String, String> plot = new CategoryPlot<>(null, null, null, null);
        plot.setDomainAxis(new CategoryAxis(""C""));
        plot.setRangeAxis(new NumberAxis(""Y""));
        plot.setRenderer(new BarRenderer());
        plot.setDataset(new DefaultCategoryDataset<>());
        assertTrue(true); // we didn't get an exception so all is good
    }",No Smells
"@Test
    public void testAddDomainMarker() {
        CategoryPlot<String, String> plot = new CategoryPlot<>();
        CategoryMarker m = new CategoryMarker(""C1"");
        plot.addDomainMarker(m);
        List<EventListener> listeners = Arrays.asList(m.getListeners(
                MarkerChangeListener.class));
        assertTrue(listeners.contains(plot));
        plot.clearDomainMarkers();
        listeners = Arrays.asList(m.getListeners(MarkerChangeListener.class));
        assertFalse(listeners.contains(plot));
    }",Eager Test
"@Test
    public void testAddRangeMarker() {
        CategoryPlot<String, String> plot = new CategoryPlot<>();
        Marker m = new ValueMarker(1.0);
        plot.addRangeMarker(m);
        List<EventListener> listeners = Arrays.asList(m.getListeners(
                MarkerChangeListener.class));
        assertTrue(listeners.contains(plot));
        plot.clearRangeMarkers();
        listeners = Arrays.asList(m.getListeners(MarkerChangeListener.class));
        assertFalse(listeners.contains(plot));
    }",Eager Test
"@Test
    public void testEquals_ObjectList4() {
        CategoryPlot<String, String> p1 = new CategoryPlot<>();
        p1.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT);
        CategoryPlot<String, String> p2 = new CategoryPlot<>();
        p2.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT);
        assertEquals(p1, p2);
        p2.setRangeAxisLocation(1, AxisLocation.TOP_OR_LEFT);
        assertNotEquals(p1, p2);
    }",Eager Test
"@Test
    public void testGetRangeAxisForDataset() {
        CategoryDataset<String, String> dataset = new DefaultCategoryDataset<>();
        CategoryAxis xAxis = new CategoryAxis(""X"");
        NumberAxis yAxis = new NumberAxis(""Y"");
        CategoryItemRenderer renderer = new DefaultCategoryItemRenderer();
        CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, xAxis, 
                yAxis, renderer);
        assertEquals(yAxis, plot.getRangeAxisForDataset(0));

        // should get IllegalArgumentException for negative index
        boolean pass = false;
        try {
            plot.getRangeAxisForDataset(-1);
        }",Eager Test
"@Test
    public void testSerialization() {
        DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>();
        CategoryAxis domainAxis = new CategoryAxis(""Domain"");
        NumberAxis rangeAxis = new NumberAxis(""Range"");
        BarRenderer renderer = new BarRenderer();
        CategoryPlot<String, String> p1 = new CategoryPlot<>(dataset, domainAxis, 
                rangeAxis, renderer);
        p1.setOrientation(PlotOrientation.HORIZONTAL);
        CategoryPlot<String, String> p2 = TestUtils.serialised(p1);
        assertEquals(p1, p2);
    }",Eager Test
"@Test
    public void testSerialization() {
        CombinedDomainXYPlot<String> plot1 = createPlot();
        CombinedDomainXYPlot<String> plot2 = TestUtils.serialised(plot1);
        assertEquals(plot1, plot2);
    }",No Smells
"@Test
    public void testSerialization() {
        CombinedRangeXYPlot<String> plot1 = createPlot();
        CombinedRangeXYPlot<String> plot2 = TestUtils.serialised(plot1);
        assertEquals(plot1, plot2);
    }",No Smells
"@Test
    public void testPublicCloneable() {
        Crosshair c1 = new Crosshair(1.0);
        assertTrue(c1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testEquals() {
        DialCap c1 = new DialCap();
        DialCap c2 = new DialCap();
        assertEquals(c1, c2);

        // visible
        c1.setVisible(false);
        assertNotEquals(c1, c2);
        c2.setVisible(false);
        assertEquals(c1, c2);
    }",No Smells
"@Test
    public void testEquals() {
        ArcDialFrame f1 = new ArcDialFrame();
        ArcDialFrame f2 = new ArcDialFrame();
        assertEquals(f1, f2);

        // background paint
        f1.setBackgroundPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.YELLOW));
        assertNotEquals(f1, f2);
        f2.setBackgroundPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.YELLOW));
        assertEquals(f1, f2);

        // foreground paint
        f1.setForegroundPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.YELLOW));
        assertNotEquals(f1, f2);
        f2.setForegroundPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.YELLOW));
        assertEquals(f1, f2);

        // stroke
        f1.setStroke(new BasicStroke(1.1f));
        assertNotEquals(f1, f2);
        f2.setStroke(new BasicStroke(1.1f));
        assertEquals(f1, f2);

        // inner radius
        f1.setInnerRadius(0.11);
        assertNotEquals(f1, f2);
        f2.setInnerRadius(0.11);
        assertEquals(f1, f2);

        // outer radius
        f1.setOuterRadius(0.88);
        assertNotEquals(f1, f2);
        f2.setOuterRadius(0.88);
        assertEquals(f1, f2);

        // startAngle
        f1.setStartAngle(99);
        assertNotEquals(f1, f2);
        f2.setStartAngle(99);
        assertEquals(f1, f2);

        // extent
        f1.setExtent(33);
        assertNotEquals(f1, f2);
        f2.setExtent(33);
        assertEquals(f1, f2);

        // check an inherited attribute
        f1.setVisible(false);
        assertNotEquals(f1, f2);
        f2.setVisible(false);
        assertEquals(f1, f2);
    }",Eager Test
"@Test
    public void testHashCode() {
        ArcDialFrame f1 = new ArcDialFrame();
        ArcDialFrame f2 = new ArcDialFrame();
        assertEquals(f1, f2);
        int h1 = f1.hashCode();
        int h2 = f2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testSerialization() {
        ArcDialFrame f1 = new ArcDialFrame();
        ArcDialFrame f2 = TestUtils.serialised(f1);
        assertEquals(f1, f2);
    }",No Smells
"@Test
    public void testHashCode() {
        DialBackground b1 = new DialBackground(Color.RED);
        DialBackground b2 = new DialBackground(Color.RED);
        assertEquals(b1, b2);
        int h1 = b1.hashCode();
        int h2 = b2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        // test a default instance
        DialCap c1 = new DialCap();
        DialCap c2 = CloneUtils.clone(c1);

        assertNotSame(c1, c2);
        assertSame(c1.getClass(), c2.getClass());
        assertEquals(c1, c2);

        // test a customised instance
        c1 = new DialCap();
        c1.setFillPaint(new GradientPaint(1.0f, 2.0f, Color.BLUE,
                3.0f, 4.0f, Color.GREEN));
        c1.setOutlinePaint(new GradientPaint(1.0f, 2.0f, Color.WHITE,
                3.0f, 4.0f, Color.GRAY));
        c1.setOutlineStroke(new BasicStroke(2.0f));
        c2 = (DialCap) c1.clone();
        assertNotSame(c1, c2);
        assertSame(c1.getClass(), c2.getClass());
        assertEquals(c1, c2);

        // check that the listener lists are independent
        MyDialLayerChangeListener l1 = new MyDialLayerChangeListener();
        c1.addChangeListener(l1);
        assertTrue(c1.hasListener(l1));
        assertFalse(c2.hasListener(l1));
    }",Eager Test
"@Test
    public void testEquals() {
        DialCap c1 = new DialCap();
        DialCap c2 = new DialCap();
        assertEquals(c1, c2);

        // radius
        c1.setRadius(0.5);
        assertNotEquals(c1, c2);
        c2.setRadius(0.5);
        assertEquals(c1, c2);

        // fill paint
        c1.setFillPaint(new GradientPaint(1.0f, 2.0f, Color.BLUE,
                3.0f, 4.0f, Color.GREEN));
        assertNotEquals(c1, c2);
        c2.setFillPaint(new GradientPaint(1.0f, 2.0f, Color.BLUE,
                3.0f, 4.0f, Color.GREEN));

        // outline paint
        c1.setOutlinePaint(new GradientPaint(1.0f, 2.0f, Color.WHITE,
                3.0f, 4.0f, Color.GRAY));
        assertNotEquals(c1, c2);
        c2.setOutlinePaint(new GradientPaint(1.0f, 2.0f, Color.WHITE,
                3.0f, 4.0f, Color.GRAY));

        assertEquals(c1, c2);

        // outline stroke
        c1.setOutlineStroke(new BasicStroke(1.1f));
        assertNotEquals(c1, c2);
        c2.setOutlineStroke(new BasicStroke(1.1f));
        assertEquals(c1, c2);

        // check an inherited attribute
        c1.setVisible(false);
        assertNotEquals(c1, c2);
        c2.setVisible(false);
        assertEquals(c1, c2);
    }",Eager Test
"@Test
    public void testHashCode() {
        DialCap c1 = new DialCap();
        DialCap c2 = new DialCap();
        assertEquals(c1, c2);
        int h1 = c1.hashCode();
        int h2 = c2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testLayerListener() {
        DialPlot p = new DialPlot();
        DialBackground b1 = new DialBackground(Color.RED);
        p.addLayer(b1);
        p.addChangeListener(this);
        this.lastEvent = null;
        b1.setPaint(Color.BLUE);
        assertNotNull(this.lastEvent);

        DialBackground b2 = new DialBackground(Color.GREEN);
        p.addLayer(b2);
        this.lastEvent = null;
        b1.setPaint(Color.RED);
        assertNotNull(this.lastEvent);
        b2.setPaint(Color.GREEN);
        assertNotNull(this.lastEvent);

        p.removeLayer(b2);
        this.lastEvent = null;
        b2.setPaint(Color.RED);
        assertNull(this.lastEvent);
    }",Eager Test
"@Test
    public void testScaleListener() {
        DialPlot p = new DialPlot();
        StandardDialScale s1 = new StandardDialScale();
        p.addScale(0, s1);
        p.addChangeListener(this);
        this.lastEvent = null;
        s1.setStartAngle(22.0);
        assertNotNull(this.lastEvent);

        StandardDialScale s2 = new StandardDialScale();
        p.addScale(0, s2);
        this.lastEvent = null;
        s1.setStartAngle(33.0);
        assertNull(this.lastEvent);
        s2.setStartAngle(33.0);
        assertNotNull(this.lastEvent);
    }",Eager Test
"@Test
    public void testEqualsPin() {
        DialPointer.Pin p1 = new DialPointer.Pin();
        DialPointer.Pin p2 = new DialPointer.Pin();
        assertEquals(p1, p2);

        p1.setPaint(Color.GREEN);
        assertNotEquals(p1, p2);
        p2.setPaint(Color.GREEN);
        assertEquals(p1, p2);

        BasicStroke s = new BasicStroke(4.4f);
        p1.setStroke(s);
        assertNotEquals(p1, p2);
        p2.setStroke(s);
        assertEquals(p1, p2);
    }",No Smells
"@Test
    public void testEqualsPointer() {
        DialPointer.Pointer p1 = new DialPointer.Pointer();
        DialPointer.Pointer p2 = new DialPointer.Pointer();
        assertEquals(p1, p2);

        p1.setFillPaint(Color.GREEN);
        assertNotEquals(p1, p2);
        p2.setFillPaint(Color.GREEN);
        assertEquals(p1, p2);

        p1.setOutlinePaint(Color.GREEN);
        assertNotEquals(p1, p2);
        p2.setOutlinePaint(Color.GREEN);
        assertEquals(p1, p2);
    }",No Smells
"@Test
    public void testHashCode() {
        DialPointer i1 = new DialPointer.Pin(1);
        DialPointer i2 = new DialPointer.Pin(1);
        assertEquals(i1, i2);
        int h1 = i1.hashCode();
        int h2 = i2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testSerialization2() {
        DialPointer i1 = new DialPointer.Pointer(1);
        DialPointer i2 = TestUtils.serialised(i1);
        assertEquals(i1, i2);
    }",No Smells
"@Test
    public void testSerialization() {
        // test a default instance
        DialTextAnnotation a1 = new DialTextAnnotation(""A1"");
        DialTextAnnotation a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);

        // test a custom instance
        a1 = new DialTextAnnotation(""A1"");
        a1.setPaint(new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f, 4.0f,
                Color.BLUE));

        a2 = TestUtils.serialised(a1);
        assertEquals(a1, a2);
    }",No Smells
"@Test
    public void testSerialization() {
        DialValueIndicator i1 = new DialValueIndicator(0);
        DialValueIndicator i2 = TestUtils.serialised(i1);
        assertEquals(i1, i2);
    }",No Smells
"@Test
    public void testHashCode() {
        StandardDialFrame f1 = new StandardDialFrame();
        StandardDialFrame f2 = new StandardDialFrame();
        assertEquals(f1, f2);
        int h1 = f1.hashCode();
        int h2 = f2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testHashCode() {
        StandardDialScale s1 = new StandardDialScale();
        StandardDialScale s2 = new StandardDialScale();
        assertEquals(s1, s2);
        int h1 = s1.hashCode();
        int h2 = s2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        FastScatterPlot p1 = new FastScatterPlot();
        FastScatterPlot p2 = CloneUtils.clone(p1);
        assertNotSame(p1, p2);
        assertSame(p1.getClass(), p2.getClass());
        assertEquals(p1, p2);
    }",No Smells
"@Test
    public void testEquals() {

        FastScatterPlot plot1 = new FastScatterPlot();
        FastScatterPlot plot2 = new FastScatterPlot();
        assertEquals(plot1, plot2);
        assertEquals(plot2, plot1);

        plot1.setPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.YELLOW));
        assertNotEquals(plot1, plot2);
        plot2.setPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.YELLOW));
        assertEquals(plot1, plot2);

        plot1.setDomainGridlinesVisible(false);
        assertNotEquals(plot1, plot2);
        plot2.setDomainGridlinesVisible(false);
        assertEquals(plot1, plot2);

        plot1.setDomainGridlinePaint(new GradientPaint(1.0f, 2.0f, Color.BLUE,
                3.0f, 4.0f, Color.YELLOW));
        assertNotEquals(plot1, plot2);
        plot2.setDomainGridlinePaint(new GradientPaint(1.0f, 2.0f, Color.BLUE,
                3.0f, 4.0f, Color.YELLOW));
        assertEquals(plot1, plot2);

        Stroke s = new BasicStroke(1.5f);
        plot1.setDomainGridlineStroke(s);
        assertNotEquals(plot1, plot2);
        plot2.setDomainGridlineStroke(s);
        assertEquals(plot1, plot2);

        plot1.setRangeGridlinesVisible(false);
        assertNotEquals(plot1, plot2);
        plot2.setRangeGridlinesVisible(false);
        assertEquals(plot1, plot2);

        plot1.setRangeGridlinePaint(new GradientPaint(1.0f, 2.0f, Color.GREEN,
                3.0f, 4.0f, Color.YELLOW));
        assertNotEquals(plot1, plot2);
        plot2.setRangeGridlinePaint(new GradientPaint(1.0f, 2.0f, Color.GREEN,
                3.0f, 4.0f, Color.YELLOW));
        assertEquals(plot1, plot2);

        Stroke s2 = new BasicStroke(1.5f);
        plot1.setRangeGridlineStroke(s2);
        assertNotEquals(plot1, plot2);
        plot2.setRangeGridlineStroke(s2);
        assertEquals(plot1, plot2);

        plot1.setDomainPannable(true);
        assertNotEquals(plot1, plot2);
        plot2.setDomainPannable(true);
        assertEquals(plot1, plot2);

        plot1.setRangePannable(true);
        assertNotEquals(plot1, plot2);
        plot2.setRangePannable(true);
        assertEquals(plot1, plot2);

    }",No Smells
"@Test
    public void testGetSetLabelPaint() {
        // we use ValueMarker for the tests, because we need a concrete
        // subclass...
        ValueMarker m = new ValueMarker(1.1);
        m.addChangeListener(this);
        this.lastEvent = null;
        assertEquals(Color.BLACK, m.getLabelPaint());
        m.setLabelPaint(Color.RED);
        assertEquals(Color.RED, m.getLabelPaint());
        assertEquals(m, this.lastEvent.getMarker());

        // check null argument...
        try {
            m.setLabelPaint(null);
            fail(""Expected an IllegalArgumentException for null."");
        }",No Smells
"@Test
    public void testGetSetOutlineStroke() {
        // we use ValueMarker for the tests, because we need a concrete
        // subclass...
        ValueMarker m = new ValueMarker(1.1);
        m.addChangeListener(this);
        this.lastEvent = null;
        assertEquals(new BasicStroke(0.5f), m.getOutlineStroke());
        m.setOutlineStroke(new BasicStroke(1.1f));
        assertEquals(new BasicStroke(1.1f), m.getOutlineStroke());
        assertEquals(m, this.lastEvent.getMarker());

        // check null argument...
        m.setOutlineStroke(null);
        assertNull(m.getOutlineStroke());
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        MeterPlot p1 = new MeterPlot();
        MeterPlot p2 = CloneUtils.clone(p1);
        assertNotSame(p1, p2);
        assertSame(p1.getClass(), p2.getClass());
        assertEquals(p1, p2);

        // the clone and the original share a reference to the SAME dataset
        assertSame(p1.getDataset(), p2.getDataset());

        // try a few checks to ensure that the clone is independent of the
        // original
        p1.getTickLabelFormat().setMinimumIntegerDigits(99);
        assertNotEquals(p1, p2);
        p2.getTickLabelFormat().setMinimumIntegerDigits(99);
        assertEquals(p1, p2);

        p1.addInterval(new MeterInterval(""Test"", new Range(1.234, 5.678)));
        assertNotEquals(p1, p2);
        p2.addInterval(new MeterInterval(""Test"", new Range(1.234, 5.678)));
        assertEquals(p1, p2);

    }",Eager Test
"@Test
    public void testConstructor() {
        MultiplePiePlot plot = new MultiplePiePlot();
        assertNull(plot.getDataset());

        // the following checks that the plot registers itself as a listener
        // with the dataset passed to the constructor - see patch 1943021
        DefaultCategoryDataset<String,String> dataset = new DefaultCategoryDataset<>();
        plot = new MultiplePiePlot(dataset);
        assertTrue(dataset.hasListener(plot));
    }",No Smells
"@Test
    public void testEquals() {
        MultiplePiePlot p1 = new MultiplePiePlot();
        MultiplePiePlot p2 = new MultiplePiePlot();
        assertEquals(p1, p2);
        assertEquals(p2, p1);

        p1.setDataExtractOrder(TableOrder.BY_ROW);
        assertNotEquals(p1, p2);
        p2.setDataExtractOrder(TableOrder.BY_ROW);
        assertEquals(p1, p2);

        p1.setLimit(1.23);
        assertNotEquals(p1, p2);
        p2.setLimit(1.23);
        assertEquals(p1, p2);

        p1.setAggregatedItemsKey(""Aggregated Items"");
        assertNotEquals(p1, p2);
        p2.setAggregatedItemsKey(""Aggregated Items"");
        assertEquals(p1, p2);

        p1.setAggregatedItemsPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.YELLOW));
        assertNotEquals(p1, p2);
        p2.setAggregatedItemsPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.YELLOW));
        assertEquals(p1, p2);

        p1.setPieChart(ChartFactory.createPieChart(""Title"", null, true, true,
                true));
        assertNotEquals(p1, p2);
        p2.setPieChart(ChartFactory.createPieChart(""Title"", null, true, true,
                true));
        assertEquals(p1, p2);

        p1.setLegendItemShape(new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0));
        assertNotEquals(p1, p2);
        p2.setLegendItemShape(new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0));
        assertEquals(p1, p2);
    }",Eager Test
"@Test
    public void testBug1126_b() throws CloneNotSupportedException {
        DefaultPieDataset<String> dataset1 = new DefaultPieDataset<>();
        PiePlot plot1 = new PiePlot(dataset1);
        plot1.setSectionOutlinePaint(""A"", Color.RED);
        plot1.setSectionOutlinePaint(""B"", Color.GREEN);
        PiePlot plot2 = CloneUtils.clone(plot1);
        plot2.setSectionOutlinePaint(""A"", Color.BLUE);
        plot2.setSectionOutlinePaint(""B"", Color.YELLOW);
        assertEquals(Color.RED, plot1.getSectionOutlinePaint(""A""));
        assertEquals(Color.GREEN, plot1.getSectionOutlinePaint(""B""));
        assertEquals(Color.BLUE, plot2.getSectionOutlinePaint(""A""));
        assertEquals(Color.YELLOW, plot2.getSectionOutlinePaint(""B""));
    }",Eager Test
"@Test
    public void testBug1126_c() throws CloneNotSupportedException {
        DefaultPieDataset<String> dataset1 = new DefaultPieDataset<>();
        PiePlot plot1 = new PiePlot(dataset1);
        plot1.setSectionOutlineStroke(""A"", new BasicStroke(5.0f));
        plot1.setSectionOutlineStroke(""B"", new BasicStroke(6.0f));
        PiePlot plot2 = CloneUtils.clone(plot1);
        plot2.setSectionOutlineStroke(""A"", new BasicStroke(7.0f));
        plot2.setSectionOutlineStroke(""B"", new BasicStroke(8.0f));
        assertEquals(new BasicStroke(5.0f), plot1.getSectionOutlineStroke(""A""));
        assertEquals(new BasicStroke(6.0f), plot1.getSectionOutlineStroke(""B""));
        assertEquals(new BasicStroke(7.0f), plot2.getSectionOutlineStroke(""A""));
        assertEquals(new BasicStroke(8.0f), plot2.getSectionOutlineStroke(""B""));
    }",Eager Test
"@Test
    public void testSerialization() {
        PiePlot p1 = new PiePlot(null);
        PiePlot p2 = TestUtils.serialised(p1);
        assertEquals(p1, p2);
    }",No Smells
"@Test
    public void testEquals() {
        assertEquals(PlotOrientation.HORIZONTAL, PlotOrientation.HORIZONTAL);
        assertEquals(PlotOrientation.VERTICAL, PlotOrientation.VERTICAL);
        assertNotEquals(PlotOrientation.HORIZONTAL, PlotOrientation.VERTICAL);
        assertNotEquals(PlotOrientation.VERTICAL, PlotOrientation.HORIZONTAL);
    }",No Smells
"@Test
    public void testSerialization() {
        PlotOrientation orientation1 = PlotOrientation.HORIZONTAL;
        PlotOrientation orientation2 = TestUtils.serialised(orientation1);
        assertEquals(orientation1, orientation2);
        boolean same = orientation1 == orientation2;
        assertTrue(same);
    }",Eager Test
"@Test
    public void testEquals() {
        PiePlot plot1 = new PiePlot();
        PiePlot plot2 = new PiePlot();
        assertEquals(plot1, plot2);
        assertEquals(plot2, plot1);

        // noDataMessage
        plot1.setNoDataMessage(""No data XYZ"");
        assertNotEquals(plot1, plot2);
        plot2.setNoDataMessage(""No data XYZ"");
        assertEquals(plot1, plot2);

        // noDataMessageFont
        plot1.setNoDataMessageFont(new Font(""SansSerif"", Font.PLAIN, 13));
        assertNotEquals(plot1, plot2);
        plot2.setNoDataMessageFont(new Font(""SansSerif"", Font.PLAIN, 13));
        assertEquals(plot1, plot2);

        // noDataMessagePaint
        plot1.setNoDataMessagePaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.BLUE));
        assertNotEquals(plot1, plot2);
        plot2.setNoDataMessagePaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.BLUE));
        assertEquals(plot1, plot2);

        // insets
        plot1.setInsets(new RectangleInsets(1.0, 2.0, 3.0, 4.0));
        assertNotEquals(plot1, plot2);
        plot2.setInsets(new RectangleInsets(1.0, 2.0, 3.0, 4.0));
        assertEquals(plot1, plot2);

        // outlineVisible
        plot1.setOutlineVisible(false);
        assertNotEquals(plot1, plot2);
        plot2.setOutlineVisible(false);
        assertEquals(plot1, plot2);

        // outlineStroke
        BasicStroke s = new BasicStroke(1.23f);
        plot1.setOutlineStroke(s);
        assertNotEquals(plot1, plot2);
        plot2.setOutlineStroke(s);
        assertEquals(plot1, plot2);

        // outlinePaint
        plot1.setOutlinePaint(new GradientPaint(1.0f, 2.0f, Color.YELLOW,
                3.0f, 4.0f, Color.GREEN));
        assertNotEquals(plot1, plot2);
        plot2.setOutlinePaint(new GradientPaint(1.0f, 2.0f, Color.YELLOW,
                3.0f, 4.0f, Color.GREEN));
        assertEquals(plot1, plot2);

        // backgroundPaint
        plot1.setBackgroundPaint(new GradientPaint(1.0f, 2.0f, Color.CYAN,
                3.0f, 4.0f, Color.GREEN));
        assertNotEquals(plot1, plot2);
        plot2.setBackgroundPaint(new GradientPaint(1.0f, 2.0f, Color.CYAN,
                3.0f, 4.0f, Color.GREEN));
        assertEquals(plot1, plot2);

//        // backgroundImage
//        plot1.setBackgroundImage(JFreeChart.INFO.getLogo());
//        assertFalse(plot1.equals(plot2));
//        plot2.setBackgroundImage(JFreeChart.INFO.getLogo());
//        assertTrue(plot1.equals(plot2));

        // backgroundImageAlignment
        plot1.setBackgroundImageAlignment(RectangleAlignment.BOTTOM_RIGHT);
        assertNotEquals(plot1, plot2);
        plot2.setBackgroundImageAlignment(RectangleAlignment.BOTTOM_RIGHT);
        assertEquals(plot1, plot2);

        // backgroundImageAlpha
        plot1.setBackgroundImageAlpha(0.77f);
        assertNotEquals(plot1, plot2);
        plot2.setBackgroundImageAlpha(0.77f);
        assertEquals(plot1, plot2);

        // foregroundAlpha
        plot1.setForegroundAlpha(0.99f);
        assertNotEquals(plot1, plot2);
        plot2.setForegroundAlpha(0.99f);
        assertEquals(plot1, plot2);

        // backgroundAlpha
        plot1.setBackgroundAlpha(0.99f);
        assertNotEquals(plot1, plot2);
        plot2.setBackgroundAlpha(0.99f);
        assertEquals(plot1, plot2);

        // drawingSupplier
        plot1.setDrawingSupplier(new DefaultDrawingSupplier(
                new Paint[] {Color.BLUE}",Eager Test
"@Test
    public void testGetLegendItems() {
        XYSeriesCollection<String> d = new XYSeriesCollection<>();
        d.addSeries(new XYSeries<>(""A""));
        d.addSeries(new XYSeries<>(""B""));
        DefaultPolarItemRenderer r = new DefaultPolarItemRenderer();
        PolarPlot plot = new PolarPlot();
        plot.setDataset(d);
        plot.setRenderer(r);
        LegendItemCollection items = plot.getLegendItems();
        assertEquals(2, items.getItemCount());
        LegendItem item1 = items.get(0);
        assertEquals(""A"", item1.getLabel());
        LegendItem item2 = items.get(1);
        assertEquals(""B"", item2.getLabel());
    }",Eager Test
"@Test
    public void testGetLegendItems2() {
        XYSeriesCollection<String> d1 = new XYSeriesCollection<>();
        d1.addSeries(new XYSeries<>(""A""));
        d1.addSeries(new XYSeries<>(""B""));
        XYSeriesCollection<String> d2 = new XYSeriesCollection<>();
        d2.addSeries(new XYSeries<>(""C""));
        d2.addSeries(new XYSeries<>(""D""));
        DefaultPolarItemRenderer r = new DefaultPolarItemRenderer();
        PolarPlot plot = new PolarPlot();
        plot.setDataset(d1);
        plot.setDataset(1, d2);
        plot.setRenderer(r);
        plot.setRenderer(1, new DefaultPolarItemRenderer());
        LegendItemCollection items = plot.getLegendItems();
        assertEquals(4, items.getItemCount());
        LegendItem item1 = items.get(0);
        assertEquals(""A"", item1.getLabel());
        LegendItem item2 = items.get(1);
        assertEquals(""B"", item2.getLabel());
        LegendItem item3 = items.get(2);
        assertEquals(""C"", item3.getLabel());
        LegendItem item4 = items.get(3);
        assertEquals(""D"", item4.getLabel());
    }",Eager Test
"@Test
    public void testSerialization() {
        PolarPlot p1 = new PolarPlot();
        p1.setAngleGridlinePaint(new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f,
                4.0f, Color.BLUE));
        p1.setAngleLabelPaint(new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f,
                4.0f, Color.BLUE));
        p1.setRadiusGridlinePaint(new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f,
                4.0f, Color.BLUE));
        PolarPlot p2 = TestUtils.serialised(p1);
        assertEquals(p1, p2);
    }",Eager Test
"@Test
    public void testTranslateToJava2D_NumberAxis() {
        
        Rectangle2D dataArea = new Rectangle2D.Double(0.0, 0.0, 100.0, 100.0);
        ValueAxis axis = new NumberAxis();
        axis.setRange(0.0, 20.0);

        PolarPlot plot = new PolarPlot(null, axis, null);
        plot.setMargin(0);
        plot.setAngleOffset(0.0);

        Point point = plot.translateToJava2D(0.0, 10.0, axis, dataArea );
        assertEquals(75.0, point.getX(), 0.5);
        assertEquals(50.0, point.getY(), 0.5);

        point = plot.translateToJava2D(90.0, 5.0, axis, dataArea );
        assertEquals(50.0, point.getX(), 0.5);
        assertEquals(62.5, point.getY(), 0.5);

        point = plot.translateToJava2D(45.0, 20.0, axis, dataArea );
        assertEquals(85.0, point.getX(), 0.5);
        assertEquals(85.0, point.getY(), 0.5);

        point = plot.translateToJava2D(135.0, 20.0, axis, dataArea );
        assertEquals(15.0, point.getX(), 0.5);
        assertEquals(85.0, point.getY(), 0.5);

        point = plot.translateToJava2D(225.0, 15.0, axis, dataArea );
        assertEquals(23.0, point.getX(), 0.5);
        assertEquals(23.0, point.getY(), 0.5);

        point = plot.translateToJava2D(315.0, 15.0, axis, dataArea );
        assertEquals(77.0, point.getX(), 0.5);
        assertEquals(23.0, point.getY(), 0.5);
        
        point = plot.translateToJava2D(21.0, 11.5, axis, dataArea );
        assertEquals(77.0, point.getX(), 0.5);
        assertEquals(60.0, point.getY(), 0.5);
        
        point = plot.translateToJava2D(162.0, 7.0, axis, dataArea );
        assertEquals(33.0, point.getX(), 0.5);
        assertEquals(55.0, point.getY(), 0.5);
        
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        RingPlot p1 = new RingPlot(null);
        GradientPaint gp = new GradientPaint(1.0f, 2.0f, Color.YELLOW,
                3.0f, 4.0f, Color.RED);
        p1.setSeparatorPaint(gp);
        RingPlot p2 = CloneUtils.clone(p1);
        assertNotSame(p1, p2);
        assertSame(p1.getClass(), p2.getClass());
        assertEquals(p1, p2);
    }",Eager Test
"@Test
    public void testEquals() {

        RingPlot plot1 = new RingPlot(null);
        RingPlot plot2 = new RingPlot(null);
        assertEquals(plot1, plot2);
        assertEquals(plot2, plot1);

        plot1.setCenterTextMode(CenterTextMode.FIXED);
        assertNotEquals(plot1, plot2);
        plot2.setCenterTextMode(CenterTextMode.FIXED);
        assertEquals(plot1, plot2);

        plot1.setCenterText(""ABC"");
        assertNotEquals(plot1, plot2);
        plot2.setCenterText(""ABC"");
        assertEquals(plot1, plot2);
        
        plot1.setCenterTextColor(Color.RED);
        assertNotEquals(plot1, plot2);
        plot2.setCenterTextColor(Color.RED);
        assertEquals(plot1, plot2);
        
        plot1.setCenterTextFont(new Font(Font.SERIF, Font.PLAIN, 7));
        assertNotEquals(plot1, plot2);
        plot2.setCenterTextFont(new Font(Font.SERIF, Font.PLAIN, 7));
        assertEquals(plot1, plot2);

        plot1.setCenterTextFormatter(new DecimalFormat(""0.000""));
        assertNotEquals(plot1, plot2);
        plot2.setCenterTextFormatter(new DecimalFormat(""0.000""));
        assertEquals(plot1, plot2);
        
        // separatorsVisible
        plot1.setSeparatorsVisible(false);
        assertNotEquals(plot1, plot2);
        plot2.setSeparatorsVisible(false);
        assertEquals(plot1, plot2);

        // separatorStroke
        Stroke s = new BasicStroke(1.1f);
        plot1.setSeparatorStroke(s);
        assertNotEquals(plot1, plot2);
        plot2.setSeparatorStroke(s);
        assertEquals(plot1, plot2);

        // separatorPaint
        plot1.setSeparatorPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                2.0f, 1.0f, Color.BLUE));
        assertNotEquals(plot1, plot2);
        plot2.setSeparatorPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                2.0f, 1.0f, Color.BLUE));
        assertEquals(plot1, plot2);

        // innerSeparatorExtension
        plot1.setInnerSeparatorExtension(0.01);
        assertNotEquals(plot1, plot2);
        plot2.setInnerSeparatorExtension(0.01);
        assertEquals(plot1, plot2);

        // outerSeparatorExtension
        plot1.setOuterSeparatorExtension(0.02);
        assertNotEquals(plot1, plot2);
        plot2.setOuterSeparatorExtension(0.02);
        assertEquals(plot1, plot2);

        // sectionDepth
        plot1.setSectionDepth(0.12);
        assertNotEquals(plot1, plot2);
        plot2.setSectionDepth(0.12);
        assertEquals(plot1, plot2);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        SpiderWebPlot p1 = new SpiderWebPlot(new DefaultCategoryDataset<String, String>());
        Rectangle2D legendShape = new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0);
        p1.setLegendItemShape(legendShape);
        SpiderWebPlot p2 = CloneUtils.clone(p1);
        assertNotSame(p1, p2);
        assertSame(p1.getClass(), p2.getClass());
        assertEquals(p1, p2);

        // change the legendItemShape
        legendShape.setRect(4.0, 3.0, 2.0, 1.0);
        assertNotEquals(p1, p2);
        p2.setLegendItemShape(legendShape);
        assertEquals(p1, p2);

        // change a series paint
        p1.setSeriesPaint(1, Color.BLACK);
        assertNotEquals(p1, p2);
        p2.setSeriesPaint(1, Color.BLACK);
        assertEquals(p1, p2);

        // change a series outline paint
        p1.setSeriesOutlinePaint(0, Color.RED);
        assertNotEquals(p1, p2);
        p2.setSeriesOutlinePaint(0, Color.RED);
        assertEquals(p1, p2);

        // change a series outline stroke
        p1.setSeriesOutlineStroke(0, new BasicStroke(1.1f));
        assertNotEquals(p1, p2);
        p2.setSeriesOutlineStroke(0, new BasicStroke(1.1f));
        assertEquals(p1, p2);

    }",Eager Test
"@Test
    public void testGetLegendItems() {
        DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>();
        dataset.addValue(35.0, ""S1"", ""C1"");
        dataset.addValue(45.0, ""S1"", ""C2"");
        dataset.addValue(55.0, ""S2"", ""C1"");
        dataset.addValue(15.0, ""S2"", ""C2"");
        SpiderWebPlot plot = new SpiderWebPlot(dataset);
        JFreeChart chart = new JFreeChart(plot);
        LegendItemCollection legendItems = plot.getLegendItems();
        assertEquals(2, legendItems.getItemCount());
        LegendItem item1 = legendItems.get(0);
        assertEquals(""S1"", item1.getLabel());
        assertEquals(""S1"", item1.getSeriesKey());
        assertEquals(0, item1.getSeriesIndex());
        assertEquals(dataset, item1.getDataset());
        assertEquals(0, item1.getDatasetIndex());

        LegendItem item2 = legendItems.get(1);
        assertEquals(""S2"", item2.getLabel());
        assertEquals(""S2"", item2.getSeriesKey());
        assertEquals(1, item2.getSeriesIndex());
        assertEquals(dataset, item2.getDataset());
        assertEquals(0, item2.getDatasetIndex());
    }",Eager Test
"@Test
    public void testEquals() {

        Marker m1 = new ValueMarker(45.0);
        Marker m2 = new ValueMarker(45.0);
        assertEquals(m1, m2);
        assertEquals(m2, m1);

        m1.setPaint(new GradientPaint(1.0f, 2.0f, Color.GREEN,
                3.0f, 4.0f, Color.RED));
        assertNotEquals(m1, m2);
        m2.setPaint(new GradientPaint(1.0f, 2.0f, Color.GREEN,
                3.0f, 4.0f, Color.RED));
        assertEquals(m1, m2);

        BasicStroke stroke = new BasicStroke(2.2f);
        m1.setStroke(stroke);
        assertNotEquals(m1, m2);
        m2.setStroke(stroke);
        assertEquals(m1, m2);

        m1.setOutlinePaint(new GradientPaint(4.0f, 3.0f, Color.YELLOW,
                2.0f, 1.0f, Color.WHITE));
        assertNotEquals(m1, m2);
        m2.setOutlinePaint(new GradientPaint(4.0f, 3.0f, Color.YELLOW,
                2.0f, 1.0f, Color.WHITE));
        assertEquals(m1, m2);

        m1.setOutlineStroke(stroke);
        assertNotEquals(m1, m2);
        m2.setOutlineStroke(stroke);
        assertEquals(m1, m2);

        m1.setAlpha(0.1f);
        assertNotEquals(m1, m2);
        m2.setAlpha(0.1f);
        assertEquals(m1, m2);

        m1.setLabel(""New Label"");
        assertNotEquals(m1, m2);
        m2.setLabel(""New Label"");
        assertEquals(m1, m2);

        m1.setLabelFont(new Font(""SansSerif"", Font.PLAIN, 10));
        assertNotEquals(m1, m2);
        m2.setLabelFont(new Font(""SansSerif"", Font.PLAIN, 10));
        assertEquals(m1, m2);

        m1.setLabelPaint(new GradientPaint(1.0f, 2.0f, Color.BLUE,
                3.0f, 4.0f, Color.YELLOW));
        assertNotEquals(m1, m2);
        m2.setLabelPaint(new GradientPaint(1.0f, 2.0f, Color.BLUE,
                3.0f, 4.0f, Color.YELLOW));
        assertEquals(m1, m2);

        m1.setLabelAnchor(RectangleAnchor.TOP_RIGHT);
        assertNotEquals(m1, m2);
        m2.setLabelAnchor(RectangleAnchor.TOP_RIGHT);
        assertEquals(m1, m2);

        m1.setLabelTextAnchor(TextAnchor.BASELINE_RIGHT);
        assertNotEquals(m1, m2);
        m2.setLabelTextAnchor(TextAnchor.BASELINE_RIGHT);
        assertEquals(m1, m2);

        m1.setLabelOffset(new RectangleInsets(10.0, 10.0, 10.0, 10.0));
        assertNotEquals(m1, m2);
        m2.setLabelOffset(new RectangleInsets(10.0, 10.0, 10.0, 10.0));
        assertEquals(m1, m2);

        m1.setLabelOffsetType(LengthAdjustmentType.EXPAND);
        assertNotEquals(m1, m2);
        m2.setLabelOffsetType(LengthAdjustmentType.EXPAND);
        assertEquals(m1, m2);

        m1 = new ValueMarker(12.3);
        m2 = new ValueMarker(45.6);
        assertNotEquals(m1, m2);
        m2 = new ValueMarker(12.3);
        assertEquals(m1, m2);

    }",Eager Test
"@Test
    public void testAddRangeMarker() {
        XYPlot<String> plot = new XYPlot<>();
        Marker m = new ValueMarker(1.0);
        plot.addRangeMarker(m);
        List<EventListener> listeners = Arrays.asList(m.getListeners(
                MarkerChangeListener.class));
        assertTrue(listeners.contains(plot));
        plot.clearRangeMarkers();
        listeners = Arrays.asList(m.getListeners(MarkerChangeListener.class));
        assertFalse(listeners.contains(plot));
    }",Eager Test
"@Test
    public void testAxisIndices() {
        XYDataset<String> dataset = new XYSeriesCollection<>();
        NumberAxis xAxis = new NumberAxis(""X"");
        NumberAxis yAxis = new NumberAxis(""Y"");
        XYItemRenderer renderer = new DefaultXYItemRenderer();
        XYPlot<String> plot = new XYPlot<>(dataset, xAxis, yAxis, renderer);
        assertEquals(xAxis, plot.getDomainAxis(0));        
        assertEquals(yAxis, plot.getRangeAxis(0)); 
        
        NumberAxis xAxis2 = new NumberAxis(""X2"");
        plot.setDomainAxis(99, xAxis2);
        assertEquals(xAxis2, plot.getDomainAxis(99));
        
        NumberAxis yAxis2 = new NumberAxis(""Y2"");
        plot.setRangeAxis(99, yAxis2);
        assertEquals(yAxis2, plot.getRangeAxis(99));
    }",Eager Test
"@Test 
    public void testAxisLocationIndices() {
        XYDataset<String> dataset = new XYSeriesCollection<>();
        NumberAxis xAxis = new NumberAxis(""X"");
        NumberAxis yAxis = new NumberAxis(""Y"");
        XYItemRenderer renderer = new DefaultXYItemRenderer();
        XYPlot<String> plot = new XYPlot<>(dataset, xAxis, yAxis, renderer);

        NumberAxis xAxis2 = new NumberAxis(""X2"");
        NumberAxis yAxis2 = new NumberAxis(""Y2"");
        plot.setDomainAxis(99, xAxis2);
        plot.setRangeAxis(99, yAxis2);
        
        plot.setDomainAxisLocation(99, AxisLocation.BOTTOM_OR_RIGHT);
        assertEquals(AxisLocation.BOTTOM_OR_RIGHT, 
                plot.getDomainAxisLocation(99));
        plot.setRangeAxisLocation(99, AxisLocation.BOTTOM_OR_LEFT);
        assertEquals(AxisLocation.BOTTOM_OR_LEFT, 
                plot.getRangeAxisLocation(99));
    }",Eager Test
"@Test
    public void testCloning4() throws CloneNotSupportedException {
        XYLineAndShapeRenderer r1 = new XYLineAndShapeRenderer();
        XYPlot<String> p1 = new XYPlot<>(null, new NumberAxis(""Domain Axis""),
                new NumberAxis(""Range Axis""), r1);
        XYPlot<String> p2 = CloneUtils.clone(p1);
        assertNotSame(p1, p2);
        assertSame(p1.getClass(), p2.getClass());
        assertEquals(p1, p2);

        // verify that the plot is listening to the cloned renderer
        XYLineAndShapeRenderer r2 = (XYLineAndShapeRenderer) p2.getRenderer();
        assertTrue(r2.hasListener(p2));
    }",Eager Test
"@Test
    public void testCloning_QuadrantOrigin() throws CloneNotSupportedException {
        XYPlot<String> p1 = new XYPlot<>();
        Point2D p = new Point2D.Double(1.2, 3.4);
        p1.setQuadrantOrigin(p);
        XYPlot<String> p2 = CloneUtils.clone(p1);
        assertNotSame(p1, p2);
        assertSame(p1.getClass(), p2.getClass());
        assertEquals(p1, p2);
        assertNotSame(p2.getQuadrantOrigin(), p);
    }",Eager Test
"@Test
    public void testCloning_QuadrantPaint() throws CloneNotSupportedException {
        XYPlot<String> p1 = new XYPlot<>();
        p1.setQuadrantPaint(3, new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.BLUE));
        XYPlot<String> p2 = CloneUtils.clone(p1);
        assertNotSame(p1, p2);
        assertSame(p1.getClass(), p2.getClass());
        assertEquals(p1, p2);

        // check for independence
        p1.setQuadrantPaint(1, Color.RED);
        assertNotEquals(p1, p2);
        p2.setQuadrantPaint(1, Color.RED);
        assertEquals(p1, p2);
    }",Eager Test
"@Test
    public void testDomainMarkerIndices() {
        XYDataset<String> dataset = new XYSeriesCollection<>();
        NumberAxis xAxis = new NumberAxis(""X"");
        NumberAxis yAxis = new NumberAxis(""Y"");
        XYItemRenderer renderer = new DefaultXYItemRenderer();
        XYPlot<String> plot = new XYPlot<>(dataset, xAxis, yAxis, renderer);
        
        // add a second dataset, plotted against a second x axis
        XYSeriesCollection<String> dataset2 = new XYSeriesCollection<>();
        dataset2.addSeries(new XYSeries<>(""Series in dataset 2""));
        plot.setDataset(99, dataset);    
        NumberAxis xAxis2 = new NumberAxis(""X2"");
        plot.setDomainAxis(1, xAxis2);
        XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer();
        plot.setRenderer(99, renderer2);
        plot.mapDatasetToDomainAxis(99, 1);
        
        ValueMarker xMarker1 = new ValueMarker(123);
        plot.addDomainMarker(99, xMarker1, Layer.FOREGROUND);
        assertTrue(plot.getDomainMarkers(99, Layer.FOREGROUND).contains(
                xMarker1));
    }",Eager Test
"@Test
    public void testEquals_ObjectList4() {
        XYPlot<String> p1 = new XYPlot<>();
        p1.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT);
        XYPlot<String> p2 = new XYPlot<>();
        p2.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT);
        assertEquals(p1, p2);
        p2.setRangeAxisLocation(1, AxisLocation.TOP_OR_LEFT);
        assertNotEquals(p1, p2);
    }",Eager Test
"@Test
    public void testGetDataRange() {
        XYSeriesCollection<String> dataset = new XYSeriesCollection<>();
        NumberAxis xAxis = new NumberAxis(""X"");
        NumberAxis yAxis = new NumberAxis(""Y"");
        XYItemRenderer renderer = new DefaultXYItemRenderer();
        XYPlot<String> plot = new XYPlot<>(dataset, xAxis, yAxis, renderer);
        assertNull(plot.getDataRange(xAxis));
        assertNull(plot.getDataRange(yAxis));
        
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        s1.add(1.0, 2.0);
        dataset.addSeries(s1);
        assertEquals(new Range(1.0, 1.0), plot.getDataRange(xAxis));
        assertEquals(new Range(2.0, 2.0), plot.getDataRange(yAxis));
        
        s1.add(5.0, null);
        assertEquals(new Range(1.0, 5.0), plot.getDataRange(xAxis));
        assertEquals(new Range(2.0, 2.0), plot.getDataRange(yAxis));
        
        s1.add(6.0, Double.NaN);
        assertEquals(new Range(1.0, 6.0), plot.getDataRange(xAxis));
        assertEquals(new Range(2.0, 2.0), plot.getDataRange(yAxis));
    }",Eager Test
"@Test
    public void testGetDataRangeWithMultipleDatasets() {
        XYSeriesCollection<String> dataset1 = new XYSeriesCollection<>();
        XYSeriesCollection<String> dataset2 = new XYSeriesCollection<>();
        NumberAxis xAxis = new NumberAxis(""X"");
        NumberAxis yAxis = new NumberAxis(""Y"");
        XYItemRenderer renderer = new DefaultXYItemRenderer();
        XYPlot<String> plot = new XYPlot<>(dataset1, xAxis, yAxis, renderer);
        plot.setDataset(1, dataset2);
        plot.mapDatasetToDomainAxis(1, 0);
        plot.mapDatasetToRangeAxis(1, 0);
        assertNull(plot.getDataRange(xAxis));
        assertNull(plot.getDataRange(yAxis));
        
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        s1.add(1.0, 2.0);
        dataset1.addSeries(s1);
        assertEquals(new Range(1.0, 1.0), plot.getDataRange(xAxis));
        assertEquals(new Range(2.0, 2.0), plot.getDataRange(yAxis));
        
        XYSeries<String> s2 = new XYSeries<>(""S2"");
        s2.add(5.0, 10.0);
        dataset2.addSeries(s2);
        assertEquals(new Range(1.0, 5.0), plot.getDataRange(xAxis));
        assertEquals(new Range(2.0, 10.0), plot.getDataRange(yAxis));
        
        s2.add(6.0, Double.NaN);
        assertEquals(new Range(1.0, 6.0), plot.getDataRange(xAxis));
        assertEquals(new Range(2.0, 10.0), plot.getDataRange(yAxis));
        
        s2.add(Double.NaN, 0.5); 
        assertEquals(new Range(1.0, 6.0), plot.getDataRange(xAxis));
        assertEquals(new Range(2.0, 10.0), plot.getDataRange(yAxis)); // only y-values for items in the x-range        
    }",Eager Test
"@Test
    public void testGetDomainAxisForDataset() {
        XYDataset<String> dataset = new XYSeriesCollection<>();
        NumberAxis xAxis = new NumberAxis(""X"");
        NumberAxis yAxis = new NumberAxis(""Y"");
        XYItemRenderer renderer = new DefaultXYItemRenderer();
        XYPlot<String> plot = new XYPlot<>(dataset, xAxis, yAxis, renderer);
        assertEquals(xAxis, plot.getDomainAxisForDataset(0));

        // should get IllegalArgumentException for negative index
        boolean pass = false;
        try {
            plot.getDomainAxisForDataset(-1);
        }",Eager Test
"@Test
    public void testGetRendererForDataset() {
        XYDataset<String> d0 = new XYSeriesCollection<>();
        XYDataset<String> d1 = new XYSeriesCollection<>();
        XYDataset<String> d2 = new XYSeriesCollection<>();
        XYDataset<String> d3 = new XYSeriesCollection<>();  // not used by plot
        XYItemRenderer r0 = new XYLineAndShapeRenderer();
        XYItemRenderer r2 = new XYLineAndShapeRenderer();
        XYPlot<String> plot = new XYPlot<>();
        plot.setDataset(0, d0);
        plot.setDataset(1, d1);
        plot.setDataset(2, d2);
        plot.setRenderer(0, r0);
        // no renderer 1
        plot.setRenderer(2, r2);
        assertEquals(r0, plot.getRendererForDataset(d0));
        assertEquals(r0, plot.getRendererForDataset(d1));
        assertEquals(r2, plot.getRendererForDataset(d2));
        assertNull(plot.getRendererForDataset(d3));
        assertNull(plot.getRendererForDataset(null));
    }",Eager Test
"@Test
    public void testSerialization1() {
        XYDataset<String> data = new XYSeriesCollection<>();
        NumberAxis domainAxis = new NumberAxis(""Domain"");
        NumberAxis rangeAxis = new NumberAxis(""Range"");
        StandardXYItemRenderer renderer = new StandardXYItemRenderer();
        XYPlot<String> p1 = new XYPlot<>(data, domainAxis, rangeAxis, renderer);
        XYPlot<String> p2 = TestUtils.serialised(p1);
        assertEquals(p1, p2);
    }",Eager Test
"@Test
    public void testSerialization4() {

        XYSeriesCollection<String> dataset = new XYSeriesCollection<>();
        JFreeChart chart = ChartFactory.createXYLineChart(""Test Chart"",
                ""Domain Axis"", ""Range Axis"", dataset);
        XYPlot<?> plot = (XYPlot) chart.getPlot();
        plot.addDomainMarker(new ValueMarker(1.0), Layer.FOREGROUND);
        plot.addDomainMarker(new IntervalMarker(2.0, 3.0), Layer.BACKGROUND);
        plot.addRangeMarker(new ValueMarker(4.0), Layer.FOREGROUND);
        plot.addRangeMarker(new IntervalMarker(5.0, 6.0), Layer.BACKGROUND);
        JFreeChart chart2 = TestUtils.serialised(chart);
        assertEquals(chart, chart2);
        try {
            chart2.createBufferedImage(300, 200);
        }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        LineAndShapeRenderer r1 = new LineAndShapeRenderer();
        Rectangle2D baseShape = new Rectangle2D.Double(11.0, 12.0, 13.0, 14.0);
        r1.setDefaultShape(baseShape);
        r1.setDefaultLegendShape(new Rectangle(4, 3, 2, 1));
        r1.setDefaultLegendTextFont(new Font(""Dialog"", Font.PLAIN, 3));
        r1.setDefaultLegendTextPaint(new Color(1, 2, 3));
        r1.setSeriesItemLabelFont(0, new Font(Font.MONOSPACED, Font.BOLD, 13));
        r1.setLegendTextFont(0, new Font(Font.MONOSPACED, Font.BOLD, 14));
        r1.setSeriesPositiveItemLabelPosition(0, new ItemLabelPosition(
                ItemLabelAnchor.CENTER, TextAnchor.TOP_LEFT));
        r1.setSeriesNegativeItemLabelPosition(0, new ItemLabelPosition(
                ItemLabelAnchor.CENTER, TextAnchor.CENTER));
        
        LineAndShapeRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);

        r1.setSeriesVisible(0, Boolean.FALSE);
        assertNotEquals(r1, r2);
        r2.setSeriesVisible(0, Boolean.FALSE);
        assertEquals(r1, r2);

        r1.setSeriesVisibleInLegend(0, Boolean.FALSE);
        assertNotEquals(r1, r2);
        r2.setSeriesVisibleInLegend(0, Boolean.FALSE);
        assertEquals(r1, r2);

        r1.setSeriesPaint(0, Color.BLACK);
        assertNotEquals(r1, r2);
        r2.setSeriesPaint(0, Color.BLACK);
        assertEquals(r1, r2);

        r1.setSeriesFillPaint(0, Color.YELLOW);
        assertNotEquals(r1, r2);
        r2.setSeriesFillPaint(0, Color.YELLOW);
        assertEquals(r1, r2);

        r1.setSeriesOutlinePaint(0, Color.YELLOW);
        assertNotEquals(r1, r2);
        r2.setSeriesOutlinePaint(0, Color.YELLOW);
        assertEquals(r1, r2);

        r1.setSeriesStroke(0, new BasicStroke(2.2f));
        assertNotEquals(r1, r2);
        r2.setSeriesStroke(0, new BasicStroke(2.2f));
        assertEquals(r1, r2);

        r1.setSeriesOutlineStroke(0, new BasicStroke(2.2f));
        assertNotEquals(r1, r2);
        r2.setSeriesOutlineStroke(0, new BasicStroke(2.2f));
        assertEquals(r1, r2);

        baseShape.setRect(4.0, 3.0, 2.0, 1.0);
        assertNotEquals(r1, r2);
        r2.setDefaultShape(new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0));
        assertEquals(r1, r2);

        r1.setSeriesShape(0, new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0));
        assertNotEquals(r1, r2);
        r2.setSeriesShape(0, new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0));
        assertEquals(r1, r2);

        r1.setSeriesItemLabelsVisible(0, Boolean.TRUE);
        assertNotEquals(r1, r2);
        r2.setSeriesItemLabelsVisible(0, Boolean.TRUE);
        assertEquals(r1, r2);

        r1.setSeriesItemLabelPaint(0, Color.RED);
        assertNotEquals(r1, r2);
        r2.setSeriesItemLabelPaint(0, Color.RED);
        assertEquals(r1, r2);
        
        r1.setSeriesPositiveItemLabelPosition(0, new ItemLabelPosition());
        assertNotEquals(r1, r2);
        r2.setSeriesPositiveItemLabelPosition(0, new ItemLabelPosition());
        assertEquals(r1, r2);

        r1.setSeriesNegativeItemLabelPosition(0, new ItemLabelPosition());
        assertNotEquals(r1, r2);
        r2.setSeriesNegativeItemLabelPosition(0, new ItemLabelPosition());
        assertEquals(r1, r2);

        r1.setSeriesCreateEntities(0, Boolean.FALSE);
        assertNotEquals(r1, r2);
        r2.setSeriesCreateEntities(0, Boolean.FALSE);
        assertEquals(r1, r2);

        r1.setLegendShape(0, new Rectangle(9, 7, 3, 4));
        assertNotEquals(r1, r2);
        r2.setLegendShape(0, new Rectangle(9, 7, 3, 4));
        assertEquals(r1, r2);

        r1.setDefaultLegendShape(new Rectangle(3, 4, 1, 5));
        assertNotEquals(r1, r2);
        r2.setDefaultLegendShape(new Rectangle(3, 4, 1, 5));
        assertEquals(r1, r2);

        r1.setLegendTextFont(1, new Font(""Dialog"", Font.PLAIN, 33));
        assertNotEquals(r1, r2);
        r2.setLegendTextFont(1, new Font(""Dialog"", Font.PLAIN, 33));
        assertEquals(r1, r2);

        r1.setDefaultLegendTextFont(new Font(""Dialog"", Font.PLAIN, 11));
        assertNotEquals(r1, r2);
        r2.setDefaultLegendTextFont(new Font(""Dialog"", Font.PLAIN, 11));
        assertEquals(r1, r2);

        r1.setLegendTextPaint(3, Color.RED);
        assertNotEquals(r1, r2);
        r2.setLegendTextPaint(3, Color.RED);
        assertEquals(r1, r2);

        r1.setDefaultLegendTextPaint(Color.GREEN);
        assertNotEquals(r1, r2);
        r2.setDefaultLegendTextPaint(Color.GREEN);
        assertEquals(r1, r2);
    }",Eager Test
"@Test
    public void testCloning2() throws CloneNotSupportedException {
        BarRenderer r1 = new BarRenderer();
        r1.setDefaultItemLabelGenerator(new IntervalCategoryItemLabelGenerator());
        BarRenderer r2 = (BarRenderer) r1.clone();

        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);

        r1 = new BarRenderer();
        r1.setSeriesItemLabelGenerator(0,
                new IntervalCategoryItemLabelGenerator());
        r2 = (BarRenderer) r1.clone();
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);

        r1 = new BarRenderer();
        r1.setDefaultItemLabelGenerator(new IntervalCategoryItemLabelGenerator());
        r2 = (BarRenderer) r1.clone();

        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
    }",Eager Test
"@Test
    public void testCloning_LegendItemLabelGenerator() throws CloneNotSupportedException {
        StandardCategorySeriesLabelGenerator generator
                = new StandardCategorySeriesLabelGenerator(""Series {0}",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        BarRenderer r1 = new BarRenderer();
        r1.setDefaultItemLabelGenerator(new StandardCategoryItemLabelGenerator());
        r1.setBarPainter(new GradientBarPainter(0.11, 0.22, 0.33));
        BarRenderer r2 = (BarRenderer) r1.clone();
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testEquals() {
        BarRenderer r1 = new BarRenderer();
        BarRenderer r2 = new BarRenderer();
        assertEquals(r1, r2);
        assertEquals(r2, r1);

        // base value
        r1.setBase(0.123);
        assertNotEquals(r1, r2);
        r2.setBase(0.123);
        assertEquals(r1, r2);

        // itemMargin
        r1.setItemMargin(0.22);
        assertNotEquals(r1, r2);
        r2.setItemMargin(0.22);
        assertEquals(r1, r2);

        // drawBarOutline
        r1.setDrawBarOutline(!r1.isDrawBarOutline());
        assertNotEquals(r1, r2);
        r2.setDrawBarOutline(!r2.isDrawBarOutline());
        assertEquals(r1, r2);

        // maximumBarWidth
        r1.setMaximumBarWidth(0.11);
        assertNotEquals(r1, r2);
        r2.setMaximumBarWidth(0.11);
        assertEquals(r1, r2);

        // minimumBarLength
        r1.setMinimumBarLength(0.04);
        assertNotEquals(r1, r2);
        r2.setMinimumBarLength(0.04);
        assertEquals(r1, r2);

        // gradientPaintTransformer
        r1.setGradientPaintTransformer(new StandardGradientPaintTransformer(
                GradientPaintTransformType.CENTER_VERTICAL));
        assertNotEquals(r1, r2);
        r2.setGradientPaintTransformer(new StandardGradientPaintTransformer(
                GradientPaintTransformType.CENTER_VERTICAL));
        assertEquals(r1, r2);

        // positiveItemLabelPositionFallback
        r1.setPositiveItemLabelPositionFallback(new ItemLabelPosition(
                ItemLabelAnchor.INSIDE1, TextAnchor.CENTER));
        assertNotEquals(r1, r2);
        r2.setPositiveItemLabelPositionFallback(new ItemLabelPosition(
                ItemLabelAnchor.INSIDE1, TextAnchor.CENTER));
        assertEquals(r1, r2);

        // negativeItemLabelPositionFallback
        r1.setNegativeItemLabelPositionFallback(new ItemLabelPosition(
                ItemLabelAnchor.INSIDE1, TextAnchor.CENTER));
        assertNotEquals(r1, r2);
        r2.setNegativeItemLabelPositionFallback(new ItemLabelPosition(
                ItemLabelAnchor.INSIDE1, TextAnchor.CENTER));
        assertEquals(r1, r2);

        // barPainter
        r1.setBarPainter(new GradientBarPainter(0.1, 0.2, 0.3));
        assertNotEquals(r1, r2);
        r2.setBarPainter(new GradientBarPainter(0.1, 0.2, 0.3));
        assertEquals(r1, r2);

        // shadowsVisible
        r1.setShadowVisible(false);
        assertNotEquals(r1, r2);
        r2.setShadowVisible(false);
        assertEquals(r1, r2);

        r1.setShadowPaint(Color.RED);
        assertNotEquals(r1, r2);
        r2.setShadowPaint(Color.RED);
        assertEquals(r1, r2);

        // shadowXOffset
        r1.setShadowXOffset(3.3);
        assertNotEquals(r1, r2);
        r2.setShadowXOffset(3.3);
        assertEquals(r1, r2);

        // shadowYOffset
        r1.setShadowYOffset(3.3);
        assertNotEquals(r1, r2);
        r2.setShadowYOffset(3.3);
        assertEquals(r1, r2);

    }",Eager Test
"@Test
    public void testGetLegendItem() {
        DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>();
        dataset.addValue(21.0, ""R1"", ""C1"");
        BarRenderer r = new BarRenderer();
        CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, 
                new CategoryAxis(""x""), new NumberAxis(""y""), r);
        /*JFreeChart chart =*/ new JFreeChart(plot);
        LegendItem li = r.getLegendItem(0, 0);
        assertNotNull(li);
        r.setSeriesVisibleInLegend(0, Boolean.FALSE);
        li = r.getLegendItem(0, 0);
        assertNull(li);
    }",Eager Test
"@Test
    public void testPublicCloneable() {
        BarRenderer r1 = new BarRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testDrawWithNullMean() {
        boolean success;
        try {
            DefaultBoxAndWhiskerCategoryDataset<String, String> dataset
                    = new DefaultBoxAndWhiskerCategoryDataset<>();
            dataset.add(new BoxAndWhiskerItem(null, 2.0, 0.0, 4.0, 0.5, 4.5, 
                    -0.5, 5.5, null), ""S1"", ""C1"");
            CategoryPlot<String, String> plot = new CategoryPlot<>(dataset,
                    new CategoryAxis(""Category""), new NumberAxis(""Value""),
                    new BoxAndWhiskerRenderer());
            ChartRenderingInfo info = new ChartRenderingInfo();
            JFreeChart chart = new JFreeChart(plot);
            /* BufferedImage image = */ chart.createBufferedImage(300, 200,
                    info);
            success = true;
        }",Eager Test
"@Test
    public void testDrawWithNullMinOutlier() {
        boolean success;
        try {
            DefaultBoxAndWhiskerCategoryDataset<String, String> dataset
                    = new DefaultBoxAndWhiskerCategoryDataset<>();
            dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 0.5, 4.5, 
                    null, 5.5, null), ""S1"", ""C1"");
            CategoryPlot<String, String> plot = new CategoryPlot<>(dataset,
                    new CategoryAxis(""Category""), new NumberAxis(""Value""),
                    new BoxAndWhiskerRenderer());
            ChartRenderingInfo info = new ChartRenderingInfo();
            JFreeChart chart = new JFreeChart(plot);
            /* BufferedImage image = */ chart.createBufferedImage(300, 200,
                    info);
            success = true;
        }",Eager Test
"@Test
    public void testDrawWithNullMinRegular() {
        boolean success;
        try {
            DefaultBoxAndWhiskerCategoryDataset<String, String> dataset
                    = new DefaultBoxAndWhiskerCategoryDataset<>();
            dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, null, 4.5, 
                    -0.5, 5.5, null), ""S1"", ""C1"");
            CategoryPlot<String, String> plot = new CategoryPlot<>(dataset,
                    new CategoryAxis(""Category""), new NumberAxis(""Value""),
                    new BoxAndWhiskerRenderer());
            ChartRenderingInfo info = new ChartRenderingInfo();
            JFreeChart chart = new JFreeChart(plot);
            /* BufferedImage image = */ chart.createBufferedImage(300, 200,
                    info);
            success = true;
        }",Eager Test
"@Test
    public void testGetLegendItem() {
        DefaultBoxAndWhiskerCategoryDataset<String, String> dataset
                = new DefaultBoxAndWhiskerCategoryDataset<>();
        List<Double> values = new ArrayList<>();
        values.add(1.10);
        values.add(1.45);
        values.add(1.33);
        values.add(1.23);
        dataset.add(values, ""R1"", ""C1"");
        BoxAndWhiskerRenderer r = new BoxAndWhiskerRenderer();
        CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, new CategoryAxis(""x""),
                new NumberAxis(""y""), r);
        /*JFreeChart chart =*/ new JFreeChart(plot);
        LegendItem li = r.getLegendItem(0, 0);
        assertNotNull(li);
        r.setSeriesVisibleInLegend(0, Boolean.FALSE);
        li = r.getLegendItem(0, 0);
        assertNull(li);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        CategoryStepRenderer r1 = new CategoryStepRenderer(false);
        CategoryStepRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testEquals() {
        CategoryStepRenderer r1 = new CategoryStepRenderer(false);
        CategoryStepRenderer r2 = new CategoryStepRenderer(false);
        assertEquals(r1, r2);

        r1 = new CategoryStepRenderer(true);
        assertNotEquals(r1, r2);
        r2 = new CategoryStepRenderer(true);
        assertEquals(r1, r2);
    }",Eager Test
"@Test
    public void testEquals() {
        DefaultCategoryItemRenderer r1 = new DefaultCategoryItemRenderer();
        DefaultCategoryItemRenderer r2 = new DefaultCategoryItemRenderer();
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testPublicCloneable() {
        DefaultCategoryItemRenderer r1 = new DefaultCategoryItemRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        GanttRenderer r1 = new GanttRenderer();
        r1.setCompletePaint(new GradientPaint(1.0f, 2.0f, Color.BLUE, 4.0f, 3.0f, Color.CYAN));
        r1.setIncompletePaint(new GradientPaint(1.0f, 2.0f, Color.RED, 4.0f, 3.0f, Color.GREEN));
        GanttRenderer r2 = (GanttRenderer) r1.clone();
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testPublicCloneable() {
        GanttRenderer r1 = new GanttRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testEquals() {
        GradientBarPainter p1 = new GradientBarPainter(0.1, 0.2, 0.3);
        GradientBarPainter p2 = new GradientBarPainter(0.1, 0.2, 0.3);
        assertEquals(p1, p2);

        p1 = new GradientBarPainter(0.11, 0.2, 0.3);
        assertNotEquals(p1, p2);
        p2 = new GradientBarPainter(0.11, 0.2, 0.3);
        assertEquals(p1, p2);

        p1 = new GradientBarPainter(0.11, 0.22, 0.3);
        assertNotEquals(p1, p2);
        p2 = new GradientBarPainter(0.11, 0.22, 0.3);
        assertEquals(p1, p2);

        p1 = new GradientBarPainter(0.11, 0.22, 0.33);
        assertNotEquals(p1, p2);
        p2 = new GradientBarPainter(0.11, 0.22, 0.33);
        assertEquals(p1, p2);
    }",Eager Test
"@Test
    public void testSerialization() {
        GradientBarPainter p1 = new GradientBarPainter(0.1, 0.2, 0.3);
        GradientBarPainter p2 = TestUtils.serialised(p1);
        assertEquals(p1, p2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        GroupedStackedBarRenderer r1 = new GroupedStackedBarRenderer();
        KeyToGroupMap map = new KeyToGroupMap();
        map.mapKeyToGroup(""A"", ""X"");
        map.mapKeyToGroup(""B"", ""Y"");
        r1.setSeriesToGroupMap(map);
        GroupedStackedBarRenderer r2 = (GroupedStackedBarRenderer) r1.clone();
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testSerialization() {
        GroupedStackedBarRenderer r1 = new GroupedStackedBarRenderer();
        GroupedStackedBarRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        IntervalBarRenderer r1 = new IntervalBarRenderer();
        IntervalBarRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testEquals() {
        IntervalBarRenderer r1 = new IntervalBarRenderer();
        IntervalBarRenderer r2 = new IntervalBarRenderer();
        assertEquals(r1, r2);

        // the renderer should not be equal to a BarRenderer
        BarRenderer br = new BarRenderer();
        assertNotEquals(r1, br);
    }",Eager Test
"@Test
    public void testHashcode() {
        IntervalBarRenderer r1 = new IntervalBarRenderer();
        IntervalBarRenderer r2 = new IntervalBarRenderer();
        assertEquals(r1, r2);
        int h1 = r1.hashCode();
        int h2 = r2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testPublicCloneable() {
        IntervalBarRenderer r1 = new IntervalBarRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testSerialization() {
        IntervalBarRenderer r1 = new IntervalBarRenderer();
        IntervalBarRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        LayeredBarRenderer r1 = new LayeredBarRenderer();
        LayeredBarRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testSerialization() {
        LayeredBarRenderer r1 = new LayeredBarRenderer();
        r1.setDefaultFillPaint(Color.RED);
        r1.setSeriesBarWidth(1, 9.0);
        LayeredBarRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testEquals() {
        LevelRenderer r1 = new LevelRenderer();
        LevelRenderer r2 = new LevelRenderer();
        assertEquals(r1, r2);
        assertEquals(r2, r1);

        r1.setItemMargin(0.123);
        assertNotEquals(r1, r2);
        r2.setItemMargin(0.123);
        assertEquals(r1, r2);

        r1.setMaximumItemWidth(0.234);
        assertNotEquals(r1, r2);
        r2.setMaximumItemWidth(0.234);
        assertEquals(r1, r2);

    }",No Smells
"@Test
    public void testHashcode() {
        LineAndShapeRenderer r1 = new LineAndShapeRenderer();
        LineAndShapeRenderer r2 = new LineAndShapeRenderer();
        assertEquals(r1, r2);
        int h1 = r1.hashCode();
        int h2 = r2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testPublicCloneable() {
        LineAndShapeRenderer r1 = new LineAndShapeRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testEquals() {
        MinMaxCategoryRenderer r1 = new MinMaxCategoryRenderer();
        MinMaxCategoryRenderer r2 = new MinMaxCategoryRenderer();
        assertEquals(r1, r2);

        r1.setDrawLines(true);
        assertNotEquals(r1, r2);
        r2.setDrawLines(true);
        assertEquals(r1, r2);

        r1.setGroupPaint(new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f, 4.0f,
                Color.YELLOW));
        assertNotEquals(r1, r2);
        r2.setGroupPaint(new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f, 4.0f,
                Color.YELLOW));
        assertEquals(r1, r2);

        r1.setGroupStroke(new BasicStroke(1.2f));
        assertNotEquals(r1, r2);
        r2.setGroupStroke(new BasicStroke(1.2f));
        assertEquals(r1, r2);
    }",Eager Test
"@Test
    public void testHashcode() {
        MinMaxCategoryRenderer r1 = new MinMaxCategoryRenderer();
        MinMaxCategoryRenderer r2 = new MinMaxCategoryRenderer();
        assertEquals(r1, r2);
        int h1 = r1.hashCode();
        int h2 = r2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testPublicCloneable() {
        MinMaxCategoryRenderer r1 = new MinMaxCategoryRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testFindRangeBounds() {
        ScatterRenderer r = new ScatterRenderer();
        assertNull(r.findRangeBounds(null));

        // an empty dataset should return a null range
        DefaultMultiValueCategoryDataset<String, String> dataset
                = new DefaultMultiValueCategoryDataset<>();
        assertNull(r.findRangeBounds(dataset));

        List<Number> values = Arrays.asList(new Double[] {1.0}",Eager Test
"@Test
    public void testPublicCloneable() {
        ScatterRenderer r1 = new ScatterRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testSerialization() {
        ScatterRenderer r1 = new ScatterRenderer();
        ScatterRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testEquals() {
        StackedAreaRenderer r1 = new StackedAreaRenderer();
        StackedAreaRenderer r2 = new StackedAreaRenderer();
        assertEquals(r1, r2);

        r1.setRenderAsPercentages(true);
        assertNotEquals(r1, r2);
        r2.setRenderAsPercentages(true);
        assertEquals(r1, r2);
    }",Eager Test
"@Test
    public void testFindRangeBounds() {
        StackedAreaRenderer r = new StackedAreaRenderer();
        assertNull(r.findRangeBounds(null));

        // an empty dataset should return a null range
        DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>();
        assertNull(r.findRangeBounds(dataset));

        dataset.addValue(1.0, ""R1"", ""C1"");
        assertEquals(new Range(0.0, 1.0), r.findRangeBounds(dataset));

        dataset.addValue(-2.0, ""R1"", ""C2"");
        assertEquals(new Range(-2.0, 1.0), r.findRangeBounds(dataset));

        dataset.addValue(null, ""R1"", ""C3"");
        assertEquals(new Range(-2.0, 1.0), r.findRangeBounds(dataset));

        dataset.addValue(2.0, ""R2"", ""C1"");
        assertEquals(new Range(-2.0, 3.0), r.findRangeBounds(dataset));

        dataset.addValue(null, ""R2"", ""C2"");
        assertEquals(new Range(-2.0, 3.0), r.findRangeBounds(dataset));
    }",Eager Test
"@Test
    public void testHashCode() {
        StackedBarRenderer r1 = new StackedBarRenderer();
        StackedBarRenderer r2 = new StackedBarRenderer();
        assertEquals(r1, r2);
        int h1 = r1.hashCode();
        int h2 = r2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testSerialization() {
        StackedBarRenderer r1 = new StackedBarRenderer();
        StackedBarRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testHashcode() {
        StandardBarPainter p1 = new StandardBarPainter();
        StandardBarPainter p2 = new StandardBarPainter();
        assertEquals(p1, p2);
        int h1 = p1.hashCode();
        int h2 = p2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        StatisticalBarRenderer r1 = new StatisticalBarRenderer();
        StatisticalBarRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testDrawWithNullDeviationHorizontal() {
        try {
            DefaultStatisticalCategoryDataset<String, String> dataset
                    = new DefaultStatisticalCategoryDataset<>();
            dataset.add(1.0, 2.0, ""S1"", ""C1"");
            dataset.add(4.0, null, ""S1"", ""C2"");
            CategoryPlot<String, String> plot = new CategoryPlot<>(dataset,
                    new CategoryAxis(""Category""), new NumberAxis(""Value""),
                    new StatisticalBarRenderer());
            plot.setOrientation(PlotOrientation.HORIZONTAL);
            JFreeChart chart = new JFreeChart(plot);
            /* BufferedImage image = */ chart.createBufferedImage(300, 200,
                    null);
        }",Eager Test
"@Test
    public void testDrawWithNullDeviationVertical() {
        try {
            DefaultStatisticalCategoryDataset<String, String> dataset
                    = new DefaultStatisticalCategoryDataset<>();
            dataset.add(1.0, 2.0, ""S1"", ""C1"");
            dataset.add(4.0, null, ""S1"", ""C2"");
            CategoryPlot<String, String> plot = new CategoryPlot<>(dataset,
                    new CategoryAxis(""Category""), new NumberAxis(""Value""),
                    new StatisticalBarRenderer());
            JFreeChart chart = new JFreeChart(plot);
            /* BufferedImage image = */ chart.createBufferedImage(300, 200,
                    null);
        }",Eager Test
"@Test
    public void testSerialization() {
        StatisticalBarRenderer r1 = new StatisticalBarRenderer();
        StatisticalBarRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",No Smells
"@Test
    public void testEquals() {
        StatisticalLineAndShapeRenderer r1
            = new StatisticalLineAndShapeRenderer();
        StatisticalLineAndShapeRenderer r2
            = new StatisticalLineAndShapeRenderer();
        assertEquals(r1, r2);
        assertEquals(r2, r1);

        r1.setErrorIndicatorPaint(Color.RED);
        assertNotEquals(r1, r2);
        r2.setErrorIndicatorPaint(Color.RED);
        assertEquals(r2, r1);
    }",No Smells
"@Test
    public void testFindRangeBounds() {
        StatisticalLineAndShapeRenderer r
                = new StatisticalLineAndShapeRenderer();
        assertNull(r.findRangeBounds(null));

        // an empty dataset should return a null range
        DefaultStatisticalCategoryDataset<String, String> dataset
                = new DefaultStatisticalCategoryDataset<>();
        assertNull(r.findRangeBounds(dataset));

        dataset.add(1.0, 0.5, ""R1"", ""C1"");
        assertEquals(new Range(0.5, 1.5), r.findRangeBounds(dataset));

        dataset.add(-2.0, 0.2, ""R1"", ""C2"");
        assertEquals(new Range(-2.2, 1.5), r.findRangeBounds(dataset));

        dataset.add(null, null, ""R1"", ""C3"");
        assertEquals(new Range(-2.2, 1.5), r.findRangeBounds(dataset));

        dataset.add(5.0, 1.0, ""R2"", ""C3"");
        assertEquals(new Range(-2.2, 6.0), r.findRangeBounds(dataset));

        // check that the series visible flag is observed
        r.setSeriesVisible(1, Boolean.FALSE);
        assertEquals(new Range(-2.2, 1.5), r.findRangeBounds(dataset));
    }",No Smells
"@Test
    public void testPublicCloneable() {
        StatisticalLineAndShapeRenderer r1
                = new StatisticalLineAndShapeRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testEquals() {
        WaterfallBarRenderer r1 = new WaterfallBarRenderer();
        WaterfallBarRenderer r2 = new WaterfallBarRenderer();
        assertEquals(r1, r2);

        // firstBarPaint;
        r1.setFirstBarPaint(Color.CYAN);
        assertNotEquals(r1, r2);
        r2.setFirstBarPaint(Color.CYAN);
        assertEquals(r1, r2);

        // lastBarPaint;
        r1.setLastBarPaint(Color.GREEN);
        assertNotEquals(r1, r2);
        r2.setLastBarPaint(Color.GREEN);
        assertEquals(r1, r2);

        // positiveBarPaint;
        r1.setPositiveBarPaint(Color.BLUE);
        assertNotEquals(r1, r2);
        r2.setPositiveBarPaint(Color.BLUE);
        assertEquals(r1, r2);

        // negativeBarPaint;
        r1.setNegativeBarPaint(Color.RED);
        assertNotEquals(r1, r2);
        r2.setNegativeBarPaint(Color.RED);
        assertEquals(r1, r2);

    }",No Smells
"@Test
    public void testFindRangeBounds() {
        WaterfallBarRenderer r = new WaterfallBarRenderer();
        assertNull(r.findRangeBounds(null));
    }",No Smells
"@Test
    public void testGetPaint() {
        GrayPaintScale gps = new GrayPaintScale();
        Color c = (Color) gps.getPaint(0.0);
        assertEquals(c, Color.BLACK);
        c = (Color) gps.getPaint(1.0);
        assertEquals(c, Color.WHITE);

        // check lookup values that are outside the bounds - see bug report
        // 1767315
        c = (Color) gps.getPaint(-0.5);
        assertEquals(c, Color.BLACK);
        c = (Color) gps.getPaint(1.5);
        assertEquals(c, Color.WHITE);
    }",Eager Test
"@Test
    public void testEquals() {
        LookupPaintScale g1 = new LookupPaintScale();
        LookupPaintScale g2 = new LookupPaintScale();
        assertEquals(g1, g2);
        assertEquals(g2, g1);

        g1 = new LookupPaintScale(1.0, 2.0, Color.RED);
        assertNotEquals(g1, g2);
        g2 = new LookupPaintScale(1.0, 2.0, Color.RED);
        assertEquals(g1, g2);

        g1.add(1.5, new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f, 4.0f,
                Color.BLUE));
        assertNotEquals(g1, g2);
        g2.add(1.5, new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f, 4.0f,
                Color.BLUE));
        assertEquals(g1, g2);
    }",Eager Test
"@Test
    public void testFindLiveItemsUpperBound_Descending() {
        var d = new DefaultXYDataset<String>() {
            @Override
            public DomainOrder getDomainOrder() {
                // we're doing this for testing only, and make sure that we
                // only add data in descending order by x-value
                return DomainOrder.DESCENDING;
            }",Eager Test
"@Test
    public void testEquals_ObjectList2() {
        XYBarRenderer r1 = new XYBarRenderer();
        r1.setSeriesToolTipGenerator(0, new StandardXYToolTipGenerator());
        XYBarRenderer r2 = new XYBarRenderer();
        r2.setSeriesToolTipGenerator(0, new StandardXYToolTipGenerator());
        assertEquals(r1, r2);
        r2.setSeriesToolTipGenerator(1, new StandardXYToolTipGenerator());
        assertNotEquals(r1, r2);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        CandlestickRenderer r1 = new CandlestickRenderer();
        CandlestickRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testFindRangeBounds() {
        CandlestickRenderer renderer = new CandlestickRenderer();

        OHLCDataItem item1 = new OHLCDataItem(new Date(1L), 2.0, 4.0, 1.0, 3.0,
                100);
        OHLCDataset dataset = new DefaultOHLCDataset(""S1"",
                new OHLCDataItem[] {item1}",Eager Test
"@Test
    public void testSerialization() {
        CandlestickRenderer r1 = new CandlestickRenderer();
        CandlestickRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        ClusteredXYBarRenderer r1 = new ClusteredXYBarRenderer();
        ClusteredXYBarRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testEquals() {
        // default instances
        DeviationRenderer r1 = new DeviationRenderer();
        DeviationRenderer r2 = new DeviationRenderer();
        assertEquals(r1, r2);
        assertEquals(r2, r1);

        r1.setAlpha(0.1f);
        assertNotEquals(r1, r2);
        r2.setAlpha(0.1f);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testEquals() {
        GradientXYBarPainter p1 = new GradientXYBarPainter(0.1, 0.2, 0.3);
        GradientXYBarPainter p2 = new GradientXYBarPainter(0.1, 0.2, 0.3);
        assertEquals(p1, p2);

        p1 = new GradientXYBarPainter(0.11, 0.2, 0.3);
        assertNotEquals(p1, p2);
        p2 = new GradientXYBarPainter(0.11, 0.2, 0.3);
        assertEquals(p1, p2);

        p1 = new GradientXYBarPainter(0.11, 0.22, 0.3);
        assertNotEquals(p1, p2);
        p2 = new GradientXYBarPainter(0.11, 0.22, 0.3);
        assertEquals(p1, p2);

        p1 = new GradientXYBarPainter(0.11, 0.22, 0.33);
        assertNotEquals(p1, p2);
        p2 = new GradientXYBarPainter(0.11, 0.22, 0.33);
        assertEquals(p1, p2);
    }",No Smells
"@Test
    public void testSerialization() {
        GradientXYBarPainter p1 = new GradientXYBarPainter(0.1, 0.2, 0.3);
        GradientXYBarPainter p2 = TestUtils.serialised(p1);
        assertEquals(p1, p2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        HighLowRenderer r1 = new HighLowRenderer();
        r1.setCloseTickPaint(Color.GREEN);
        HighLowRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
        TestUtils.checkIndependence(r1, r2);
    }",Eager Test
"@Test
    public void testSerialization() {
        StackedXYAreaRenderer2 r1 = new StackedXYAreaRenderer2();
        StackedXYAreaRenderer2 r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        StackedXYAreaRenderer r1 = new StackedXYAreaRenderer();
        StackedXYAreaRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
    }",Eager Test
"@Test
    public void testFindRangeBounds() {
        TableXYDataset<String> dataset
                = RendererXYPackageUtils.createTestTableXYDataset();
        JFreeChart chart = ChartFactory.createStackedXYAreaChart(
                ""Test Chart"", ""X"", ""Y"", dataset,
                PlotOrientation.VERTICAL, false, false, false);
        XYPlot<?> plot = (XYPlot) chart.getPlot();
        plot.setRenderer(new StackedXYBarRenderer());
        NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis();
        Range bounds = rangeAxis.getRange();
        assertTrue(bounds.contains(6.0));
        assertTrue(bounds.contains(8.0));
    }",Eager Test
"@Test
    public void testSerialization() {
        StackedXYBarRenderer r1 = new StackedXYBarRenderer();
        r1.setSeriesPaint(0, new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f,
                4.0f, Color.YELLOW));
        StackedXYBarRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testNoDisplayedItem() {
        XYSeriesCollection<String> dataset = new XYSeriesCollection<>();
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        s1.add(10.0, 10.0);
        dataset.addSeries(s1);
        JFreeChart chart = ChartFactory.createXYLineChart(""Title"", ""X"", ""Y"",
                dataset, PlotOrientation.VERTICAL, false, true, false);
        XYPlot<?> plot = (XYPlot) chart.getPlot();
        plot.setRenderer(new StandardXYItemRenderer());
        NumberAxis xAxis = (NumberAxis) plot.getDomainAxis();
        xAxis.setRange(0.0, 5.0);
        NumberAxis yAxis = (NumberAxis) plot.getRangeAxis();
        yAxis.setRange(0.0, 5.0);
        BufferedImage image = new BufferedImage(200 , 100,
                BufferedImage.TYPE_INT_RGB);
        Graphics2D g2 = image.createGraphics();
        ChartRenderingInfo info = new ChartRenderingInfo();
        chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, info);
        g2.dispose();
        EntityCollection ec = info.getEntityCollection();
        assertFalse(TestUtils.containsInstanceOf(ec.getEntities(), XYItemEntity.class));
    }",Eager Test
"@Test
    public void testPublicCloneable() {
        VectorRenderer r1 = new VectorRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testSerialization() {
        VectorRenderer r1 = new VectorRenderer();
        VectorRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testSerialization() {
        WindItemRenderer r1 = new WindItemRenderer();
        WindItemRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        XYAreaRenderer2 r1 = new XYAreaRenderer2();
        Rectangle rect = new Rectangle(1, 2, 3, 4);
        r1.setLegendArea(rect);
        XYAreaRenderer2 r2 = (XYAreaRenderer2) r1.clone();
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);

        // check independence
        rect.setBounds(99, 99, 99, 99);
        assertNotEquals(r1, r2);
    }",Eager Test
"@Test
    public void testGetLegendItemSeriesIndex() {
        XYSeriesCollection<String> d1 = new XYSeriesCollection<>();
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        s1.add(1.0, 1.1);
        XYSeries<String> s2 = new XYSeries<>(""S2"");
        s2.add(1.0, 1.1);
        d1.addSeries(s1);
        d1.addSeries(s2);

        XYSeriesCollection<String> d2 = new XYSeriesCollection<>();
        XYSeries<String> s3 = new XYSeries<>(""S3"");
        s3.add(1.0, 1.1);
        XYSeries<String> s4 = new XYSeries<>(""S4"");
        s4.add(1.0, 1.1);
        XYSeries<String> s5 = new XYSeries<>(""S5"");
        s5.add(1.0, 1.1);
        d2.addSeries(s3);
        d2.addSeries(s4);
        d2.addSeries(s5);

        XYAreaRenderer r = new XYAreaRenderer();
        XYPlot<String> plot = new XYPlot<>(d1, new NumberAxis(""x""),
                new NumberAxis(""y""), r);
        plot.setDataset(1, d2);
        JFreeChart chart = new JFreeChart(plot);
        LegendItem li = r.getLegendItem(1, 2);
        assertEquals(""S5"", li.getLabel());
        assertEquals(1, li.getDatasetIndex());
        assertEquals(2, li.getSeriesIndex());
    }",Eager Test
"@Test
    public void testSerialization() {
        XYAreaRenderer r1 = new XYAreaRenderer();
        XYAreaRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testFindRangeBounds() {
        DefaultIntervalXYDataset<String> dataset = new DefaultIntervalXYDataset<>();
        double[] x = {1.0, 2.0, 3.0, 4.0}",Eager Test
"@Test
    public void testBug1766646A() {
        XYBlockRenderer r = new XYBlockRenderer();
        Range range = r.findDomainBounds(null);
        assertNull(range);
        DefaultXYZDataset<String> emptyDataset = new DefaultXYZDataset<>();
        range = r.findDomainBounds(emptyDataset);
        assertNull(range);
    }",Eager Test
"@Test
    public void testBug1766646B() {
        XYBlockRenderer r = new XYBlockRenderer();
        Range range = r.findRangeBounds(null);
        assertNull(range);
        DefaultXYZDataset<String> emptyDataset = new DefaultXYZDataset<>();
        range = r.findRangeBounds(emptyDataset);
        assertNull(range);
    }",Eager Test
"@Test
    public void testHashcode() {
        XYBoxAndWhiskerRenderer r1 = new XYBoxAndWhiskerRenderer();
        XYBoxAndWhiskerRenderer r2 = new XYBoxAndWhiskerRenderer();
        assertEquals(r1, r2);
        int h1 = r1.hashCode();
        int h2 = r2.hashCode();
        assertEquals(h1, h2);
    }",No Smells
"@Test
    public void testEquals() {
        XYBubbleRenderer r1 = new XYBubbleRenderer();
        XYBubbleRenderer r2 = new XYBubbleRenderer();
        assertEquals(r1, r2);

        r1 = new XYBubbleRenderer(XYBubbleRenderer.SCALE_ON_RANGE_AXIS);
        assertNotEquals(r1, r2);
        r2 = new XYBubbleRenderer(XYBubbleRenderer.SCALE_ON_RANGE_AXIS);
        assertEquals(r1, r2);
    }",Eager Test
"@Test
    public void testSerialization() {
        XYBubbleRenderer r1 = new XYBubbleRenderer();
        XYBubbleRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        XYDifferenceRenderer r1 = new XYDifferenceRenderer(Color.RED, Color.BLUE, false);
        XYDifferenceRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);

        // check independence
        Shape s = r1.getLegendLine();
        if (s instanceof Line2D) {
            Line2D l = (Line2D) s;
            l.setLine(1.0, 2.0, 3.0, 4.0);
            assertNotEquals(r1, r2);
        }",Eager Test
"@Test
    public void testEquals() {
        XYDifferenceRenderer r1 = new XYDifferenceRenderer(
                Color.RED, Color.BLUE, false);
        XYDifferenceRenderer r2 = new XYDifferenceRenderer(
                Color.RED, Color.BLUE, false);
        assertEquals(r1, r2);

        // positive paint
        r1.setPositivePaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.BLUE));
        assertNotEquals(r1, r2);
        r2.setPositivePaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.BLUE));
        assertEquals(r1, r2);

        // negative paint
        r1.setNegativePaint(new GradientPaint(1.0f, 2.0f, Color.YELLOW,
                3.0f, 4.0f, Color.BLUE));
        assertNotEquals(r1, r2);
        r2.setNegativePaint(new GradientPaint(1.0f, 2.0f, Color.YELLOW,
                3.0f, 4.0f, Color.BLUE));
        assertEquals(r1, r2);

        // shapesVisible
        r1 = new XYDifferenceRenderer(Color.GREEN, Color.YELLOW, true);
        assertNotEquals(r1, r2);
        r2 = new XYDifferenceRenderer(Color.GREEN, Color.YELLOW, true);
        assertEquals(r1, r2);

        // legendLine
        r1.setLegendLine(new Line2D.Double(1.0, 2.0, 3.0, 4.0));
        assertNotEquals(r1, r2);
        r2.setLegendLine(new Line2D.Double(1.0, 2.0, 3.0, 4.0));
        assertEquals(r1, r2);

        // roundXCoordinates
        r1.setRoundXCoordinates(true);
        assertNotEquals(r1, r2);
        r2.setRoundXCoordinates(true);
        assertEquals(r1, r2);

        assertNotEquals(null, r1);
    }",Eager Test
"@Test
    public void testHashcode() {
        XYDifferenceRenderer r1 = new XYDifferenceRenderer(Color.RED, Color.BLUE, false);
        XYDifferenceRenderer r2 = new XYDifferenceRenderer(Color.RED, Color.BLUE, false);
        assertEquals(r1, r2);
        int h1 = r1.hashCode();
        int h2 = r2.hashCode();
        assertEquals(h1, h2);
    }",No Smells
"@Test
    public void testGetLegendItemSeriesIndex() {
        XYSeriesCollection<String> d1 = new XYSeriesCollection<>();
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        s1.add(1.0, 1.1);
        XYSeries<String> s2 = new XYSeries<>(""S2"");
        s2.add(1.0, 1.1);
        d1.addSeries(s1);
        d1.addSeries(s2);

        XYSeriesCollection<String> d2 = new XYSeriesCollection<>();
        XYSeries<String> s3 = new XYSeries<>(""S3"");
        s3.add(1.0, 1.1);
        XYSeries<String> s4 = new XYSeries<>(""S4"");
        s4.add(1.0, 1.1);
        XYSeries<String> s5 = new XYSeries<>(""S5"");
        s5.add(1.0, 1.1);
        d2.addSeries(s3);
        d2.addSeries(s4);
        d2.addSeries(s5);

        XYDotRenderer r = new XYDotRenderer();
        XYPlot<String> plot = new XYPlot<>(d1, new NumberAxis(""x""),
                new NumberAxis(""y""), r);
        plot.setDataset(1, d2);
        /*JFreeChart chart =*/ new JFreeChart(plot);
        LegendItem li = r.getLegendItem(1, 2);
        assertEquals(""S5"", li.getLabel());
        assertEquals(1, li.getDatasetIndex());
        assertEquals(2, li.getSeriesIndex());
    }",Eager Test
"@Test
    public void testPublicCloneable() {
        XYDotRenderer r1 = new XYDotRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testSerialization() {
        XYDotRenderer r1 = new XYDotRenderer();
        XYDotRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testEquals() {
        XYErrorRenderer r1 = new XYErrorRenderer();
        XYErrorRenderer r2 = new XYErrorRenderer();
        assertEquals(r1, r2);

        // drawXError
        r1.setDrawXError(false);
        assertNotEquals(r1, r2);
        r2.setDrawXError(false);
        assertEquals(r1, r2);

        // drawYError
        r1.setDrawYError(false);
        assertNotEquals(r1, r2);
        r2.setDrawYError(false);
        assertEquals(r1, r2);

        // capLength
        r1.setCapLength(9.0);
        assertNotEquals(r1, r2);
        r2.setCapLength(9.0);
        assertEquals(r1, r2);

        // errorPaint
        r1.setErrorPaint(new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f, 4.0f,
                Color.GREEN));
        assertNotEquals(r1, r2);
        r2.setErrorPaint(new GradientPaint(1.0f, 2.0f, Color.RED, 3.0f, 4.0f,
                Color.GREEN));
        assertEquals(r1, r2);

        // errorStroke
        r1.setErrorStroke(new BasicStroke(1.5f));
        assertNotEquals(r1, r2);
        r2.setErrorStroke(new BasicStroke(1.5f));
        assertEquals(r1, r2);

    }",Eager Test
"@Test
    public void testPublicCloneable() {
        XYErrorRenderer r1 = new XYErrorRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testEquals2() {
        XYLineAndShapeRenderer r1 = new XYLineAndShapeRenderer();
        XYLineAndShapeRenderer r2 = new XYLineAndShapeRenderer();
        assertEquals(r1, r2);
        assertEquals(r2, r1);

        r1.setURLGenerator(new TimeSeriesURLGenerator());
        assertNotEquals(r1, r2);
        r2.setURLGenerator(new TimeSeriesURLGenerator());
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testFindRangeBounds() {
        TableXYDataset<String> dataset
                = RendererXYPackageUtils.createTestTableXYDataset();
        JFreeChart chart = ChartFactory.createXYLineChart(
                ""Test Chart"", ""X"", ""Y"", dataset, PlotOrientation.VERTICAL,
                false, false, false);
        XYPlot<?> plot = (XYPlot) chart.getPlot();
        NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis();
        rangeAxis.setAutoRangeIncludesZero(false);
        Range bounds = rangeAxis.getRange();
        assertFalse(bounds.contains(1.0));
        assertTrue(bounds.contains(2.0));
        assertTrue(bounds.contains(5.0));
        assertFalse(bounds.contains(6.0));
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        XYShapeRenderer r1 = new XYShapeRenderer();
        XYShapeRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testEquals() {
        XYShapeRenderer r1 = new XYShapeRenderer();
        XYShapeRenderer r2 = new XYShapeRenderer();
        assertEquals(r1, r2);
        assertEquals(r2, r1);

        r1.setPaintScale(new LookupPaintScale(1.0, 2.0, Color.WHITE));
        assertNotEquals(r1, r2);
        r2.setPaintScale(new LookupPaintScale(1.0, 2.0, Color.WHITE));
        assertEquals(r1, r2);

        r1.setDrawOutlines(true);
        assertNotEquals(r1, r2);
        r2.setDrawOutlines(true);
        assertEquals(r1, r2);

        r1.setUseOutlinePaint(false);
        assertNotEquals(r1, r2);
        r2.setUseOutlinePaint(false);
        assertEquals(r1, r2);

        r1.setUseFillPaint(true);
        assertNotEquals(r1, r2);
        r2.setUseFillPaint(true);
        assertEquals(r1, r2);

        r1.setGuideLinesVisible(true);
        assertNotEquals(r1, r2);
        r2.setGuideLinesVisible(true);
        assertEquals(r1, r2);

        r1.setGuideLinePaint(Color.RED);
        assertNotEquals(r1, r2);
        r2.setGuideLinePaint(Color.RED);
        assertEquals(r1, r2);

    }",Eager Test
"@Test
    public void testFindZBounds() {
        XYShapeRenderer r = new XYShapeRenderer();
        assertNull(r.findZBounds(null));

        DefaultXYZDataset<String> dataset = new DefaultXYZDataset<>();
        Range range;

        double[][] data1 = { {1,1,1}",Eager Test
"@Test
    public void testSerialization() {
        XYShapeRenderer r1 = new XYShapeRenderer();
        XYShapeRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        Rectangle2D legendShape = new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0);
        XYSplineRenderer r1 = new XYSplineRenderer();
        r1.setLegendLine(legendShape);
        XYSplineRenderer r2 = CloneUtils.clone(r1);
        assertNotSame(r1, r2);
        assertSame(r1.getClass(), r2.getClass());
        assertEquals(r1, r2);
    }",Eager Test
"@Test
    public void testHashcode() {
        XYSplineRenderer r1 = new XYSplineRenderer();
        XYSplineRenderer r2 = new XYSplineRenderer();
        assertEquals(r1, r2);
        int h1 = r1.hashCode();
        int h2 = r2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testPublicCloneable() {
        XYStepAreaRenderer r1 = new XYStepAreaRenderer();
        assertTrue(r1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testSerialization() {
        XYStepRenderer r1 = new XYStepRenderer();
        r1.setStepPoint(0.123);
        XYStepRenderer r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void testCloning() {
        CompositeTitle t1 = new CompositeTitle(new BlockContainer());
        t1.getContainer().add(new TextTitle(""T1""));
        t1.setBackgroundPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.YELLOW));
        CompositeTitle t2 = null;
        try {
            t2 = CloneUtils.clone(t1);
        }",Eager Test
"@Test
    public void testEquals() {
        CompositeTitle t1 = new CompositeTitle(new BlockContainer());
        CompositeTitle t2 = new CompositeTitle(new BlockContainer());
        assertEquals(t1, t2);
        assertEquals(t2, t1);

        // margin
        t1.setMargin(new RectangleInsets(1.0, 2.0, 3.0, 4.0));
        assertNotEquals(t1, t2);
        t2.setMargin(new RectangleInsets(1.0, 2.0, 3.0, 4.0));
        assertEquals(t1, t2);

        // frame
        t1.setFrame(new BlockBorder(Color.RED));
        assertNotEquals(t1, t2);
        t2.setFrame(new BlockBorder(Color.RED));
        assertEquals(t1, t2);

        // padding
        t1.setPadding(new RectangleInsets(1.0, 2.0, 3.0, 4.0));
        assertNotEquals(t1, t2);
        t2.setPadding(new RectangleInsets(1.0, 2.0, 3.0, 4.0));
        assertEquals(t1, t2);

        // contained titles
        t1.getContainer().add(new TextTitle(""T1""));
        assertNotEquals(t1, t2);
        t2.getContainer().add(new TextTitle(""T1""));
        assertEquals(t1, t2);

        t1.setBackgroundPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.YELLOW));
        assertNotEquals(t1, t2);
        t2.setBackgroundPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.YELLOW));
        assertEquals(t1, t2);

    }",Eager Test
"@Test
    public void testSerialization() {
        CompositeTitle t1 = new CompositeTitle(new BlockContainer());
        t1.getContainer().add(new TextTitle(""T1""));
        t1.setBackgroundPaint(new GradientPaint(1.0f, 2.0f, Color.RED,
                3.0f, 4.0f, Color.BLUE));
        CompositeTitle t2 = TestUtils.serialised(t1);
        assertEquals(t1, t2);
    }",Eager Test
"@Test
    public void testHashcode() {
        DateTitle t1 = new DateTitle();
        DateTitle t2 = new DateTitle();
        assertEquals(t1, t2);
        int h1 = t1.hashCode();
        int h2 = t2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testEquals() {
        LegendGraphic g1 = new LegendGraphic(new Rectangle2D.Double(1.0, 2.0,
                3.0, 4.0), Color.BLACK);
        LegendGraphic g2 = new LegendGraphic(new Rectangle2D.Double(1.0, 2.0,
                3.0, 4.0), Color.BLACK);
        assertEquals(g1, g2);
        assertEquals(g2, g1);

        // shapeVisible
        g1.setShapeVisible(!g1.isShapeVisible());
        assertNotEquals(g1, g2);
        g2.setShapeVisible(!g2.isShapeVisible());
        assertEquals(g1, g2);

        // shape
        g1.setShape(new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0));
        assertNotEquals(g1, g2);
        g2.setShape(new Rectangle2D.Double(4.0, 3.0, 2.0, 1.0));
        assertEquals(g1, g2);

        // shapeFilled
        g1.setShapeFilled(!g1.isShapeFilled());
        assertNotEquals(g1, g2);
        g2.setShapeFilled(!g2.isShapeFilled());
        assertEquals(g1, g2);

        // fillPaint
        g1.setFillPaint(Color.GREEN);
        assertNotEquals(g1, g2);
        g2.setFillPaint(Color.GREEN);
        assertEquals(g1, g2);

        // shapeOutlineVisible
        g1.setShapeOutlineVisible(!g1.isShapeOutlineVisible());
        assertNotEquals(g1, g2);
        g2.setShapeOutlineVisible(!g2.isShapeOutlineVisible());
        assertEquals(g1, g2);

        // outlinePaint
        g1.setOutlinePaint(Color.GREEN);
        assertNotEquals(g1, g2);
        g2.setOutlinePaint(Color.GREEN);
        assertEquals(g1, g2);

        // outlineStroke
        g1.setOutlineStroke(new BasicStroke(1.23f));
        assertNotEquals(g1, g2);
        g2.setOutlineStroke(new BasicStroke(1.23f));
        assertEquals(g1, g2);

        // shapeAnchor
        g1.setShapeAnchor(RectangleAnchor.BOTTOM_RIGHT);
        assertNotEquals(g1, g2);
        g2.setShapeAnchor(RectangleAnchor.BOTTOM_RIGHT);
        assertEquals(g1, g2);

        // shapeLocation
        g1.setShapeLocation(RectangleAnchor.BOTTOM_RIGHT);
        assertNotEquals(g1, g2);
        g2.setShapeLocation(RectangleAnchor.BOTTOM_RIGHT);
        assertEquals(g1, g2);

        // lineVisible
        g1.setLineVisible(!g1.isLineVisible());
        assertNotEquals(g1, g2);
        g2.setLineVisible(!g2.isLineVisible());
        assertEquals(g1, g2);

        // line
        g1.setLine(new Line2D.Double(1.0, 2.0, 3.0, 4.0));
        assertNotEquals(g1, g2);
        g2.setLine(new Line2D.Double(1.0, 2.0, 3.0, 4.0));
        assertEquals(g1, g2);

        // linePaint
        g1.setLinePaint(Color.GREEN);
        assertNotEquals(g1, g2);
        g2.setLinePaint(Color.GREEN);
        assertEquals(g1, g2);

        // lineStroke
        g1.setLineStroke(new BasicStroke(1.23f));
        assertNotEquals(g1, g2);
        g2.setLineStroke(new BasicStroke(1.23f));
        assertEquals(g1, g2);

        // fillPaintTransformer
        g1.setFillPaintTransformer(new StandardGradientPaintTransformer(
                GradientPaintTransformType.CENTER_HORIZONTAL));
        assertNotEquals(g1, g2);
        g2.setFillPaintTransformer(new StandardGradientPaintTransformer(
                GradientPaintTransformType.CENTER_HORIZONTAL));
        assertEquals(g1, g2);

    }",Eager Test
"@Test
    public void testSerialization() {
        Stroke s = new BasicStroke(1.23f);
        LegendGraphic g1 = new LegendGraphic(new Rectangle2D.Double(1.0, 2.0, 
                3.0, 4.0), Color.BLACK);
        g1.setOutlineStroke(s);
        LegendGraphic g2 = TestUtils.serialised(g1);
        assertEquals(g1, g2);
    }",Eager Test
"@Test
    public void testSerialization() {
        XYPlot<String> plot = new XYPlot<>();
        LegendTitle t1 = new LegendTitle(plot);
        LegendTitle t2 = TestUtils.serialised(t1);
        assertEquals(t1, t2);
        assertEquals(t2.getSources()[0], plot);
    }",No Smells
"@Test
    public void testHashcode() {
        PaintScaleLegend l1 = new PaintScaleLegend(new GrayPaintScale(),
                new NumberAxis(""X""));
        PaintScaleLegend l2 = new PaintScaleLegend(new GrayPaintScale(),
                new NumberAxis(""X""));
        assertEquals(l1, l2);
        int h1 = l1.hashCode();
        int h2 = l2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        ShortTextTitle t1 = new ShortTextTitle(""ABC"");
        ShortTextTitle t2 = CloneUtils.clone(t1);
        assertNotSame(t1, t2);
        assertSame(t1.getClass(), t2.getClass());
        assertEquals(t1, t2);
    }",No Smells
"@Test
    public void testSerialization() {
        ShortTextTitle t1 = new ShortTextTitle(""ABC"");
        ShortTextTitle t2 = TestUtils.serialised(t1);
        assertEquals(t1, t2);
    }",No Smells
"@Test
    public void testPublicCloneable() {
        CustomXYURLGenerator g1 = new CustomXYURLGenerator();
        assertTrue(g1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testGenerateURL() {
        TimeSeriesURLGenerator g = new TimeSeriesURLGenerator();
        DefaultXYDataset<String> dataset = new DefaultXYDataset<>();
        dataset.addSeries(""Series '1'"", new double[][] {{1.0, 2.0}",No Smells
"@Test
    public void testPublicCloneable() {
        TimeSeriesURLGenerator g1 = new TimeSeriesURLGenerator();
        assertFalse(g1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testClipLine() {
        Rectangle2D rect = new Rectangle2D.Double(1.0, 1.0, 1.0, 1.0);
        Line2D line = new Line2D.Double();

        assertFalse(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 0.0, 0.0, 0.0, 0.0));

        line.setLine(0.5, 0.5, 0.6, 0.6);
        assertFalse(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 0.5, 0.5, 0.6, 0.6));

        line.setLine(0.5, 0.5, 1.6, 0.6);
        assertFalse(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 0.5, 0.5, 1.6, 0.6));

        line.setLine(0.5, 0.5, 2.6, 0.6);
        assertFalse(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 0.5, 0.5, 2.6, 0.6));

        line.setLine(0.5, 0.5, 0.6, 1.6);
        assertFalse(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 0.5, 0.5, 0.6, 1.6));

        line.setLine(0.5, 0.5, 1.6, 1.6);
        assertTrue(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 1.0, 1.0, 1.6, 1.6));

        line.setLine(0.5, 0.5, 2.6, 1.6);
        assertTrue(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 1.4545454545454546, 1.0, 2.0,
                1.2857142857142858));

        line.setLine(0.5, 0.5, 0.5, 2.6);
        assertFalse(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 0.5, 0.5, 0.5, 2.6));

        line.setLine(0.5, 0.5, 1.5, 2.6);
        assertTrue(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 1.0, 1.55, 1.2142857142857142, 2.0));

        line.setLine(0.5, 0.5, 2.5, 2.6);
        assertTrue(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 1.0, 1.025, 1.9285714285714284, 2.0));

        line.setLine(0.5, 0.5, 1.5, 1.5);
        assertTrue(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 1.0, 1.0, 1.5, 1.5));

        line.setLine(2.5, 1.0, 1.5, 1.5);
        assertTrue(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 2.0, 1.25, 1.5, 1.5));

        line.setLine(1.5, 1.5, 2.5, 1.0);
        assertTrue(LineUtils.clipLine(line, rect));
        assertTrue(lineEquals(line, 1.5, 1.5, 2.0, 1.25));
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        LogFormat f1 = new LogFormat(10.0, ""10"", true);
        LogFormat f2 = CloneUtils.clone(f1);
        assertNotSame(f1, f2);
        assertSame(f1.getClass(), f2.getClass());
        assertEquals(f1, f2);
    }",No Smells
"@Test
    public void testEquals() {
        LogFormat f1 = new LogFormat(10.0, ""10"", true);
        LogFormat f2 = new LogFormat(10.0, ""10"", true);
        assertEquals(f1, f2);

        f1 = new LogFormat(11.0, ""10"", true);
        assertNotEquals(f1, f2);
        f2 = new LogFormat(11.0, ""10"", true);
        assertEquals(f1, f2);

        f1 = new LogFormat(11.0, ""11"", true);
        assertNotEquals(f1, f2);
        f2 = new LogFormat(11.0, ""11"", true);
        assertEquals(f1, f2);

        f1 = new LogFormat(11.0, ""11"", false);
        assertNotEquals(f1, f2);
        f2 = new LogFormat(11.0, ""11"", false);
        assertEquals(f1, f2);

        f1.setExponentFormat(new DecimalFormat(""0.000""));
        assertNotEquals(f1, f2);
        f2.setExponentFormat(new DecimalFormat(""0.000""));
        assertEquals(f1, f2);
    }",No Smells
"@Test
    public void testCloning() {
        NumberFormat nf = new DecimalFormat(""0"");
        RelativeDateFormat df1 = new RelativeDateFormat();
        df1.setSecondFormatter(nf);
        RelativeDateFormat df2 = (RelativeDateFormat) df1.clone();
        assertNotSame(df1, df2);
        assertSame(df1.getClass(), df2.getClass());
        assertEquals(df1, df2);

        // is the clone independent
        nf.setMinimumFractionDigits(2);
        assertNotEquals(df1, df2);
    }",No Smells
"@Test
    public void testFormat() {
        RelativeDateFormat rdf = new RelativeDateFormat();
        String s = rdf.format(new Date(2 * 60L * 60L * 1000L + 122500L));
        assertEquals(""2h2m2.500s"", s);
    }",No Smells
"@Test
    public void testNegative() {
        NumberFormat nf = new DecimalFormat(""0"");
        RelativeDateFormat df1 = new RelativeDateFormat();
        df1.setSecondFormatter(nf);
        assertEquals(""-0h0m1s"", df1.format(new Date(-1000L)));
    }",No Smells
"@Test
    public void testSerialization() {
        DefaultCategoryDataset<String, String> underlying = new DefaultCategoryDataset<>();
        underlying.addValue(1.1, ""R1"", ""C1"");
        underlying.addValue(2.2, ""R1"", ""C2"");
        CategoryToPieDataset d1 = new CategoryToPieDataset(underlying,
                TableOrder.BY_COLUMN, 1);
        CategoryToPieDataset d2 = (CategoryToPieDataset) 
                TestUtils.serialised(d1);
        assertEquals(d1, d2);

        // regular equality for the datasets doesn't check the fields, just
        // the data values...so let's check some more things...
        assertEquals(d1.getUnderlyingDataset(), d2.getUnderlyingDataset());
        assertEquals(d1.getExtractType(), d2.getExtractType());
        assertEquals(d1.getExtractIndex(), d2.getExtractIndex());
    }",Eager Test
"@Test
    public void testEquals() {
        DefaultCategoryDataset<String,String> d1 = new DefaultCategoryDataset<>();
        d1.setValue(23.4, ""R1"", ""C1"");
        DefaultCategoryDataset<String,String> d2 = new DefaultCategoryDataset<>();
        d2.setValue(23.4, ""R1"", ""C1"");
        assertEquals(d1, d2);
        assertEquals(d2, d1);

        d1.setValue(36.5, ""R1"", ""C2"");
        assertNotEquals(d1, d2);
        d2.setValue(36.5, ""R1"", ""C2"");
        assertEquals(d1, d2);

        d1.setValue(null, ""R1"", ""C1"");
        assertNotEquals(d1, d2);
        d2.setValue(null, ""R1"", ""C1"");
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testGetValue2() {
        DefaultCategoryDataset<String,String> d = new DefaultCategoryDataset<>();
        boolean pass = false;
        try {
            /* Number n =*/ d.getValue(0, 0);
        }",No Smells
"@Test
    public void testIncrementValue() {
        DefaultCategoryDataset<String,String> d = new DefaultCategoryDataset<>();
        d.addValue(1.0, ""R1"", ""C1"");
        d.incrementValue(2.0, ""R1"", ""C1"");
        assertEquals(3.0, d.getValue(""R1"", ""C1""));

        // increment a null value
        d.addValue(null, ""R2"", ""C1"");
        d.incrementValue(2.0, ""R2"", ""C1"");
        assertEquals(2.0, d.getValue(""R2"", ""C1""));

        // increment an unknown row
        boolean pass = false;
        try {
            d.incrementValue(1.0, ""XX"", ""C1"");
        }",No Smells
"@Test
    public void testRemoveRow() {
        DefaultCategoryDataset<String,String> d = new DefaultCategoryDataset<>();
        d.addValue(1.0, ""R1"", ""C1"");
        d.addValue(2.0, ""R2"", ""C2"");
        assertEquals(2, d.getRowCount());
        d.removeRow(""R2"");
        assertEquals(1, d.getRowCount());

        boolean pass = false;
        try {
            d.removeRow(""XXX"");
        }",No Smells
"@Test
    public void testRemoveValue() {
        DefaultCategoryDataset<String,String> d = new DefaultCategoryDataset<>();
        d.removeValue(""R1"", ""C1"");
        d.addValue(1.0, ""R1"", ""C1"");
        d.removeValue(""R1"", ""C1"");
        assertEquals(0, d.getRowCount());
        assertEquals(0, d.getColumnCount());

        d.addValue(1.0, ""R1"", ""C1"");
        d.addValue(2.0, ""R2"", ""C1"");
        d.removeValue(""R1"", ""C1"");
        assertEquals(2.0, d.getValue(0, 0));

        boolean pass = false;
        try {
            d.removeValue(null, ""C1"");
        }",No Smells
"@Test
    public void testCloning2() throws CloneNotSupportedException {
        DefaultIntervalCategoryDataset d1
                = new DefaultIntervalCategoryDataset(new double[0][0],
                    new double[0][0]);
        DefaultIntervalCategoryDataset d2;
        d2 = (DefaultIntervalCategoryDataset) d1.clone();
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testGetCategoryCount() {
        // check an empty dataset
        DefaultIntervalCategoryDataset empty
                = new DefaultIntervalCategoryDataset(new double[0][0],
                        new double[0][0]);
        assertEquals(0, empty.getCategoryCount());
    }",No Smells
"@Test
    public void testGetRowIndex() {
        // check an empty dataset
        DefaultIntervalCategoryDataset empty
                = new DefaultIntervalCategoryDataset(new double[0][0],
                        new double[0][0]);
        assertEquals(-1, empty.getRowIndex(""ABC""));
    }",No Smells
"@Test
    public void testGetSeriesIndex() {
        // check an empty dataset
        DefaultIntervalCategoryDataset empty
                = new DefaultIntervalCategoryDataset(new double[0][0],
                        new double[0][0]);
        assertEquals(-1, empty.getSeriesIndex(""ABC""));
    }",No Smells
"@Test
    public void testGetValue() {
        double[] starts_S1 = new double[] {0.1, 0.2, 0.3}",Eager Test
"@Test
    public void testSetCategoryKeys() {
        // check an empty dataset
        DefaultIntervalCategoryDataset empty
                = new DefaultIntervalCategoryDataset(new double[0][0],
                        new double[0][0]);
        boolean pass = true;
        try {
            empty.setCategoryKeys(new String[0]);
        }",No Smells
"@Test
    public void testGetColumnIndex() {
        DefaultCategoryDataset<String, String> underlying = new DefaultCategoryDataset<>();
        underlying.addValue(1.0, ""R1"", ""C1"");
        underlying.addValue(2.0, ""R1"", ""C2"");
        underlying.addValue(3.0, ""R1"", ""C3"");
        underlying.addValue(4.0, ""R1"", ""C4"");
        SlidingCategoryDataset<String, String> dataset 
                = new SlidingCategoryDataset<>(underlying, 1, 2);
        assertEquals(-1, dataset.getColumnIndex(""C1""));
        assertEquals(0, dataset.getColumnIndex(""C2""));
        assertEquals(1, dataset.getColumnIndex(""C3""));
        assertEquals(-1, dataset.getColumnIndex(""C4""));
    }",Eager Test
"@Test
    public void testSerialization() {
        DefaultCategoryDataset<String, String> u1 = new DefaultCategoryDataset<>();
        u1.addValue(1.0, ""R1"", ""C1"");
        u1.addValue(2.0, ""R1"", ""C2"");
        SlidingCategoryDataset<String, String> d1 = new SlidingCategoryDataset<>(u1, 0, 5);
        SlidingCategoryDataset<String, String> d2 = TestUtils.serialised(d1);
        assertEquals(d1, d2);

        // basic check for independence
        u1.addValue(3.0, ""R1"", ""C3"");
        assertNotEquals(d1, d2);
        DefaultCategoryDataset<String, String> u2
                = (DefaultCategoryDataset) d2.getUnderlyingDataset();
        u2.addValue(3.0, ""R1"", ""C3"");
        assertEquals(d1, d2);
    }",Eager Test
"@Test
    public void testConstructor1() {
        ComparableObjectSeries<String> s1 = new ComparableObjectSeries<>(""s1"");
        assertEquals(""s1"", s1.getKey());
        assertTrue(s1.getAllowDuplicateXValues());
        assertTrue(s1.getAutoSort());
        assertEquals(0, s1.getItemCount());
        assertEquals(Integer.MAX_VALUE, s1.getMaximumItemCount());

        // try null key
        boolean pass = false;
        try {
            /*s1 = */new ComparableObjectSeries<String>(null);
        }",Eager Test
"@Test
    public void testCalculateRowTotal2() {
        DefaultKeyedValues2D<String, String> table = new DefaultKeyedValues2D<>();
        table.addValue(1.0, ""R0"", ""C0"");
        table.addValue(2.0, ""R0"", ""C1"");
        table.addValue(3.0, ""R1"", ""C0"");
        table.addValue(4.0, ""R1"", ""C1"");
        assertEquals(3.0, DataUtils.calculateRowTotal(table, 0,
                new int[] {0, 1}",Eager Test
"@Test
    public void testCreateNumberArray2D() {
        double[][] d = new double[2][];
        d[0] = new double[] {1.1, 2.2, 3.3, 4.4}",Eager Test
"@Test
    public void testRemoveValue() {
        DefaultKeyedValues2D<String, String> d = new DefaultKeyedValues2D<>();
        d.removeValue(""R1"", ""C1"");
        d.addValue(1.0, ""R1"", ""C1"");
        d.removeValue(""R1"", ""C1"");
        assertEquals(0, d.getRowCount());
        assertEquals(0, d.getColumnCount());

        d.addValue(1.0, ""R1"", ""C1"");
        d.addValue(2.0, ""R2"", ""C1"");
        d.removeValue(""R1"", ""C1"");
        assertEquals(2.0, d.getValue(0, 0));
    }",No Smells
"@Test
    public void testSerialization() {
        DefaultKeyedValues2D<String, String> kv2D1 = new DefaultKeyedValues2D<>();
        kv2D1.addValue(234.2, ""Row1"", ""Col1"");
        kv2D1.addValue(null, ""Row1"", ""Col2"");
        kv2D1.addValue(345.9, ""Row2"", ""Col1"");
        kv2D1.addValue(452.7, ""Row2"", ""Col2"");

        DefaultKeyedValues2D<String, String> kv2D2 = TestUtils.serialised(kv2D1);
        assertEquals(kv2D1, kv2D2);
    }",No Smells
"@Test
    public void testGetItemCount() {
        DefaultKeyedValues<String> d = new DefaultKeyedValues<>();
        assertEquals(0, d.getItemCount());
        d.addValue(""A"", 1.0);
        assertEquals(1, d.getItemCount());
        d.addValue(""B"", 2.0);
        assertEquals(2, d.getItemCount());
        d.clear();
        assertEquals(0, d.getItemCount());
    }",No Smells
"@Test
    public void testGetKeys() {
        DefaultKeyedValues<String> d = new DefaultKeyedValues<>();
        List<String> keys = d.getKeys();
        assertTrue(keys.isEmpty());
        d.addValue(""A"", 1.0);
        keys = d.getKeys();
        assertEquals(1, keys.size());
        assertTrue(keys.contains(""A""));
        d.addValue(""B"", 2.0);
        keys = d.getKeys();
        assertEquals(2, keys.size());
        assertTrue(keys.contains(""A""));
        assertTrue(keys.contains(""B""));
        d.clear();
        keys = d.getKeys();
        assertEquals(0, keys.size());
    }",No Smells
"@Test
    public void testInsertValue() {
        DefaultKeyedValues<String> v1 = new DefaultKeyedValues<>();
        v1.insertValue(0, ""A"", 1.0);
        assertEquals(1.0, v1.getValue(0));
        v1.insertValue(0, ""B"", 2.0);
        assertEquals(2.0, v1.getValue(0));
        assertEquals(1.0, v1.getValue(1));

        // it's OK to use an index equal to the size of the list
        v1.insertValue(2, ""C"", 3.0);
        assertEquals(2.0, v1.getValue(0));
        assertEquals(1.0, v1.getValue(1));
        assertEquals(3.0, v1.getValue(2));

        // try replacing an existing value
        v1.insertValue(2, ""B"", 4.0);
        assertEquals(1.0, v1.getValue(0));
        assertEquals(3.0, v1.getValue(1));
        assertEquals(4.0, v1.getValue(2));
    }",No Smells
"@Test
    public void testSortByKeyAscending() {

        DefaultKeyedValues<String> data = new DefaultKeyedValues<>();
        data.addValue(""C"", 1.0);
        data.addValue(""B"", null);
        data.addValue(""D"", 3.0);
        data.addValue(""A"", 2.0);

        data.sortByKeys(SortOrder.ASCENDING);

        // check key order
        assertEquals(data.getKey(0), ""A"");
        assertEquals(data.getKey(1), ""B"");
        assertEquals(data.getKey(2), ""C"");
        assertEquals(data.getKey(3), ""D"");

        // check retrieve value by key
        assertEquals(data.getValue(""A""), 2.0);
        assertNull(data.getValue(""B""));
        assertEquals(data.getValue(""C""), 1.0);
        assertEquals(data.getValue(""D""), 3.0);

        // check retrieve value by index
        assertEquals(data.getValue(0), 2.0);
        assertNull(data.getValue(1));
        assertEquals(data.getValue(2), 1.0);
        assertEquals(data.getValue(3), 3.0);

    }",No Smells
"@Test
    public void testSortByKeyDescending() {

        DefaultKeyedValues<String> data = new DefaultKeyedValues<>();
        data.addValue(""C"", 1.0);
        data.addValue(""B"", null);
        data.addValue(""D"", 3.0);
        data.addValue(""A"", 2.0);

        data.sortByKeys(SortOrder.DESCENDING);

        // check key order
        assertEquals(data.getKey(0), ""D"");
        assertEquals(data.getKey(1), ""C"");
        assertEquals(data.getKey(2), ""B"");
        assertEquals(data.getKey(3), ""A"");

        // check retrieve value by key
        assertEquals(data.getValue(""A""), 2.0);
        assertNull(data.getValue(""B""));
        assertEquals(data.getValue(""C""), 1.0);
        assertEquals(data.getValue(""D""), 3.0);

        // check retrieve value by index
        assertEquals(data.getValue(0), 3.0);
        assertEquals(data.getValue(1), 1.0);
        assertNull(data.getValue(2));
        assertEquals(data.getValue(3), 2.0);

    }",No Smells
"@Test
    public void testSortByValueDescending() {

        DefaultKeyedValues<String> data = new DefaultKeyedValues<>();
        data.addValue(""C"", 1.0);
        data.addValue(""B"", null);
        data.addValue(""D"", 3.0);
        data.addValue(""A"", 2.0);

        data.sortByValues(SortOrder.DESCENDING);

        // check key order
        assertEquals(data.getKey(0), ""D"");
        assertEquals(data.getKey(1), ""A"");
        assertEquals(data.getKey(2), ""C"");
        assertEquals(data.getKey(3), ""B"");

        // check retrieve value by key
        assertEquals(data.getValue(""A""), 2.0);
        assertNull(data.getValue(""B""));
        assertEquals(data.getValue(""C""), 1.0);
        assertEquals(data.getValue(""D""), 3.0);

        // check retrieve value by index
        assertEquals(data.getValue(0), 3.0);
        assertEquals(data.getValue(1), 2.0);
        assertEquals(data.getValue(2), 1.0);
        assertNull(data.getValue(3));

    }",No Smells
"@Test
    public void testConstructor() {
        DefaultKeyedValue<String> v = new DefaultKeyedValue<>(""A"", 1);
        assertEquals(""A"", v.getKey());
        assertEquals(1, v.getValue());

        // try null key
        boolean pass = false;
        try {
            v = new DefaultKeyedValue<>(null, 1);
        }",No Smells
"@Test
    public void testEquals() {
        assertEquals(DomainOrder.NONE, DomainOrder.NONE);
        assertEquals(DomainOrder.ASCENDING, DomainOrder.ASCENDING);
        assertEquals(DomainOrder.DESCENDING, DomainOrder.DESCENDING);
        assertNotEquals(DomainOrder.NONE, DomainOrder.ASCENDING);
        assertNotEquals(DomainOrder.NONE, DomainOrder.DESCENDING);
        assertNotEquals(null, DomainOrder.NONE);
        assertNotEquals(DomainOrder.ASCENDING, DomainOrder.NONE);
        assertNotEquals(DomainOrder.ASCENDING, DomainOrder.DESCENDING);
        assertNotEquals(null, DomainOrder.ASCENDING);
        assertNotEquals(DomainOrder.DESCENDING, DomainOrder.NONE);
        assertNotEquals(DomainOrder.DESCENDING, DomainOrder.ASCENDING);
        assertNotEquals(null, DomainOrder.DESCENDING);
    }",No Smells
"@Test
    public void testSerialization() {
        LineFunction2D f1 = new LineFunction2D(1.0, 2.0);
        LineFunction2D f2 = TestUtils.serialised(f1);
        assertEquals(f1, f2);
    }",No Smells
"@Test
    public void testEquals() {
        PolynomialFunction2D f1 = new PolynomialFunction2D(new double[] {1.0,
                2.0}",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        TaskSeries<String> s1 = new TaskSeries<>(""Series"");
        s1.add(new Task(""Task 1"", new Date(0L), new Date(1L)));
        TaskSeriesCollection<String, String> u1 = new TaskSeriesCollection<>();
        u1.add(s1);
        SlidingGanttCategoryDataset d1 = new SlidingGanttCategoryDataset(
                u1, 0, 5);
        SlidingGanttCategoryDataset d2 = CloneUtils.clone(d1);
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);

        // basic check for independence
        s1.add(new Task(""Task 2"", new Date(10L), new Date(11L)));
        assertNotEquals(d1, d2);
        TaskSeriesCollection<String, String> u2
                = (TaskSeriesCollection) d2.getUnderlyingDataset();
        TaskSeries<String> s2 = u2.getSeries(""Series"");
        s2.add(new Task(""Task 2"", new Date(10L), new Date(11L)));
        assertEquals(d1, d2);
    }",Eager Test
"@Test
    public void testSerialization() {
        TaskSeries<String> s1 = new TaskSeries<>(""Series"");
        s1.add(new Task(""Task 1"", new Date(0L), new Date(1L)));
        TaskSeriesCollection<String, String> u1 = new TaskSeriesCollection<>();
        u1.add(s1);
        SlidingGanttCategoryDataset d1 = new SlidingGanttCategoryDataset(
                u1, 0, 5);
        SlidingGanttCategoryDataset d2 = TestUtils.serialised(d1);
        assertEquals(d1, d2);

        // basic check for independence
        s1.add(new Task(""Task 2"", new Date(10L), new Date(11L)));
        assertNotEquals(d1, d2);
        TaskSeriesCollection<String, String> u2
                = (TaskSeriesCollection) d2.getUnderlyingDataset();
        TaskSeries<String> s2 = u2.getSeries(""Series"");
        s2.add(new Task(""Task 2"", new Date(10L), new Date(11L)));
        assertEquals(d1, d2);
    }",Eager Test
"@Test
    public void test697153() {

        TaskSeries<String> s1 = new TaskSeries<>(""S1"");
        s1.add(new Task(""Task 1"", new SimpleTimePeriod(new Date(),
                new Date())));
        s1.add(new Task(""Task 2"", new SimpleTimePeriod(new Date(),
                new Date())));
        s1.add(new Task(""Task 3"", new SimpleTimePeriod(new Date(),
                new Date())));

        TaskSeries<String> s2 = new TaskSeries<>(""S2"");
        s2.add(new Task(""Task 2"", new SimpleTimePeriod(new Date(),
                new Date())));
        s2.add(new Task(""Task 3"", new SimpleTimePeriod(new Date(),
                new Date())));
        s2.add(new Task(""Task 4"", new SimpleTimePeriod(new Date(),
                new Date())));

        TaskSeriesCollection<String, String> tsc = new TaskSeriesCollection<>();
        tsc.add(s1);
        tsc.add(s2);

        s1.removeAll();

        int taskCount = tsc.getColumnCount();

        assertEquals(3, taskCount);

    }",No Smells
"@Test
    public void testEquals() {

        TaskSeries<String> s1 = new TaskSeries<>(""S"");
        s1.add(new Task(""T1"", new Date(1), new Date(2)));
        s1.add(new Task(""T2"", new Date(11), new Date(22)));
        TaskSeries<String> s2 = new TaskSeries<>(""S"");
        s2.add(new Task(""T1"", new Date(1), new Date(2)));
        s2.add(new Task(""T2"", new Date(11), new Date(22)));
        TaskSeriesCollection<String, String> c1 = new TaskSeriesCollection<>();
        c1.add(s1);
        c1.add(s2);

        TaskSeries<String> s1b = new TaskSeries<>(""S"");
        s1b.add(new Task(""T1"", new Date(1), new Date(2)));
        s1b.add(new Task(""T2"", new Date(11), new Date(22)));
        TaskSeries<String> s2b = new TaskSeries<>(""S"");
        s2b.add(new Task(""T1"", new Date(1), new Date(2)));
        s2b.add(new Task(""T2"", new Date(11), new Date(22)));
        TaskSeriesCollection<String, String> c2 = new TaskSeriesCollection<>();
        c2.add(s1b);
        c2.add(s2b);

        assertEquals(c1, c2);
        assertEquals(c2, c1);

    }",No Smells
"@Test
    public void testGetRowIndex() {
        TaskSeriesCollection<String, String> c = createCollection1();
        assertEquals(0, c.getRowIndex(""S1""));
        assertEquals(1, c.getRowIndex(""S2""));
    }",No Smells
"@Test
    public void testGetStartValue() {
        TaskSeriesCollection<String, String> c = createCollection1();
        assertEquals(1L, c.getStartValue(""S1"", ""Task 1""));
        assertEquals(3L, c.getStartValue(""S1"", ""Task 2""));
        assertEquals(5L, c.getStartValue(""S2"", ""Task 3""));

        assertEquals(1L, c.getStartValue(0, 0));
        assertEquals(3L, c.getStartValue(0, 1));
        assertNull(c.getStartValue(0, 2));
        assertNull(c.getStartValue(1, 0));
        assertNull(c.getStartValue(1, 1));
        assertEquals(5L, c.getStartValue(1, 2));

        // test collection 3, which doesn't define all tasks in all series
        TaskSeriesCollection<String, String> c3 = createCollection3();
        assertEquals(100L, c3.getStartValue(0, 0));
        assertEquals(220L, c3.getStartValue(0, 1));
        assertNull(c3.getStartValue(1, 0));
        assertEquals(2220L, c3.getStartValue(1, 1));
    }",No Smells
"@Test
    public void testGetStartValue2() {
        TaskSeriesCollection<String, String> c = createCollection2();
        assertEquals(10L, c.getStartValue(""S1"", ""Task 1"", 0));
        assertEquals(16L, c.getStartValue(""S1"", ""Task 1"", 1));
        assertEquals(30L, c.getStartValue(""S1"", ""Task 2"", 0));
        assertEquals(36L, c.getStartValue(""S1"", ""Task 2"", 1));
        assertEquals(50L, c.getStartValue(""S2"", ""Task 3"", 0));
        assertEquals(56L, c.getStartValue(""S2"", ""Task 3"", 1));

        assertEquals(10L, c.getStartValue(0, 0, 0));
        assertEquals(16L, c.getStartValue(0, 0, 1));
        assertEquals(30L, c.getStartValue(0, 1, 0));
        assertEquals(36L, c.getStartValue(0, 1, 1));
        assertEquals(50L, c.getStartValue(1, 2, 0));
        assertEquals(56L, c.getStartValue(1, 2, 1));

        TaskSeriesCollection<String, String> c3 = createCollection3();
        assertEquals(11L, c3.getStartValue(0, 0, 0));
        assertEquals(22L, c3.getStartValue(0, 1, 0));
        assertEquals(33L, c3.getStartValue(0, 1, 1));
        assertNull(c3.getStartValue(1, 0, 0));
        assertEquals(44L, c3.getStartValue(1, 1, 0));
        assertEquals(55L, c3.getStartValue(1, 1, 1));
        assertEquals(66L, c3.getStartValue(1, 1, 2));
    }",No Smells
"@Test
    public void testGetSubIntervalCount() {
        TaskSeriesCollection<String, String> tsc = createCollection3();
        assertEquals(1, tsc.getSubIntervalCount(0, 0));
        assertEquals(2, tsc.getSubIntervalCount(0, 1));
        assertEquals(0, tsc.getSubIntervalCount(1, 0));
        assertEquals(3, tsc.getSubIntervalCount(1, 1));
    }",No Smells
"@Test
    public void testGetValue() {
        TaskSeriesCollection<String, String> c = createCollection1();
        assertEquals(1L, c.getValue(""S1"", ""Task 1""));
        assertEquals(3L, c.getValue(""S1"", ""Task 2""));
        assertEquals(5L, c.getValue(""S2"", ""Task 3""));

        assertEquals(1L, c.getValue(0, 0));
        assertEquals(3L, c.getValue(0, 1));
        assertNull(c.getValue(0, 2));
        assertNull(c.getValue(1, 0));
        assertNull(c.getValue(1, 1));
        assertEquals(5L, c.getValue(1, 2));
    }",No Smells
"@Test
    public void testEquals() {
        TaskSeries<String> s1 = new TaskSeries<>(""S"");
        s1.add(new Task(""T1"", new Date(1), new Date(2)));
        s1.add(new Task(""T2"", new Date(11), new Date(22)));
        TaskSeries<String> s2 = new TaskSeries<>(""S"");
        s2.add(new Task(""T1"", new Date(1), new Date(2)));
        s2.add(new Task(""T2"", new Date(11), new Date(22)));
        assertEquals(s1, s2);
        assertEquals(s2, s1);

        s1.add(new Task(""T3"", new Date(22), new Date(33)));
        assertNotEquals(s1, s2);
        s2.add(new Task(""T3"", new Date(22), new Date(33)));
        assertEquals(s1, s2);
    }",No Smells
"@Test
    public void testSerialization() {
        TaskSeries<String> s1 = new TaskSeries<>(""S"");
        s1.add(new Task(""T1"", new Date(1), new Date(2)));
        s1.add(new Task(""T2"", new Date(11), new Date(22)));
        TaskSeries<String> s2 = TestUtils.serialised(s1);
        assertEquals(s1, s2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        Task t1 = new Task(""T"", new Date(1), new Date(2));
        Task t2 = CloneUtils.clone(t1);
        assertNotSame(t1, t2);
        assertSame(t1.getClass(), t2.getClass());
        assertEquals(t1, t2);
    }",Eager Test
"@Test
    public void test803660() {
        DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>();
        dataset.addValue(100.0, ""Series 1"", ""Type 1"");
        dataset.addValue(101.1, ""Series 1"", ""Type 2"");
        Number n = DatasetUtils.findMaximumRangeValue(dataset);
        assertTrue(n.doubleValue() > 101.0);
    }",Eager Test
"@Test
    public void testBug2849731_2() {
        XYIntervalSeriesCollection<String> d = new XYIntervalSeriesCollection<>();
        XYIntervalSeries<String> s = new XYIntervalSeries<>(""S1"");
        s.add(1.0, Double.NaN, Double.NaN, Double.NaN, 1.5, Double.NaN);
        d.addSeries(s);
        Range r = DatasetUtils.iterateDomainBounds(d);
        assertEquals(1.0, r.getLowerBound(), EPSILON);
        assertEquals(1.0, r.getUpperBound(), EPSILON);

        s.add(1.0, 1.5, Double.NaN, Double.NaN, 1.5, Double.NaN);
        r = DatasetUtils.iterateDomainBounds(d);
        assertEquals(1.0, r.getLowerBound(), EPSILON);
        assertEquals(1.5, r.getUpperBound(), EPSILON);

        s.add(1.0, Double.NaN, 0.5, Double.NaN, 1.5, Double.NaN);
        r = DatasetUtils.iterateDomainBounds(d);
        assertEquals(0.5, r.getLowerBound(), EPSILON);
        assertEquals(1.5, r.getUpperBound(), EPSILON);
    }",Eager Test
"@Test
    public void testCumulativeRange_NaN() {
        DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>();
        dataset.addValue(10.0, ""Series 1"", ""Start"");
        dataset.addValue(15.0, ""Series 1"", ""Delta 1"");
        dataset.addValue(Double.NaN, ""Series 1"", ""Delta 2"");
        Range range = DatasetUtils.findCumulativeRangeBounds(dataset);
        assertEquals(0.0, range.getLowerBound(), EPSILON);
        assertEquals(25.0, range.getUpperBound(), EPSILON);
    }",Eager Test
"@Test
    public void testFindDomainBounds3() {
        DefaultIntervalXYDataset<String> dataset = new DefaultIntervalXYDataset<>();
        double[] x1 = new double[] {1.0, 2.0, 3.0}",Eager Test
"@Test
    public void testFindMaximumRangeValue() {
        CategoryDataset<String, String> d1 = createCategoryDataset1();
        Number max1 = DatasetUtils.findMaximumRangeValue(d1);
        assertEquals(6.0, max1);

        XYDataset<String> dataset = createXYDataset1();
        Number maximum = DatasetUtils.findMaximumRangeValue(dataset);
        assertEquals(105.0, maximum);
    }",Eager Test
"@Test
    public void testFindMaximumStackedRangeValue2() {
        DefaultCategoryDataset<String, String> dataset 
                = new DefaultCategoryDataset<>();
        dataset.addValue(-1.0, ""R1"", ""C1"");
        Number max = DatasetUtils.findMaximumStackedRangeValue(dataset);
        assertEquals(0.0, max.doubleValue(), EPSILON);

        dataset.addValue(-2.0, ""R2"", ""C1"");
        max = DatasetUtils.findMaximumStackedRangeValue(dataset);
        assertEquals(0.0, max.doubleValue(), EPSILON);
    }",Eager Test
"@Test
    public void testFindRangeBounds_CategoryDataset() {
        CategoryDataset<String,String> dataset = createCategoryDataset1();
        Range r = DatasetUtils.findRangeBounds(dataset);
        assertEquals(1.0, r.getLowerBound(), EPSILON);
        assertEquals(6.0, r.getUpperBound(), EPSILON);
    }",No Smells
"@Test
    public void testIterateDomainBounds_NaN2() {
        DefaultIntervalXYDataset<String> dataset = new DefaultIntervalXYDataset<>();
        double[] x1 = new double[] {Double.NaN, 2.0, 3.0}",Eager Test
"@Test
    public void testIterateRangeBounds_CategoryDataset() {
        CategoryDataset<String,String> dataset = createCategoryDataset1();
        Range r = DatasetUtils.iterateRangeBounds(dataset, false);
        assertEquals(1.0, r.getLowerBound(), EPSILON);
        assertEquals(6.0, r.getUpperBound(), EPSILON);
    }",No Smells
"@Test
    public void testIterateToFindRangeBounds2_XYDataset() {
        List<String> visibleSeriesKeys = new ArrayList<>();
        Range xRange = new Range(0.0, 10.0);

        // empty dataset returns null
        XYSeriesCollection<String> dataset = new XYSeriesCollection<>();
        Range r = DatasetUtils.iterateToFindRangeBounds(dataset,
                visibleSeriesKeys, xRange, false);
        assertNull(r);

        // add an empty series
        XYSeries<String> s1 = new XYSeries<>(""A"");
        dataset.addSeries(s1);
        visibleSeriesKeys.add(""A"");
        r = DatasetUtils.iterateToFindRangeBounds(dataset,
                visibleSeriesKeys, xRange, false);
        assertNull(r);

        // check a null value
        s1.add(1.0, null);
        r = DatasetUtils.iterateToFindRangeBounds(dataset,
                visibleSeriesKeys, xRange, false);
        assertNull(r);

        // check a NaN
        s1.add(2.0, Double.NaN);
        r = DatasetUtils.iterateToFindRangeBounds(dataset,
                visibleSeriesKeys, xRange, false);
        assertNull(r);

        // check a regular value
        s1.add(3.0, 5.0);
        r = DatasetUtils.iterateToFindRangeBounds(dataset,
                visibleSeriesKeys, xRange, false);
        assertEquals(new Range(5.0, 5.0), r);

        // check another regular value
        s1.add(4.0, 6.0);
        r = DatasetUtils.iterateToFindRangeBounds(dataset,
                visibleSeriesKeys, xRange, false);
        assertEquals(new Range(5.0, 6.0), r);

        // add a second series
        XYSeries<String> s2 = new XYSeries<>(""B"");
        dataset.addSeries(s2);
        r = DatasetUtils.iterateToFindRangeBounds(dataset,
                visibleSeriesKeys, xRange, false);
        assertEquals(new Range(5.0, 6.0), r);
        visibleSeriesKeys.add(""B"");
        r = DatasetUtils.iterateToFindRangeBounds(dataset,
                visibleSeriesKeys, xRange, false);
        assertEquals(new Range(5.0, 6.0), r);

        // add a value to the second series
        s2.add(5.0, 15.0);
        r = DatasetUtils.iterateToFindRangeBounds(dataset,
                visibleSeriesKeys, xRange, false);
        assertEquals(new Range(5.0, 15.0), r);

        // add a value that isn't in the xRange
        s2.add(15.0, 150.0);
        r = DatasetUtils.iterateToFindRangeBounds(dataset,
                visibleSeriesKeys, xRange, false);
        assertEquals(new Range(5.0, 15.0), r);

        r = DatasetUtils.iterateToFindRangeBounds(dataset,
                visibleSeriesKeys, new Range(0.0, 20.0), false);
        assertEquals(new Range(5.0, 150.0), r);
    }",Eager Test
"@Test
    public void testStackedRangeWithMap() {
        CategoryDataset<String, String> d = createCategoryDataset1();
        KeyToGroupMap<String, String> map = new KeyToGroupMap<>(""G0"");
        map.mapKeyToGroup(""R2"", ""G1"");
        Range r = DatasetUtils.findStackedRangeBounds(d, map);
        assertEquals(0.0, r.getLowerBound(), EPSILON);
        assertEquals(9.0, r.getUpperBound(), EPSILON);
    }",Eager Test
"@Test
    public void testGeneral() {
        DefaultHeatMapDataset d = new DefaultHeatMapDataset(10, 5, 0.0, 9.0,
                0.0, 5.0);
        assertEquals(10, d.getXSampleCount());
        assertEquals(5, d.getYSampleCount());
        assertEquals(0.0, d.getMinimumXValue(), EPSILON);
        assertEquals(9.0, d.getMaximumXValue(), EPSILON);
        assertEquals(0.0, d.getMinimumYValue(), EPSILON);
        assertEquals(5.0, d.getMaximumYValue(), EPSILON);
        assertEquals(0.0, d.getZValue(0, 0), EPSILON);
        d.addChangeListener(this);
        d.setZValue(0, 0, 1.0, false);
        assertEquals(1.0, d.getZValue(0, 0), EPSILON);
        assertNull(this.lastEvent);
        d.setZValue(1, 2, 2.0);
        assertEquals(2.0, d.getZValue(1, 2), EPSILON);
        assertNotNull(this.lastEvent);
    }",No Smells
"@Test
    public void testSerialization() {
        DefaultHeatMapDataset d1 = new DefaultHeatMapDataset(2, 3, -1.0, 4.0,
                -2.0, 5.0);
        d1.setZValue(0, 0, 10.0);
        d1.setZValue(0, 1, Double.NEGATIVE_INFINITY);
        d1.setZValue(0, 2, Double.POSITIVE_INFINITY);
        d1.setZValue(1, 0, Double.NaN);
        DefaultHeatMapDataset d2 = TestUtils.serialised(d1);
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        DefaultKeyedValueDataset d1 = new DefaultKeyedValueDataset(""Test"", 45.5);
        DefaultKeyedValueDataset d2 = (DefaultKeyedValueDataset) d1.clone();
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testEquals() {

        DefaultKeyedValueDataset d1 = new DefaultKeyedValueDataset(""Test"", 45.5);
        DefaultKeyedValueDataset d2 = new DefaultKeyedValueDataset(""Test"", 45.5);
        assertEquals(d1, d2);
        assertEquals(d2, d1);

        d1 = new DefaultKeyedValueDataset(""Test 1"", 45.5);
        d2 = new DefaultKeyedValueDataset(""Test 2"", 45.5);
        assertNotEquals(d1, d2);

        d1 = new DefaultKeyedValueDataset(""Test"", 45.5);
        d2 = new DefaultKeyedValueDataset(""Test"", 45.6);
        assertNotEquals(d1, d2);

    }",No Smells
"@Test
    public void testSerialization() {
        DefaultKeyedValues2DDataset<String, String> d1 = new DefaultKeyedValues2DDataset<>();
        d1.addValue(234.2, ""Row1"", ""Col1"");
        d1.addValue(null, ""Row1"", ""Col2"");
        d1.addValue(345.9, ""Row2"", ""Col1"");
        d1.addValue(452.7, ""Row2"", ""Col2"");

        DefaultKeyedValues2DDataset<String, String> d2 = TestUtils.serialised(d1);
        assertEquals(d1, d2);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        DefaultKeyedValuesDataset<String> d1 = new DefaultKeyedValuesDataset<>();
        d1.setValue(""V1"", 1);
        d1.setValue(""V2"", null);
        d1.setValue(""V3"", 3);
        DefaultKeyedValuesDataset<String> d2 = CloneUtils.clone(d1);
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);
    }",Eager Test
"@Test
    public void testGetKey() {
        DefaultPieDataset<String> d = new DefaultPieDataset<>();
        d.setValue(""A"", 1.0);
        d.setValue(""B"", 2.0);
        assertEquals(""A"", d.getKey(0));
        assertEquals(""B"", d.getKey(1));

        boolean pass = false;
        try {
            d.getKey(-1);
        }",No Smells
"@Test
    public void testGetValueByIndex() {
        KeyedObjects2D<String, String> data = new KeyedObjects2D<>();
        data.addObject(""Obj1"", ""R1"", ""C1"");
        data.addObject(""Obj2"", ""R2"", ""C2"");
        assertEquals(""Obj1"", data.getObject(0, 0));
        assertEquals(""Obj2"", data.getObject(1, 1));
        assertNull(data.getObject(0, 1));
        assertNull(data.getObject(1, 0));

        // check invalid indices
        boolean pass = false;
        try {
            data.getObject(-1, 0);
        }",No Smells
"@Test
    public void testGetValueByKey() {
        KeyedObjects2D<String, String> data = new KeyedObjects2D<>();
        data.addObject(""Obj1"", ""R1"", ""C1"");
        data.addObject(""Obj2"", ""R2"", ""C2"");
        assertEquals(""Obj1"", data.getObject(""R1"", ""C1""));
        assertEquals(""Obj2"", data.getObject(""R2"", ""C2""));
        assertNull(data.getObject(""R1"", ""C2""));
        assertNull(data.getObject(""R2"", ""C1""));

        // check invalid indices
        boolean pass = false;
        try {
            data.getObject(""XX"", ""C1"");
        }",No Smells
"@Test
    public void testRemoveColumnByIndex() {
        KeyedObjects2D<String, String> data = new KeyedObjects2D<>();
        data.setObject(""Obj1"", ""R1"", ""C1"");
        data.setObject(""Obj2"", ""R2"", ""C2"");
        data.removeColumn(0);
        assertEquals(1, data.getColumnCount());
        assertEquals(""Obj2"", data.getObject(1, 0));

        // try negative column index
        boolean pass = false;
        try {
            data.removeColumn(-1);
        }",No Smells
"@Test
    public void testRemoveColumnByKey() {
        KeyedObjects2D<String, String> data = new KeyedObjects2D<>();
        data.setObject(""Obj1"", ""R1"", ""C1"");
        data.setObject(""Obj2"", ""R2"", ""C2"");
        data.removeColumn(""C2"");
        assertEquals(1, data.getColumnCount());
        assertEquals(""Obj1"", data.getObject(0, 0));

        // try unknown column key
        boolean pass = false;
        try {
            data.removeColumn(""XXX"");
        }",No Smells
"@Test
    public void testRemoveRowByKey() {
        KeyedObjects2D<String, String> data = new KeyedObjects2D<>();
        data.setObject(""Obj1"", ""R1"", ""C1"");
        data.setObject(""Obj2"", ""R2"", ""C2"");
        data.removeRow(""R2"");
        assertEquals(1, data.getRowCount());
        assertEquals(""Obj1"", data.getObject(0, 0));

        // try unknown row key
        boolean pass = false;
        try {
            data.removeRow(""XXX"");
        }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        KeyedObjects<String> ko1 = new KeyedObjects<>();
        ko1.addObject(""V1"", 1);
        ko1.addObject(""V2"", null);
        ko1.addObject(""V3"", 3);
        KeyedObjects<String> ko2 = CloneUtils.clone(ko1);
        assertNotSame(ko1, ko2);
        assertSame(ko1.getClass(), ko2.getClass());
        assertEquals(ko1, ko2);
    }",No Smells
"@Test
    public void testCloning2() throws CloneNotSupportedException {
        // case 1 - object is mutable but not PublicCloneable
        Object obj1 = new ArrayList<>();
        KeyedObjects<String> ko1 = new KeyedObjects<>();
        ko1.addObject(""K1"", obj1);
        KeyedObjects<String> ko2 = CloneUtils.clone(ko1);
        assertNotSame(ko1, ko2);
        assertSame(ko1.getClass(), ko2.getClass());
        assertEquals(ko1, ko2);

        // the clone contains a reference to the original object
        assertSame(ko2.getObject(""K1""), obj1);

        // CASE 2 - object is mutable AND PublicCloneable
        obj1 = new DefaultPieDataset<String>();
        ko1 = new KeyedObjects<>();
        ko1.addObject(""K1"", obj1);
        ko2 = CloneUtils.clone(ko1);
        assertNotSame(ko1, ko2);
        assertSame(ko1.getClass(), ko2.getClass());
        assertEquals(ko1, ko2);

        // the clone contains a reference to a CLONE of the original object
        assertNotSame(ko2.getObject(""K1""), obj1);
    }",No Smells
"@Test
    public void testGetObject() {
        // retrieve an item
        KeyedObjects<String> ko1 = new KeyedObjects<>();
        ko1.addObject(""Key 1"", ""Object 1"");
        ko1.addObject(""Key 2"", null);
        ko1.addObject(""Key 3"", ""Object 2"");
        assertEquals(""Object 1"", ko1.getObject(0));
        assertNull(ko1.getObject(1));
        assertEquals(""Object 2"", ko1.getObject(2));

        // request with a negative index
        boolean pass = false;
        try {
            ko1.getObject(-1);
        }",No Smells
"@Test
    public void testInsertAndRetrieve() {

        KeyedObjects<String> data = new KeyedObjects<>();
        data.addObject(""A"", 1.0);
        data.addObject(""B"", 2.0);
        data.addObject(""C"", 3.0);
        data.addObject(""D"", null);

        // check key order
        assertEquals(data.getKey(0), ""A"");
        assertEquals(data.getKey(1), ""B"");
        assertEquals(data.getKey(2), ""C"");
        assertEquals(data.getKey(3), ""D"");

        // check retrieve value by key
        assertEquals(data.getObject(""A""), 1.0);
        assertEquals(data.getObject(""B""), 2.0);
        assertEquals(data.getObject(""C""), 3.0);
        assertNull(data.getObject(""D""));

        boolean pass = false;
        try {
            data.getObject(""Not a key"");
        }",No Smells
"@Test
    public void testRemoveValueInt() {
        KeyedObjects<String> ko1 = new KeyedObjects<>();
        ko1.setObject(""Key 1"", ""Object 1"");
        ko1.setObject(""Key 2"", null);
        ko1.setObject(""Key 3"", ""Object 2"");

        ko1.removeValue(1);
        assertEquals(2, ko1.getItemCount());
        assertEquals(1, ko1.getIndex(""Key 3""));


        // try negative key index
        boolean pass = false;
        try {
            ko1.removeValue(-1);
        }",No Smells
"@Test
    public void testEquals() {
        KeyToGroupMap<String, String> m1 = new KeyToGroupMap<>(""Default Group"");
        KeyToGroupMap<String, String> m2 = new KeyToGroupMap<>(""Default Group"");
        assertEquals(m1, m2);
        assertEquals(m2, m1);

        m1.mapKeyToGroup(""K1"", ""G1"");
        assertNotEquals(m1, m2);
        m2.mapKeyToGroup(""K1"", ""G1"");
        assertEquals(m1, m2);
    }",No Smells
"@Test
    public void testSerialization() {
        KeyToGroupMap<String, String> m1 = new KeyToGroupMap<>(""Test"");
        KeyToGroupMap<String, String> m2 = TestUtils.serialised(m1);
        assertEquals(m1, m2);
    }",No Smells
"@Test
    public void testConstructor() {
        Range r1 = new Range(0.1, 1000.0);
        assertEquals(r1.getLowerBound(), 0.1, 0.0d);
        assertEquals(r1.getUpperBound(), 1000.0, 0.0d);

        try {
            Range r2 = new Range(10.0, 0.0);
            fail(""Lower bound cannot be greater than the upper"");
        }",No Smells
"@Test
    public void testContains() {
        Range r1 = new Range(0.0, 1.0);
        assertFalse(r1.contains(Double.NaN));
        assertFalse(r1.contains(Double.NEGATIVE_INFINITY));
        assertFalse(r1.contains(-1.0));
        assertTrue(r1.contains(0.0));
        assertTrue(r1.contains(0.5));
        assertTrue(r1.contains(1.0));
        assertFalse(r1.contains(2.0));
        assertFalse(r1.contains(Double.POSITIVE_INFINITY));
    }",No Smells
"@Test
    public void testEquals() {
        assertEquals(RangeType.FULL, RangeType.FULL);
        assertEquals(RangeType.NEGATIVE, RangeType.NEGATIVE);
        assertEquals(RangeType.POSITIVE, RangeType.POSITIVE);
        assertNotEquals(RangeType.FULL, RangeType.NEGATIVE);
        assertNotEquals(RangeType.FULL, RangeType.POSITIVE);
        assertNotEquals(null, RangeType.FULL);
        assertNotEquals(RangeType.NEGATIVE, RangeType.FULL);
        assertNotEquals(RangeType.NEGATIVE, RangeType.POSITIVE);
        assertNotEquals(null, RangeType.NEGATIVE);
        assertNotEquals(RangeType.POSITIVE, RangeType.NEGATIVE);
        assertNotEquals(RangeType.POSITIVE, RangeType.FULL);
        assertNotEquals(null, RangeType.POSITIVE);
    }",No Smells
"@Test
    public void testEquals() {

        BoxAndWhiskerItem i1 = new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0,
                5.0, 6.0, 7.0, 8.0, new ArrayList<>());
        BoxAndWhiskerItem i2 = new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0,
                5.0, 6.0, 7.0, 8.0, new ArrayList<>());
        assertEquals(i1, i2);
        assertEquals(i2, i1);
    }",No Smells
"@Test
    public void testAdd() {
        DefaultBoxAndWhiskerCategoryDataset<String, String> dataset
                = new DefaultBoxAndWhiskerCategoryDataset<>();
        BoxAndWhiskerItem item1 = new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0,
                5.0, 6.0, 7.0, 8.0, new ArrayList<>());
        dataset.add(item1, ""R1"", ""C1"");

        assertEquals(2.0, dataset.getValue(""R1"", ""C1"").doubleValue(), EPSILON);
        assertEquals(1.0, dataset.getMeanValue(""R1"", ""C1"").doubleValue(),
                EPSILON);
        assertEquals(2.0, dataset.getMedianValue(""R1"", ""C1"").doubleValue(),
                EPSILON);
        assertEquals(3.0, dataset.getQ1Value(""R1"", ""C1"").doubleValue(),
                EPSILON);
        assertEquals(4.0, dataset.getQ3Value(""R1"", ""C1"").doubleValue(),
                EPSILON);
        assertEquals(5.0, dataset.getMinRegularValue(""R1"", ""C1"").doubleValue(),
                EPSILON);
        assertEquals(6.0, dataset.getMaxRegularValue(""R1"", ""C1"").doubleValue(),
                EPSILON);
        assertEquals(7.0, dataset.getMinOutlier(""R1"", ""C1"").doubleValue(),
                EPSILON);
        assertEquals(8.0, dataset.getMaxOutlier(""R1"", ""C1"").doubleValue(),
                EPSILON);
        assertEquals(new Range(7.0, 8.0), dataset.getRangeBounds(false));
    }",No Smells
"@Test
    public void testConstructor() {
        DefaultBoxAndWhiskerCategoryDataset<String, String> dataset
                = new DefaultBoxAndWhiskerCategoryDataset<>();
        assertEquals(0, dataset.getColumnCount());
        assertEquals(0, dataset.getRowCount());
        assertTrue(Double.isNaN(dataset.getRangeLowerBound(false)));
        assertTrue(Double.isNaN(dataset.getRangeUpperBound(false)));
    }",No Smells
"@Test
    public void testEquals() {
        DefaultBoxAndWhiskerCategoryDataset<String, String> d1
                = new DefaultBoxAndWhiskerCategoryDataset<>();
        d1.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0,
                new ArrayList<>()), ""ROW1"", ""COLUMN1"");
        DefaultBoxAndWhiskerCategoryDataset<String, String> d2
                = new DefaultBoxAndWhiskerCategoryDataset<>();
        d2.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0,
                new ArrayList<>()), ""ROW1"", ""COLUMN1"");
        assertEquals(d1, d2);
        assertEquals(d2, d1);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        DefaultBoxAndWhiskerXYDataset<String> d1 
                = new DefaultBoxAndWhiskerXYDataset<>(""Series"");
        d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0,
                6.0, 7.0, 8.0, new ArrayList<>()));
        DefaultBoxAndWhiskerXYDataset<String> d2 = CloneUtils.clone(d1);
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);

        // test independence
        d1.add(new Date(2L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0,
                6.0, 7.0, 8.0, new ArrayList<>()));
        assertNotEquals(d1, d2);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        DefaultMultiValueCategoryDataset<String, String> d1
                = new DefaultMultiValueCategoryDataset<>();
        DefaultMultiValueCategoryDataset<String, String> d2 = CloneUtils.clone(d1);
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);

        // try a dataset with some content...
        List<Integer> values = new ArrayList<>();
        values.add(99);
        d1.add(values, ""R1"", ""C1"");
        d2 = CloneUtils.clone(d1);
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);

        // check that the clone doesn't share the same underlying arrays.
        List<Integer> values2 = new ArrayList<>();
        values2.add(111);
        d1.add(values2, ""R2"", ""C2"");
        assertNotEquals(d1, d2);
        d2.add(values2, ""R2"", ""C2"");
        assertEquals(d1, d2);
    }",Eager Test
"@Test
    public void testSerialization() {
        DefaultMultiValueCategoryDataset<String, String> d1
                = new DefaultMultiValueCategoryDataset<>();
        DefaultMultiValueCategoryDataset<String, String> d2 
                = TestUtils.serialised(d1);
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testAdd() {
        DefaultStatisticalCategoryDataset<String, String> d1
                = new DefaultStatisticalCategoryDataset<>();
        d1.add(1.0, 2.0, ""R1"", ""C1"");
        assertEquals(1.0, d1.getValue(""R1"", ""C1"").doubleValue(), EPSILON);
        assertEquals(2.0, d1.getStdDevValue(""R1"", ""C1"").doubleValue(), EPSILON);

        // overwrite the value
        d1.add(10.0, 20.0, ""R1"", ""C1"");
        assertEquals(10.0, d1.getValue(""R1"", ""C1"").doubleValue(), EPSILON);
        assertEquals(20.0, d1.getStdDevValue(""R1"", ""C1"").doubleValue(), EPSILON);
    }",No Smells
"@Test
    public void testEquals() {
        DefaultStatisticalCategoryDataset<String, String> d1
                = new DefaultStatisticalCategoryDataset<>();
        DefaultStatisticalCategoryDataset<String, String> d2
                = new DefaultStatisticalCategoryDataset<>();
        assertEquals(d1, d2);
        assertEquals(d2, d1);

    }",No Smells
"@Test
    public void testGetRangeBounds2() {
        DefaultStatisticalCategoryDataset<String, String> d1
                = new DefaultStatisticalCategoryDataset<>();
        d1.add(1.0, 2.0, ""R1"", ""C1"");
        assertEquals(new Range(1.0, 1.0), d1.getRangeBounds(false));
        assertEquals(new Range(-1.0, 3.0), d1.getRangeBounds(true));

        d1.add(10.0, 20.0, ""R1"", ""C1"");
        assertEquals(new Range(10.0, 10.0), d1.getRangeBounds(false));
        assertEquals(new Range(-10.0, 30.0), d1.getRangeBounds(true));
    }",No Smells
"@Test
    public void testRemove() {
        DefaultStatisticalCategoryDataset<String, String> data
                = new DefaultStatisticalCategoryDataset<>();

        boolean pass = false;
        try {
            data.remove(""R1"", ""R2"");
        }",No Smells
"@Test
    public void testSerialization1() {
        DefaultStatisticalCategoryDataset<String, String> d1
            = new DefaultStatisticalCategoryDataset<>();
        d1.add(1.1, 2.2, ""R1"", ""C1"");
        d1.add(3.3, 4.4, ""R1"", ""C2"");
        d1.add(null, 5.5, ""R1"", ""C3"");
        d1.add(6.6, null, ""R2"", ""C3"");
        DefaultStatisticalCategoryDataset<String, String> d2 = TestUtils.serialised(d1);
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testSerialization2() {
        DefaultStatisticalCategoryDataset<String, String> d1
            = new DefaultStatisticalCategoryDataset<>();
        d1.add(1.2, 3.4, ""Row 1"", ""Column 1"");
        DefaultStatisticalCategoryDataset<String, String> d2 = TestUtils.serialised(d1);
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testSerialization() {
        double start = 10.0;
        double end = 20.0;
        HistogramBin b1 = new HistogramBin(start, end);
        HistogramBin b2 = TestUtils.serialised(b1);
        assertEquals(b1, b2);
    }",No Smells
"@Test
    public void test2902842() {
        this.lastEvent = null;
        double[] values = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0}",Eager Test
"@Test
    public void testEquals() {
        double[] values = {1.0, 2.0, 3.0, 4.0, 6.0, 12.0, 5.0, 6.3, 4.5}",Eager Test
"@Test
    public void testEquals() {
        MeanAndStandardDeviation m1 = new MeanAndStandardDeviation(1.2, 3.4);
        MeanAndStandardDeviation m2 = new MeanAndStandardDeviation(1.2, 3.4);
        assertEquals(m1, m2);
        assertEquals(m2, m1);

        m1 = new MeanAndStandardDeviation(1.0, 3.4);
        assertNotEquals(m1, m2);
        m2 = new MeanAndStandardDeviation(1.0, 3.4);
        assertEquals(m1, m2);

        m1 = new MeanAndStandardDeviation(1.0, 3.0);
        assertNotEquals(m1, m2);
        m2 = new MeanAndStandardDeviation(1.0, 3.0);
        assertEquals(m1, m2);
    }",Eager Test
"@Test
    public void testOLSRegression1b() {

        double[][] data = createSampleData1();

        XYSeries<String> series = new XYSeries<>(""Test"");
        for (int i = 0; i < 11; i++) {
            series.add(data[i][0], data[i][1]);
        }",Eager Test
"@Test
    public void testPowerRegression1a() {
        double[][] data = createSampleData1();
        double[] result = Regression.getPowerRegression(data);
        assertEquals(0.91045813, result[0], 0.0000001);
        assertEquals(0.88918346, result[1], 0.0000001);
    }",No Smells
"@Test
    public void testPowerRegression1b() {

        double[][] data = createSampleData1();

        XYSeries<String> series = new XYSeries<>(""Test"");
        for (int i = 0; i < 11; i++) {
            series.add(data[i][0], data[i][1]);
        }",Eager Test
"@Test
    public void testEquals() {
        SimpleHistogramBin b1 = new SimpleHistogramBin(1.0, 2.0);
        SimpleHistogramBin b2 = new SimpleHistogramBin(1.0, 2.0);
        assertEquals(b1, b2);
        assertEquals(b2, b1);

        b1 = new SimpleHistogramBin(1.1, 2.0, true, true);
        assertNotEquals(b1, b2);
        b2 = new SimpleHistogramBin(1.1, 2.0, true, true);
        assertEquals(b1, b2);

        b1 = new SimpleHistogramBin(1.1, 2.2, true, true);
        assertNotEquals(b1, b2);
        b2 = new SimpleHistogramBin(1.1, 2.2, true, true);
        assertEquals(b1, b2);

        b1 = new SimpleHistogramBin(1.1, 2.2, false, true);
        assertNotEquals(b1, b2);
        b2 = new SimpleHistogramBin(1.1, 2.2, false, true);
        assertEquals(b1, b2);

        b1 = new SimpleHistogramBin(1.1, 2.2, false, false);
        assertNotEquals(b1, b2);
        b2 = new SimpleHistogramBin(1.1, 2.2, false, false);
        assertEquals(b1, b2);

        b1.setItemCount(99);
        assertNotEquals(b1, b2);
        b2.setItemCount(99);
        assertEquals(b1, b2);
    }",Eager Test
"@Test
    public void testSerialization() {
        SimpleHistogramBin b1 = new SimpleHistogramBin(1.0, 2.0, false, true);
        b1.setItemCount(123);
        SimpleHistogramBin b2 = TestUtils.serialised(b1);
        assertEquals(b1, b2);
    }",No Smells
"@Test
    public void testClearObservations() {
        SimpleHistogramDataset<String> d1 = new SimpleHistogramDataset<>(""D1"");
        d1.clearObservations();
        assertEquals(0, d1.getItemCount(0));
        d1.addBin(new SimpleHistogramBin(0.0, 1.0));
        d1.addObservation(0.5);
        assertEquals(1.0, d1.getYValue(0, 0), EPSILON);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        SimpleHistogramDataset<String> d1 = new SimpleHistogramDataset<>(""Dataset 1"");
        SimpleHistogramDataset<String> d2 = CloneUtils.clone(d1);
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);

        // check that clone is independent of the original
        d2.addBin(new SimpleHistogramBin(2.0, 3.0));
        d2.addObservation(2.3);
        assertNotEquals(d1, d2);
    }",Eager Test
"@Test
    public void testEquals() {
        SimpleHistogramDataset<String> d1 = new SimpleHistogramDataset<>(""Dataset 1"");
        SimpleHistogramDataset<String> d2 = new SimpleHistogramDataset<>(""Dataset 1"");
        assertEquals(d1, d2);

        d1.addBin(new SimpleHistogramBin(1.0, 2.0));
        assertNotEquals(d1, d2);
        d2.addBin(new SimpleHistogramBin(1.0, 2.0));
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testRemoveAllBins() {
        SimpleHistogramDataset<String> d1 = new SimpleHistogramDataset<>(""D1"");
        d1.addBin(new SimpleHistogramBin(0.0, 1.0));
        d1.addObservation(0.5);
        d1.addBin(new SimpleHistogramBin(2.0, 3.0));
        assertEquals(2, d1.getItemCount(0));
        d1.removeAllBins();
        assertEquals(0, d1.getItemCount(0));
    }",No Smells
"@Test
    public void testSerialization() {
        SimpleHistogramDataset<String> d1 = new SimpleHistogramDataset<>(""D1"");
        SimpleHistogramDataset<String> d2 = TestUtils.serialised(d1);
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testCalculateMean_Collection() {

        // try a null collection
        boolean pass = false;
        try {
            Statistics.calculateMean((Collection) null);
        }",Eager Test
"@Test
    public void testClone() {
        DateRange r1 = new DateRange(new Date(1000L), new Date(2000L));
        assertFalse(r1 instanceof Cloneable);
    }",No Smells
"@Test
    public void testImmutable() {
        Date d1 = new Date(10L);
        Date d2 = new Date(20L);
        DateRange r = new DateRange(d1, d2);
        d1.setTime(11L);
        assertEquals(new Date(10L), r.getLowerDate());
        r.getUpperDate().setTime(22L);
        assertEquals(new Date(20L), r.getUpperDate());
    }",Eager Test
"@Test
    public void testSerialization() {
        DateRange r1 = new DateRange(new Date(1000L), new Date(2000L));
        DateRange r2 = TestUtils.serialised(r1);
        assertEquals(r1, r2);
    }",No Smells
"@Test
    public void test31Dec9999Previous() {
        Day dec31st9999 = new Day(31, MonthConstants.DECEMBER, 9999);
        Day previous = (Day) dec31st9999.previous();
        assertEquals(30, previous.getDayOfMonth());
    }",No Smells
"@Test
    public void testDateConstructor2() {
        TimeZone zone = TimeZone.getTimeZone(""Europe/Helsinki"");
        Calendar cal = Calendar.getInstance(zone);
        Locale locale = Locale.getDefault();  // locale shouldn't matter here
        Day d1 = new Day(new Date(1078091999999L), zone, locale);
        Day d2 = new Day(new Date(1078092000000L), zone, locale);

        assertEquals(MonthConstants.FEBRUARY, d1.getMonth());
        assertEquals(1078091999999L, d1.getLastMillisecond(cal));

        assertEquals(MonthConstants.MARCH, d2.getMonth());
        assertEquals(1078092000000L, d2.getFirstMillisecond(cal));
    }",Eager Test
"@Test
    public void testEqualsSelf() {
        Day day = new Day();
        assertEquals(day, day);
    }",No Smells
"@Test
    public void testGetFirstMillisecond() {
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.UK);
        TimeZone savedZone = TimeZone.getDefault();
        TimeZone.setDefault(TimeZone.getTimeZone(""Europe/London""));
        Day d = new Day(1, 3, 1970);
        assertEquals(5094000000L, d.getFirstMillisecond());
        Locale.setDefault(saved);
        TimeZone.setDefault(savedZone);
    }",Eager Test
"@Test
    public void testGetLastMillisecondWithTimeZone() {
        Hour h = new Hour(2, 7, 7, 1950);
        TimeZone zone = TimeZone.getTimeZone(""America/Los_Angeles"");
        Calendar cal = Calendar.getInstance(zone);
        assertEquals(-614959200001L, h.getLastMillisecond(cal));

        // try null calendar
        boolean pass = false;
        try {
            h.getLastMillisecond((Calendar) null);
        }",Eager Test
"@Test
    public void testHashcode() {
        Hour h1 = new Hour(7, 9, 10, 1999);
        Hour h2 = new Hour(7, 9, 10, 1999);
        assertEquals(h1, h2);
        int hash1 = h1.hashCode();
        int hash2 = h2.hashCode();
        assertEquals(hash1, hash2);
    }",Eager Test
"@Test
    public void testLastHourPrevious() {
        Hour last = new Hour(23, new Day(31, MonthConstants.DECEMBER, 9999));
        Hour previous = (Hour) last.previous();
        assertEquals(22, previous.getHour());
        assertEquals(9999, previous.getYear());
    }",No Smells
"@Test
    public void testNotCloneable() {
        Hour h = new Hour(7, 9, 10, 1999);
        assertFalse(h instanceof Cloneable);
    }",No Smells
"@Test
    public void testSerialization() {
        Hour h1 = new Hour();
        Hour h2 = TestUtils.serialised(h1);
        assertEquals(h1, h2);
    }",No Smells
"@Test
    public void test943985() {
        Millisecond ms = new Millisecond(new java.util.Date(4));
        assertEquals(ms.getFirstMillisecond(), ms.getMiddleMillisecond());
        assertEquals(ms.getMiddleMillisecond(), ms.getLastMillisecond());
        ms = new Millisecond(new java.util.Date(5));
        assertEquals(ms.getFirstMillisecond(), ms.getMiddleMillisecond());
        assertEquals(ms.getMiddleMillisecond(), ms.getLastMillisecond());
    }",No Smells
"@Test
    public void testEqualsSelf() {
        Millisecond millisecond = new Millisecond();
        assertEquals(millisecond, millisecond);
    }",Eager Test
"@Test
    public void testEqualsSelf() {
        Millisecond millisecond = new Millisecond();
        assertEquals(millisecond, millisecond);
    }",No Smells
"@Test
    public void testDateConstructor1() {
        TimeZone zone = TimeZone.getTimeZone(""GMT"");
        Calendar cal = Calendar.getInstance(zone);
        Locale locale = Locale.getDefault(); // locale should not matter here
        Minute m1 = new Minute(new Date(1016729699999L), zone, locale);
        Minute m2 = new Minute(new Date(1016729700000L), zone, locale);

        assertEquals(54, m1.getMinute());
        assertEquals(1016729699999L, m1.getLastMillisecond(cal));

        assertEquals(55, m2.getMinute());
        assertEquals(1016729700000L, m2.getFirstMillisecond(cal));
    }",Eager Test
"@Test
    public void testGetFirstMillisecond() {
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.UK);
        TimeZone savedZone = TimeZone.getDefault();
        TimeZone.setDefault(TimeZone.getTimeZone(""Europe/London""));
        Minute m = new Minute(43, 15, 1, 4, 2006);
        assertEquals(1143902580000L, m.getFirstMillisecond());
        Locale.setDefault(saved);
        TimeZone.setDefault(savedZone);
    }",Eager Test
"@Test
    public void testGetStart() {
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.ITALY);
        TimeZone savedZone = TimeZone.getDefault();
        TimeZone.setDefault(TimeZone.getTimeZone(""Europe/Rome""));
        Calendar cal = Calendar.getInstance(Locale.ITALY);
        cal.set(2006, Calendar.JANUARY, 16, 3, 47, 0);
        cal.set(Calendar.MILLISECOND, 0);
        Minute m = new Minute(47, 3, 16, 1, 2006);
        assertEquals(cal.getTime(), m.getStart());
        Locale.setDefault(saved);
        TimeZone.setDefault(savedZone);
    }",Eager Test
"@Test
    public void testDateConstructor2() {

        TimeZone zone = TimeZone.getTimeZone(""Pacific/Auckland"");
        Calendar cal = Calendar.getInstance(zone);
        Month m1 = new Month(new Date(951821999999L), zone, Locale.getDefault());
        Month m2 = new Month(new Date(951822000000L), zone, Locale.getDefault());

        assertEquals(MonthConstants.FEBRUARY, m1.getMonth());
        assertEquals(951821999999L, m1.getLastMillisecond(cal));

        assertEquals(MonthConstants.MARCH, m2.getMonth());
        assertEquals(951822000000L, m2.getFirstMillisecond(cal));

    }",Eager Test
"@Test
    public void testDec9999Next() {
        Month next = (Month) this.dec9999.next();
        assertNull(next);
    }",No Smells
"@Test
    public void testEqualsSelf() {
        Month month = new Month();
        assertEquals(month, month);
    }",No Smells
"@Test
    public void testGetEnd() {
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.ITALY);
        Calendar cal = Calendar.getInstance(Locale.ITALY);
        cal.set(2006, Calendar.JANUARY, 31, 23, 59, 59);
        cal.set(Calendar.MILLISECOND, 999);
        Month m = new Month(1, 2006);
        assertEquals(cal.getTime(), m.getEnd());
        Locale.setDefault(saved);
    }",Eager Test
"@Test
    public void testGetFirstMillisecondWithCalendar() {
        Month m = new Month(1, 2001);
        GregorianCalendar calendar = new GregorianCalendar(Locale.GERMANY);
        calendar.setTimeZone(TimeZone.getTimeZone(""Europe/Frankfurt""));
        assertEquals(978307200000L, m.getFirstMillisecond(calendar));

        // try null calendar
        boolean pass = false;
        try {
            m.getFirstMillisecond((Calendar) null);
        }",Eager Test
"@Test
    public void testGetLastMillisecondWithTimeZone() {
        Month m = new Month(2, 1950);
        TimeZone zone = TimeZone.getTimeZone(""America/Los_Angeles"");
        Calendar cal = Calendar.getInstance(zone);
        assertEquals(-626025600001L, m.getLastMillisecond(cal));

        // try null calendar
        boolean pass = false;
        try {
            m.getLastMillisecond((Calendar) null);
        }",Eager Test
"@Test
    public void testGetStart() {
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.ITALY);
        Calendar cal = Calendar.getInstance(Locale.ITALY);
        cal.set(2006, Calendar.MARCH, 1, 0, 0, 0);
        cal.set(Calendar.MILLISECOND, 0);
        Month m = new Month(3, 2006);
        assertEquals(cal.getTime(), m.getStart());
        Locale.setDefault(saved);
    }",Eager Test
"@Test
    public void testJan1900Previous() {
        Month previous = (Month) this.jan1900.previous();
        assertNull(previous);
    }",No Smells
"@Test
    public void testParseMonth() {
        Month month = null;

        // test 1...
        try {
            month = Month.parseMonth(""1990-01"");
        }",Eager Test
"@Test
    public void testConstructor1() {
        OHLCItem item1 = new OHLCItem(new Year(2006), 2.0, 4.0, 1.0, 3.0);
        assertEquals(new Year(2006), item1.getPeriod());
        assertEquals(2.0, item1.getOpenValue(), EPSILON);
        assertEquals(4.0, item1.getHighValue(), EPSILON);
        assertEquals(1.0, item1.getLowValue(), EPSILON);
        assertEquals(3.0, item1.getCloseValue(), EPSILON);
    }",No Smells
"@Test
    public void testSerialization() {
        OHLCItem item1 = new OHLCItem(new Year(2006), 2.0, 4.0, 1.0, 3.0);
        OHLCItem item2 = TestUtils.serialised(item1);
        assertEquals(item1, item2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        OHLCSeriesCollection c1 = new OHLCSeriesCollection();
        OHLCSeries<String> s1 = new OHLCSeries<>(""Series"");
        s1.add(new Year(2006), 1.0, 1.1, 1.2, 1.3);
        c1.addSeries(s1);
        OHLCSeriesCollection c2 = CloneUtils.clone(c1);
        assertNotSame(c1, c2);
        assertSame(c1.getClass(), c2.getClass());
        assertEquals(c1, c2);

        // check independence
        c1.setXPosition(TimePeriodAnchor.END);
        assertNotEquals(c1, c2);
    }",Eager Test
"@Test
    public void testSerialization() {
        OHLCSeriesCollection c1 = new OHLCSeriesCollection();
        OHLCSeries<String> s1 = new OHLCSeries<>(""Series"");
        s1.add(new Year(2006), 1.0, 1.1, 1.2, 1.3);
        c1.addSeries(s1);
        OHLCSeriesCollection c2 = TestUtils.serialised(c1);
        assertEquals(c1, c2);
    }",Eager Test
"@Test
    public void testSerialization() {
        OHLCSeries<String> s1 = new OHLCSeries<>(""s1"");
        s1.add(new Year(2006), 2.0, 4.0, 1.0, 3.0);
        OHLCSeries<String> s2 = TestUtils.serialised(s1);
        assertEquals(s1, s2);
    }",No Smells
"@Test
    public void testCloning() {
        OHLC i1 = new OHLC(2.0, 4.0, 1.0, 3.0);
        assertFalse(i1 instanceof Cloneable);
    }",No Smells
"@Test
    public void testEquals() {
        OHLC i1 = new OHLC(2.0, 4.0, 1.0, 3.0);
        OHLC i2 = new OHLC(2.0, 4.0, 1.0, 3.0);
        assertEquals(i1, i2);

        i1 = new OHLC(2.2, 4.0, 1.0, 3.0);
        assertNotEquals(i1, i2);
        i2 = new OHLC(2.2, 4.0, 1.0, 3.0);
        assertEquals(i1, i2);

        i1 = new OHLC(2.2, 4.4, 1.0, 3.0);
        assertNotEquals(i1, i2);
        i2 = new OHLC(2.2, 4.4, 1.0, 3.0);
        assertEquals(i1, i2);

        i1 = new OHLC(2.2, 4.4, 1.1, 3.0);
        assertNotEquals(i1, i2);
        i2 = new OHLC(2.2, 4.4, 1.1, 3.0);
        assertEquals(i1, i2);

        i1 = new OHLC(2.2, 4.4, 1.1, 3.3);
        assertNotEquals(i1, i2);
        i2 = new OHLC(2.2, 4.4, 1.1, 3.3);
        assertEquals(i1, i2);
    }",No Smells
"@Test
    public void testConstructor() {
        boolean pass = false;
        try {
            /*Quarter q =*/ new Quarter(0, 2005);
        }",No Smells
"@Test
    public void testEqualsSelf() {
        Quarter quarter = new Quarter();
        assertEquals(quarter, quarter);
    }",No Smells
"@Test
    public void testGetFirstMillisecond() {
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.UK);
        TimeZone savedZone = TimeZone.getDefault();
        TimeZone.setDefault(TimeZone.getTimeZone(""Europe/London""));
        Quarter q = new Quarter(3, 1970);
        assertEquals(15634800000L, q.getFirstMillisecond());
        Locale.setDefault(saved);
        TimeZone.setDefault(savedZone);
    }",Eager Test
"@Test
    public void testGetLastMillisecond() {
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.UK);
        TimeZone savedZone = TimeZone.getDefault();
        TimeZone.setDefault(TimeZone.getTimeZone(""Europe/London""));
        Quarter q = new Quarter(3, 1970);
        assertEquals(23583599999L, q.getLastMillisecond());
        Locale.setDefault(saved);
        TimeZone.setDefault(savedZone);
    }",Eager Test
"@Test
    public void testGetLastMillisecondWithTimeZone() {
        Quarter q = new Quarter(2, 1950);
        TimeZone zone = TimeZone.getTimeZone(""America/Los_Angeles"");
        Calendar cal = Calendar.getInstance(zone);
        assertEquals(-615488400001L, q.getLastMillisecond(cal));

        // try null calendar
        boolean pass = false;
        try {
            q.getLastMillisecond((Calendar) null);
        }",Eager Test
"@Test
    public void testGetSerialIndex() {
        Quarter q = new Quarter(1, 2000);
        assertEquals(8001L, q.getSerialIndex());
        q = new Quarter(1, 1900);
        assertEquals(7601L, q.getSerialIndex());
    }",No Smells
"@Test
    public void testHashcode() {
        Quarter q1 = new Quarter(2, 2003);
        Quarter q2 = new Quarter(2, 2003);
        assertEquals(q1, q2);
        int h1 = q1.hashCode();
        int h2 = q2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testDateConstructor2() {
        TimeZone zone = TimeZone.getTimeZone(""America/Chicago"");
        Calendar cal = Calendar.getInstance(zone);
        Locale locale = Locale.getDefault();  // locale shouldn't matter here
        Second s1 = new Second(new Date(1016751358999L), zone, locale);
        Second s2 = new Second(new Date(1016751359000L), zone, locale);

        assertEquals(58, s1.getSecond());
        assertEquals(1016751358999L, s1.getLastMillisecond(cal));

        assertEquals(59, s2.getSecond());
        assertEquals(1016751359000L, s2.getFirstMillisecond(cal));
    }",Eager Test
"@Test
    public void testGetLastMillisecond() {
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.UK);
        TimeZone savedZone = TimeZone.getDefault();
        TimeZone.setDefault(TimeZone.getTimeZone(""Europe/London""));
        Second s = new Second(1, 1, 1, 1, 1, 1970);
        assertEquals(61999L, s.getLastMillisecond());
        Locale.setDefault(saved);
        TimeZone.setDefault(savedZone);
    }",Eager Test
"@Test
    public void testNotCloneable() {
        Second s = new Second(13, 45, 5, 1, 2, 2003);
        assertFalse(s instanceof Cloneable);
    }",No Smells
"@Test
    public void testHashcode() {
        SimpleTimePeriod s1 = new SimpleTimePeriod(new Date(10L),
                new Date(20L));
        SimpleTimePeriod s2 = new SimpleTimePeriod(new Date(10L),
                new Date(20L));
        assertEquals(s1, s2);
        int h1 = s1.hashCode();
        int h2 = s2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testImmutable() {
        SimpleTimePeriod p1 = new SimpleTimePeriod(new Date(10L),
                new Date(20L));
        SimpleTimePeriod p2 = new SimpleTimePeriod(new Date(10L),
                new Date(20L));
        assertEquals(p1, p2);
        p1.getStart().setTime(11L);
        assertEquals(p1, p2);

        Date d1 = new Date(10L);
        Date d2 = new Date(20L);
        p1 = new SimpleTimePeriod(d1, d2);
        d1.setTime(11L);
        assertEquals(new Date(10L), p1.getStart());
    }",Eager Test
"@Test 
    public void testGetDomainBoundsWithInterval() {
        // check empty dataset
        TimePeriodValuesCollection dataset = new TimePeriodValuesCollection();
        Range r = dataset.getDomainBounds(true);
        assertNull(r);
        
        // check dataset with one time period
        TimePeriodValues<String> s1 = new TimePeriodValues<>(""S1"");
        s1.add(new SimpleTimePeriod(1000L, 2000L), 1.0);
        dataset.addSeries(s1);
        r = dataset.getDomainBounds(true);
        assertEquals(1000.0, r.getLowerBound(), EPSILON);
        assertEquals(2000.0, r.getUpperBound(), EPSILON);
        
        // check dataset with two time periods
        s1.add(new SimpleTimePeriod(1500L, 3000L), 2.0);
        r = dataset.getDomainBounds(true);
        assertEquals(1000.0, r.getLowerBound(), EPSILON);
        assertEquals(3000.0, r.getUpperBound(), EPSILON);
        
        // add a third time period
        s1.add(new SimpleTimePeriod(6000L, 7000L), 1.5);
        r = dataset.getDomainBounds(true);
        assertEquals(1000.0, r.getLowerBound(), EPSILON);
        assertEquals(7000.0, r.getUpperBound(), EPSILON);

        // add a fourth time period
        s1.add(new SimpleTimePeriod(4000L, 5000L), 1.4);
        r = dataset.getDomainBounds(true);
        assertEquals(1000.0, r.getLowerBound(), EPSILON);
        assertEquals(7000.0, r.getUpperBound(), EPSILON);    
    }",Eager Test
"@Test
    public void testSerialization() {
        TimePeriodValuesCollection c1 = new TimePeriodValuesCollection();
        TimePeriodValuesCollection c2 = TestUtils.serialised(c1);
        assertEquals(c1, c2);
    }",No Smells
"@Test
    public void testEqualsSelf() {
        TimePeriodValue tpv = new TimePeriodValue(new Day(), 55.75);
        assertEquals(tpv, tpv);
    }",No Smells
"@Test
    public void testGetRangeBounds() {
        TimeSeriesCollection<String> dataset = new TimeSeriesCollection<>();
        
        // when the dataset contains no series, we expect the range to be null
        assertNull(dataset.getRangeBounds(false));
        assertNull(dataset.getRangeBounds(true));

        // when the dataset contains one or more series, but those series
        // contain no items, we still expect the range to be null
        TimeSeries<String> s1 = new TimeSeries<>(""S1"");
        dataset.addSeries(s1);
        assertNull(dataset.getRangeBounds(false));
        assertNull(dataset.getRangeBounds(true));

        // tests with values
        s1.add(new Year(2012), 1.0);
        assertEquals(new Range(1.0, 1.0), dataset.getRangeBounds(false));
        assertEquals(new Range(1.0, 1.0), dataset.getRangeBounds(true));
        s1.add(new Year(2013), -1.0);
        assertEquals(new Range(-1.0, 1.0), dataset.getRangeBounds(false));
        assertEquals(new Range(-1.0, 1.0), dataset.getRangeBounds(true));
        s1.add(new Year(2014), null);
        assertEquals(new Range(-1.0, 1.0), dataset.getRangeBounds(false));
        assertEquals(new Range(-1.0, 1.0), dataset.getRangeBounds(true));
        
        // adding a second series
        TimeSeries<String> s2 = new TimeSeries<>(""S2"");
        dataset.addSeries(s2);
        assertEquals(new Range(-1.0, 1.0), dataset.getRangeBounds(false));
        assertEquals(new Range(-1.0, 1.0), dataset.getRangeBounds(true));
        
        s2.add(new Year(2014), 5.0);
        assertEquals(new Range(-1.0, 5.0), dataset.getRangeBounds(false));
        assertEquals(new Range(-1.0, 5.0), dataset.getRangeBounds(true));
        
        dataset.removeAllSeries();
        assertNull(dataset.getRangeBounds(false));
        assertNull(dataset.getRangeBounds(true));
        
        s1 = new TimeSeries<>(""s1"");
        s2 = new TimeSeries<>(""s2"");
        dataset.addSeries(s1);
        dataset.addSeries(s2);
        assertNull(dataset.getRangeBounds(false));
        assertNull(dataset.getRangeBounds(true));
        
        s2.add(new Year(2014), 100.0);
        assertEquals(new Range(100.0, 100.0), dataset.getRangeBounds(false));
        assertEquals(new Range(100.0, 100.0), dataset.getRangeBounds(true));
    }",Eager Test
"@Test
    public void testIndexOf() {
        TimeSeries<String> s1 = new TimeSeries<>(""S1"");
        TimeSeries<String> s2 = new TimeSeries<>(""S2"");
        TimeSeriesCollection<String> dataset = new TimeSeriesCollection<>();
        assertEquals(-1, dataset.indexOf(s1));
        assertEquals(-1, dataset.indexOf(s2));

        dataset.addSeries(s1);
        assertEquals(0, dataset.indexOf(s1));
        assertEquals(-1, dataset.indexOf(s2));

        dataset.addSeries(s2);
        assertEquals(0, dataset.indexOf(s1));
        assertEquals(1, dataset.indexOf(s2));

        dataset.removeSeries(s1);
        assertEquals(-1, dataset.indexOf(s1));
        assertEquals(0, dataset.indexOf(s2));

        TimeSeries<String> s2b = new TimeSeries<>(""S2"");
        assertEquals(0, dataset.indexOf(s2b));
    }",Eager Test
"@Test
    public void testRemoveSeries() {
        TimeSeriesCollection<String> c1 = new TimeSeriesCollection<>();

        TimeSeries<String> s1 = new TimeSeries<>(""Series 1"");
        TimeSeries<String> s2 = new TimeSeries<>(""Series 2"");
        TimeSeries<String> s3 = new TimeSeries<>(""Series 3"");
        TimeSeries<String> s4 = new TimeSeries<>(""Series 4"");

        c1.addSeries(s1);
        c1.addSeries(s2);
        c1.addSeries(s3);
        c1.addSeries(s4);

        c1.removeSeries(s3);

        TimeSeries<String> s = c1.getSeries(2);
        boolean b1 = s.equals(s4);
        assertTrue(b1);
    }",Eager Test
"@Test
    public void testSerialization() {
        var s1 = createSeries();
        TimeSeriesCollection<String> c1 = new TimeSeriesCollection<>(s1);
        TimeSeriesCollection<String> c2 = TestUtils.serialised(c1);
        assertEquals(c1, c2);

        // check independence
        s1.add(new Day(26, 4, 2000), 99.9);
        assertNotEquals(c1, c2);
        var s2 = c2.getSeries(0);
        s2.add(new Day(26, 4, 2000), 99.9);
        assertEquals(c1, c2);

        // check that c2 gets notifications when s2 is changed
        DatasetChangeConfirmation listener = new DatasetChangeConfirmation();
        c2.addChangeListener(listener);
        s2.add(new Day(27, 4, 2000), 99.9);
        assertNotNull(listener.event);
    }",No Smells
"@Test
    public void testSerialization() {
        TimeSeriesDataItem item1 = new TimeSeriesDataItem(new Day(23, 9, 2001), 
                99.7);
        TimeSeriesDataItem item2 = TestUtils.serialised(item1);
        assertEquals(item1, item2);
    }",No Smells
"@Test
    public void testAddValue() {
        this.seriesA.add(new Year(1999), 1);
        int value = this.seriesA.getValue(0).intValue();
        assertEquals(1, value);
    }",No Smells
"@Test
    public void testAddOrUpdate2() {
        TimeSeries<String> s1 = new TimeSeries<>(""S1"");
        s1.setMaximumItemCount(2);
        s1.addOrUpdate(new Year(2010), 1.1);
        s1.addOrUpdate(new Year(2011), 2.2);
        s1.addOrUpdate(new Year(2012), 3.3);
        assertEquals(2, s1.getItemCount());
        assertEquals(2.2, s1.getMinY(), EPSILON);
        assertEquals(3.3, s1.getMaxY(), EPSILON);
    }",No Smells
"@Test
    public void testBug1864222() {
        TimeSeries<String> s = new TimeSeries<>(""S"");
        s.add(new Day(19, 8, 2005), 1);
        s.add(new Day(31, 1, 2006), 1);
        boolean pass = true;
        try {
            s.createCopy(new Day(1, 12, 2005), new Day(18, 1, 2006));
        }",No Smells
"@Test
    public void testClear() {
        TimeSeries<String> s1 = new TimeSeries<>(""S1"");
        s1.add(new Year(2009), 1.1);
        s1.add(new Year(2010), 2.2);

        assertEquals(2, s1.getItemCount());

        s1.clear();
        assertEquals(0, s1.getItemCount());
        assertTrue(Double.isNaN(s1.getMinY()));
        assertTrue(Double.isNaN(s1.getMaxY()));
    }",No Smells
"@Test
    public void testDelete() {
        seriesA.delete(0, 0);
        assertEquals(5, seriesA.getItemCount());
        assertNull(seriesA.getValue(new Year(2000)));
    }",No Smells
"@Test
    public void testDelete3() {
        TimeSeries<String> s1 = new TimeSeries<>(""S1"");
        s1.add(new Year(2011), 1.1);
        s1.add(new Year(2012), 2.2);
        s1.add(new Year(2013), 3.3);
        s1.add(new Year(2014), 4.4);
        s1.add(new Year(2015), 5.5);
        s1.add(new Year(2016), 6.6);
        s1.delete(2, 5);
        assertEquals(2, s1.getItemCount());
        assertEquals(new Year(2011), s1.getTimePeriod(0));
        assertEquals(new Year(2012), s1.getTimePeriod(1));
        assertEquals(1.1, s1.getMinY(), EPSILON);
        assertEquals(2.2, s1.getMaxY(), EPSILON);
    }",No Smells
"@Test
    public void testFindValueRange() {
        TimeSeries<String> ts = new TimeSeries<>(""Time Series"");
        assertNull(ts.findValueRange());
        
        ts.add(new Year(2014), 1.0);
        assertEquals(new Range(1.0, 1.0), ts.findValueRange());
        
        ts.add(new Year(2015), 2.0);
        assertEquals(new Range(1.0, 2.0), ts.findValueRange());

        // null items are ignored
        ts.add(new Year(2016), null);
        assertEquals(new Range(1.0, 2.0), ts.findValueRange());
        
        // Double.NaN values are also ignored
        ts.add(new Year(2017), Double.NaN);
        assertEquals(new Range(1.0, 2.0), ts.findValueRange());
        
        ts.clear();
        assertNull(ts.findValueRange());
        
        // if there are only null items, we get a NaNRange
        ts.add(new Year(2014), null);
        assertTrue(ts.findValueRange().isNaNRange()); 
    }",No Smells
"@Test
    public void testGetValue() {
        assertNull(seriesA.getValue(new Year(1999)));
        assertEquals(102000.0, seriesA.getValue(new Year(2000)));
    }",No Smells
"@Test
    public void testGetTimePeriod()  {
        TimeTableXYDataset d = new TimeTableXYDataset();
        d.add(new Year(1999), 1.0, ""Series 1"");
        d.add(new Year(1998), 2.0, ""Series 1"");
        d.add(new Year(1996), 3.0, ""Series 1"");
        assertEquals(d.getTimePeriod(0), new Year(1996));
        assertEquals(d.getTimePeriod(1), new Year(1998));
        assertEquals(d.getTimePeriod(2), new Year(1999));
    }",No Smells
"@Test
    public void testBug1498805() {
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.UK);
        try {
            TimeZone zone = TimeZone.getTimeZone(""GMT"");
            GregorianCalendar gc = new GregorianCalendar(zone);
            gc.set(2005, Calendar.JANUARY, 1, 12, 0, 0);
            Week w = new Week(gc.getTime(), zone, Locale.UK);
            assertEquals(53, w.getWeek());
            assertEquals(new Year(2004), w.getYear());
        }",Eager Test
"@Test
    public void testGetFirstMillisecondWithCalendar() {
        Week w = new Week(1, 2001);
        GregorianCalendar calendar = new GregorianCalendar(Locale.GERMANY);
        calendar.setTimeZone(TimeZone.getTimeZone(""Europe/Frankfurt""));
        assertEquals(978307200000L, w.getFirstMillisecond(calendar));

        // try null calendar
        boolean pass = false;
        try {
            w.getFirstMillisecond((Calendar) null);
        }",No Smells
"@Test
    public void testGetLastMillisecondWithTimeZone() {
        Week w = new Week(2, 1950);
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.US);
        try {
            TimeZone zone = TimeZone.getTimeZone(""America/Los_Angeles"");
            Calendar cal = Calendar.getInstance(zone);
            assertEquals(-629913600001L, w.getLastMillisecond(cal));
        }",Eager Test
"@Test
    public void testHashcode() {
        Week w1 = new Week(2, 2003);
        Week w2 = new Week(2, 2003);
        assertEquals(w1, w2);
        int h1 = w1.hashCode();
        int h2 = w2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testSerialization() {
        Week w1 = new Week(24, 1999);
        Week w2 = TestUtils.serialised(w1);
        assertEquals(w1, w2);
    }",No Smells
"@Test
    public void test9999Next() {
        Year current = new Year(9999);
        Year next = (Year) current.next();
        assertNull(next);
    }",No Smells
"@Test
    public void test9999Previous() {
        Year current = new Year(9999);
        Year previous = (Year) current.previous();
        assertEquals(9998, previous.getYear());
    }",No Smells
"@Test
    public void testEqualsSelf() {
        Year year = new Year();
        assertEquals(year, year);
    }",No Smells
"@Test
    public void testGetFirstMillisecond() {
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.UK);
        TimeZone savedZone = TimeZone.getDefault();
        TimeZone.setDefault(TimeZone.getTimeZone(""Europe/London""));
        Year y = new Year(1970);
        // TODO: Check this result...
        assertEquals(-3600000L, y.getFirstMillisecond());
        Locale.setDefault(saved);
        TimeZone.setDefault(savedZone);
    }",Eager Test
"@Test
    public void testGetFirstMillisecondWithCalendar() {
        Year y = new Year(2001);
        GregorianCalendar calendar = new GregorianCalendar(Locale.GERMANY);
        calendar.setTimeZone(TimeZone.getTimeZone(""Europe/Frankfurt""));
        assertEquals(978307200000L, y.getFirstMillisecond(calendar));

        // try null calendar
        boolean pass = false;
        try {
            y.getFirstMillisecond((Calendar) null);
        }",Eager Test
"@Test
    public void testGetLastMillisecond() {
        Locale saved = Locale.getDefault();
        Locale.setDefault(Locale.UK);
        TimeZone savedZone = TimeZone.getDefault();
        TimeZone.setDefault(TimeZone.getTimeZone(""Europe/London""));
        Year y = new Year(1970);
        // TODO: Check this result...
        assertEquals(31532399999L, y.getLastMillisecond());
        Locale.setDefault(saved);
        TimeZone.setDefault(savedZone);
    }",Eager Test
"@Test
    public void testAddSeries() {
        CategoryTableXYDataset d1 = new CategoryTableXYDataset();
        d1.setAutoWidth(true);
        d1.add(3.0, 1.1, ""Series 1"");
        d1.add(7.0, 2.2, ""Series 1"");
        assertEquals(3.0, d1.getXValue(0, 0), EPSILON);
        assertEquals(7.0, d1.getXValue(0, 1), EPSILON);
        assertEquals(1.0, d1.getStartXValue(0, 0), EPSILON);
        assertEquals(5.0, d1.getStartXValue(0, 1), EPSILON);
        assertEquals(5.0, d1.getEndXValue(0, 0), EPSILON);
        assertEquals(9.0, d1.getEndXValue(0, 1), EPSILON);

        // now add some more data
        d1.add(7.5, 1.1, ""Series 2"");
        d1.add(9.0, 2.2, ""Series 2"");

        assertEquals(3.0, d1.getXValue(1, 0), EPSILON);
        assertEquals(7.0, d1.getXValue(1, 1), EPSILON);
        assertEquals(7.5, d1.getXValue(1, 2), EPSILON);
        assertEquals(9.0, d1.getXValue(1, 3), EPSILON);

        assertEquals(7.25, d1.getStartXValue(1, 2), EPSILON);
        assertEquals(8.75, d1.getStartXValue(1, 3), EPSILON);
        assertEquals(7.75, d1.getEndXValue(1, 2), EPSILON);
        assertEquals(9.25, d1.getEndXValue(1, 3), EPSILON);

        // and check the first series too...
        assertEquals(2.75, d1.getStartXValue(0, 0), EPSILON);
        assertEquals(6.75, d1.getStartXValue(0, 1), EPSILON);
        assertEquals(3.25, d1.getEndXValue(0, 0), EPSILON);
        assertEquals(7.25, d1.getEndXValue(0, 1), EPSILON);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        CategoryTableXYDataset d1 = new CategoryTableXYDataset();
        d1.add(1.0, 1.1, ""Series 1"");
        d1.add(2.0, 2.2, ""Series 1"");

        CategoryTableXYDataset d2 = CloneUtils.clone(d1);
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);

        d1.add(3.0, 3.3, ""Series 1"");
        assertNotEquals(d1, d2);
        d2.add(3.0, 3.3, ""Series 1"");
        assertEquals(d1, d2);

        d1.setIntervalPositionFactor(0.33);
        assertNotEquals(d1, d2);
        d2.setIntervalPositionFactor(0.33);
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testEquals() {
        DefaultHighLowDataset d1 = new DefaultHighLowDataset(""Series 1"",
                new Date[0], new double[0], new double[0], new double[0],
                new double[0], new double[0]);
        DefaultHighLowDataset d2 = new DefaultHighLowDataset(""Series 1"",
                new Date[0], new double[0], new double[0], new double[0],
                new double[0], new double[0]);
        assertEquals(d1, d2);
        assertEquals(d2, d1);

        d1 = new DefaultHighLowDataset(""Series 2"",
                new Date[0], new double[0], new double[0], new double[0],
                new double[0], new double[0]);
        assertNotEquals(d1, d2);
        d2 = new DefaultHighLowDataset(""Series 2"",
                new Date[0], new double[0], new double[0], new double[0],
                new double[0], new double[0]);
        assertEquals(d1, d2);

        d1 = new DefaultHighLowDataset(""Series 2"",
                new Date[] {new Date(123L)}",Eager Test
"@Test
    public void testPublicCloneable() {
        DefaultHighLowDataset d1 = new DefaultHighLowDataset(""Series 1"",
                new Date[0], new double[0], new double[0], new double[0],
                new double[0], new double[0]);
        assertTrue(d1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testEquals() {
        DefaultIntervalXYDataset<String> d1 = new DefaultIntervalXYDataset<>();
        DefaultIntervalXYDataset<String> d2 = new DefaultIntervalXYDataset<>();
        assertEquals(d1, d2);
        assertEquals(d2, d1);

        d1 = createSampleDataset1();
        assertNotEquals(d1, d2);
        d2 = createSampleDataset1();
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testGetEndYValue() {
        DefaultIntervalXYDataset<String> d = createSampleDataset1();
        assertEquals(1.11, d.getEndYValue(0, 0), EPSILON);
        assertEquals(2.11, d.getEndYValue(0, 1), EPSILON);
        assertEquals(3.11, d.getEndYValue(0, 2), EPSILON);
        assertEquals(11.11, d.getEndYValue(1, 0), EPSILON);
        assertEquals(12.11, d.getEndYValue(1, 1), EPSILON);
        assertEquals(13.11, d.getEndYValue(1, 2), EPSILON);
    }",No Smells
"@Test
    public void testGetStartXValue() {
        DefaultIntervalXYDataset<String> d = createSampleDataset1();
        assertEquals(0.9, d.getStartXValue(0, 0), EPSILON);
        assertEquals(1.9, d.getStartXValue(0, 1), EPSILON);
        assertEquals(2.9, d.getStartXValue(0, 2), EPSILON);
        assertEquals(10.9, d.getStartXValue(1, 0), EPSILON);
        assertEquals(11.9, d.getStartXValue(1, 1), EPSILON);
        assertEquals(12.9, d.getStartXValue(1, 2), EPSILON);
    }",No Smells
"@Test
    public void testGetXValue() {
        DefaultIntervalXYDataset<String> d = createSampleDataset1();
        assertEquals(1.0, d.getXValue(0, 0), EPSILON);
        assertEquals(2.0, d.getXValue(0, 1), EPSILON);
        assertEquals(3.0, d.getXValue(0, 2), EPSILON);
        assertEquals(11.0, d.getXValue(1, 0), EPSILON);
        assertEquals(12.0, d.getXValue(1, 1), EPSILON);
        assertEquals(13.0, d.getXValue(1, 2), EPSILON);
    }",No Smells
"@Test
    public void testIndexOf() {
        DefaultIntervalXYDataset<String> d = createSampleDataset1();
        assertEquals(0, d.indexOf(""S1""));
        assertEquals(1, d.indexOf(""S2""));
        assertEquals(-1, d.indexOf(""Green Eggs and Ham""));
        assertEquals(-1, d.indexOf(null));
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        DefaultOHLCDataset d1 = new DefaultOHLCDataset(""Series 1"",
                new OHLCDataItem[0]);
        DefaultOHLCDataset d2 = (DefaultOHLCDataset) d1.clone();
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testDataRange() {
        OHLCDataItem[] data = new OHLCDataItem[3];
        data[0] = new OHLCDataItem(new Date(11L), 2.0, 4.0, 1.0, 3.0, 100.0);
        data[1] = new OHLCDataItem(new Date(22L), 4.0, 9.0, 2.0, 5.0, 120.0);
        data[2] = new OHLCDataItem(new Date(33L), 3.0, 7.0, 3.0, 6.0, 140.0);
        DefaultOHLCDataset d = new DefaultOHLCDataset(""S1"", data);
        Range r = DatasetUtils.findRangeBounds(d, true);
        assertEquals(1.0, r.getLowerBound(), EPSILON);
        assertEquals(9.0, r.getUpperBound(), EPSILON);
    }",No Smells
"@Test
    public void testEquals() {
        DefaultTableXYDataset<String> d1 = new DefaultTableXYDataset<>();
        XYSeries<String> s1 = new XYSeries<>(""Series 1"", true, false);
        s1.add(1.0, 1.1);
        s1.add(2.0, 2.2);
        d1.addSeries(s1);

        DefaultTableXYDataset<String> d2 = new DefaultTableXYDataset<>();
        XYSeries<String> s2 = new XYSeries<>(""Series 1"", true, false);
        s2.add(1.0, 1.1);
        s2.add(2.0, 2.2);
        d2.addSeries(s2);

        assertEquals(d1, d2);
        assertEquals(d2, d1);

        s1.add(3.0, 3.3);
        assertNotEquals(d1, d2);

        s2.add(3.0, 3.3);
        assertEquals(d1, d2);
    }",Eager Test
"@Test
    public void testEquals() {
        DefaultWindDataset d1 = new DefaultWindDataset();
        DefaultWindDataset d2 = new DefaultWindDataset();
        assertEquals(d1, d2);
        assertEquals(d2, d1);

        d1 = createSampleDataset1();
        assertNotEquals(d1, d2);
        d2 = createSampleDataset1();
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testIndexOf() {
        DefaultWindDataset d = createSampleDataset1();
        assertEquals(0, d.indexOf(""Series 1""));
        assertEquals(1, d.indexOf(""Series 2""));
        assertEquals(-1, d.indexOf(""Green Eggs and Ham""));
        assertEquals(-1, d.indexOf(null));
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        DefaultXYDataset<String> d1 = new DefaultXYDataset<>();
        DefaultXYDataset<String> d2 = CloneUtils.clone(d1);
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);

        // try a dataset with some content...
        double[] x1 = new double[] {1.0, 2.0, 3.0}",Eager Test
"@Test
    public void testSerialization() {
        DefaultXYDataset<String> d1 = new DefaultXYDataset<>();
        DefaultXYDataset<String> d2 = TestUtils.serialised(d1);
        assertEquals(d1, d2);

        // try a dataset with some content...
        double[] x1 = new double[] {1.0, 2.0, 3.0}",Eager Test
"@Test
    public void testPublicCloneable() {
        DefaultXYZDataset<String> d1 = new DefaultXYZDataset<>();
        assertTrue(d1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testSerialization() {
        XYSeries<String> s1 = new XYSeries<>(""Series"");
        s1.add(1.2, 3.4);
        XYSeriesCollection<String> c1 = new XYSeriesCollection<>();
        c1.addSeries(s1);
        IntervalXYDelegate d1 = new IntervalXYDelegate(c1);
        IntervalXYDelegate d2 = TestUtils.serialised(d1);
        assertEquals(d1, d2);
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        MatrixSeries<String> s1 = new MatrixSeries<>(""Series"", 2, 3);
        s1.update(0, 0, 1.1);
        MatrixSeriesCollection<String> c1 = new MatrixSeriesCollection<>();
        c1.addSeries(s1);
        MatrixSeriesCollection<String> c2 = CloneUtils.clone(c1);

        assertNotSame(c1, c2);
        assertSame(c1.getClass(), c2.getClass());
        assertEquals(c1, c2);

        // check independence
        c2.removeAllSeries();
        assertNotEquals(c1, c2);
    }",Eager Test
"@Test
    public void testPublicCloneable() {
        MatrixSeriesCollection<String> c1 = new MatrixSeriesCollection<>();
        assertTrue(c1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testSerialization() {
        MatrixSeries<String> s1 = new MatrixSeries<>(""Series"", 2, 3);
        s1.update(0, 0, 1.1);
        MatrixSeriesCollection<String> c1 = new MatrixSeriesCollection<>();
        c1.addSeries(s1);
        MatrixSeriesCollection<String> c2 = TestUtils.serialised(c1);
        assertEquals(c1, c2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        MatrixSeries<String> m1 = new MatrixSeries<>(""Test"", 8, 3);
        m1.update(0, 0, 11.0);
        m1.update(7, 2, 22.0);
        MatrixSeries<String> m2 = CloneUtils.clone(m1);
        assertNotSame(m1, m2);
        assertSame(m1.getClass(), m2.getClass());
        assertEquals(m1, m2);
    }",Eager Test
"@Test
    public void testGetItemColumn() {
        MatrixSeries<String> m = new MatrixSeries<>(""Test"", 3, 2);
        assertEquals(0, m.getItemColumn(0));
        assertEquals(1, m.getItemColumn(1));
        assertEquals(0, m.getItemColumn(2));
        assertEquals(1, m.getItemColumn(3));
        assertEquals(0, m.getItemColumn(4));
        assertEquals(1, m.getItemColumn(5));
    }",No Smells
"@Test
    public void testSerialization() {
        MatrixSeries<String> m1 = new MatrixSeries<>(""Test"", 8, 3);
        m1.update(0, 0, 11.0);
        m1.update(7, 2, 22.0);
        MatrixSeries<String> m2 = TestUtils.serialised(m1);
        assertEquals(m1, m2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        DefaultTableXYDataset<String> d1 = new DefaultTableXYDataset<>();
        d1.addSeries(createSeries1());
        DefaultTableXYDataset<String> d2 = CloneUtils.clone(d1);
        assertNotSame(d1, d2);
        assertSame(d1.getClass(), d2.getClass());
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testEquals() {
        DefaultTableXYDataset<String> d1 = new DefaultTableXYDataset<>();
        DefaultTableXYDataset<String> d2 = new DefaultTableXYDataset<>();
        assertEquals(d1, d2);
        assertEquals(d2, d1);

        d1.addSeries(createSeries1());
        assertNotEquals(d1, d2);

        d2.addSeries(createSeries1());
        assertEquals(d1, d2);
    }",No Smells
"@Test
    public void testPrune() {
        DefaultTableXYDataset<String> dataset = new DefaultTableXYDataset<>();
        dataset.addSeries(createSeries1());
        dataset.addSeries(createSeries2());
        dataset.removeSeries(1);
        dataset.prune();
        assertEquals(4, dataset.getItemCount());
    }",No Smells
"@Test
    public void testTableXYDataset() {
        XYSeries<String> series1 = createSeries1();
        XYSeries<String> series2 = createSeries2();

        DefaultTableXYDataset<String> dataset = new DefaultTableXYDataset<>();
        dataset.addSeries(series1);
        dataset.addSeries(series2);

        //  Test that there are 6 X points and some specific values
        assertEquals(6, dataset.getItemCount());
        assertEquals(6, dataset.getX(0, 5).intValue());
        assertNull(dataset.getY(0, 5));
        assertEquals(6, dataset.getX(1, 5).intValue());
        assertEquals(2, dataset.getY(1, 5).intValue());

        // after adding a point to a series, check that there are now 7
        // items in each series
        series2.add(7, 2);
        assertEquals(7, dataset.getItemCount());
        assertNull(dataset.getY(0, 6));
        assertEquals(2, dataset.getY(1, 6).intValue());

        //  Remove series 1
        dataset.removeSeries(series1);
        //  Test that there are still 7 X points
        assertEquals(7, dataset.getItemCount());

        //  Remove series 2 and add new series
        dataset.removeSeries(series2);
        series1 = createSeries1();
        dataset.addSeries(series1);

        //  Test that there are now 4 X points
        assertEquals(4, dataset.getItemCount());
    }",Eager Test
"@Test
    public void testCloning() throws CloneNotSupportedException {
        VectorDataItem v1 = new VectorDataItem(1.0, 2.0, 3.0, 4.0);
        VectorDataItem v2 = CloneUtils.clone(v1);
        assertNotSame(v1, v2);
        assertSame(v1.getClass(), v2.getClass());
        assertEquals(v1, v2);
    }",No Smells
"@Test
    public void testSerialization() {
        VectorDataItem v1 = new VectorDataItem(1.0, 2.0, 3.0, 4.0);
        VectorDataItem v2 = TestUtils.serialised(v1);
        assertEquals(v1, v2);
    }",No Smells
"@Test
    public void testIndexOf() {
        VectorSeries<String> s1 = new VectorSeries<>(""Series 1"");
        s1.add(1.0, 1.0, 1.0, 2.0);
        s1.add(2.0, 2.0, 2.0, 3.0);
        s1.add(3.0, 3.0, 3.0, 4.0);
        assertEquals(0, s1.indexOf(new XYCoordinate(1.0, 1.0)));
    }",No Smells
"@Test
    public void testRemove() {
        VectorSeries<String> s1 = new VectorSeries<>(""Series 1"");
        s1.add(1.0, 1.0, 1.0, 2.0);
        s1.add(3.0, 3.0, 3.0, 3.0);
        s1.add(2.0, 2.0, 2.0, 2.0);
        assertEquals(3, s1.getItemCount());

        s1.remove(new XYCoordinate(2.0, 2.0));
        assertEquals(3.0, s1.getXValue(1), EPSILON);

        s1.remove(new XYCoordinate(1.0, 1.0));
        assertEquals(3.0, s1.getXValue(0), EPSILON);
    }",No Smells
"@Test
    public void testSerialization() {
        VectorSeries<String> s1 = new VectorSeries<>(""s1"");
        s1.add(1.0, 0.5, 1.5, 2.0);
        VectorSeries<String> s2 = TestUtils.serialised(s1);
        assertEquals(s1, s2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        XIntervalDataItem item1 = new XIntervalDataItem(1.0, 2.0, 3.0, 4.0);
        XIntervalDataItem item2 = CloneUtils.clone(item1);
        assertNotSame(item1, item2);
        assertSame(item1.getClass(), item2.getClass());
        assertEquals(item1, item2);
    }",No Smells
"@Test
    public void testSerialization() {
        XIntervalDataItem item1 = new XIntervalDataItem(1.0, 2.0, 3.0, 4.0);
        XIntervalDataItem item2 = TestUtils.serialised(item1);
        assertEquals(item1, item2);
    }",No Smells
"@Test
    public void testIndexOf() {
        XIntervalSeries<String> s1 = new XIntervalSeries<>(""Series 1"");
        s1.add(1.0, 1.0, 1.0, 2.0);
        s1.add(2.0, 2.0, 2.0, 3.0);
        s1.add(3.0, 3.0, 3.0, 4.0);
        assertEquals(0, s1.indexOf(1.0));
    }",No Smells
"@Test
    public void testSerialization()  {
        XIntervalSeries<String> s1 = new XIntervalSeries<>(""s1"");
        s1.add(1.0, 0.5, 1.5, 2.0);
        XIntervalSeries<String> s2 = TestUtils.serialised(s1);
        assertEquals(s1, s2);
    }",No Smells
"@Test
    public void testEquals() {
        DefaultXYDataset<String> d1 = new DefaultXYDataset<>();
        double[] x1 = new double[] {1.0, 2.0, 3.0}",Eager Test
"@Test
    public void testHashcode() {
        XYCoordinate v1 = new XYCoordinate(1.0, 2.0);
        XYCoordinate v2 = new XYCoordinate(1.0, 2.0);
        assertEquals(v1, v2);
        int h1 = v1.hashCode();
        int h2 = v2.hashCode();
        assertEquals(h1, h2);
    }",Eager Test
"@Test
    public void testSerialization() {
        XYDataItem i1 = new XYDataItem(1.0, 1.1);
        XYDataItem i2 = TestUtils.serialised(i1);
        assertEquals(i1, i2);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        XYIntervalDataItem item1 = new XYIntervalDataItem(1.0, 0.5, 1.5, 2.0,
                1.9, 2.1);
        XYIntervalDataItem item2 = CloneUtils.clone(item1);
        assertNotSame(item1, item2);
        assertSame(item1.getClass(), item2.getClass());
        assertEquals(item1, item2);
    }",No Smells
"@Test
    public void testConstructor1() {
        XYIntervalDataItem item1 = new XYIntervalDataItem(1.0, 0.5, 1.5, 2.0,
                1.9, 2.1);
        assertEquals(Double.valueOf(1.0), item1.getX());
        assertEquals(0.5, item1.getXLowValue(), EPSILON);
        assertEquals(1.5, item1.getXHighValue(), EPSILON);
        assertEquals(2.0, item1.getYValue(), EPSILON);
        assertEquals(1.9, item1.getYLowValue(), EPSILON);
        assertEquals(2.1, item1.getYHighValue(), EPSILON);
    }",No Smells
"@Test
    public void testEquals() {
        XYIntervalDataItem item1 = new XYIntervalDataItem(1.0, 0.5, 1.5, 2.0,
                1.9, 2.1);
        XYIntervalDataItem item2 = new XYIntervalDataItem(1.0, 0.5, 1.5, 2.0,
                1.9, 2.1);
        assertEquals(item1, item2);
        assertEquals(item2, item1);

        // x
        item1 = new XYIntervalDataItem(1.1, 0.5, 1.5, 2.0, 1.9, 2.1);
        assertNotEquals(item1, item2);
        item2 = new XYIntervalDataItem(1.1, 0.5, 1.5, 2.0, 1.9, 2.1);
        assertEquals(item1, item2);

        // xLow
        item1 = new XYIntervalDataItem(1.1, 0.55, 1.5, 2.0, 1.9, 2.1);
        assertNotEquals(item1, item2);
        item2 = new XYIntervalDataItem(1.1, 0.55, 1.5, 2.0, 1.9, 2.1);
        assertEquals(item1, item2);

        // xHigh
        item1 = new XYIntervalDataItem(1.1, 0.55, 1.55, 2.0, 1.9, 2.1);
        assertNotEquals(item1, item2);
        item2 = new XYIntervalDataItem(1.1, 0.55, 1.55, 2.0, 1.9, 2.1);
        assertEquals(item1, item2);

        // y
        item1 = new XYIntervalDataItem(1.1, 0.55, 1.55, 2.2, 1.9, 2.1);
        assertNotEquals(item1, item2);
        item2 = new XYIntervalDataItem(1.1, 0.55, 1.55, 2.2, 1.9, 2.1);
        assertEquals(item1, item2);

        // yLow
        item1 = new XYIntervalDataItem(1.1, 0.55, 1.55, 2.2, 1.99, 2.1);
        assertNotEquals(item1, item2);
        item2 = new XYIntervalDataItem(1.1, 0.55, 1.55, 2.2, 1.99, 2.1);
        assertEquals(item1, item2);

        // yHigh
        item1 = new XYIntervalDataItem(1.1, 0.55, 1.55, 2.2, 1.99, 2.11);
        assertNotEquals(item1, item2);
        item2 = new XYIntervalDataItem(1.1, 0.55, 1.55, 2.2, 1.99, 2.11);
        assertEquals(item1, item2);
    }",Eager Test
"@Test
    public void testSerialization() {
        XYIntervalDataItem item1 = new XYIntervalDataItem(1.0, 0.5, 1.5, 2.0,
                1.9, 2.1);
        XYIntervalDataItem item2 = TestUtils.serialised(item1);
        assertEquals(item1, item2);
    }",No Smells
"@Test
    public void test1170825() {
        XYIntervalSeries<String> s1 = new XYIntervalSeries<>(""Series1"");
        XYIntervalSeriesCollection<String> dataset = new XYIntervalSeriesCollection<>();
        dataset.addSeries(s1);
        try {
            /* XYSeries s = */ dataset.getSeries(1);
        }",Eager Test
"@Test
    public void testPublicCloneable() {
        XYIntervalSeriesCollection<String> c1 = new XYIntervalSeriesCollection<>();
        assertTrue(c1 instanceof PublicCloneable);
    }",No Smells
"@Test
    public void testAdditionOfDuplicateXValues() {
        XYIntervalSeries<String> s1 = new XYIntervalSeries<>(""Series 1"");
        s1.add(1.0, 1.0, 1.0, 1.0, 1.0, 1.0);
        s1.add(2.0, 2.0, 2.0, 2.0, 2.0, 2.0);
        s1.add(2.0, 3.0, 3.0, 3.0, 3.0, 3.0);
        s1.add(2.0, 4.0, 4.0, 4.0, 4.0, 4.0);
        s1.add(3.0, 5.0, 5.0, 5.0, 5.0, 5.0);
        assertEquals(1.0, s1.getYValue(0), EPSILON);
        assertEquals(2.0, s1.getYValue(1), EPSILON);
        assertEquals(3.0, s1.getYValue(2), EPSILON);
        assertEquals(4.0, s1.getYValue(3), EPSILON);
        assertEquals(5.0, s1.getYValue(4), EPSILON);
    }",No Smells
"@Test
    public void testCloning() {
        XYInterval i1 = new XYInterval(1.0, 2.0, 3.0, 2.5, 3.5);
        assertFalse(i1 instanceof Cloneable);
    }",No Smells
"@Test
    public void testAddSeries() {
        XYSeriesCollection<String> c = new XYSeriesCollection<>();
        XYSeries<String> s1 = new XYSeries<>(""s1"");
        c.addSeries(s1);

        // the dataset should prevent the addition of a series with the
        // same name as an existing series in the dataset
        XYSeries<String> s2 = new XYSeries<>(""s1"");
        try {
            c.addSeries(s2);
            fail(""Should have thrown IllegalArgumentException on duplicate key"");
        }",Eager Test
"@Test
    public void testGetRangeUpperBound() {
        XYSeriesCollection<String> dataset = new XYSeriesCollection<>();
        
        // when the dataset contains no series, we expect the value range to 
        // be null
        assertTrue(Double.isNaN(dataset.getRangeUpperBound(false)));
        assertTrue(Double.isNaN(dataset.getRangeUpperBound(true)));

        // when the dataset contains one or more series, but those series 
        // contain no items, we expect the value range to be null
        XYSeries<String> series = new XYSeries<>(""S1"");
        dataset.addSeries(series);
        assertTrue(Double.isNaN(dataset.getRangeUpperBound(false)));
        assertTrue(Double.isNaN(dataset.getRangeUpperBound(true)));

        // tests with values
        series.add(1.0, 1.1);
        assertEquals(1.1, dataset.getRangeUpperBound(false), EPSILON);
        assertEquals(1.1, dataset.getRangeUpperBound(true), EPSILON);

        series.add(-1.0, -1.1);
        assertEquals(1.1, dataset.getRangeUpperBound(false), EPSILON);
        assertEquals(1.1, dataset.getRangeUpperBound(true), EPSILON);
        
        series.add(0.0, null);
        assertEquals(1.1, dataset.getRangeUpperBound(false), EPSILON);
        assertEquals(1.1, dataset.getRangeUpperBound(true), EPSILON);
        
        XYSeries<String> s2 = new XYSeries<>(""S2"");
        dataset.addSeries(s2);
        assertEquals(1.1, dataset.getRangeUpperBound(false), EPSILON);
        assertEquals(1.1, dataset.getRangeUpperBound(true), EPSILON);
        
        s2.add(2.0, 5.0);
        assertEquals(5.0, dataset.getRangeUpperBound(false), EPSILON);
        assertEquals(5.0, dataset.getRangeUpperBound(true), EPSILON);
    }",Eager Test
"@Test
    public void testGetSeries() {
        XYSeriesCollection<String> c = new XYSeriesCollection<>();
        XYSeries<String> s1 = new XYSeries<>(""s1"");
        c.addSeries(s1);
        assertEquals(""s1"", c.getSeries(0).getKey());

        try {
            c.getSeries(-1);
            fail(""Should have thrown IndexOutOfBoundsException on negative key"");
        }",Eager Test
"@Test
    public void testAddOrUpdate() {
        XYSeries<String> series = new XYSeries<>(""S1"", true, false);
        XYDataItem old = series.addOrUpdate(Long.valueOf(1L), Long.valueOf(2L));
        assertNull(old);
        assertEquals(1, series.getItemCount());
        assertEquals(2L, series.getY(0));

        old = series.addOrUpdate(Long.valueOf(2L), Long.valueOf(3L));
        assertNull(old);
        assertEquals(2, series.getItemCount());
        assertEquals(3L, series.getY(1));

        old = series.addOrUpdate(Long.valueOf(1L), Long.valueOf(99L));
        assertEquals(new XYDataItem(Long.valueOf(1L), Long.valueOf(2L)), old);
        assertEquals(2, series.getItemCount());
        assertEquals(99L, series.getY(0));
        assertEquals(3L, series.getY(1));
    }",No Smells
"@Test
    public void testGetMaxY() {
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        assertTrue(Double.isNaN(s1.getMaxY()));

        s1.add(1.0, 1.1);
        assertEquals(1.1, s1.getMaxY(), EPSILON);

        s1.add(2.0, 2.2);
        assertEquals(2.2, s1.getMaxY(), EPSILON);

        s1.add(Double.NaN, 99.9);
        assertEquals(99.9, s1.getMaxY(), EPSILON);

        s1.add(-1.0, -1.1);
        assertEquals(99.9, s1.getMaxY(), EPSILON);

        s1.add(0.0, null);
        assertEquals(99.9, s1.getMaxY(), EPSILON);
    }",No Smells
"@Test
    public void testGetMaxY2() {
        XYSeries<Integer> series = new XYSeries<>(1, true, false);
        series.addOrUpdate(1, 20);
        series.addOrUpdate(2, 30);
        series.addOrUpdate(3, 40);
        assertEquals(40.0, series.getMaxY(), EPSILON);
        series.addOrUpdate(2, 22);
        assertEquals(40.0, series.getMaxY(), EPSILON);        
    }",No Smells
"@Test
    public void testGetMinX() {
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        assertTrue(Double.isNaN(s1.getMinX()));

        s1.add(1.0, 1.1);
        assertEquals(1.0, s1.getMinX(), EPSILON);

        s1.add(2.0, 2.2);
        assertEquals(1.0, s1.getMinX(), EPSILON);

        s1.add(Double.NaN, 99.9);
        assertEquals(1.0, s1.getMinX(), EPSILON);

        s1.add(-1.0, -1.1);
        assertEquals(-1.0, s1.getMinX(), EPSILON);

        s1.add(0.0, null);
        assertEquals(-1.0, s1.getMinX(), EPSILON);
    }",No Smells
"@Test
    public void testHashCode() {
        XYSeries<String> s1 = new XYSeries<>(""Test"");
        XYSeries<String> s2 = new XYSeries<>(""Test"");
        assertEquals(s1, s2);
        assertEquals(s1.hashCode(), s2.hashCode());

        s1.add(1.0, 500.0);
        s2.add(1.0, 500.0);
        assertEquals(s1, s2);
        assertEquals(s1.hashCode(), s2.hashCode());

        s1.add(2.0, null);
        s2.add(2.0, null);
        assertEquals(s1, s2);
        assertEquals(s1.hashCode(), s2.hashCode());

        s1.add(5.0, 111.0);
        s2.add(5.0, 111.0);
        assertEquals(s1, s2);
        assertEquals(s1.hashCode(), s2.hashCode());

        s1.add(9.0, 1.0);
        s2.add(9.0, 1.0);
        assertEquals(s1, s2);
        assertEquals(s1.hashCode(), s2.hashCode());
    }",No Smells
"@Test
    public void testIndexOf() {
        XYSeries<String> s1 = new XYSeries<>(""Series 1"");
        s1.add(1.0, 1.0);
        s1.add(2.0, 2.0);
        s1.add(3.0, 3.0);
        assertEquals(0, s1.indexOf(1.0));
        assertEquals(1, s1.indexOf(2.0));
        assertEquals(2, s1.indexOf(3.0));
        assertEquals(-4, s1.indexOf(99.9));
    }",No Smells
"@Test
    public void testRemove2() {
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        s1.add(1.0, 1.1);
        s1.add(2.0, 2.2);
        s1.add(3.0, 3.3);
        s1.add(4.0, 4.4);
        s1.add(5.0, 5.5);
        s1.add(6.0, 6.6);
        assertEquals(6, s1.getItemCount());
        assertEquals(1.0, s1.getMinX(), EPSILON);
        assertEquals(6.0, s1.getMaxX(), EPSILON);
        assertEquals(1.1, s1.getMinY(), EPSILON);
        assertEquals(6.6, s1.getMaxY(), EPSILON);

        s1.remove(5);
        assertEquals(5, s1.getItemCount());
        assertEquals(1.0, s1.getMinX(), EPSILON);
        assertEquals(5.0, s1.getMaxX(), EPSILON);
        assertEquals(1.1, s1.getMinY(), EPSILON);
        assertEquals(5.5, s1.getMaxY(), EPSILON);
    }",No Smells
"@Test
    public void testSetMaximumItemCount() {
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        assertEquals(Integer.MAX_VALUE, s1.getMaximumItemCount());
        s1.setMaximumItemCount(2);
        assertEquals(2, s1.getMaximumItemCount());
        s1.add(1.0, 1.1);
        s1.add(2.0, 2.2);
        s1.add(3.0, 3.3);
        assertEquals(2.0, s1.getX(0).doubleValue(), EPSILON);
        assertEquals(3.0, s1.getX(1).doubleValue(), EPSILON);
    }",No Smells
"@Test
    public void testSetMaximumItemCount2() {
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        s1.add(1.0, 1.1);
        s1.add(2.0, 2.2);
        s1.add(3.0, 3.3);
        s1.setMaximumItemCount(2);
        assertEquals(2.0, s1.getX(0).doubleValue(), EPSILON);
        assertEquals(3.0, s1.getX(1).doubleValue(), EPSILON);
    }",No Smells
"@Test
    public void testSetMaximumItemCount3() {
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        s1.add(1.0, 1.1);
        s1.add(2.0, 2.2);
        s1.add(3.0, 3.3);
        s1.add(4.0, 4.4);
        s1.add(5.0, 5.5);
        s1.add(6.0, 6.6);
        s1.setMaximumItemCount(2);
        assertEquals(5.0, s1.getX(0).doubleValue(), EPSILON);
        assertEquals(6.0, s1.getX(1).doubleValue(), EPSILON);
        assertEquals(5.0, s1.getMinX(), EPSILON);
        assertEquals(6.0, s1.getMaxX(), EPSILON);
        assertEquals(5.5, s1.getMinY(), EPSILON);
        assertEquals(6.6, s1.getMaxY(), EPSILON);
    }",No Smells
"@Test
    public void testUpdate() {
        XYSeries<String> series = new XYSeries<>(""S1"");
        series.add(1, Integer.valueOf(2));
        assertEquals(2, series.getY(0));
        series.update(1, 3);
        assertEquals(3, series.getY(0));
        try {
            series.update(2, 99);
            fail();
        }",No Smells
"@Test
    public void testUpdateXY() {
        XYSeries<String> s1 = new XYSeries<>(""S1"");
        s1.add(1.0, Double.NaN);

        assertTrue(Double.isNaN(s1.getMinY()));
        assertTrue(Double.isNaN(s1.getMaxY()));

        s1.update(1.0, 1.0);
        assertEquals(1.0, s1.getMinY(), EPSILON);
        assertEquals(1.0, s1.getMaxY(), EPSILON);

        s1.update(1.0, 2.0);
        assertEquals(2.0, s1.getMinY(), EPSILON);
        assertEquals(2.0, s1.getMaxY(), EPSILON);
    }",No Smells
"@Test
    public void test1170825() {
        YIntervalSeries<String> s1 = new YIntervalSeries<>(""Series1"");
        YIntervalSeriesCollection<String> dataset = new YIntervalSeriesCollection<>();
        dataset.addSeries(s1);
        try {
            /* XYSeries s = */ dataset.getSeries(1);
        }",No Smells
"@Test
    public void testAdditionOfDuplicateXValues() {
        YIntervalSeries<String> s1 = new YIntervalSeries<>(""Series 1"");
        s1.add(1.0, 1.0, 1.0, 1.0);
        s1.add(2.0, 2.0, 2.0, 2.0);
        s1.add(2.0, 3.0, 3.0, 3.0);
        s1.add(2.0, 4.0, 4.0, 4.0);
        s1.add(3.0, 5.0, 5.0, 5.0);
        assertEquals(1.0, s1.getYValue(0), EPSILON);
        assertEquals(2.0, s1.getYValue(1), EPSILON);
        assertEquals(3.0, s1.getYValue(2), EPSILON);
        assertEquals(4.0, s1.getYValue(3), EPSILON);
        assertEquals(5.0, s1.getYValue(4), EPSILON);
    }",No Smells
"@Test
    public void testCloning() throws CloneNotSupportedException {
        YIntervalSeries<String> s1 = new YIntervalSeries<>(""s1"");
        s1.add(1.0, 0.5, 1.5, 2.0);
        YIntervalSeries<String> s2 = CloneUtils.clone(s1);
        assertNotSame(s1, s2);
        assertSame(s1.getClass(), s2.getClass());
        assertEquals(s1, s2);
    }",No Smells
"@Test
    public void testCloning() {
        YInterval i1 = new YInterval(1.0, 0.5, 1.5);
        assertFalse(i1 instanceof Cloneable);
    }",No Smells
"@Test
    public void testEquals() {
        YInterval i1 = new YInterval(1.0, 0.5, 1.5);
        YInterval i2 = new YInterval(1.0, 0.5, 1.5);
        assertEquals(i1, i2);

        i1 = new YInterval(1.1, 0.5, 1.5);
        assertNotEquals(i1, i2);
        i2 = new YInterval(1.1, 0.5, 1.5);
        assertEquals(i1, i2);

        i1 = new YInterval(1.1, 0.55, 1.5);
        assertNotEquals(i1, i2);
        i2 = new YInterval(1.1, 0.55, 1.5);
        assertEquals(i1, i2);

        i1 = new YInterval(1.1, 0.55, 1.55);
        assertNotEquals(i1, i2);
        i2 = new YInterval(1.1, 0.55, 1.55);
        assertEquals(i1, i2);
    }",Eager Test
"@Test
    public void testSerialization() {
        YWithXInterval i1 = new YWithXInterval(1.0, 0.5, 1.5);
        YWithXInterval i2 = TestUtils.serialised(i1);
        assertEquals(i1, i2);
    }",No Smells
"@Test
    public void shouldExtractSingleGroupInPattern() {
        List<String> groups = capturer.extractGroups(""{(hello)}",No Smells
"@Test
    public void shouldCaptureValuesFromSimplePattern() {
        capturer.captureValuesFromPattern(""(.*) world"", Lists.newArrayList(""hello""), ""Hi world"");
        verify(world).put(""hello"", ""Hi"");
    }",No Smells
"@Test
    public void shouldInvokeCaptureValuesFromPatternIfAtLeastOneGroupFound() {
        capturer.capture(""{(hello)}",No Smells
"@Test
    public void shouldNotInvokeCaptureValuesFromPatternIfRegexDoesNotMatchValue() {
        capturer.capture(""{(hello)}",No Smells
"@Test
    public void testInflateGroups() {
        doReturn(Optional.of(""foo"")).when(world).get(""foo"");
        String value = inflater.inflateGroups(""{(foo)}",No Smells
"@Test
    public void testInflateGroups_halfEmpty() {
        doReturn(Optional.of(""foo"")).when(world).get(""foo"");
        String value = inflater.inflateGroups(""{(foo)}",No Smells
"@Test
    public void testInflateGroups_multipleSameExist() {
        doReturn(Optional.of(""foo"")).when(world).get(""foo"");
        String value = inflater.inflateGroups(""{(foo)}",No Smells
"@Test
    public void shouldNotReturnBodyWhenEnabledButContentTypeOctet() {
        byte[] body = RandomUtils.nextBytes(20);

        HttpResponseFacade mock = mock(HttpResponseFacade.class);
        when(mock.response()).thenReturn(generateResponse(
            ""application/octet-stream"",
            404,
            body));

        ((HttpAssertionFacadeImpl) facade).facade = mock;
        world.put(ASSERTS_STATUS_CODE_DISPLAY_BODY, ""true"");
        world.put(ASSERTS_STATUS_CODE_MAX_SIZE, ""5000"");

        validateException(
            200,
            ""1 expectation failed.\n"" +
                ""Expected status code \""200\"" but was \""404\"" with body <binary>.\n"");
    }",No Smells
"@Test
    public void shouldNotReturnBodyWhenEnabledButLongerThanMaxSize() {
        String body = ""{\n"" +
            ""  \""error\"": \""not found\""\n"" +
            ""}",No Smells
"@Test
    public void matchesNotEndWith() {
        assertThat(""hello world"", Matchers.not(EndsWithRegexp.endsWithRegexp(""hello"")));
    }",No Smells
"@Test
    public void stringValueIsCheckedAsString() throws Exception {
        BasicAttributes entity = new BasicAttributes(true);
        entity.put(""userPassword"", ""hello"");

        setField(entityFacade, entityFacade.getClass().getDeclaredField(""entity""), entity);

        entityFacade.entityHasAttributeWithValue(""userpassword"", ""hello"");
    }",No Smells
"@Test
    public void compare_sameTree() {
        assertThat(comparator.compare(""cn=root"", ""cn=b,cn=root""), is(more()));
        assertThat(comparator.compare(""cn=a,cn=root"", ""cn=root""), is(less()));
        assertThat(comparator.compare(""cn=a,cn=root"", ""cn=a,cn=root""), is(same()));
    }",No Smells
"@Test
    public void read() throws Exception {
        Map<String, Attributes> entities = LDIFUtils.read(getClass().getResourceAsStream(""/example.ldif""));
        assertThat(entities.size(), is(4));
    }",Mystery Guest + Resource Optimism
"@Test
    public void readMultipleEntities() throws Exception {
        String ldif = ""dn: dc=example,dc=com\n"" +
            ""objectClass: domain\n"" +
            ""objectClass: top\n"" +
            ""dc: example\n"" +
            ""\n"" +
            ""dn: ou=Users,dc=example,dc=com\n"" +
            ""objectClass: organizationalUnit\n"" +
            ""objectClass: top\n"" +
            ""ou: Users\n"";

        Map<String, Attributes> entities = LDIFUtils.read(new ByteArrayInputStream(ldif.getBytes()));
        assertThat(entities.size(), is(2));
        assertThat(entities.containsKey(""dc=example,dc=com""), is(true));
        assertThat(entities.containsKey(""ou=Users,dc=example,dc=com""), is(true));
    }",Mystery Guest + Resource Optimism
"@Test
	public void testSecureJs() throws Exception {
		final String js1 = jsSanitizer.secureJs(""while(a > 0)\n\n\n {\n\n\nprint(a);}",Eager Test
"@Test
  public void onlyMatchesOptional() throws IOException {
    server.enqueue(new MockResponse());

    Object body = service.object().execute().body();
    assertThat(body).isNull();
  }",No Smells
"@Test
  public void responseType() {
    Type bodyClass = new TypeToken<ListenableFuture<String>>() {}",Eager Test
"@Test
  public void rawResponseTypeThrows() {
    Type observableType = new TypeToken<CompletableFuture<Response>>() {}",No Smells
"@Test
  public void response() {
    Response<String> response = Response.success(""Hi"");
    Result<String> result = Result.response(response);
    assertThat(result.isError()).isFalse();
    assertThat(result.error()).isNull();
    assertThat(result.response()).isSameInstanceAs(response);
  }",No Smells
"@Test
  public void nullErrorThrows() {
    try {
      Result.error(null);
      fail();
    }",No Smells
"@Test
  public void response() {
    Response<String> response = Response.success(""Hi"");
    Result<String> result = Result.response(response);
    assertThat(result.isError()).isFalse();
    assertThat(result.error()).isNull();
    assertThat(result.response()).isSameInstanceAs(response);
  }",No Smells
"@Test
  public void rawBodyTypeThrows() {
    Type observableType = new TypeToken<Observable>() {}",Eager Test
"@Test
  public void rawResponseTypeThrows() {
    Type observableType = new TypeToken<Observable<Response>>() {}",Eager Test
"@Test
  public void rawResultTypeThrows() {
    Type observableType = new TypeToken<Observable<Result>>() {}",Eager Test
"@Test
  public void responseTypes() {
    Type oBodyClass = new TypeToken<Observable<String>>() {}",Eager Test
"@Test
  public void nonListenableFutureReturnsNull() {
    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
    assertThat(adapter).isNull();
  }",No Smells
"@Test
  public void parameterizedTypes() {
    ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {}",Eager Test
"@Test
  public void conversionProblemOutgoingSync() throws IOException {
    Retrofit retrofit =
        new Retrofit.Builder()
            .baseUrl(server.url(""/""))
            .addConverterFactory(
                new ToStringConverterFactory() {
                  @Override
                  public Converter<String, RequestBody> requestBodyConverter(
                      Type type,
                      Annotation[] parameterAnnotations,
                      Annotation[] methodAnnotations,
                      Retrofit retrofit) {
                    return value -> {
                      throw new UnsupportedOperationException(""I am broken!"");
                    }",Eager Test + Mystery Guest
"@Test
  public void responseBodyStreams() throws IOException {
    Retrofit retrofit =
        new Retrofit.Builder()
            .baseUrl(server.url(""/""))
            .addConverterFactory(new ToStringConverterFactory())
            .build();
    Service example = retrofit.create(Service.class);

    server.enqueue(
        new MockResponse().setBody(""1234"").setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));

    Response<ResponseBody> response = example.getStreamingBody().execute();

    ResponseBody streamedBody = response.body();
    // When streaming we only detect socket problems as the ResponseBody is read.
    try {
      streamedBody.string();
      fail();
    }",Eager Test + Mystery Guest
"@Test
  public void transportProblemSync() {
    Retrofit retrofit =
        new Retrofit.Builder()
            .baseUrl(server.url(""/""))
            .addConverterFactory(new ToStringConverterFactory())
            .build();
    Service example = retrofit.create(Service.class);

    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));

    Call<String> call = example.getString();
    try {
      call.execute();
      fail();
    }",Eager Test + Mystery Guest
"@Test
  public void xmlRequestBody() throws Exception {
    server.enqueue(new MockResponse());

    Call<Void> call = service.postXml(SAMPLE_CONTACT);
    call.execute();

    RecordedRequest request = server.takeRequest();
    assertThat(request.getHeader(""Content-Type"")).isEqualTo(""application/xml; charset=utf-8"");
    assertThat(request.getBody().readUtf8()).isEqualTo(SAMPLE_CONTACT_XML);
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void requireFullResponseDocumentConsumption() throws Exception {
    server.enqueue(new MockResponse().setBody(""{\""theName\"":\""value\""}",No Smells
"@Test
  public void deserializeWrongValue() throws IOException {
    ByteString encoded = ByteString.decodeBase64(""////"");
    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));

    Call<?> call = service.get();
    try {
      call.execute();
      fail();
    }",Eager Test
"@Test
  public void deserializeWrongValue() throws IOException {
    server.enqueue(new MockResponse().setBody(""<myObject><foo/><bar/></myObject>""));

    Call<?> call = service.get();
    try {
      call.execute();
      fail();
    }",No Smells
"@Test
  public void deserializeWrongClass() throws IOException {
    ByteString encoded = ByteString.decodeBase64(""Cg4oNTE5KSA4NjctNTMwOQ=="");
    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));

    try {
      service.wrongClass();
      fail();
    }",No Smells
"@Test
  public void deserializeWrongType() throws IOException {
    ByteString encoded = ByteString.decodeBase64(""Cg4oNTE5KSA4NjctNTMwOQ=="");
    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));

    try {
      service.wrongType();
      fail();
    }",No Smells
"@Test
  public void deferredReturnExecute() throws IOException {
    Call<Integer> counts =
        Calls.defer(
            new Callable<Call<Integer>>() {
              private int count = 0;

              @Override
              public Call<Integer> call() throws Exception {
                return Calls.response(++count);
              }",Eager Test
"@Test
  public void responseCancelEnqueue() throws IOException {
    Call<String> taco = Calls.response(Response.success(""Taco""));
    assertFalse(taco.isCanceled());
    taco.cancel();
    assertTrue(taco.isCanceled());

    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
    taco.enqueue(
        new Callback<String>() {
          @Override
          public void onResponse(Call<String> call, Response<String> response) {
            fail();
          }",Eager Test
"@Test
  public void backgroundExecutorNullThrows() {
    MockRetrofit.Builder builder = new MockRetrofit.Builder(retrofit);
    try {
      builder.backgroundExecutor(null);
      fail();
    }",No Smells
"@Test
  public void retrofitNullThrows() {
    try {
      new MockRetrofit.Builder(null);
      fail();
    }",No Smells
"@Test
  public void defaultThrowable() {
    Throwable t = behavior.failureException();
    assertThat(t).isInstanceOf(IOException.class);
    // Exact instance check as opposed to isInstanceOf's subtype checking.
    assertThat(t.getClass()).isEqualTo(MockRetrofitIOException.class);
    assertThat(t.getStackTrace()).isEmpty();
  }",No Smells
"@Test
  public void errorFactoryCannotReturnNull() {
    behavior.setErrorFactory(() -> null);
    try {
      behavior.createErrorResponse();
      fail();
    }",No Smells
"@Test
  public void errorFactoryCannotThrow() {
    final RuntimeException broken = new RuntimeException(""Broken"");
    behavior.setErrorFactory(
        () -> {
          throw broken;
        }",No Smells
"@Test
  public void errorPercentageIsAccurate() {
    behavior.setErrorPercent(0);
    for (int i = 0; i < 10000; i++) {
      assertThat(behavior.calculateIsError()).isFalse();
    }",Eager Test
"@Test
  public void failureExceptionIsNotNull() {
    try {
      behavior.setFailureException(null);
      fail();
    }",No Smells
"@Test
  public void varianceRestrictsRange() {
    try {
      behavior.setVariancePercent(-13);
      fail();
    }",No Smells
"@Test
  public void contentTypeAnnotationHeaderOverrides() {
    class Example {
      @POST(""/"") //
      @Headers(""Content-Type: text/not-plain"") //
      Call<ResponseBody> method(@Body RequestBody body) {
        return null;
      }",Eager Test
"@Test
  public void contentTypeParameterHeaderOverrides() {
    class Example {
      @POST(""/"") //
      Call<ResponseBody> method(
          @Header(""Content-Type"") String contentType, @Body RequestBody body) {
        return null;
      }",Eager Test
"@Test
  public void customMethodWithBody() {
    class Example {
      @HTTP(method = ""CUSTOM2"", path = ""/foo"", hasBody = true)
      Call<ResponseBody> method(@Body RequestBody body) {
        return null;
      }",Eager Test
"@Test
  public void fieldParamMapsConvertedToNullShouldError() throws Exception {
    class Example {
      @FormUrlEncoded
      @POST(""/query"")
      Call<ResponseBody> queryPath(@FieldMap Map<String, String> a) {
        return null;
      }",Eager Test
"@Test
  public void fieldParamsSkippedIfConvertedToNull() throws Exception {
    class Example {
      @FormUrlEncoded
      @POST(""/query"")
      Call<ResponseBody> queryPath(@Field(""a"") Object a) {
        return null;
      }",Eager Test
"@Test
  public void formEncodedFieldList() {
    class Example {
      @FormUrlEncoded //
      @POST(""/foo"") //
      Call<ResponseBody> method(@Field(""foo"") List<Object> fields, @Field(""kit"") String kit) {
        return null;
      }",No Smells
"@Test
  public void formEncodedFieldOptional() {
    class Example {
      @FormUrlEncoded //
      @POST(""/foo"") //
      Call<ResponseBody> method(
          @Field(""foo"") String foo, @Field(""ping"") String ping, @Field(""kit"") String kit) {
        return null;
      }",No Smells
"@Test
  public void formEncodedFieldPrimitiveArray() {
    class Example {
      @FormUrlEncoded //
      @POST(""/foo"") //
      Call<ResponseBody> method(@Field(""foo"") int[] fields, @Field(""kit"") String kit) {
        return null;
      }",Eager Test
"@Test
  public void formEncodedWithEncodedNameFieldParamMap() {
    class Example {
      @FormUrlEncoded //
      @POST(""/foo"") //
      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
        return null;
      }",No Smells
"@Test
  public void getAbsoluteUrl() {
    class Example {
      @GET(""http://example2.com/foo/bar/"")
      Call<ResponseBody> method() {
        return null;
      }",No Smells
"@Test
  public void getUrlAndUrlParamThrows() {
    class Example {
      @GET(""foo/bar"")
      Call<ResponseBody> method(@Url Object url) {
        return null;
      }",No Smells
"@Test
  public void getWithEncodedPathParam() {
    class Example {
      @GET(""/foo/bar/{ping}",No Smells
"@Test
  public void getWithEncodedPathSegments() {
    class Example {
      @GET(""/foo/bar/{ping}",No Smells
"@Test
  public void getWithEncodedPathStillPreventsRequestSplitting() {
    class Example {
      @GET(""/foo/bar/{ping}",No Smells
"@Test
  public void getWithEncodedQueryParam() {
    class Example {
      @GET(""/foo/bar/"") //
      Call<ResponseBody> method(@Query(value = ""pi%20ng"", encoded = true) String ping) {
        return null;
      }",No Smells
"@Test
  public void getWithHeaderMap() {
    class Example {
      @GET(""/search"")
      Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
        return null;
      }",Eager Test
"@Test
  public void getWithJavaUriUrl() {
    class Example {
      @GET
      Call<ResponseBody> method(@Url URI url) {
        return null;
      }",No Smells
"@Test
  public void getWithPathAndQueryQuestionMarkParam() {
    class Example {
      @GET(""/foo/bar/{ping}",No Smells
"@Test
  public void getWithQueryMapThenUrlThrows() {
    class Example {
      @GET
      Call<ResponseBody> method(@QueryMap Map<String, String> queries, @Url String url) {
        throw new AssertionError();
      }",No Smells
"@Test
  public void getWithQueryNameParamArray() {
    class Example {
      @GET(""/foo/bar/"") //
      Call<ResponseBody> method(@QueryName Object[] keys) {
        return null;
      }",Eager Test
"@Test
  public void getWithQueryNameParamPrimitiveArray() {
    class Example {
      @GET(""/foo/bar/"") //
      Call<ResponseBody> method(@QueryName int[] keys) {
        return null;
      }",Eager Test
"@Test
  public void getWithQueryParamMap() {
    class Example {
      @GET(""/foo/bar/"") //
      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
        return null;
      }",No Smells
"@Test
  public void getWithQueryThenPathThrows() {
    class Example {
      @GET(""/foo/bar/{ping}",No Smells
"@Test
  public void getWithStringUrlAbsolute() {
    class Example {
      @GET
      Call<ResponseBody> method(@Url String url) {
        return null;
      }",No Smells
"@Test
  public void headerMapMustBeAMapOrHeaders() {
    class Example {
      @GET(""/"")
      Call<ResponseBody> method(
          @HeaderMap okhttp3.Headers headers, @HeaderMap List<String> headerMap) {
        return null;
      }",No Smells
"@Test
  public void headerParamToString() {
    class Example {
      @GET(""/foo/bar/"") //
      Call<ResponseBody> method(@Header(""kit"") BigInteger kit) {
        return null;
      }",No Smells
"@Test
  public void multipartArrayRequiresName() {
    class Example {
      @Multipart //
      @POST(""/foo/bar/"") //
      Call<ResponseBody> method(@Part RequestBody[] part) {
        return null;
      }",No Smells
"@Test
  public void multipartIterableRequiresName() {
    class Example {
      @Multipart //
      @POST(""/foo/bar/"") //
      Call<ResponseBody> method(@Part List<RequestBody> part) {
        return null;
      }",Eager Test
"@Test
  public void multipartOkHttpPartForbidsName() {
    class Example {
      @Multipart //
      @POST(""/foo/bar/"") //
      Call<ResponseBody> method(@Part(""name"") MultipartBody.Part part) {
        return null;
      }",Eager Test
"@Test
  public void multipartPartMap() throws IOException {
    class Example {
      @Multipart //
      @POST(""/foo/bar/"") //
      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
        return null;
      }",Eager Test
"@Test
  public void multipartPartMapMustBeMap() {
    class Example {
      @Multipart //
      @POST(""/foo/bar/"") //
      Call<ResponseBody> method(@PartMap List<Object> parts) {
        return null;
      }",No Smells
"@Test
  public void multipartPartMapRejectsOkHttpPartValues() {
    class Example {
      @Multipart //
      @POST(""/foo/bar/"") //
      Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
        return null;
      }",No Smells
"@Test
  public void multipartPartsShouldBeInOrder() throws IOException {
    class Example {
      @Multipart
      @POST(""/foo"")
      Call<ResponseBody> get(
          @Part(""first"") String data,
          @Part(""second"") String dataTwo,
          @Part(""third"") String dataThree) {
        return null;
      }",Eager Test
"@Test
  public void pathParamRequired() {
    class Example {
      @GET(""/foo/bar/{ping}",Eager Test
"@Test
  public void postWithUrl() {
    class Example {
      @POST
      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
        return null;
      }",Eager Test
"@Test
  public void queryMapRejectsNull() {
    class Example {
      @GET(""/"") //
      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
        return null;
      }",No Smells
"@Test
  public void queryParamMapsConvertedToNullShouldError() throws Exception {
    class Example {
      @GET(""/query"")
      Call<ResponseBody> queryPath(@QueryMap Map<String, String> a) {
        return null;
      }",No Smells
"@Test
  public void simpleFormEncoded() {
    class Example {
      @FormUrlEncoded //
      @POST(""/foo"") //
      Call<ResponseBody> method(@Field(""foo"") String foo, @Field(""ping"") String ping) {
        return null;
      }",No Smells
"@Test
  public void success() {
    Object body = new Object();
    Response<Object> response = Response.success(body);
    assertThat(response.raw()).isNotNull();
    assertThat(response.code()).isEqualTo(200);
    assertThat(response.message()).isEqualTo(""OK"");
    assertThat(response.headers().size()).isEqualTo(0);
    assertThat(response.isSuccessful()).isTrue();
    assertThat(response.body()).isSameInstanceAs(body);
    assertThat(response.errorBody()).isNull();
  }",No Smells
"@Test
  public void errorWithRawResponse() {
    ResponseBody errorBody = ResponseBody.create(null, ""Broken!"");
    Response<?> response = Response.error(errorBody, errorResponse);
    assertThat(response.raw()).isSameInstanceAs(errorResponse);
    assertThat(response.code()).isEqualTo(400);
    assertThat(response.message()).isEqualTo(""Broken!"");
    assertThat(response.headers().size()).isEqualTo(0);
    assertThat(response.isSuccessful()).isFalse();
    assertThat(response.body()).isNull();
    assertThat(response.errorBody()).isSameInstanceAs(errorBody);
  }",No Smells
"@Test
  public void nullErrorWithRawResponseThrows() {
    try {
      Response.error(null, errorResponse);
      fail();
    }",No Smells
"@Test
  public void success() {
    Object body = new Object();
    Response<Object> response = Response.success(body);
    assertThat(response.raw()).isNotNull();
    assertThat(response.code()).isEqualTo(200);
    assertThat(response.message()).isEqualTo(""OK"");
    assertThat(response.headers().size()).isEqualTo(0);
    assertThat(response.isSuccessful()).isTrue();
    assertThat(response.body()).isSameInstanceAs(body);
    assertThat(response.errorBody()).isNull();
  }",No Smells
"@Test
  public void argumentCapture() throws Exception {
    AtomicInteger i = new AtomicInteger();

    server.enqueue(new MockResponse().setBody(""a""));
    server.enqueue(new MockResponse().setBody(""b""));

    Retrofit retrofit =
        new Retrofit.Builder()
            .baseUrl(server.url(""/""))
            .addConverterFactory(new ToStringConverterFactory())
            .build();
    MutableParameters mutableParameters = retrofit.create(MutableParameters.class);

    i.set(100);
    Call<String> call1 = mutableParameters.method(i);

    i.set(101);
    Response<String> response1 = call1.execute();

    i.set(102);
    assertEquals(""a"", response1.body());
    assertEquals(""/?i=101"", server.takeRequest().getPath());

    i.set(200);
    Call<String> call2 = call1.clone();

    i.set(201);
    Response<String> response2 = call2.execute();

    i.set(202);
    assertEquals(""b"", response2.body());

    assertEquals(""/?i=201"", server.takeRequest().getPath());
  }",Eager Test
"@Test
  public void baseHttpUrlPropagated() {
    HttpUrl url = HttpUrl.get(""http://example.com/"");
    Retrofit retrofit = new Retrofit.Builder().baseUrl(url).build();
    assertThat(retrofit.baseUrl()).isSameInstanceAs(url);
  }",No Smells
"@Test
  public void baseUrlNullThrows() {
    try {
      new Retrofit.Builder().baseUrl((String) null);
      fail();
    }",No Smells
"@Test
  public void baseUrlStringPropagated() {
    Retrofit retrofit = new Retrofit.Builder().baseUrl(""http://example.com/"").build();
    HttpUrl baseUrl = retrofit.baseUrl();
    assertThat(baseUrl).isEqualTo(HttpUrl.get(""http://example.com/""));
  }",No Smells
"@Test
  public void callAdapterFactoryDefault() {
    Retrofit retrofit = new Retrofit.Builder().baseUrl(""http://example.com/"").build();
    assertThat(retrofit.callAdapterFactories()).isNotEmpty();
  }",No Smells
"@Test
  public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
    Type type = String.class;
    Annotation[] annotations = new Annotation[0];

    final CallAdapter<?, ?> expectedAdapter =
        new CallAdapter<Object, Object>() {
          @Override
          public Type responseType() {
            throw new AssertionError();
          }",Eager Test
"@Test
  public void callbackExecutorNullThrows() {
    try {
      new Retrofit.Builder().callbackExecutor(null);
      fail();
    }",No Smells
"@Test
  public void callbackExecutorUsedForSuccess() throws InterruptedException {
    final CountDownLatch runnableLatch = new CountDownLatch(1);
    final AtomicReference<Runnable> runnableRef = new AtomicReference<>();
    Executor executor =
        command -> {
          runnableRef.set(command);
          runnableLatch.countDown();
        }",Eager Test
"@Test
  public void callFactoryClientPropagated() {
    OkHttpClient client = new OkHttpClient();
    Retrofit retrofit =
        new Retrofit.Builder().baseUrl(""http://example.com/"").client(client).build();
    assertThat(retrofit.callFactory()).isSameInstanceAs(client);
  }",Eager Test
"@Test
  public void callFactoryReturningNullThrows() throws IOException {
    okhttp3.Call.Factory callFactory = request -> null;
    Retrofit retrofit =
        new Retrofit.Builder().baseUrl(""http://example.com/"").callFactory(callFactory).build();

    server.enqueue(new MockResponse());

    CallMethod service = retrofit.create(CallMethod.class);
    Call<ResponseBody> call = service.getResponseBody();
    try {
      call.execute();
      fail();
    }",Eager Test
"@Test
  public void callFactoryUsed() throws IOException {
    final AtomicBoolean called = new AtomicBoolean();
    okhttp3.Call.Factory callFactory =
        request -> {
          called.set(true);
          return new OkHttpClient().newCall(request);
        }",Eager Test
"@Test
  public void customCallAdapter() {
    class GreetingCallAdapterFactory extends CallAdapter.Factory {
      @Override
      public @Nullable CallAdapter<Object, String> get(
          Type returnType, Annotation[] annotations, Retrofit retrofit) {
        if (getRawType(returnType) != String.class) {
          return null;
        }",Eager Test
"@Test
  public void customCallAdapterMissingThrows() {
    Retrofit retrofit = new Retrofit.Builder().baseUrl(server.url(""/"")).build();
    FutureMethod example = retrofit.create(FutureMethod.class);
    try {
      example.method();
      fail();
    }",Eager Test
"@Test
  public void methodAnnotationsPassedToResponseBodyConverter() {
    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
    class MyConverterFactory extends Converter.Factory {
      @Override
      public Converter<ResponseBody, ?> responseBodyConverter(
          Type type, Annotation[] annotations, Retrofit retrofit) {
        annotationsRef.set(annotations);
        return new ToStringConverterFactory().responseBodyConverter(type, annotations, retrofit);
      }",Eager Test
"@Test
  public void requestConverterFactoryNoMatchThrows() {
    Type type = String.class;
    Annotation[] annotations = new Annotation[0];

    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();

    Retrofit retrofit =
        new Retrofit.Builder()
            .baseUrl(""http://example.com/"")
            .addConverterFactory(nonMatchingFactory)
            .build();

    try {
      retrofit.requestBodyConverter(type, annotations, annotations);
      fail();
    }",Eager Test
"@Test
  public void responseConverterFactoryNoMatchThrows() {
    Type type = String.class;
    Annotation[] annotations = new Annotation[0];

    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();

    Retrofit retrofit =
        new Retrofit.Builder()
            .baseUrl(""http://example.com/"")
            .addConverterFactory(nonMatchingFactory)
            .build();

    try {
      retrofit.responseBodyConverter(type, annotations);
      fail();
    }",Eager Test
"@Test
  public void responseTypeCannotBeOkHttpResponse() {
    Retrofit retrofit = new Retrofit.Builder().baseUrl(server.url(""/"")).build();
    CallMethod service = retrofit.create(CallMethod.class);
    try {
      service.badType2();
      fail();
    }",Eager Test + Mystery Guest
"@Test
  public void doubleConversionValidation() throws Exception {
    BpmnModel bpmnModel = readXmlFile();
    validateModel(bpmnModel);
    bpmnModel = convertToJsonAndBack(bpmnModel);
    validateModel(bpmnModel);
  }",No Smells
"@Test
  public void testOManyComaInExpression() {
    String testString = ""${Everything,should,be,made,as,simple,as,possible}",No Smells
"@Test
    public void executeParseShouldUseDefaultBehaviorWhenNoInformationIsProvided() throws Exception {
        //given
        ServiceTask serviceTask = new ServiceTask();
        ServiceTaskDelegateExpressionActivityBehavior defaultBehavior = mock(ServiceTaskDelegateExpressionActivityBehavior.class);
        given(activityBehaviorFactory.createDefaultServiceTaskBehavior(serviceTask)).willReturn(defaultBehavior);

        //when
        serviceTaskParseHandler.executeParse(bpmnParse,
                                             serviceTask);

        //then
        assertThat(serviceTask.getBehavior()).isEqualTo(defaultBehavior);
    }",No Smells
"@Test
  public void testRegularAsyncExecution() {

    ProcessEngine processEngine = null;

    try {
      // Deploy
      processEngine = createProcessEngine(true);
      setClockToCurrentTime(processEngine);
      deploy(processEngine, ""AsyncExecutorTest.testRegularAsyncExecution.bpmn20.xml"");

      // Start process instance. Wait for all jobs to be done
      processEngine.getRuntimeService().startProcessInstanceByKey(""asyncExecutor"");

      // Move clock 3 minutes. Nothing should happen
      addSecondsToCurrentTime(processEngine, 180L);
      ProcessEngine processEngineForException = processEngine;
      assertThatExceptionOfType(ActivitiException.class)
        .isThrownBy(() -> waitForAllJobsBeingExecuted(processEngineForException, 500L));
      assertThat(processEngine.getTaskService().createTaskQuery().taskName(""The Task"").count()).isEqualTo(1);
      assertThat(processEngine.getTaskService().createTaskQuery().taskName(""Task after timer"").count()).isEqualTo(0);
      assertThat(processEngine.getManagementService().createTimerJobQuery().count()).isEqualTo(1);
      assertThat(getAsyncExecutorJobCount(processEngine)).isEqualTo(0);

      // Move clock 3 minutes and 1 second. Triggers the timer
      addSecondsToCurrentTime(processEngine, 181);
      waitForAllJobsBeingExecuted(processEngine);

      // Verify if all is as expected
      assertThat(processEngine.getTaskService().createTaskQuery().taskName(""The Task"").count()).isEqualTo(0);
      assertThat(processEngine.getTaskService().createTaskQuery().taskName(""Task after timer"").count()).isEqualTo(1);
      assertThat(processEngine.getManagementService().createTimerJobQuery().count()).isEqualTo(0);
      assertThat(processEngine.getManagementService().createJobQuery().count()).isEqualTo(0);

      assertThat(getAsyncExecutorJobCount(processEngine)).isEqualTo(1);
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void hasConnectorBeanShouldReturnFalseIfABeanOfDifferentTypeIsFound() {
        //given
        String connectorName = ""connector"";
        DelegateExecution execution = ConnectorRuntimeApiTestHelper.buildExecution(connectorName);
        given(context.containsBean(connectorName)).willReturn(true);
        DelegateExecution nonConnectorBean = mock(DelegateExecution.class);
        given(context.getBean(connectorName)).willReturn(nonConnectorBean);

        //when
        boolean hasConnectorBean = behavior.hasConnectorBean(execution);

        //then
        assertThat(hasConnectorBean).isFalse();
    }",Eager Test
"@Test
    public void calculateStatusCreatedAndNotAssignedTaskShouldReturnCreated() {
        assertThat(taskConverter.from(taskBuilder().build()))
                .isNotNull()
                .extracting(Task::getStatus)
                .isEqualTo(CREATED);
    }",No Smells
"@Test
    public void denyAllShouldAddUnmatchableFilter() {
        //when
        GetProcessDefinitionsPayload filter = restrictionApplier.denyAll();

        //then
        assertThat(filter.getProcessDefinitionKeys()).hasSize(1);
        assertThat(filter.getProcessDefinitionKeys().iterator().next()).startsWith(""missing-"");
    }",No Smells
"@Test
    public void testDeployResources() {
        final Resource[] resources = new Resource[]{resourceMock1, resourceMock2, resourceMock3, resourceMock4, resourceMock5}",No Smells
"@Test
    public void testDetermineResourceNameWithExceptionFailsGracefully() throws Exception {
        when(resourceMock3.getFile()).thenThrow(new IOException());
        when(resourceMock3.getFilename()).thenReturn(resourceName3);

        final Resource[] resources = new Resource[]{resourceMock3}",No Smells
"@Test
    public void testHandlesMode() {
        assertThat(deploymentStrategy.handlesMode(ResourceParentFolderAutoDeploymentStrategy.DEPLOYMENT_MODE)).isTrue();
        assertThat(deploymentStrategy.handlesMode(""other-mode"")).isFalse();
        assertThat(deploymentStrategy.handlesMode(null)).isFalse();
    }",No Smells
"@Test
    public void testDeployResources() {
        final Resource[] resources = new Resource[]{resourceMock1, resourceMock2, resourceMock3, resourceMock4, resourceMock5}",No Smells
"@Test
    public void daylightSaving23HourDay() throws Exception {
        Clock testingClock = new DefaultClockImpl();
        testingClock.setCurrentCalendar(parseCalendar(""20140309-00:00:00"", TimeZone.getTimeZone(""US/Eastern"")));

        DurationHelper dh = new DurationHelper(""R2/2014-03-09T00:00:00/P1D"", testingClock);

        assertThat(dh.getCalendarAfter(testingClock.getCurrentCalendar())).isEqualTo(parseCalendar(""20140310-00:00:00"", TimeZone.getTimeZone(""US/Eastern"")));
    }",Eager Test
"@Test
    public void daylightSaving25HourDayEurope() throws Exception {
        Clock testingClock = new DefaultClockImpl();
        testingClock.setCurrentCalendar(parseCalendar(""20131027-00:00:00"", TimeZone.getTimeZone(""Europe/Amsterdam"")));

        DurationHelper dh = new DurationHelper(""R2/2013-10-27T00:00:00/P1D"", testingClock);

        assertThat(dh.getCalendarAfter(testingClock.getCurrentCalendar())).isEqualTo(parseCalendar(""20131028-00:00:00"", TimeZone.getTimeZone(""Europe/Amsterdam"")));
    }",Eager Test
"@Test
    public void daylightSavingFall() throws Exception {
        Clock testingClock = new DefaultClockImpl();
        testingClock.setCurrentCalendar(parseCalendar(""20131103-04:45:00"", TimeZone.getTimeZone(""UTC"")));

        DurationHelper dh = new DurationHelper(""R2/2013-11-03T00:45:00-04:00/PT1H"", testingClock);

        assertThat(dh.getCalendarAfter(testingClock.getCurrentCalendar(TimeZone.getTimeZone(""US/Eastern"")))).isEqualTo(parseCalendar(""20131103-05:45:00"", TimeZone.getTimeZone(""UTC"")));

        testingClock.setCurrentCalendar(parseCalendar(""20131103-05:45:00"", TimeZone.getTimeZone(""UTC"")));

        assertThat(dh.getCalendarAfter(testingClock.getCurrentCalendar(TimeZone.getTimeZone(""US/Eastern"")))).isEqualTo(parseCalendar(""20131103-06:45:00"", TimeZone.getTimeZone(""UTC"")));
    }",Eager Test
"@Test
    public void daylightSavingFallFirstHour() throws Exception {
        Clock testingClock = new DefaultClockImpl();
        testingClock.setCurrentCalendar(parseCalendar(""20131103-05:45:00"", TimeZone.getTimeZone(""UTC"")));
        Calendar easternTime = testingClock.getCurrentCalendar(TimeZone.getTimeZone(""US/Eastern""));

        DurationHelper dh = new DurationHelper(""R2/2013-11-03T01:45:00-04:00/PT1H"", testingClock);

        assertThat(dh.getCalendarAfter(easternTime)).isEqualTo(parseCalendar(""20131103-06:45:00"", TimeZone.getTimeZone(""UTC"")));
    }",Eager Test
"@Test
    public void daylightSavingFallObservedSecondHour() throws Exception {
        Clock testingClock = new DefaultClockImpl();
        testingClock.setCurrentCalendar(parseCalendar(""20131103-00:45:00"", TimeZone.getTimeZone(""US/Eastern"")));

        DurationHelper dh = new DurationHelper(""R2/2013-11-03T00:45:00-04:00/PT2H"", testingClock);
        Calendar expected = parseCalendarWithOffset(""20131103-01:45:00 -05:00"");

        assertThat(expected.compareTo(dh.getCalendarAfter()) == 0).isTrue();
    }",Eager Test
"@Test
    public void shouldNotExceedNumber() throws Exception {
        Clock testingClock = new DefaultClockImpl();
        testingClock.setCurrentTime(new Date(0));
        DurationHelper dh = new DurationHelper(""R2/PT10S"", testingClock);

        testingClock.setCurrentTime(new Date(15000));
        assertThat(dh.getDateAfter().getTime()).isEqualTo(20000);

        testingClock.setCurrentTime(new Date(30000));
        assertThat(dh.getDateAfter().getTime()).isEqualTo(30000);
    }",Eager Test
"@Test
    public void executeValidationShouldNotRiseErrorsForServiceTasksSettingOnlyTheImplementation() {
        //given
        Process process = new Process();
        ServiceTask serviceTask = new ServiceTask();
        serviceTask.setImplementation(""myImpl"");
        process.addFlowElement(serviceTask);
        BpmnModel bpmnModel = new BpmnModel();
        bpmnModel.addProcess(process);

        //when
        var errors = validator.validate(bpmnModel);

        //then
        assertThat(errors)
                .as(""No error is expected: the default behavior will be used"")
                .isEmpty();
    }",Eager Test
"@Test
  public void get_scheduled_by_task_name() {
    Instant now = TimeHelper.truncatedInstantNow();
    final SchedulableTaskInstance<Void> execution1 =
        new SchedulableTaskInstance<>(
            oneTimeTask.instance(""id"" + 1), now.plus(new Random().nextInt(10), ChronoUnit.HOURS));
    taskRepository.createIfNotExists(execution1);
    taskRepository.createIfNotExists(
        new SchedulableTaskInstance<>(
            oneTimeTask.instance(""id"" + 2), now.plus(new Random().nextInt(10), ChronoUnit.HOURS)));
    taskRepository.createIfNotExists(
        new SchedulableTaskInstance<>(
            alternativeOneTimeTask.instance(""id"" + 3),
            now.plus(new Random().nextInt(10), ChronoUnit.HOURS)));

    taskRepository.pick(
        taskRepository.getExecution(execution1.getTaskInstance()).get(), Instant.now());
    assertThat(getScheduledExecutions(all().withPicked(true), oneTimeTask.getName()), hasSize(1));
    assertThat(getScheduledExecutions(all().withPicked(false), oneTimeTask.getName()), hasSize(1));
    assertThat(getScheduledExecutions(all(), oneTimeTask.getName()), hasSize(2));

    assertThat(
        getScheduledExecutions(all().withPicked(false), alternativeOneTimeTask.getName()),
        hasSize(1));
    assertThat(getScheduledExecutions(all().withPicked(false), ""non-existing""), empty());
  }",Eager Test
"@Test
  public void reschedule_should_move_execution_in_time() {
    Instant now = TimeHelper.truncatedInstantNow();
    final TaskInstance<Void> instance = oneTimeTask.instance(""id1"");
    taskRepository.createIfNotExists(new SchedulableTaskInstance<>(instance, now));
    List<Execution> due = taskRepository.getDue(now, POLLING_LIMIT);
    assertThat(due, hasSize(1));

    Execution execution = due.get(0);
    final Optional<Execution> pickedExecution = taskRepository.pick(execution, now);
    final Instant nextExecutionTime = now.plus(Duration.ofMinutes(1));
    taskRepository.reschedule(pickedExecution.get(), nextExecutionTime, now, null, 0);

    assertThat(taskRepository.getDue(now, POLLING_LIMIT), hasSize(0));
    assertThat(taskRepository.getDue(nextExecutionTime, POLLING_LIMIT), hasSize(1));

    final Optional<Execution> nextExecution = taskRepository.getExecution(instance);
    assertTrue(nextExecution.isPresent());
    assertThat(nextExecution.get().picked, is(false));
    assertThat(nextExecution.get().pickedBy, nullValue());
    assertThat(nextExecution.get().executionTime, is(nextExecutionTime));
  }",Eager Test
"@Test
  public void should_not_be_able_to_pick_execution_that_has_been_rescheduled() {
    Instant now = TimeHelper.truncatedInstantNow();
    final TaskInstance<Void> instance = oneTimeTask.instance(""id1"");
    taskRepository.createIfNotExists(new SchedulableTaskInstance<>(instance, now));

    List<Execution> due = taskRepository.getDue(now, POLLING_LIMIT);
    assertThat(due, hasSize(1));
    final Execution execution = due.get(0);
    final Optional<Execution> pickedExecution = taskRepository.pick(execution, now);
    assertThat(pickedExecution.isPresent(), is(true));
    taskRepository.reschedule(pickedExecution.get(), now.plusSeconds(1), now, null, 0);

    assertThat(taskRepository.pick(pickedExecution.get(), now).isPresent(), is(false));
  }",Eager Test
"@Test
  public void test_equals() {
    Instant now = Instant.now();
    assertEquals(createExecution(""task"", ""1"", now), createExecution(""task"", ""1"", now));
    assertNotEquals(createExecution(""task"", ""1"", now), createExecution(""task2"", ""1"", now));
    assertNotEquals(createExecution(""task"", ""1"", now), createExecution(""task"", ""2"", now));
    assertNotEquals(
        createExecution(""task"", ""1"", now), createExecution(""task"", ""1"", now.plusSeconds(1)));
  }",No Smells
"@Test
  public void scheduler_should_execute_task_when_exactly_due() {
    LOG.info(""scheduler_should_execute_task_when_exactly_due()"");
    OneTimeTask<Void> oneTimeTask = TestTasks.oneTime(""OneTime"", Void.class, handler);
    ManualScheduler scheduler = schedulerFor(oneTimeTask);

    try {
      Instant executionTime = clock.now().plus(ofMinutes(1));
      scheduler.schedule(oneTimeTask.instance(""1""), executionTime);

      scheduler.runAnyDueExecutions();
      assertThat(handler.timesExecuted.get(), is(0));

      clock.set(executionTime);
      scheduler.runAnyDueExecutions();
      assertThat(handler.timesExecuted.get(), is(1));
    }",Eager Test
"@Test
  public void scheduler_should_not_execute_canceled_tasks() {
    OneTimeTask<Void> oneTimeTask = TestTasks.oneTime(""OneTime"", Void.class, handler);
    Scheduler scheduler = schedulerFor(oneTimeTask);

    Instant executionTime = clock.now().plus(ofMinutes(1));
    String instanceId = ""1"";
    TaskInstance<Void> oneTimeTaskInstance = oneTimeTask.instance(instanceId);
    scheduler.schedule(oneTimeTaskInstance, executionTime);
    scheduler.cancel(oneTimeTaskInstance);
    scheduler.executeDue();
    assertThat(handler.timesExecuted.get(), is(0));

    clock.set(executionTime);
    scheduler.executeDue();
    assertThat(handler.timesExecuted.get(), is(0));
  }",Eager Test
"@Test
  public void should_generate_next_date_correctly() {
    LocalDate currentDate = Instant.now().atZone(ZONE).toLocalDate();
    LocalDate nextDay = currentDate.plusDays(1);

    assertThat(
        new Daily(HOUR_8).getNextExecutionTime(complete(instant(currentDate, HOUR_0))),
        is(instant(currentDate, HOUR_8)));
    assertThat(
        new Daily(HOUR_8).getNextExecutionTime(complete(instant(currentDate, HOUR_8))),
        is(instant(nextDay, HOUR_8)));

    assertThat(
        new Daily(HOUR_8, HOUR_12).getNextExecutionTime(complete(instant(currentDate, HOUR_0))),
        is(instant(currentDate, HOUR_8)));
    assertThat(
        new Daily(HOUR_8, HOUR_12).getNextExecutionTime(complete(instant(currentDate, HOUR_8))),
        is(instant(currentDate, HOUR_12)));
    assertThat(
        new Daily(HOUR_8, HOUR_12).getNextExecutionTime(complete(instant(currentDate, HOUR_12))),
        is(instant(nextDay, HOUR_8)));
    // order should be irrelevant
    assertThat(
        new Daily(HOUR_12, HOUR_8).getNextExecutionTime(complete(instant(currentDate, HOUR_0))),
        is(instant(currentDate, HOUR_8)));
  }",No Smells
"@Test
    public void noDefaultProfile() throws IOException {
        final ConfigFile configFile =
                ConfigFileReader.parse(""src/test/resources/unit_test_no_default_config"", ""USER"");
        assertEquals(""default_user"", configFile.get(""user""));
        assertEquals(""default_tenancy"", configFile.get(""tenancy""));
        assertNull(configFile.get(""region""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void testNullFieldInSuperclass() throws Exception {
        Subclass pojo = Subclass.builder().subVal(""two"").build();
        JsonGenerator jgen = mock(JsonGenerator.class);
        SerializerProvider provider = mock(SerializerProvider.class);
        PropertyWriter writer = mock(PropertyWriter.class);

        when(writer.getName()).thenReturn(""baseVal"");

        filter.serializeAsField(pojo, jgen, provider, writer);

        verify(writer, atLeast(1)).getName();
        verifyNoMoreInteractions(writer);
    }",Eager Test
"@Test
    public void testNullInSubclass() throws Exception {
        Subclass pojo = Subclass.builder().baseVal(1).build();
        JsonGenerator jgen = mock(JsonGenerator.class);
        SerializerProvider provider = mock(SerializerProvider.class);
        PropertyWriter writer = mock(PropertyWriter.class);

        when(writer.getName()).thenReturn(""subVal"");

        filter.serializeAsField(pojo, jgen, provider, writer);

        verify(writer, atLeast(1)).getName();
        verifyNoMoreInteractions(writer);
    }",Eager Test
"@Test
    public void format_rfc3339_zeroMillis() {
        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(""GMT""));
        cal.set(1985, 3, 12, 23, 20, 50);
        cal.set(Calendar.MILLISECOND, 0);
        Date date = cal.getTime();
        assertEquals(""1985-04-12T23:20:50Z"", HttpDateUtils.format(date));
    }",Eager Test
"@Test
    public void otherDateHeader_rfc3339_dateTime_withMillis_utc() {
        Date date = HttpDateUtils.parse(""other-date"", ""1985-04-12T23:20:50.052Z"");
        assertEquals(482196050052L, date.getTime());
    }",No Smells
"@Test
    public void calculateMissingHeaders_postDuplicatableInputStreamAsPlainText()
            throws IOException {
        final InputStream body = StreamUtils.createByteArrayInputStream(BYTE_BUFFER);
        calculateAndVerifyMissingHeaders(
                ""POST"", ""text/plain"", body, BYTE_BUFFER.length, SigningStrategy.STANDARD);

        // Read the stream one more time to verify it wasn't consumed already and verify content
        // matches source
        assertTrue(Arrays.equals(BYTE_BUFFER, StreamUtils.toByteArray(body)));
    }",No Smells
"@Test
    public void allVariables_allFilledIn() {
        String endpoint =
                DefaultEndpointConfiguration.builder(
                                ""https://{serviceEndpointPrefix}",Mystery Guest
"@Test
    public void someVariables_noSecondLevelDomain() {
        String endpoint =
                DefaultEndpointConfiguration.builder(
                                ""https://{serviceEndpointPrefix}",Mystery Guest
"@Test
    public void someVariables_noServiceName_noSecondLevelDomain() {
        String endpoint =
                DefaultEndpointConfiguration.builder(""https://foobar.{region}",Mystery Guest
"@Test
    public void createEndpoint_useCustomTemplate() {
        Service testService =
                Services.serviceBuilder()
                        .serviceEndpointPrefix(""foobar"")
                        .serviceName(""EndpointBuilderTest2"")
                        .serviceEndpointTemplate(""https://foobar2.{region}",Mystery Guest
"@Test
    public void createEndpoint_useCustomTemplate_allTemplatesUsed() {
        Service testService =
                Services.serviceBuilder()
                        .serviceEndpointPrefix(""foobar"")
                        .serviceName(""EndpointBuilderTest3"")
                        .serviceEndpointTemplate(
                                ""http://{serviceEndpointPrefix}",Mystery Guest
"@Test
    public void getSourceFile() throws IOException {
        try (WrappedFileInputStream wrappedStream = new WrappedFileInputStream(tmpFile)) {
            assertSame(tmpFile, wrappedStream.getSourceFile());
        }",No Smells
"@Test
    public void parse_noStartHasContentLength() {
        Range range = Range.parse(""bytes -10/25"");
        assertNull(range.getStartByte());
        assertEquals(10L, (long) range.getEndByte());
        assertEquals(25L, (long) range.getContentLength());
    }",No Smells
"@Test
    public void abortAll() throws Exception {
        UploadPartRequest request1 = UploadPartRequest.builder().uploadPartNum(1).build();
        final UploadPartResponse response1 = UploadPartResponse.builder().build();

        when(service.uploadPart(request1))
                .thenAnswer(
                        new Answer<UploadPartResponse>() {
                            @Override
                            public UploadPartResponse answer(InvocationOnMock arg0)
                                    throws Throwable {
                                // long enough to abort without starting the task
                                Thread.sleep(10000L);
                                return response1;
                            }",Eager Test
"@Test
    public void shouldCalculateMd5_enabled_notSet() {
        assertTrue(
                MultipartUtils.shouldCalculateMd5(
                        UploadConfiguration.builder().enforceMd5(true).build(),
                        PutObjectRequest.builder().build()));
    }",No Smells
"@Test
    public void shouldUseMultipart_multipartsDisabled_shouldReturnFalse() {
        UploadConfiguration configuration =
                UploadConfiguration.builder().allowMultipartUploads(false).build();

        assertFalse(MultipartUtils.shouldUseMultipart(configuration, LARGE_ENOUGH_FOR_MULTIPART));
    }",No Smells
"@Test
    public void shouldUseMultipart_objectNotTooLarge_shouldReturnTrue() {
        UploadConfiguration configuration = UploadConfiguration.builder().build();

        assertTrue(MultipartUtils.shouldUseMultipart(configuration, TOO_LARGE_FOR_MULTIPART - 1L));
    }",No Smells
"@Test
    public void addParts_allSuccessful_commit() throws Exception {
        String uploadId = ""uploadId"";
        initializeCreateMultipartUpload(uploadId);
        MultipartManifest manifest =
                assembler.newRequest(CONTENT_TYPE, CONTENT_LANGUAGE, CONTENT_ENCODING, OPC_META);

        byte[] bytes = ""abcd"".getBytes();

        File file = File.createTempFile(""unitTest"", "".txt"");
        file.deleteOnExit();
        try (FileOutputStream fos = new FileOutputStream(file)) {
            fos.write(bytes);
        }",Eager Test
"@Test
    public void newRequest_andVerifyManifestWithRetryConfiguration() {
        String uploadId = ""uploadId"";

        initializeCreateMultipartUpload(uploadId);

        MultipartManifest manifest =
                assemblerWithRetryConfiguration.newRequest(
                        CONTENT_TYPE, CONTENT_LANGUAGE, CONTENT_ENCODING, OPC_META);
        assertNotNull(manifest);
        assertEquals(uploadId, manifest.getUploadId());

        ArgumentCaptor<CreateMultipartUploadRequest> captor =
                ArgumentCaptor.forClass(CreateMultipartUploadRequest.class);
        verify(service).createMultipartUpload(captor.capture());

        CreateMultipartUploadRequest request = captor.getValue();
        assertEquals(NAMESPACE, request.getNamespaceName());
        assertEquals(BUCKET, request.getBucketName());
        assertEquals(OBJECT, request.getCreateMultipartUploadDetails().getObject());
        assertEquals(CONTENT_TYPE, request.getCreateMultipartUploadDetails().getContentType());
        assertEquals(
                CONTENT_LANGUAGE, request.getCreateMultipartUploadDetails().getContentLanguage());
        assertEquals(
                CONTENT_ENCODING, request.getCreateMultipartUploadDetails().getContentEncoding());
        assertEquals(OPC_META, request.getCreateMultipartUploadDetails().getMetadata());
        assertEquals(mockInvocationCallback, request.getInvocationCallback());
        assertEquals(CACHE_CONTROL, request.getCreateMultipartUploadDetails().getCacheControl());
        assertEquals(
                CONTENT_DISPOSITION,
                request.getCreateMultipartUploadDetails().getContentDisposition());
    }",Eager Test
"@Test
    public void resumeUpload_noMatchingUploadId_shouldThrowIllegalArgumentException() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage(""Could not find existing upload with ID doesNotExist"");

        ArrayList<MultipartUpload> existingUploads = new ArrayList<>();
        existingUploads.add(MultipartUpload.builder().uploadId(""foobar"").build());
        ListMultipartUploadsResponse listResponse1 =
                ListMultipartUploadsResponse.builder()
                        .opcNextPage(""nextPage"")
                        .items(existingUploads)
                        .build();
        ListMultipartUploadsResponse listResponse2 =
                ListMultipartUploadsResponse.builder()
                        .items(new ArrayList<MultipartUpload>())
                        .build();
        when(service.listMultipartUploads(any(ListMultipartUploadsRequest.class)))
                .thenReturn(listResponse1)
                .thenReturn(listResponse2);

        assembler.resumeRequest(""doesNotExist"");
    }",Eager Test
"@Test
    public void multipartUploadProgressTrackerFactory_differentProgressTracker() {
        final ProgressTrackerFactory progressTrackerFactory =
                ProgressTrackerFactory.createMultiPartUploadProgressTrackerFactory(
                        new ProgressReporter() {
                            @Override
                            public void onProgress(long completed, long total) {}",No Smells
"@Test
    public void singleUpload_progressReporter() {
        final UploadConfiguration uploadConfiguration =
                UploadConfiguration.builder().allowMultipartUploads(false).build();
        final UploadManager uploadManager = new UploadManager(objectStorage, uploadConfiguration);

        final AtomicInteger expectedProgressNotificationCount = new AtomicInteger();
        when(objectStorage.putObject(any(PutObjectRequest.class)))
                .then(
                        new Answer<PutObjectResponse>() {
                            @Override
                            public PutObjectResponse answer(InvocationOnMock invocationOnMock)
                                    throws Throwable {
                                final PutObjectRequest putObjectRequest =
                                        invocationOnMock.getArgument(0);
                                final InputStream inputStream = putObjectRequest.getPutObjectBody();
                                byte[] buffer = new byte[READ_BLOCK_SIZE];
                                while (inputStream.read(buffer) != -1) {
                                    expectedProgressNotificationCount.getAndIncrement();
                                }",Eager Test
"@Test
    public void upload_singleUpload_enforceMd5() throws Exception {
        UploadConfiguration uploadConfiguration =
                UploadConfiguration.builder().allowMultipartUploads(false).enforceMd5(true).build();
        UploadManager uploadManager = new UploadManager(objectStorage, uploadConfiguration);

        UploadRequest request = createUploadRequest();

        ArgumentCaptor<PutObjectRequest> putRequestCaptor =
                ArgumentCaptor.forClass(PutObjectRequest.class);
        PutObjectResponse putResponse = PutObjectResponse.builder().build();
        when(objectStorage.putObject(putRequestCaptor.capture())).thenReturn(putResponse);

        UploadResponse uploadResponse = uploadManager.upload(request);
        assertNotNull(uploadResponse);
        byte[] buffer = new byte[(int) CONTENT_LENGTH];
        putRequestCaptor.getValue().getPutObjectBody().read(buffer);
        assertEquals(CONTENT, new String(buffer));
        assertEquals(CONTENT_LENGTH, putRequestCaptor.getValue().getContentLength().longValue());
        assertEquals(
                ""U2yw5mJhFHg/U4cBMrrFyw=="",
                putRequestCaptor.getValue().getContentMD5()); // 'a' times content-length
    }",Eager Test
"@Test
    public void regionalEndpoint_withRegionEnum_andRegionString_oc1() {
        String expectedEndpoint = ""https://foobar.us-phoenix-1.oraclecloud.com"";
        Region oc1Region = Region.US_PHOENIX_1;
        assertEquals(expectedEndpoint, Region.formatDefaultRegionEndpoint(TEST_SERVICE, oc1Region));
        assertEquals(
                expectedEndpoint,
                Region.formatDefaultRegionEndpoint(TEST_SERVICE, oc1Region.getRegionId()));
    }",No Smells
"@Test
    public void expandUserHome_tildeNoHomeShortcut() {
        assertEquals(""~foo/bar"", FileUtils.expandUserHome(""~foo/bar""));
    }",No Smells
"@Test
    public void version_java9_prerelease() {
        System.setProperty(""java.version"", ""9-ea"");
        JreVersion version = JavaRuntimeUtils.parse();
        assertEquals(JreVersion.Java_9, version);
    }",No Smells
"@Test
    public void shouldNotTerminate() {
        WaitContext context = new WaitContext(0L);
        context.setCurrentTime(500L);
        assertFalse(STRATEGY.shouldTerminate(context));
    }",No Smells
"@Test
    public void shouldTerminate_equal() {
        WaitContext context = new WaitContext(0L);
        context.setCurrentTime(1000L);
        assertTrue(STRATEGY.shouldTerminate(context));
    }",No Smells
"@Test public void deadEventPosting() {
    GhostCatcher catcher = new GhostCatcher();
    bus.register(catcher);

    bus.post(new DeadEvent(this, EVENT));

    List<DeadEvent> events = catcher.getEvents();
    assertEquals(""The explicit DeadEvent should be delivered."",
        1, events.size());
    assertEquals(""The dead event must not be re-wrapped."",
        EVENT, events.get(0).event);
  }",Eager Test
"@Test public void missingSubscribe() {
    bus.register(new Object());
  }",No Smells
"@Test public void polymorphicDistribution() {
    // Three catchers for related types String, Object, and Comparable<?>.
    // String isa Object
    // String isa Comparable<?>
    // Comparable<?> isa Object
    StringCatcher stringCatcher = new StringCatcher();

    final List<Object> objectEvents = new ArrayList<Object>();
    Object objCatcher = new Object() {
      @SuppressWarnings(""unused"")
      @Subscribe public void eat(Object food) {
        objectEvents.add(food);
      }",Eager Test
"@Test public void producerUnregisterAllowsReregistering() {
    StringProducer producer1 = new StringProducer();
    StringProducer producer2 = new StringProducer();

    bus.register(producer1);
    bus.unregister(producer1);
    bus.register(producer2);
  }",Eager Test
"@Test public void exceptionWrapping() throws NoSuchMethodException {
    Method method = getExceptionThrowingMethod();
    EventHandler handler = new EventHandler(this, method);

    try {
      handler.handleEvent(new Object());
      fail(""Handlers whose methods throw must throw InvocationTargetException"");
    }",No Smells
"@Test public void rejectionOfNullTargets() throws NoSuchMethodException {
    Method method = getRecordingMethod();
    try {
      new EventHandler(null, method);
      fail(""EventHandler must immediately reject null targets."");
    }",No Smells
"@Test public void returnValueNotCached() throws Exception {
    Method method = getRecordingMethod();
    EventProducer producer = new EventProducer(this, method);
    producer.produceEvent();
    methodReturnValue = new Object();
    methodCalled = false;
    Object secondReturnValue = producer.produceEvent();

    assertTrue(""Producer must call provided method twice."", methodCalled);
    assertSame(""Producer result must be *exactly* the specified return value on each invocation."",
        secondReturnValue, methodReturnValue);
  }",Eager Test
"@Test public void allowsKeyAndValueWhenNeitherIsNull() {
        assertTrue(generator.okToAdd(new Object(), new Object()));
    }",No Smells
"@Test public void disallowsNullKeyAndNullValue() {
        assertFalse(generator.okToAdd(null, null));
    }",No Smells
"@Test public void addingComponentsDoesNothing() {
        generator.addComponentGenerators(emptyList());
    }",No Smells
"@Test public void noComponents() {
        assertFalse(generator.hasComponents());
    }",No Smells
"@Test public void manySourcesOfMany() {
        CartesianIterator<Integer> iter =
            new CartesianIterator<>(
                asList(
                    asList(0, 1, 2, 3, 4).iterator(),
                    asList(5, 6).iterator(),
                    asList(7, 8, 9).iterator(),
                    asList(10, 11, 12).iterator()));

        List<List<Integer>> result = newArrayList(iter);

        assertEquals(
            asList(
                asList(0, 5, 7, 10), asList(1, 5, 7, 10), asList(2, 5, 7, 10), asList(3, 5, 7, 10), asList(4, 5, 7, 10),
                asList(0, 6, 7, 10), asList(1, 6, 7, 10), asList(2, 6, 7, 10), asList(3, 6, 7, 10), asList(4, 6, 7, 10),
                asList(0, 5, 8, 10), asList(1, 5, 8, 10), asList(2, 5, 8, 10), asList(3, 5, 8, 10), asList(4, 5, 8, 10),
                asList(0, 6, 8, 10), asList(1, 6, 8, 10), asList(2, 6, 8, 10), asList(3, 6, 8, 10), asList(4, 6, 8, 10),
                asList(0, 5, 9, 10), asList(1, 5, 9, 10), asList(2, 5, 9, 10), asList(3, 5, 9, 10), asList(4, 5, 9, 10),
                asList(0, 6, 9, 10), asList(1, 6, 9, 10), asList(2, 6, 9, 10), asList(3, 6, 9, 10), asList(4, 6, 9, 10),
                asList(0, 5, 7, 11), asList(1, 5, 7, 11), asList(2, 5, 7, 11), asList(3, 5, 7, 11), asList(4, 5, 7, 11),
                asList(0, 6, 7, 11), asList(1, 6, 7, 11), asList(2, 6, 7, 11), asList(3, 6, 7, 11), asList(4, 6, 7, 11),
                asList(0, 5, 8, 11), asList(1, 5, 8, 11), asList(2, 5, 8, 11), asList(3, 5, 8, 11), asList(4, 5, 8, 11),
                asList(0, 6, 8, 11), asList(1, 6, 8, 11), asList(2, 6, 8, 11), asList(3, 6, 8, 11), asList(4, 6, 8, 11),
                asList(0, 5, 9, 11), asList(1, 5, 9, 11), asList(2, 5, 9, 11), asList(3, 5, 9, 11), asList(4, 5, 9, 11),
                asList(0, 6, 9, 11), asList(1, 6, 9, 11), asList(2, 6, 9, 11), asList(3, 6, 9, 11), asList(4, 6, 9, 11),
                asList(0, 5, 7, 12), asList(1, 5, 7, 12), asList(2, 5, 7, 12), asList(3, 5, 7, 12), asList(4, 5, 7, 12),
                asList(0, 6, 7, 12), asList(1, 6, 7, 12), asList(2, 6, 7, 12), asList(3, 6, 7, 12), asList(4, 6, 7, 12),
                asList(0, 5, 8, 12), asList(1, 5, 8, 12), asList(2, 5, 8, 12), asList(3, 5, 8, 12), asList(4, 5, 8, 12),
                asList(0, 6, 8, 12), asList(1, 6, 8, 12), asList(2, 6, 8, 12), asList(3, 6, 8, 12), asList(4, 6, 8, 12),
                asList(0, 5, 9, 12), asList(1, 5, 9, 12), asList(2, 5, 9, 12), asList(3, 5, 9, 12), asList(4, 5, 9, 12),
                asList(0, 6, 9, 12), asList(1, 6, 9, 12), asList(2, 6, 9, 12), asList(3, 6, 9, 12), asList(4, 6, 9, 12)
            ),
            result);
    }",Eager Test
"@Test public void manySourcesOfOne() {
        CartesianIterator<Integer> iter =
            new CartesianIterator<>(
                asList(
                    singletonList(1).iterator(),
                    singletonList(2).iterator(),
                    singletonList(3).iterator(),
                    singletonList(4).iterator()));

        List<List<Integer>> result = newArrayList(iter);

        assertEquals(singletonList(asList(1, 2, 3, 4)), result);
    }",Eager Test
"@Test public void oneSourceOfManyAtPositionMid() {
        CartesianIterator<Integer> iter =
            new CartesianIterator<>(
                asList(
                    singletonList(1).iterator(),
                    singletonList(2).iterator(),
                    asList(3, 4, 5).iterator(),
                    singletonList(6).iterator()));

        List<List<Integer>> result = newArrayList(iter);

        assertEquals(
            asList(
                asList(1, 2, 3, 6),
                asList(1, 2, 4, 6),
                asList(1, 2, 5, 6)),
            result);
    }",Eager Test
"@Test public void singleSourceIsEmpty() {
        CartesianIterator<Integer> iter =
            new CartesianIterator<>(singletonList(emptyIterator()));

        List<List<Integer>> result = newArrayList(iter);

        assertEquals(0, result.size());
    }",Eager Test
"@Test public void inRangeMinOnlyOnBound() {
        assertTrue(inRangeMinOnly.test(-3));
    }",Eager Test
"@Test public void inRangeUnbounded() {
        assertTrue(inRangeUnbounded.test(2));
    }",Eager Test
"@Test public void leastMagnitudeBothLessThanZero() {
        assertEquals(
            Integer.valueOf(-1),
            Comparables.leastMagnitude(-4, -1, 0));
    }",Eager Test
"@Test public void leastMagnitudePositiveMaxOnly() {
        assertEquals(
            Integer.valueOf(0),
            Comparables.leastMagnitude(null, 5, 0));
    }",Eager Test
"@Test public void leastMagnitudeStraddlingZero() {
        assertEquals(
            Integer.valueOf(0),
            Comparables.leastMagnitude(-2, 4, 0));
    }",Eager Test
"@Test public void whenExpressionContainsAnUndefinedVariable() {
        evaluator = new ConstraintEvaluator(""#x == -3"");
        evaluator.bind(-3);

        assertThrows(
            EvaluationException.class,
            () -> evaluator.evaluate());
    }",No Smells
"@Test public void whenExpressionIsMalformed() {
        assertThrows(
            EvaluationException.class,
            () -> new ConstraintEvaluator(""#_ !*@&#^*""));
    }",No Smells
"@Test public void capabilityOfShrinkingArrayOfIdenticalComponentType() {
        assertTrue(intArrayGenerator.canShrink(new int[0]));
    }",No Smells
"@Test public void
    capabilityOfShrinkingFalseIfNoComponentsCanShrinkAValue() {
        when(first.canShrink(8)).thenReturn(false);
        when(second.canShrink(8)).thenReturn(false);
        when(third.canShrink(8)).thenReturn(false);

        assertFalse(composite.canShrink(8));
    }",No Smells
"@Test public void capabilityOfShrinkingNonEnum() {
        assertFalse(generator.canShrink(new Object()));
    }",No Smells
"@Test public void whenDiscardRatioExceededEvenWithSomeSuccesses()
        throws Exception {

        PropertyParameterContext parameter =
            new PropertyParameterContext(
                ParameterTypeContext.forParameter(parameter()))
                    .annotate(annotatedElement());

        PropertyParameterGenerationContext gen =
            new PropertyParameterGenerationContext(
                parameter,
                new GeneratorRepository(random).register(new Countdown()),
                new GeometricDistribution(),
                random,
                new TupleParameterSampler(20));

        DiscardRatioExceededException ex =
            assertThrows(
                DiscardRatioExceededException.class,
                () -> {
                    while (gen.attempts() < 100)
                        gen.generate();
                }",Eager Test
"@Test public void nonZeroMeanProbability() {
        assertEquals(1 / 6D, distro.probabilityOfMean(6), 0);
    }",No Smells
"@Test public void sampleWithCertainProbability() {
        assertEquals(0, distro.sample(1, random));
    }",No Smells
"@Test public void sampleWithNonCertainProbability() {
        when(random.nextDouble()).thenReturn(0.88);

        assertEquals(10, distro.sample(0.2, random));
    }",No Smells
"@Test public void choosingFromEmptyCollection() {
        assertThrows(
            IllegalArgumentException.class,
            () -> Items.choose(emptyList(), random));
    }",No Smells
"@Test public void removalsFromAnEmptyList() {
        assertEquals(emptyList(), Lists.removeFrom(emptyList(), 1));
    }",No Smells
"@Test public void shrinksOfNonEmptyList() {
        List<List<Integer>> shrinks =
            Lists.shrinksOfOneItem(
                random,
                newArrayList(1, 2, 3),
                (r, i) -> {
                    assumeThat(r, sameInstance(random));
                    return newArrayList(4, 5);
                }",No Smells
"@Test public void chooseLongsMustReturnValuesInTheExpectedRange() {
        assertRangeOfRandomLong(-10L, 100L);
        assertRangeOfRandomLong(1L, 1L);
        assertRangeOfRandomLong(Long.MIN_VALUE, Long.MIN_VALUE + 1);
        assertRangeOfRandomLong(Long.MAX_VALUE - 1, Long.MAX_VALUE);
        assertRangeOfRandomLong(Long.MIN_VALUE, Long.MAX_VALUE);
    }",No Smells
"@Test public void weakSanityCheckForDistributionOfChooseLongs() {
        boolean[] hits = new boolean[5];
        SourceOfRandomness random = new SourceOfRandomness(new Random(0));

        for (int i = 0; i < 100; i++) {
            int index =
                (int) Ranges.choose(random, 0, (long) hits.length - 1);
            hits[index] = true;
        }",Eager Test
"@Test public void aClassIsNotASingleAbstractMethodType() {
        assertNull(singleAbstractMethodOf(String.class));
    }",No Smells
"@Test public void
    anInterfaceThatOverridesHashCodeIsNotASingleAbstractMethodType() {
        assertNull(singleAbstractMethodOf(OverridingHashCode.class));
    }",No Smells
"@Test public void
    anInterfaceWithASingleAbstractMethodIsASingleAbstractMethodType()
    throws Exception {
        assertEquals(
            Comparator.class.getMethod(""compare"", Object.class, Object.class),
            singleAbstractMethodOf(Comparator.class));
    }",No Smells
"@Test public void findingSingleAccessibleConstructorSuccessfully() {
        Constructor<Object> ctor = singleAccessibleConstructor(Object.class);

        assertEquals(0, ctor.getParameterTypes().length);
    }",No Smells
"@Test public void invokingMethodPropagatesIllegalArgumentException() {
        assertThrows(
            IllegalArgumentException.class,
            () -> invoke(findMethod(getClass(), ""bar""), this, ""baz""));
    }",No Smells
"@Test public void
    invokingNonZeroArgConstructorQuietlyPropagatesIllegalArgumentException() {
        assertThrows(
            IllegalArgumentException.class,
            () -> instantiate(
                Integer.class.getDeclaredConstructor(int.class),
                ""2""));
    }",No Smells
"@Test public void
    invokingNonZeroArgConstructorQuietlyWrapsIllegalAccessException() {
        ReflectionException ex =
            assertThrows(
                ReflectionException.class,
                () -> instantiate(
                    MultiArgIllegalAccessProblematic.class
                        .getDeclaredConstructor(int.class),
                    2));
        assertThat(
            ex.getMessage(),
            containsString(IllegalAccessException.class.getName()));
    }",No Smells
"@Test public void
    invokingNonZeroArgConstructorQuietlyWrapsInstantiationException() {
        ReflectionException ex =
            assertThrows(
                ReflectionException.class,
                () -> instantiate(
                    MultiArgInstantiationProblematic.class
                        .getConstructor(int.class),
                    2));
        assertThat(
            ex.getMessage(),
            containsString(InstantiationException.class.getName()));
    }",No Smells
"@Test public void settingInaccessibleFieldBypassingProtection()
        throws Exception {

        WithInaccessibleField target = new WithInaccessibleField();

        setField(target.getClass().getDeclaredField(""i""), target, 3, true);

        assertEquals(3, target.i);
    }",No Smells
"@Test public void shouldNotCallOnFailingSetHookIfTestSucceeds() {
        assumeThat(testResult(SuccessfulTest.class), isSuccessful());

        assertEquals(0, StoreFailingSetInGlobalVariable.counter);
        assertNull(StoreFailingSetInGlobalVariable.counterexample);
    }",No Smells
"@Test
    public void testHasChangesAlterEdgeLabel() {
        mutation.alterEdgeLabel(""newEdgeLabel"");
        assertTrue(""should have changes"", mutation.hasChanges());
    }",No Smells
"@Test
    public void testDisallowLeadingWildcardsInQueryString() {
        graph.prepareVertex(""v1"", VISIBILITY_A).setProperty(""prop1"", ""value1"", VISIBILITY_A).save(AUTHORIZATIONS_A);
        graph.flush();

        try {
            graph.query(""*alue1"", AUTHORIZATIONS_A).limit(0).search().getTotalHits();
            fail(""Wildcard prefix of query string should have caused an exception"");
        }",No Smells
"@Test
    public void testQueryExecutionCountWhenPaging() {
        graph.prepareVertex(""v1"", VISIBILITY_A).save(AUTHORIZATIONS_A);
        graph.prepareVertex(""v2"", VISIBILITY_A).save(AUTHORIZATIONS_A);
        graph.flush();

        long startingNumQueries = getNumQueries();

        QueryResultsIterable<Vertex> vertices = graph.query(AUTHORIZATIONS_A).vertices();
        assertEquals(startingNumQueries, getNumQueries());

        assertResultsCount(2, 2, vertices);
        assertEquals(startingNumQueries + 2, getNumQueries());

        vertices = graph.query(AUTHORIZATIONS_A).limit(1).vertices();
        assertEquals(startingNumQueries + 4, getNumQueries());

        assertResultsCount(1, 2, vertices);
        assertEquals(startingNumQueries + 4, getNumQueries());

        vertices = graph.query(AUTHORIZATIONS_A).limit(10).vertices();
        assertEquals(startingNumQueries + 6, getNumQueries());

        assertResultsCount(2, 2, vertices);
        assertEquals(startingNumQueries + 6, getNumQueries());
    }",No Smells
"@Test
    public void testQueryExecutionCountWhenScrollingApi() {
        Elasticsearch5SearchIndex searchIndex = (Elasticsearch5SearchIndex) ((GraphWithSearchIndex) graph).getSearchIndex();
        searchIndex.getConfig().getGraphConfiguration().set(GraphConfiguration.SEARCH_INDEX_PROP_PREFIX + ""."" + ElasticsearchSearchIndexConfiguration.QUERY_PAGE_SIZE, 1);

        graph.prepareVertex(""v1"", VISIBILITY_A).save(AUTHORIZATIONS_A);
        graph.prepareVertex(""v2"", VISIBILITY_A).save(AUTHORIZATIONS_A);
        graph.flush();

        long startingNumQueries = getNumQueries();

        QueryResultsIterable<Vertex> vertices = graph.query(AUTHORIZATIONS_A).vertices();
        assertResultsCount(2, vertices);
        assertEquals(startingNumQueries + 4, getNumQueries());

        searchIndex = (Elasticsearch5SearchIndex) ((GraphWithSearchIndex) graph).getSearchIndex();
        searchIndex.getConfig().getGraphConfiguration().set(GraphConfiguration.SEARCH_INDEX_PROP_PREFIX + ""."" + ElasticsearchSearchIndexConfiguration.QUERY_PAGE_SIZE, 2);

        graph.prepareVertex(""v3"", VISIBILITY_A).save(AUTHORIZATIONS_A);
        graph.flush();

        vertices = graph.query(AUTHORIZATIONS_A).vertices();
        assertResultsCount(3, vertices);
        assertEquals(startingNumQueries + 8, getNumQueries());
    }",Eager Test
"@Test
    public void testEncode() {
        // validated using https://www.tools4noobs.com/online_tools/ascii85_encode/
        assertEquals(""<+oue+DGm>@3BZ'F*%"", Ascii85.encode(""This is a test"".getBytes()));
        assertEquals("";f?Ma+E)@8ATAo8ATMr9G%#30AH"", Ascii85.encode(""Some other test value"".getBytes()));
    }",No Smells
"@Test
    public void testHasChangesProperties() {
        mutation.addPropertyValue(""key1"", ""name1"", ""value1"", new Visibility(""""));
        assertTrue(""should have changes"", mutation.hasChanges());
    }",No Smells
"@Test
    public void testInflate() {
        String test = testSubject.inflate(SimpleNameSubstitutionStrategy.wrap(VALUE1));
        assertThat(test, is(KEY1));
    }",No Smells
"@Test
    public void testInflateCache() {
        assertEquals(0, testSubject.getInflateCacheMisses());
        assertEquals(0, testSubject.getInflateCalls());

        testSubject.inflate(SimpleNameSubstitutionStrategy.wrap(VALUE1));
        assertEquals(1, testSubject.getInflateCacheMisses());
        assertEquals(1, testSubject.getInflateCalls());

        testSubject.inflate(SimpleNameSubstitutionStrategy.wrap(VALUE1));
        assertEquals(1, testSubject.getInflateCacheMisses());
        assertEquals(2, testSubject.getInflateCalls());
    }",No Smells
"@Test
    public void testSubstitutionIsInvertible() {
        String test = testSubject.inflate(testSubject.deflate(KEY1));
        assertThat(test, is(KEY1));
    }",No Smells
"@Test
    public void testHasChangesProperties() {
        mutation.addPropertyValue(""key1"", ""name1"", ""Hello"", new Visibility(""""));
        assertTrue(""should have changes"", mutation.hasChanges());
    }",No Smells
"@Test
    public void testHasChangesSetPropertyMetadata() {
        mutation.setPropertyMetadata(""key1"", ""name1"", ""value"", new Visibility(""""));
        assertTrue(""should have changes"", mutation.hasChanges());
    }",No Smells
"@Test
    public void testHasChangesSoftDeleteProperty() {
        mutation.softDeleteProperty(new MutablePropertyImpl(
            ""key1"",
            ""name1"",
            ""value"",
            null,
            null,
            null,
            new Visibility(""""),
            FetchHints.ALL
        ));
        assertTrue(""should have changes"", mutation.hasChanges());
    }",No Smells
"@Test
    public void testHashCode() {
        IdRange range = new IdRange(null, null);
        range.hashCode();

        range = new IdRange(""a"", null);
        range.hashCode();

        range = new IdRange(null, ""a"");
        range.hashCode();

        range = new IdRange(""a"", ""a"");
        range.hashCode();
    }",No Smells
"@Test
    public void testIsInRange() throws Exception {
        IdRange range = new IdRange(""b"", ""c"");
        assertTrue(range.isInRange(""b""));
        assertTrue(range.isInRange(""ba""));
        assertFalse(range.isInRange(""c""));

        range = new IdRange(null, ""c"");
        assertTrue(range.isInRange(""b""));
        assertFalse(range.isInRange(""c""));

        range = new IdRange(""b"", null);
        assertFalse(range.isInRange(""az""));
        assertTrue(range.isInRange(""b""));

        range = new IdRange(""b"", true, ""c"", true);
        assertTrue(range.isInRange(""b""));
        assertTrue(range.isInRange(""ba""));
        assertTrue(range.isInRange(""c""));

        range = new IdRange(""b"", false, ""c"", false);
        assertFalse(range.isInRange(""b""));
        assertTrue(range.isInRange(""ba""));
        assertFalse(range.isInRange(""c""));

        range = new IdRange(""b"", true, ""c"", false);
        assertTrue(range.isInRange(""b""));
        assertTrue(range.isInRange(""ba""));
        assertFalse(range.isInRange(""c""));

        range = new IdRange(""b"", false, ""c"", true);
        assertFalse(range.isInRange(""b""));
        assertTrue(range.isInRange(""ba""));
        assertTrue(range.isInRange(""c""));
    }",No Smells
"@Test
    public void testLongString() {
        System.out.println(""testLongString"");
        timeItLongString(new KryoVertexiumSerializer());
        long quickKryoTime = timeItLongString(new QuickKryoVertexiumSerializer(graphConfiguration));
        long kryoTime = timeItLongString(new KryoVertexiumSerializer());
        assertTiming(quickKryoTime, kryoTime);
    }",No Smells
"@Test
    public void testTestClassQuick() {
        TestClass testClass = new TestClass(""value1"", 42);
        QuickKryoVertexiumSerializer serializer = new QuickKryoVertexiumSerializer(graphConfiguration);
        byte[] v = serializer.objectToBytes(testClass);
        assertEquals(testClass, serializer.bytesToObject(v));
    }",Eager Test
"@Test
    public void existingFileShouldBeDeletedWhenStreamIsClosed() throws IOException {
        file = File.createTempFile(getClass().getSimpleName(), null);
        file.deleteOnExit();

        AutoDeleteFileInputStream adFileInputStream = new AutoDeleteFileInputStream(file);
        assertTrue(file.exists());

        adFileInputStream.close();
        assertFalse(file.exists());
    }",Eager Test
"@Test
    public void currentTimeMillisReturnsEverIncreasingTime() {
        List<Long> times = new ArrayList<>(NUM_ITERATIONS);
        // iterate without sleeping to insure IncreasingTime will encounter duplicate system times.
        for (int i = 0; i < NUM_ITERATIONS; i++) {
            times.add(IncreasingTime.currentTimeMillis());
        }",Eager Test
"@Test
    public void testText() throws Exception {


        final AtomicBoolean connected = new AtomicBoolean(false);

        final ServletContainer container = ServletContainer.Factory.newInstance();

        DeploymentUtils.setupServlet(new ServletInfo(""websocket"", WebSocketServlet.class,
                new ImmediateInstanceFactory<Servlet>(new WebSocketServlet(new WebSocketConnectionCallback() {
                    @Override
                    public void onConnect(final WebSocketHttpExchange exchange, final WebSocketChannel channel) {
                        connected.set(true);
                        channel.getReceiveSetter().set(new AbstractReceiveListener() {

                            @Override
                            protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage message) throws IOException {
                                final String string = message.getData();
                                if(string.equals(""hello"")) {
                                    WebSockets.sendText(""world"", channel, null);
                                }",Eager Test + Mystery Guest
"@Test
    public void testAnnotatedClientEndpoint() throws Exception {
        AnnotatedClientEndpoint.reset();
        Session session = deployment.connectToServer(AnnotatedClientEndpoint.class, new URI(""ws://"" + DefaultServer.getHostAddress(""default"") + "":"" + DefaultServer.getHostPort(""default"") + ""/ws/chat/Bob""));

        Assert.assertEquals(""hi Bob (protocol=foo)"", AnnotatedClientEndpoint.message());

        session.close();
        Assert.assertEquals(""CLOSED"", AnnotatedClientEndpoint.message());
    }",No Smells
"@Test
    public void testClientSideIdleTimeout() throws Exception {
        //make a sub class
        CountDownLatch latch = new CountDownLatch(1);
        CloseCountdownEndpoint c = new CloseCountdownEndpoint(latch);

        Session session = deployment.connectToServer(c, new URI(""ws://"" + DefaultServer.getHostAddress(""default"") + "":"" + DefaultServer.getHostPort(""default"") + ""/ws/chat/Bob""));
        session.setMaxIdleTimeout(100);
        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS));
        Assert.assertFalse(session.isOpen());

    }",Eager Test
"@Test
    public void testEncodingAndDecodingBinary() throws Exception {
        final byte[] payload = ""hello"".getBytes();
        final FutureResult<?> latch = new FutureResult<>();

        WebSocketTestClient client = new WebSocketTestClient(WebSocketVersion.V13, new URI(""ws://"" + DefaultServer.getHostAddress(""default"") + "":"" + DefaultServer.getHostPort(""default"") + ""/ws/encoding/Stuart""));
        client.connect();
        client.send(new BinaryWebSocketFrame(Unpooled.wrappedBuffer(payload)), new FrameChecker(TextWebSocketFrame.class, ""hello Stuart"".getBytes(), latch));
        latch.getIoFuture().get();
        client.destroy();
    }",Eager Test
"@Test
  public void acceptedClientIdAutoGenerated(TestContext context) {

    this.expectedReturnCode = MqttConnectReturnCode.CONNECTION_ACCEPTED;

    try {
      MemoryPersistence persistence = new MemoryPersistence();
      MqttClient client = new MqttClient(String.format(""tcp://%s:%d"", MQTT_SERVER_HOST, MQTT_SERVER_PORT), """", persistence);
      client.connect();
    }",Eager Test
"@Test
  public void refusedServerUnavailable(TestContext context) {

    this.expectedReturnCode = MqttConnectReturnCode.CONNECTION_REFUSED_SERVER_UNAVAILABLE;

    try {
      MemoryPersistence persistence = new MemoryPersistence();
      MqttClient client = new MqttClient(String.format(""tcp://%s:%d"", MQTT_SERVER_HOST, MQTT_SERVER_PORT), ""12345"", persistence);
      client.connect();
      context.fail();
    }",Eager Test
"@Test
  public void refusedUnacceptableProtocolVersion(TestContext context) {

    this.expectedReturnCode = MqttConnectReturnCode.CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION;

    try {
      MemoryPersistence persistence = new MemoryPersistence();
      MqttConnectOptions options = new MqttConnectOptions();
      // trying the old 3.1
      options.setMqttVersion(MqttConnectOptions.MQTT_VERSION_3_1);
      MqttClient client = new MqttClient(String.format(""tcp://%s:%d"", MQTT_SERVER_HOST, MQTT_SERVER_PORT), ""12345"", persistence);
      client.connect(options);
      context.fail();
    }",Eager Test
"@Test
    public void testFieldHasValue() {
        String stringValue = ""value1"";
        Integer intValue = 1;
        long longValue = 2L;
        Float floatValue = 4.7f;
        double doubleValue = 3.5d;
        List<String> listValue = Arrays.asList(""some"", ""list"");
        ImmutableMap<String, String> mapValue = ImmutableMap.of(""some"", ""map"");
        String templateValue = ""{{templateField}",Eager Test
"@Test
    public void testFieldTypeList() {
        FieldTypeCondition isListCondition = new FieldTypeCondition(""testField"", ""list"");

        verifyFalse(isListCondition, ""otherField"",""otherValue"");
        verifyFalse(isListCondition, ""testField"", null);
        verifyFalse(isListCondition, ""testField"", 5);
        verifyFalse(isListCondition, ""testField"", new HashMap<>());
        verifyFalse(isListCondition, ""testField"", """");
        verifyFalse(isListCondition, ""testField"", ""some text"");
        verifyFalse(isListCondition, ""testField"", ""4.20"");
        verifyFalse(isListCondition, ""testField"", 4.20);
        verifyFalse(isListCondition, ""testField"", -4.20);

        verifyTrue(isListCondition, ""testField"", new ArrayList<>());
    }",No Smells
"@Test
    public void testFieldTypeLong() {
        FieldTypeCondition isLongCondition = new FieldTypeCondition(""testField"", ""Long"");

        verifyFalse(isLongCondition, ""otherField"", ""otherValue"");
        verifyFalse(isLongCondition, ""testField"", new HashMap<>());
        verifyFalse(isLongCondition, ""testField"", null);
        verifyFalse(isLongCondition, ""testField"", new ArrayList<>());
        verifyFalse(isLongCondition, ""testField"", """");
        verifyFalse(isLongCondition, ""testField"", ""some text"");
        verifyFalse(isLongCondition, ""testField"", ""4.20"");
        verifyFalse(isLongCondition, ""testField"", 4.20);
        verifyFalse(isLongCondition, ""testField"", -4.20);
        verifyFalse(isLongCondition, ""testField"", ""5"");

        verifyTrue(isLongCondition, ""testField"", 5);
        verifyTrue(isLongCondition, ""testField"", -5);
    }",No Smells
"@Test
    public void testWrongConfigs() {
        FieldTypeCondition.Factory factory = new FieldTypeCondition.Factory();
        Map<String,Object> config = new HashMap<>();
        config.put(""path"", ""fieldName"");
        config.put(""type"", ""balagan"");

        assertThatThrownBy(() ->factory.create(config, null)).isInstanceOf(ProcessorConfigurationException.class)
                .hasMessageContaining(""type [balagan] must be one of"");

        config.put(""type"", """");
        assertThatThrownBy(() ->factory.create(config, null)).isInstanceOf(ProcessorConfigurationException.class)
                .hasMessageContaining(""type [] must be one of"");

        assertThatThrownBy(() -> new FieldTypeCondition(""path"", ""not-a-valid-type"")).isInstanceOf(ProcessorConfigurationException.class)
                .hasMessageContaining(""type [not-a-valid-type] must be one of"");

        assertThatThrownBy(() -> new FieldTypeCondition(null, ""not-a-valid-type"")).isInstanceOf(ProcessorConfigurationException.class)
                .hasMessageContaining(""failed to parse fieldType condition, could not resolve field path"");

        assertThatThrownBy(() -> new FieldTypeCondition(""path"", null)).isInstanceOf(ProcessorConfigurationException.class)
                .hasMessageContaining(""failed to parse fieldType condition, could not resolve field type"");
    }",No Smells
"@Test
    public void testFieldNotExists() {
        String field = ""field1"";
        String value = ""value1"";

        InCondition inCondition = new InCondition(field, value);

        Doc doc = createDoc(""field2"", ""value2"");

        assertThat(inCondition.evaluate(doc)).isFalse();
    }",Eager Test
"@Test
    public void testInvalidRegex() {
        String field = ""field1"";
        String invalidRegexEscaping = ""Wed\\""+'x';
        assertThatThrownBy(() -> new MatchRegexCondition(field, invalidRegexEscaping, false, false))
                .isInstanceOf(PatternSyntaxException.class)
                .hasMessageContaining(""Illegal hexadecimal escape sequence near index"");

        String invalidRegex = ""[]"";
        assertThatThrownBy(() -> new MatchRegexCondition(field, invalidRegex, false, false))
                .isInstanceOf(PatternSyntaxException.class)
                .hasMessageContaining(""Unclosed character class near index"");
    }",Eager Test
"@Test
    public void testGte() {
        String field = ""field1"";
        Long gte = 10l;


        Map<String, Object> config = createConfig(""field"", field,
                ""gte"", gte);
        MathComparatorCondition mathComparatorCondition = new MathComparatorCondition.Factory().create(config, conditionParser);

        Doc doc = createDoc(""field1"", 15l);
        assertThat(mathComparatorCondition.evaluate(doc)).isTrue();

        doc = createDoc(""field1"", 10);
        assertThat(mathComparatorCondition.evaluate(doc)).isTrue();

        doc = createDoc(""field1"", 5l);
        assertThat(mathComparatorCondition.evaluate(doc)).isFalse();
    }",Eager Test + Mystery Guest
"@Test
    public void testGtAndLt() {
        String field = ""field1"";
        Long lt = 20l;
        Long gt = 10l;


        Map<String, Object> config = createConfig(""field"", field,
                ""lt"", lt,
                ""gt"", gt);
        MathComparatorCondition mathComparatorCondition = new MathComparatorCondition.Factory().create(config, conditionParser);

        Doc doc = createDoc(""field1"", 15l);
        assertThat(mathComparatorCondition.evaluate(doc)).isTrue();

        doc = createDoc(""field1"", 10);
        assertThat(mathComparatorCondition.evaluate(doc)).isFalse();

        doc = createDoc(""field1"", 20);
        assertThat(mathComparatorCondition.evaluate(doc)).isFalse();

        doc = createDoc(""field1"", 5l);
        assertThat(mathComparatorCondition.evaluate(doc)).isFalse();

        doc = createDoc(""field1"", 25l);
        assertThat(mathComparatorCondition.evaluate(doc)).isFalse();
    }",Eager Test + Mystery Guest
"@Test
    public void testLte() {
        String field = ""field1"";
        Long lte = 10l;


        Map<String, Object> config = createConfig(""field"", field,
                ""lte"", lte);
        MathComparatorCondition mathComparatorCondition = new MathComparatorCondition.Factory().create(config, conditionParser);

        Doc doc = createDoc(""field1"", 15l);
        assertThat(mathComparatorCondition.evaluate(doc)).isFalse();

        doc = createDoc(""field1"", 10);
        assertThat(mathComparatorCondition.evaluate(doc)).isTrue();

        doc = createDoc(""field1"", 5l);
        assertThat(mathComparatorCondition.evaluate(doc)).isTrue();
    }",Eager Test + Mystery Guest
"@Test
    public void testNotFalse() {
        NotCondition notCondition = new NotCondition(Collections.singletonList(c -> false));
        Doc doc = createDoc(""field1"", ""value1"");

        assertThat(notCondition.evaluate(doc)).isTrue();
    }",No Smells
"@Test
    public void testHasField() {
        Doc doc = createDoc(""int"", 15, ""String"", ""test"", ""object"",
                JsonUtils.createMap(""nestedField"", ""nestedValue"")
        );

        assertThat(doc.hasField(""int"")).isTrue();
        assertThat(doc.hasField(""notExists"")).isFalse();
        assertThat(doc.hasField(""notExists"", String.class)).isFalse();
        assertThat(doc.hasField(""int"", Integer.class)).isTrue();
        assertThat(doc.hasField(""int"", String.class)).isFalse();
        assertThat(doc.hasField(""String"", String.class)).isTrue();
        assertThat(doc.hasField(""String"", Integer.class)).isFalse();
        assertThat(doc.hasField(""object.nestedField"", String.class)).isTrue();

    }",No Smells
"@Test
    public void testParseConditionalExecutionStep() {
        List<ExecutionStepDefinition> executionStepDefinitionList = Collections.singletonList(
                new ConditionalExecutionStepDefinition(
                        createAndExistsConditionDefinition(),
                        Collections.singletonList(
                                createAddTagStepDefinition()
                        ),
                        Collections.singletonList(
                                createAddTagStepDefinition()
                        )));

        List<ExecutionStep> executionSteps = executionStepsParser.parse(executionStepDefinitionList);
        assertThat(executionSteps.size()).isEqualTo(1);

        ConditionalExecutionStep conditionalExecutionStep = (ConditionalExecutionStep) executionSteps.get(0);

        assertThat(conditionalExecutionStep.getCondition()).isInstanceOf(AndCondition.class);

        ProcessorExecutionStep onTrueExecutionStep = (ProcessorExecutionStep) conditionalExecutionStep.getOnTrue().get(0);
        assertThat(onTrueExecutionStep.getProcessor()).isInstanceOf(AddTagProcessor.class);

        ProcessorExecutionStep onFalseExecutionStep = (ProcessorExecutionStep) conditionalExecutionStep.getOnFalse().get(0);
        assertThat(onFalseExecutionStep.getProcessor()).isInstanceOf(AddTagProcessor.class);
    }",Eager Test
"@Test
    public void testParseOnFailureExecutionStep() {
        List<ExecutionStepDefinition> executionStepDefinitionList = Collections.singletonList(
                createAddTagStepDefinition(Collections.singletonList(
                        createAddTagStepDefinition()
                ))
        );

        List<ExecutionStep> executionSteps = executionStepsParser.parse(executionStepDefinitionList);

        ProcessorExecutionStep processorExecutionStep = (ProcessorExecutionStep) executionSteps.get(0);
        List<ExecutionStep> onFailureExecutionSteps = processorExecutionStep.getOnFailureExecutionSteps().get();

        assertThat(onFailureExecutionSteps.size()).isEqualTo(1);

        ProcessorExecutionStep onFailureExecutionStep = (ProcessorExecutionStep) onFailureExecutionSteps.get(0);
        assertThat(onFailureExecutionStep.getProcessor()).isInstanceOf(AddTagProcessor.class);
    }",Eager Test
"@Test
    public void testParseOnSuccessExecutionStep() {
        List<ExecutionStepDefinition> executionStepDefinitionList = Collections.singletonList(
                createAddTagStepDefinition(null, null, Collections.singletonList(createAddTagStepDefinition()))
        );

        List<ExecutionStep> executionSteps = executionStepsParser.parse(executionStepDefinitionList);

        ProcessorExecutionStep processorExecutionStep = (ProcessorExecutionStep) executionSteps.get(0);
        List<ExecutionStep> onSuccessExecutionSteps = processorExecutionStep.getOnSuccessExecutionSteps().get();

        assertThat(onSuccessExecutionSteps.size()).isEqualTo(1);

        ProcessorExecutionStep onSuccessExecutionStep = (ProcessorExecutionStep) onSuccessExecutionSteps.get(0);
        assertThat(onSuccessExecutionStep.getProcessor()).isInstanceOf(AddTagProcessor.class);
    }",Eager Test
"@Test
    public void testParseProcessorExecutionStep() {
        List<ExecutionStepDefinition> executionStepDefinitionList = Collections.singletonList(
                createAddTagStepDefinition()
        );

        List<ExecutionStep> executionSteps = executionStepsParser.parse(executionStepDefinitionList);
        assertThat(executionSteps.size()).isEqualTo(1);

        ProcessorExecutionStep processorExecutionStep = (ProcessorExecutionStep) executionSteps.get(0);
        assertThat(processorExecutionStep.getProcessor()).isInstanceOf(AddTagProcessor.class);

        Optional<List<ExecutionStep>> onFailureExecutionSteps = processorExecutionStep.getOnFailureExecutionSteps();
        assertThat(onFailureExecutionSteps.isPresent()).isFalse();
    }",Eager Test
"@Test
    public void testMultipleNamedCapturesWithSameName() throws InterruptedException {
        Map<String, String> bank = new HashMap<>();
        bank.put(""SINGLEDIGIT"", ""[0-9]"");
        Grok grok = new Grok(bank, ""%{SINGLEDIGIT:num}",Eager Test
"@Test
    public void testNumericCaptures() throws InterruptedException {
        Map<String, String> bank = new HashMap<>();
        bank.put(""BASE10NUM"", ""(?<![0-9.+-])(?>[+-]?(?:(?:[0-9]+(?:\\.[0-9]+)?)|(?:\\.[0-9]+)))"");
        bank.put(""NUMBER"", ""(?:%{BASE10NUM}",Eager Test
"@Test
    public void testConditionalElse() {
        String json = createJson(createMap(
                ""steps"", createList(
                        createMap(
                                ""if"", createMap(
                                        ""condition"", createMap(
                                                ""testCondition"", createMap(""value"", ""message1"")),
                                        ""then"", createList(
                                                createMap(""removeField"", createMap(
                                                        ""name"", ""on true"",
                                                        ""config"", createMap(""path"", ""field1"")
                                                ))
                                        ),
                                        ""else"", createList(
                                                createMap(""removeField"", createMap(
                                                        ""name"", ""on false"",
                                                        ""config"", createMap(""path"", ""field2"")
                                                ))
                                        )
                                ))
                )
        ));

        PipelineDefinition pipelineDefinition = PipelineDefinitionJsonParser.parse(json);
        assertThat(pipelineDefinition.getExecutionSteps().size()).isEqualTo(1);

        ConditionalExecutionStepDefinition executionStepDefinition =
                (ConditionalExecutionStepDefinition) pipelineDefinition.getExecutionSteps().get(0);

        List<ExecutionStepDefinition> onFalse = executionStepDefinition.getOnFalse().get();
        assertThat(onFalse.size()).isEqualTo(1);

        ProcessorExecutionStepDefinition onFalseProcessorExecutionStep = (ProcessorExecutionStepDefinition) onFalse.get(0);
        assertThat(onFalseProcessorExecutionStep.getName().get()).isEqualTo(""on false"");
        assertThat(onFalseProcessorExecutionStep.getOnFailureExecutionStepDefinitionList().isPresent()).isFalse();

        ProcessorDefinition processorDefinition2 = onFalseProcessorExecutionStep.getProcessorDefinition();
        assertThat(processorDefinition2.getType()).isEqualTo(""removeField"");
        assertThat(processorDefinition2.getConfig().get(""path"")).isEqualTo(""field2"");
    }",Eager Test
"@Test
    public void testConditionalExecutionStep() {
        String fieldExists1 = ""fieldExists1"";
        String fieldExists2 = ""fieldExists2"";
        String fieldToAdd = ""fieldToAdd"";
        String valueOnTrue = ""valueOnTrue"";
        String valueOnFalse = ""valueOnFalse"";

        Pipeline pipeline = createPipeline(createConditionalExecutionStep(
                createExistsCondition(fieldExists1, fieldExists2),
                createExecutionSteps(
                        createAddFieldExecutionStep(""newField1"", ""value1""),
                        createAddFieldExecutionStep(fieldToAdd, valueOnTrue)
                ),
                createExecutionSteps(
                        createAddFieldExecutionStep(""newField1"", ""value1""),
                        createAddFieldExecutionStep(fieldToAdd, valueOnFalse))));

        Doc doc1 = createDoc(fieldExists1, ""value1"", fieldExists2, ""value2"");
        ExecutionResult executionResult = pipelineExecutor.execute(pipeline, doc1);
        assertThat(executionResult.isSucceeded()).isTrue();
        assertThat(executionResult.isOvertime()).isFalse();
        assertThat(doc1.getSource().get(""newField1"")).isEqualTo(""value1"");
        String value1 = doc1.getField(fieldToAdd);
        assertThat(value1).isEqualTo(valueOnTrue);

        Doc doc2 = createDoc(fieldExists1, ""value3"");
        ExecutionResult executionResult2 = pipelineExecutor.execute(pipeline, doc2);
        assertThat(executionResult2.isSucceeded()).isTrue();
        assertThat(executionResult2.isOvertime()).isFalse();
        assertThat(doc2.getSource().get(""newField1"")).isEqualTo(""value1"");
        String value2 = doc2.getField(fieldToAdd);
        assertThat(value2).isEqualTo(valueOnFalse);
        assertThat(pipelineExecutorMetrics.getTotalDocsSucceededProcessing()).isEqualTo(2);
    }",Eager Test + Mystery Guest
"@Test
    public void testFailOnFailureExecutionStep() {
        Pipeline pipeline = createStopOnFailurePipeline(
                createAddFieldExecutionStep(""newField1"", ""value1""),
                createFailAlwaysExecutionStep(
                        createAddFieldExecutionStep(""newField2"", ""value2"")),
                        createFailAlwaysExecutionStep()
                );

        Doc doc = createDoc(""id"", ""testFailOnFailureExecutionStep"", ""message"", ""hola"");

        ExecutionResult executionResult = pipelineExecutor.execute(pipeline, doc);
        assertThat(executionResult.isSucceeded()).isFalse();

        assertThat(doc.getSource().get(""newField1"")).isEqualTo(""value1"");
        assertThat(doc.getSource().get(""newField2"")).isEqualTo(""value2"");
        assertThat(overtimeProcessingDocs.contains(doc)).isFalse();
        assertThat(executionResult.isOvertime()).isFalse();
        assertThat(pipelineExecutorMetrics.getTotalDocsFailedProcessing()).isEqualTo(1);
        assertThat(pipelineExecutorMetrics.getTotalDocsSucceededProcessing()).isEqualTo(0);
    }",Eager Test + Mystery Guest
"@Test
    public void testFailureWithException() {
        Pipeline pipeline = createStopOnFailurePipeline(
                createAddFieldExecutionStep(""newField1"", ""value1""),
                createFailAlwaysExecutionStep(new ProcessorExecutionException(""failProcessor"", new RuntimeException(""fail message"")))
        );
        Doc doc = createDoc(""id"", ""testFailureWithException"", ""message"", ""hola"",
                ""type"", ""test"");

        ExecutionResult result = pipelineExecutor.execute(pipeline, doc);
        assertThat(result.isSucceeded()).isFalse();
        assertThat(result.isOvertime()).isFalse();
        assertThat(result.getError().get().getException().isPresent()).isTrue();

        assertThat(doc.getSource().get(""newField1"")).isEqualTo(""value1"");
        assertThat(overtimeProcessingDocs.contains(doc)).isFalse();
        assertThat(pipelineExecutorMetrics.getTotalDocsFailedProcessing()).isEqualTo(1);
        assertThat(pipelineExecutorMetrics.getTotalDocsSucceededProcessing()).isEqualTo(0);
    }",Eager Test + Mystery Guest
"@Test
    public void testKillLongProcessingExecution() {
        Pipeline pipeline = createPipeline(
                createAddFieldExecutionStep(""newField1"", ""value1""),
                createSleepExecutionStep(EXPIRED_THRESHOLD_TIME_MS + 300)
        );
        Doc doc = createDoc(""id"", ""testKillLongProcessingExecution"", ""message"", ""hola"",
                ""type"", ""test"");

        ExecutionResult executionResult = pipelineExecutor.execute(pipeline, doc);
        assertThat(executionResult.isExpired()).isTrue();
        assertThat(Thread.currentThread().isInterrupted()).isFalse();

        assertThat(doc.getSource().get(""newField1"")).isEqualTo(""value1"");
        assertThat(overtimeProcessingDocs.contains(doc)).isTrue();
        assertThat(pipelineExecutorMetrics.getTotalDocsOvertimeProcessing()).isEqualTo(1);
        assertThat(pipelineExecutorMetrics.getTotalDocsProcessingExpired()).isEqualTo(1);
    }",Eager Test + Mystery Guest
"@Test
    public void testConditional() {
        String pipelineString = ""{"" +
                ""steps: [{"" +
                ""    if: {"" +
                ""        condition: {"" +
                ""            and: ["" +
                ""                {"" +
                ""                    testCondition.value: message1"" +
                ""                }",Eager Test
"@Test
    public void testBadConfig() {
        assertThatThrownBy(() -> createProcessor(AnonymizeProcessor.class, createConfig(""key"", key))).isInstanceOf(ProcessorConfigurationException.class);
        assertThatThrownBy(() -> createProcessor(AnonymizeProcessor.class, createConfig(""fields"", Arrays.asList(""1"")))).isInstanceOf(ProcessorConfigurationException.class);
    }",No Smells
"@Test
    public void testAppendValuesWhileFieldExist() {
        List<String> existingList = new ArrayList<>();
        existingList.add(EXISTING_VALUE);

        List<String> values = Arrays.asList(APPENDED_VALUE, ANOTHER_VALUE);
        AppendListProcessor appendListProcessor = createProcessor(AppendListProcessor.class, ""path"", FIELD_NAME, ""values"", values);
        Doc doc = createDoc(FIELD_NAME, existingList);

        assertThat(appendListProcessor.process(doc).isSucceeded()).isTrue();
        assertThat((List) doc.getField(FIELD_NAME)).isEqualTo(Arrays.asList(EXISTING_VALUE, APPENDED_VALUE, ANOTHER_VALUE));
    }",Eager Test + Mystery Guest
"@Test
    public void testAppendValuesWithTemplate() {
        List<String> values = Arrays.asList(ANOTHER_VALUE, ""{{"" + TEMPLATE_FIELD + ""}",Eager Test + Mystery Guest
"@Test
    public void testConvertToBoolean() {
        testConversion(""yes"", true);
    }",Eager Test
"@Test
    public void testConvertToDouble() {
        testConversion(""1.55"", 1.55d);
    }",No Smells
"@Test
    public void testConvertToDoubleDefaultIsZero() {
        testConversion(""-"", 0l);
    }",No Smells
"@Test
    public void testConvertToLongDefaultIsZero() {
        testConversion(""-"", 0L);
    }",No Smells
"@Test
    public void testFactoryOfSinglePath() {
        Map<String,Object> config = new HashMap<>();
        config.put(""path"", ""fieldName"");
        config.put(""type"", ""long"");

        ConvertFieldProcessor convertFieldProcessor = createProcessor(ConvertFieldProcessor.class, config);

        assertThat(convertFieldProcessor.getFieldType()).isEqualTo(FieldType.LONG);
    }",No Smells
"@Test
    public void testWithPartialColumnsNames() {
        String field = ""message"";
        String csv = ""1,\""this\"",is,an,ip,\""192.168.1.1\"",true"";

        Doc doc = createDoc(field, csv);

        Map<String,Object> config = new HashMap<>();
        config.put(""field"", field);
        config.put(""columns"", Arrays.asList(""id"", ""field1"", ""field2"", ""field3"", ""field4""));

        CsvProcessor csvProcessor = new CsvProcessor.Factory().create(config);

        ProcessResult processResult = csvProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat((String) doc.getField(""id"")).isEqualTo(""1"");
        assertThat((String) doc.getField(""field1"")).isEqualTo(""this"");
        assertThat((String) doc.getField(""field2"")).isEqualTo(""is"");
        assertThat((String) doc.getField(""field3"")).isEqualTo(""an"");
        assertThat((String) doc.getField(""field4"")).isEqualTo(""ip"");
        assertThat((String) doc.getField(""column6"")).isEqualTo(""192.168.1.1"");
        assertThat((String) doc.getField(""column7"")).isEqualTo(""true"");
    }",Eager Test + Mystery Guest
"@Test
    public void testWithSeparatorAndQuoteChar() {
        String field = ""message"";
        String csv = ""1\t\\this\\\tis\tan\tip\t\\192.168.1.1\\"";

        Doc doc = createDoc(field, csv);

        Map<String,Object> config = new HashMap<>();
        config.put(""field"", field);
        config.put(""separator"", ""\t"");
        config.put(""quoteChar"", ""\\"");

        CsvProcessor csvProcessor = new CsvProcessor.Factory().create(config);

        ProcessResult processResult = csvProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat((String) doc.getField(""column1"")).isEqualTo(""1"");
        assertThat((String) doc.getField(""column2"")).isEqualTo(""this"");
        assertThat((String) doc.getField(""column3"")).isEqualTo(""is"");
        assertThat((String) doc.getField(""column4"")).isEqualTo(""an"");
        assertThat((String) doc.getField(""column5"")).isEqualTo(""ip"");
        assertThat((String) doc.getField(""column6"")).isEqualTo(""192.168.1.1"");
    }",Eager Test + Mystery Guest
"@Test
    public void testBadConfigs() {
        assertThatThrownBy(() -> createProcessor(DateProcessor.class)).isInstanceOf(ProcessorConfigurationException.class);
        assertThatThrownBy(() -> createProcessor(DateProcessor.class, ""field"", ""aaaa"")).isInstanceOf(ProcessorConfigurationException.class);
        assertThatThrownBy(() -> createProcessor(DateProcessor.class, ""formats"", Arrays.asList(""aaaa""))).isInstanceOf(NullPointerException.class);
        assertThatThrownBy(() -> createProcessor(DateProcessor.class, ""field"", ""bla"", ""formats"", Arrays.asList(""notValid""))).isInstanceOf(RuntimeException.class);
        assertThatThrownBy(() -> createProcessor(DateProcessor.class, ""field"", ""bla"", ""formats"", Arrays.asList(""UNIX""), ""outputFormat"", ""notValid"")).isInstanceOf(RuntimeException.class);
    }",No Smells
"@Test
    public void testIso8601Format() {
        String field = ""datetime"";
        String targetField = ""@timestamp"";
        ZoneId zoneId = ZoneId.of(""UTC"");
        ZonedDateTime zonedDateTime = LocalDateTime.now().atZone(zoneId);
        String iso8601Format1 = zonedDateTime.format(DateTimeFormatter.ofPattern(""yyyy-MM-dd'T'HH:mm:ss,SSS""));
        String iso8601Format2 = zonedDateTime.format(DateTimeFormatter.ofPattern(""yyyy-MM-dd'T'HH:mm:ss.SSSSSSxxx""));
        Doc doc = createDoc(field, iso8601Format1);

        Map<String,Object> config = createConfig(""field"", field,
                ""targetField"", targetField,
                ""formats"", Arrays.asList(""ISO8601""),
                ""timeZone"", zoneId.toString());

        DateProcessor dateProcessor = createProcessor(DateProcessor.class, config);

        assertThat(dateProcessor.process(doc).isSucceeded()).isTrue();
        assertThat((String) doc.getField(targetField)).isEqualTo(zonedDateTime.format(DateProcessor.ELASTIC));

        doc = createDoc(field, iso8601Format2);

        assertThat(dateProcessor.process(doc).isSucceeded()).isTrue();
        assertThat((String) doc.getField(targetField)).isEqualTo(zonedDateTime.format(DateProcessor.ELASTIC));
    }",Eager Test + Mystery Guest
"@Test
    public void testISOFormatWithNumberValueInField() {
        String field = ""datetime"";
        String targetField = ""timestamp"";

        ZoneId zoneId = ZoneId.of(""UTC"");
        ZonedDateTime zonedDateTime = LocalDateTime.now().atZone(zoneId);
        Doc doc = createDoc(field, zonedDateTime.toInstant().toEpochMilli() / 1000);

        Map<String,Object> config = createConfig(""field"", field,
                ""targetField"", targetField,
                ""formats"", Arrays.asList(""dd/MMM/yyyy:HH:mm:ss""));

        DateProcessor dateProcessor = createProcessor(DateProcessor.class, config);

        assertThat(dateProcessor.process(doc).isSucceeded()).isFalse();
        assertThat(doc.hasField(targetField)).isFalse();
    }",Eager Test + Mystery Guest
"@Test
    public void testOutputForamtUnix() {
        String field = ""datetime"";
        String targetField = ""@timestamp"";
        ZoneId zoneId = ZoneId.of(""Europe/Paris"");
        String outputFormat = ""UNIX"";
        ZonedDateTime zonedDateTime = LocalDateTime.now().atZone(zoneId);
        String iso8601Format = zonedDateTime.format(DateTimeFormatter.ofPattern(""yyyy-MM-dd'T'HH:mm:ss,SSS""));
        Doc doc = createDoc(field, iso8601Format);

        Map<String,Object> config = createConfig(""field"", field,
                ""targetField"", targetField,
                ""formats"", Arrays.asList(""ISO8601""),
                ""outputFormat"", outputFormat,
                ""timeZone"", zoneId.toString());

        DateProcessor dateProcessor = createProcessor(DateProcessor.class, config);

        assertThat(dateProcessor.process(doc).isSucceeded()).isTrue();
        assertThat((String)doc.getField(targetField)).isEqualTo(zonedDateTime.format(DateProcessor.UNIX));
    }",Eager Test + Mystery Guest
"@Test
    public void testParseInvalidObjects() {
        String field = ""datetime"";
        String targetField = ""@timestamp"";
        ZoneId zoneId = ZoneId.of(""UTC"");
        Doc docWithMap = createDoc(field, ImmutableMap.of(""its"", ""a"", ""map"", ""should"", ""not"", ""work""));

        Map<String,Object> config = createConfig(""field"", field,
                ""targetField"", targetField,
                ""formats"", Arrays.asList(""UNIX_MS""),
                ""timeZone"", zoneId.toString());

        DateProcessor dateProcessor = createProcessor(DateProcessor.class, config);

        assertThat(dateProcessor.process(docWithMap).isSucceeded()).isFalse();

        Doc docWithList = createDoc(field, Arrays.asList(""its"", ""a"", ""list"", ""should"", ""not"", ""work""));

        assertThat(dateProcessor.process(docWithList).isSucceeded()).isFalse();
    }",Eager Test + Mystery Guest
"@Test
    public void testSeveralISOPatterns() {
        String field = ""datetime"";
        String targetField = ""@timestamp"";
        ZoneId zoneId = ZoneId.of(""UTC"");
        ZonedDateTime zonedDateTime = LocalDateTime.now().atZone(zoneId);
        List<String> formats = Arrays.asList(""dd/MM/yyyy HH:mm:ss"", ""yyyy-MM-dd'T'HH:mm:ssZ"", ""yyyy-MM-dd HH:mm:ss.SSSSS"", ""ddMMyyyy HHmmssSSS"");

        Map<String,Object> config = createConfig(""field"", field,
                ""targetField"", targetField,
                ""formats"", formats,
                ""timeZone"", zoneId.toString());

        DateProcessor dateProcessor = createProcessor(DateProcessor.class, config);

        formats.forEach(format -> {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format);
            String dateString = zonedDateTime.format(formatter);
            Doc doc = createDoc(field, dateString);

            ZonedDateTime expectedDateTime = LocalDateTime.parse(dateString, formatter).atZone(zoneId);

            assertThat(dateProcessor.process(doc).isSucceeded()).isTrue();
            assertThat((String) doc.getField(targetField)).isEqualTo(expectedDateTime.format(DateProcessor.ELASTIC));
        }",Eager Test + Mystery Guest
"@Test
    public void testUnixFormatString() {
        String field = ""datetime"";
        String targetField = ""@timestamp"";
        ZoneId zoneId = ZoneId.of(""Europe/Paris"");
        ZonedDateTime zonedDateTime = LocalDateTime.now().atZone(zoneId).truncatedTo(ChronoUnit.SECONDS);
        Doc doc = createDoc(field, String.valueOf(zonedDateTime.toInstant().toEpochMilli() / 1000));

        Map<String,Object> config = createConfig(""field"", field,
                ""targetField"", targetField,
                ""formats"", Arrays.asList(""UNIX""),
                ""timeZone"", zoneId.toString());

        DateProcessor dateProcessor = createProcessor(DateProcessor.class, config);

        assertThat(dateProcessor.process(doc).isSucceeded()).isTrue();
        assertThat((String) doc.getField(targetField)).isEqualTo(zonedDateTime.format(DateProcessor.ELASTIC));
    }",Eager Test + Mystery Guest
"@Test
    public void testUnixMsFormat() {
        String field = ""datetime"";
        String targetField = ""@timestamp"";
        ZoneId zoneId = ZoneId.of(""Europe/Paris"");
        ZonedDateTime zonedDateTime = LocalDateTime.now().atZone(zoneId);
        Doc doc = createDoc(field, zonedDateTime.toInstant().toEpochMilli());

        Map<String,Object> config = createConfig(""field"", field,
                ""targetField"", targetField,
                ""formats"", Arrays.asList(""UNIX_MS""),
                ""timeZone"", zoneId.toString());

        DateProcessor dateProcessor = createProcessor(DateProcessor.class, config);

        assertThat(dateProcessor.process(doc).isSucceeded()).isTrue();
        assertThat((String)doc.getField(targetField)).isEqualTo(zonedDateTime.format(DateProcessor.ELASTIC));
    }",Eager Test + Mystery Guest
"@Test
    public void testUnixMsFormatString() {
        String field = ""datetime"";
        String targetField = ""@timestamp"";
        ZoneId zoneId = ZoneId.of(""Europe/Paris"");
        ZonedDateTime zonedDateTime = LocalDateTime.now().atZone(zoneId);
        Doc doc = createDoc(field, String.valueOf(zonedDateTime.toInstant().toEpochMilli()));

        Map<String,Object> config = createConfig(""field"", field,
                ""targetField"", targetField,
                ""formats"", Arrays.asList(""UNIX_MS""),
                ""timeZone"", zoneId.toString());

        DateProcessor dateProcessor = createProcessor(DateProcessor.class, config);

        assertThat(dateProcessor.process(doc).isSucceeded()).isTrue();
        assertThat((String)doc.getField(targetField)).isEqualTo(zonedDateTime.format(DateProcessor.ELASTIC));
    }",Eager Test + Mystery Guest
"@Test
    public void testConstructor(){
        Doc doc = createDoc(""docSize"", 15);
        DocSizeProcessor sizeProcessor = createProcessor(DocSizeProcessor.class, createConfig(""targetField"", ""docSize_test""));
        ProcessResult processResult = sizeProcessor.process(doc);
        assertThat(processResult.isSucceeded()).isTrue();
        assertThat(doc.hasField(""docSize_test"")).isTrue();
    }",Eager Test
"@Test
    public void testInternalIp() {
        String ip = ""192.168.1.1"";
        String source = ""ipString"";
        String target = ""geoip"";

        Map<String, Object> config = createConfig(""sourceField"", source,
                ""tagsOnSuccess"", Arrays.asList(""geoip""));

        GeoIpProcessor geoIpProcessor = createProcessor(GeoIpProcessor.class, config);

        Doc doc = createDoc(source, ip);

        assertThat(geoIpProcessor.process(doc).isSucceeded()).isTrue();
        assertThat(doc.hasField(target)).isFalse();
    }",Eager Test + Mystery Guest
"@Test
    public void testValidIpWithSpecificProperties() {
        String ip = ""81.2.69.144"";
        String source = ""ipString"";

        Map<String,Object> config = createConfig(""sourceField"", source,
                ""properties"", Arrays.asList(""ip"", ""country_name"", ""country_code2"", ""city_name""));
        GeoIpProcessor geoIpProcessor = createProcessor(GeoIpProcessor.class, config);

        Doc doc = createDoc(source, ip);

        ProcessResult processResult = geoIpProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat(doc.hasField(""geoip"")).isTrue();
        Map<String, Object> geoIp = doc.getField(""geoip"");
        assertThat(geoIp.size()).isGreaterThanOrEqualTo(3);
        assertThat(geoIp.get(""country_name"")).isEqualTo(""United Kingdom"");
        assertThat(geoIp.get(""ip"")).isEqualTo(ip);
    }",Eager Test + Mystery Guest
"@Test
    public void testConverters() throws InterruptedException {
        String field = ""message"";
        List<String> patterns = Arrays.asList(""%{NUMBER:int:int}",Eager Test + Mystery Guest
"@Test
    public void testGrokParseFailure() throws InterruptedException {
        String field = ""message"";
        List<String> patterns = Arrays.asList(""%{COMBINEDAPACHELOG}",Eager Test + Mystery Guest
"@Test
    public void testPatternsPriority() throws InterruptedException {
        String field = ""message"";
        List<String> patterns = Arrays.asList(
                ""%{COMBINEDAPACHELOG}",Eager Test + Mystery Guest
"@Test
    public void testValidJsonWithoutTarget() {
        String field = ""message"";

        Map<String,Object> jsonMap = JsonUtils.fromJsonString(Map.class, VALID_JSON);

        Doc doc = createDoc(field, VALID_JSON);

        JsonProcessor jsonProcessor = createProcessor(JsonProcessor.class, createConfig(""field"", field));

        ProcessResult processResult = jsonProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        jsonMap.entrySet().forEach(entry ->
            assertThat((Object) doc.getField(entry.getKey())).isEqualTo(entry.getValue())
        );
        assertThat(doc.hasField(field)).isTrue();
    }",Eager Test
"@Test
    public void testAllowDuplicateValues() throws InterruptedException {
        String field = ""message"";
        Doc doc = createDoc(field, KEY_VALUE_MESSAGE_WITH_DUPLICATE_KEYS);

        Map<String,Object> config = createConfig(""field"", field);

        KeyValueProcessor kvProcessor = createProcessor(KeyValueProcessor.class, config);

        ProcessResult processResult = kvProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat((List) doc.getField(""sameKey"")).isEqualTo(Arrays.asList(""value1"", ""value2"", ""value3"", ""value4""));
    }",Eager Test + Mystery Guest
"@Test
    public void testDontAllowDuplicateValues() throws InterruptedException {
        String field = ""message"";
        Doc doc = createDoc(field, KEY_VALUE_MESSAGE_WITH_DUPLICATE_KEYS);

        Map<String,Object> config = createConfig(""field"", field,
                ""allowDuplicateValues"", false);

        KeyValueProcessor kvProcessor = createProcessor(KeyValueProcessor.class, config);

        ProcessResult processResult = kvProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat((String) doc.getField(""sameKey"")).isEqualTo(""value1"");
    }",Eager Test + Mystery Guest
"@Test
    public void testNullField() throws InterruptedException {
        String field = ""message"";
        Doc doc = createDoc(field, null);

        Map<String,Object> config = createConfig(""field"", field);

        KeyValueProcessor kvProcessor = createProcessor(KeyValueProcessor.class, config);

        ProcessResult processResult = kvProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isFalse();
    }",Eager Test + Mystery Guest
"@Test
    public void testWithTargetField() throws InterruptedException {
        String field = ""message"";
        String targetField = ""kv"";
        Doc doc = createDoc(field, getDefaultMessage());

        Map<String,Object> config = createConfig(""field"", field,
                ""targetField"", targetField);

        KeyValueProcessor kvProcessor = createProcessor(KeyValueProcessor.class, config);

        ProcessResult processResult = kvProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat(doc.hasField(targetField)).isTrue();
        Map<Object,String> kv = doc.getField(targetField);
        assertThat(kv.get(""simple"")).isEqualTo(""value"");
        assertThat(kv.get(""brackets"")).isEqualTo(""with space"");
        assertThat(kv.get(""roundBrackets"")).isEqualTo(""with two spaces"");
        assertThat(kv.get(""angleBrackets"")).isEqualTo(""without"");
        assertThat(kv.get(""%trim%"")).isEqualTo(""!value!"");
        assertThat(kv.get(""complex"")).isEqualTo(""innerKey=innerValue withBrackets=(another innerValue)"");
    }",Eager Test + Mystery Guest
"@Test
    public void testBadConfigs() {
        assertThatThrownBy(() -> createProcessor(MathProcessor.class)).isInstanceOf(NullPointerException.class);
        assertThatThrownBy(() -> createProcessor(MathProcessor.class, ""targetField"", ""aaa"")).isInstanceOf(NullPointerException.class);
        assertThatThrownBy(() -> createProcessor(MathProcessor.class, ""expression"", ""1 + 2"")).isInstanceOf(NullPointerException.class);
    }",No Smells
"@Test
    public void testRenameField() {
        String fromField = RandomStringUtils.randomAlphanumeric(5);
        String nestedToField = RandomStringUtils.randomAlphanumeric(5) + ""."" + RandomStringUtils.randomAlphanumeric(5);
        Doc doc = createDoc(fromField, ""value"");

        Map<String, Object> config = createConfig(""from"", fromField,
                ""to"", nestedToField);
        RenameFieldProcessor renameFieldProcessor = createProcessor(RenameFieldProcessor.class, config);

        assertThat(renameFieldProcessor.process(doc).isSucceeded()).isTrue();

        assertThat((String)doc.getField(nestedToField)).isEqualTo(""value"");
        assertThatThrownBy(() -> doc.getField(fromField)).isInstanceOf(IllegalStateException.class);
    }",Eager Test + Mystery Guest
"@Test
    public void testRenameJsonWithTemplateInTo() {
        Map valueBeingRename = ImmutableMap.of(""x"", 5);

        Doc doc = createDoc(
                ""field-a"", ""field-b"",
                ""field-c"", valueBeingRename);

        Map<String, Object> config = createConfig(
                ""from"", ""field-c"",
                ""to"", ""{{field-a}",Eager Test + Mystery Guest
"@Test
    public void testRenameWithTemplateInTo() {
        Doc doc = createDoc(""field-a"", ""field-b"",
                            ""field-c"", ""value-of-c"");

        Map<String, Object> config = createConfig(
                ""from"", ""field-c"",
                ""to"", ""{{field-a}",Eager Test + Mystery Guest
"@Test
    public void testStringFieldNotContainedSeparator() {
        String field = ""fieldName"";
        String value = ""this string is gonna be without any commas"";

        Doc doc = createDoc(field, value);

        SplitProcessor splitProcessor = createProcessor(SplitProcessor.class, createConfig(""field"", field, ""separator"", "",""));

        ProcessResult processResult = splitProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat((String) doc.getField(field)).isEqualTo(value);
    }",Eager Test + Mystery Guest
"@Test
    public void testSubstitute() {
        String field = ""message"";
        String message = ""I'm g@nna \""remove\"" $ome spec!al characters"";

        String pattern = ""\\$|@|!|\\\""|'"";
        String replacement = ""."";
        Map<String, Object> config = createConfig(""field"", field,
                ""pattern"", pattern,
                ""replacement"", replacement);

        Doc doc = createDoc(field, message);

        SubstituteProcessor substituteProcessor = createProcessor(SubstituteProcessor.class, config);

        ProcessResult processResult = substituteProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat((String) doc.getField(field)).isEqualTo(""I.m g.nna .remove. .ome spec.al characters"");
    }",Eager Test + Mystery Guest
"@Test
    public void testListOfStringFields() {
        List<String> fields = Arrays.asList(""field1"", ""field2"", ""field3"");

        Doc doc = createDoc(""field1"", ""lower case"",
                ""field2"", ""camelCase"",
                ""field3"", ""UPPER CASE"");

        UpperCaseProcessor upperCaseProcessor = createProcessor(UpperCaseProcessor.class, ""fields"", fields);

        ProcessResult processResult = upperCaseProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat((String) doc.getField(""field1"")).isEqualTo(""LOWER CASE"");
        assertThat((String) doc.getField(""field2"")).isEqualTo(""CAMELCASE"");
        assertThat((String) doc.getField(""field3"")).isEqualTo(""UPPER CASE"");
    }",Eager Test + Mystery Guest
"@Test
    public void testLongInvalidUserAgent() {
        String field = ""agent"";
        String targetField = ""user_agent"";
        String uaString = ""CuYDtymfoAScnOxlaYbvTZiOZEWVJsbLZIZBGPvDVjuqcxytUchOaksgiArcMcBhbmfynRsdFMpgSpUrbLqPncRqpMLuvlNvAkEhllRxWcTQSTRqVZVBfIYDVaCdZSd"" +
                ""nGivuEqYjSvNrywusJkRPyduDWrLVulUhjwcjIdBcdGscnJbSMdnHAhynpMrkKCGZbObUUHVrnDQKahvIgWImBAjfmGiFiRkqMwbarGNyZKyAARSairELcVQjJUntvraJvwjaLERayVhdA"" +
                ""ChAQPQtxDLJWKFgrPsmopUOGIHDsvWfesGmBMlmtBuqVZYLmhdntvtMQIoWSETeqMWbvZhodEqewrrZhIepPffvrQCYaNtVLQDHtRxLtPkTotNypeNFrWpUDybqFGhXXMoGZmLjQIsEMYSNpAbx"" +
                ""GjwelEhCGtUWVpLQpqRjdImPEPJoWFjqMDYfmgXHiLXAZTxUWXIolDvPuAWQMMSdMWGoqunKcscNUgfLpepUUKcQInfkNtbfVgbKHQVnIQpxxsClYbdfUmtclWtEPlnacpqBmmTvqAuqFnETBCMoiw"" +
                ""MTNGYMkcnpnATSkFIiiBdfNDRxqFSVLjyJvErEUaNLwjZBjZQaTlZRqcdJLnNyncDiJnuTjYeBNbjesLxPHuhnmWQMyAqSUXQNnlAQEyIuMeMgUDOopchnbywdvZPAFeFqZiRZHvcyOuPfrrHnyTDXhvrb"" +
                ""PvsjXhGORhwKVxqeFTekIhaXJVRMyosFcixPIrMEJWQTWlrcBUkCoNFNkoAFgNgLnZKLNhqKGKMXAPydwaCDWnMpfSuLVrKtJItkPQlorTRZFumHILjeTXYWBQbFhsZQXZCgGKfFFVRmODbjNGuTGFBRNTkF"" +
                ""nQkyORSPrTBRYYoCnPrJISdVxKBDaNDObbUUdMruDDoZRHxiRmOLWoYXwJvYblLNTVPAWkuHjhaETjVrJIyjmDJJcwpGhjFsHbNkUviOonqgssqjRidcrOibeXmmZxopIPrJIQyFOpEOpqCxWXotAefjlUtraVxC"" +
                ""iVXZAnwbvAASmAZnVWEMfeyDnZsyAYkKkHVgfRZMNfvBTRHpOiljWfPxlfuGwEIOHDPjJrqcvBidPoGASKqGucXnHrCApdJLVsIfVgQvNdiipSULVHhTvCcYMvMbPEOLiLtxHxwSmmGNNyGHlPJHixdBnVecmlwDggRArN"" +
                ""YFThgTPZnhJLOVdnAvAqoLkNmnVZtqsycjxaOWgQHdZRGFLePqaoibfSYjZERticqPpDymJgQDgMLTbpwIbqHggWaNEcAeUKlRjImqLjeJDBkELMIvhPSWDWsoZAcpBNnFYKtSbMEGtTWUjNQAJUOLUVqFFWQeS"" +
                ""LcuegjfsKxRyLSLOSbhLimlZSbBTWvZOqHuSaWGGnHtEQODgmlovxEOLeVxromEJDjXOPKSxFTaoNbFBGdvaPyIhBiDugAUEptbgQDIBKWXAVBCBiTjNolVjpTbMqYyucMfTVuCVqOHqxOXamDEjlUgXKBfCdwuFiKFsFfut"" +
                ""pcBMdYntTglEUMDigTQeDmfRErWVxJDNJhgFyCwtxcXqCtStUqHLPiwKZMrwkqDyexijsBpSdtlKBRXWCXMjrXYQmcsqgLThYWPvmrNTbyfpNEQUCimIGryiHnyCLkIxwqeZCsGpbeenALhrCfNcNCumNqwoa"" +
                ""gPXIXySbhpLkkqPZZqIWAqeaufviIYnLKswSxoLQpMOlMBhmkkBPjejWHjflHJtFZUSZWoytPnpjGYOOBFdqDMpDLOwoZsnuAIRwdepUreybIyQIafxigaLrayUNisocGYdlJJWagcoNPjTUtdjWiWwwqeLXh"" +
                ""KvJGGVYgBSMYGeeLKsuEliUYQNZVAurpNmrlHCYrIpTdURiPRTWACViTHnUUvHZYWOsgUUWgVKGBQQfuMOVoMWuoIpfaVoNoVvUnlbdoTvpCcbyGOyEdInlatGCxgwAKYKDlyUbgcwDNoEtotgLJOYXYxoxh"" +
                ""rrXtnMCXjsJtWfdBUfHtTZXvibUxVrqcCxjpQFVhCCNrtvmxKyPPAEMmKYaYbbWgXCiXBHgUJKprxlaLHbgPlfAnNggqUHhkuDXQR"";
        Doc doc = createDoc(field, uaString);

        Map<String,Object> config = createConfig(""field"", field,
                ""targetField"", targetField);
        UserAgentProcessor uaProceesor = createProcessor(UserAgentProcessor.class, config);
        ProcessResult processResult = uaProceesor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat(doc.hasField(targetField)).isTrue();

        Map<String,String> userAgent = doc.getField(targetField);

        assertThat(userAgent.get(""name"")).isEqualTo(""Other"");
        assertThat(userAgent.get(""os"")).isEqualTo(""Other"");
        assertThat(userAgent.get(""os_name"")).isEqualTo(""Other"");
        assertThat(userAgent.get(""device"")).isEqualTo(""Other"");

        assertThat(doc.hasField(""tags"")).isTrue();
        assertThat((List)doc.getField(""tags"")).isNotEmpty().contains(""_user_agent_truncated"");

    }",Eager Test + Mystery Guest
"@Test
    public void testUserAgentWithPrefix() {
        String field = ""agent"";
        String prefix = ""UA-"";
        String uaString = ""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.98 Safari/537.36"";
        Doc doc = createDoc(field, uaString);

        Map<String,Object> config = createConfig(""field"", field,
                ""prefix"", prefix);
        UserAgentProcessor uaProceesor = createProcessor(UserAgentProcessor.class, config);

        ProcessResult processResult = uaProceesor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat((String)doc.getField(prefix + ""name"")).isEqualTo(""Chrome"");
        assertThat((String)doc.getField(prefix + ""major"")).isEqualTo(""54"");
        assertThat((String)doc.getField(prefix + ""minor"")).isEqualTo(""0"");
        assertThat((String)doc.getField(prefix + ""patch"")).isEqualTo(""2840"");

        assertThat((String)doc.getField(prefix + ""os"")).isEqualTo(""Mac OS X 10.10.5"");
        assertThat((String)doc.getField(prefix + ""os_name"")).isEqualTo(""Mac OS X"");
        assertThat((String)doc.getField(prefix + ""os_major"")).isEqualTo(""10"");
        assertThat((String)doc.getField(prefix + ""os_minor"")).isEqualTo(""10"");
        assertThat((String)doc.getField(prefix + ""os_patch"")).isEqualTo(""5"");

        assertThat((String)doc.getField(prefix + ""device"")).isEqualTo(""Other"");
    }",Eager Test + Mystery Guest
"@Test
    public void testInvalidXml() {
        String field = ""xml"";

        Doc doc = createDoc(field, INVALID_XML);

        XmlProcessor xmlProcessor = createProcessor(XmlProcessor.class, ""field"", field);

        ProcessResult processResult = xmlProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isFalse();
    }",Eager Test + Mystery Guest
"@Test
    public void testValidXml() {
        String field = ""xml"";

        Doc doc = createDoc(field, VALID_XML);

        XmlProcessor xmlProcessor = createProcessor(XmlProcessor.class, ""field"", field);

        ProcessResult processResult = xmlProcessor.process(doc);

        assertThat(processResult.isSucceeded()).isTrue();
        assertThat((String) doc.getField(""country.id"")).isEqualTo(""1"");
        assertThat((String) doc.getField(""country.name"")).isEqualTo(""Israel"");
        assertThat(doc.hasField(""country.TestEmptyField"")).isFalse();
        assertThatThrownBy(() -> doc.getField(""country.TestEmptyField"")).isInstanceOf(IllegalStateException.class);
        assertThat((List) doc.getField(""country.cities.city""))
                .isEqualTo(Arrays.asList(ImmutableMap.of(""name"", ""Jerusalem""),
                        ImmutableMap.of(""name"", ""Tel Aviv"")));
        assertThat((String) doc.getField(""country.lat"")).isEqualTo(""31.0461"");
        assertThat((String) doc.getField(""country.long"")).isEqualTo(""34.8516"");
        assertThat((String) doc.getField(""country.continent"")).isEqualTo(""Asia"");
        assertThat((String) doc.getField(""country.currency"")).isEqualTo(""New Shekel"");
        assertThat((List) doc.getField(""country.languages.language"")).isEqualTo(Arrays.asList(""Hebrew"", ""Arabic"", ""English""));
    }",Eager Test + Mystery Guest
"@Test
    public void testDocWithListField() {
        Template listTemplate = templateService.createTemplate(""this is {{list}",Eager Test + Mystery Guest
"@Test
    public void testDocWithoutAllFields() {
        Doc doc = createDoc(""anotherField"", ""Robles"", SALUD_FIELD, ""Buenos Dias"");

        String value = template.render(doc);

        assertThat(value).isEqualTo(""Buenos Dias seor , Have a good day"");
    }",No Smells
"@Test
    public void testNullContext() {
        Doc doc = null;

        String value = template.render(doc);

        assertThat(value).isEqualTo("" seor , Have a good day"");
    }",No Smells
"@Test
    public void test_v4_1_16() throws Exception {
        NavMesh mesh = loadNavMesh(""graph_v4_1_16.zip"");
        float[] startPos = new float[] { 22.93f, -2.37f, -5.11f }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testDungeon32Bit() throws IOException {
        InputStream is = getClass().getClassLoader().getResourceAsStream(""dungeon_all_tiles_navmesh_32bit.bin"");
        NavMesh mesh = reader.read32Bit(is, 6);
        assertThat(mesh.getMaxTiles()).isEqualTo(128);
        assertThat(mesh.getParams().maxPolys).isEqualTo(0x8000);
        assertThat(mesh.getParams().tileWidth).isEqualTo(9.6f, offset(0.001f));
        List<MeshTile> tiles = mesh.getTilesAt(6, 9);
        assertThat(tiles).hasSize(1);
        assertThat(tiles.get(0).data.polys).hasSize(2);
        assertThat(tiles.get(0).data.verts).hasSize(7 * 3);
        tiles = mesh.getTilesAt(2, 9);
        assertThat(tiles).hasSize(1);
        assertThat(tiles.get(0).data.polys).hasSize(2);
        assertThat(tiles.get(0).data.verts).hasSize(9 * 3);
        tiles = mesh.getTilesAt(4, 3);
        assertThat(tiles).hasSize(1);
        assertThat(tiles.get(0).data.polys).hasSize(3);
        assertThat(tiles.get(0).data.verts).hasSize(6 * 3);
        tiles = mesh.getTilesAt(2, 8);
        assertThat(tiles).hasSize(1);
        assertThat(tiles.get(0).data.polys).hasSize(5);
        assertThat(tiles.get(0).data.verts).hasSize(17 * 3);
    }",Eager Test + Mystery Guest
"@Test
    public void testLZ4() throws IOException {
        testDungeon(ByteOrder.LITTLE_ENDIAN, false);
        testDungeon(ByteOrder.LITTLE_ENDIAN, true);
        testDungeon(ByteOrder.BIG_ENDIAN, false);
        testDungeon(ByteOrder.BIG_ENDIAN, true);
        test(ByteOrder.LITTLE_ENDIAN, false);
        test(ByteOrder.LITTLE_ENDIAN, true);
        test(ByteOrder.BIG_ENDIAN, false);
        test(ByteOrder.BIG_ENDIAN, true);
    }",No Smells
"@Test
    public void phrasePrefixQueryPhraseAsPhrase() {
        phrasePrefixQueryTestCase(false);
    }",No Smells
"@Test
    public void detectWildcard() {
        Automaton automaton = new RegExp("".foo"").toAutomaton();
        assertThat(AutomatonHitEnum.hasLeadingWildcard(automaton), equalTo(false));

        automaton = new RegExp(""f.+oo"").toAutomaton();
        assertThat(AutomatonHitEnum.hasLeadingWildcard(automaton), equalTo(false));

        // The handling for .+ also ends up catching this. Probably ok.
        automaton = new RegExp(""f.*oo"").toAutomaton();
        assertThat(AutomatonHitEnum.hasLeadingWildcard(automaton), equalTo(true));

        automaton = new RegExp(""f?.+oo"").toAutomaton();
        assertThat(AutomatonHitEnum.hasLeadingWildcard(automaton), equalTo(true));

        automaton = new RegExp(""f?.*oo"").toAutomaton();
        assertThat(AutomatonHitEnum.hasLeadingWildcard(automaton), equalTo(true));

        automaton = new RegExp(""foo.*"").toAutomaton();
        assertThat(AutomatonHitEnum.hasLeadingWildcard(automaton), equalTo(false));

        automaton = new RegExp(""[a-z]?foo"").toAutomaton();
        assertThat(AutomatonHitEnum.hasLeadingWildcard(automaton), equalTo(false));

        automaton = new RegExp(""[a-z]+foo"").toAutomaton();
        assertThat(AutomatonHitEnum.hasLeadingWildcard(automaton), equalTo(true));

        automaton = new RegExp(""[a-z]*foo"").toAutomaton();
        assertThat(AutomatonHitEnum.hasLeadingWildcard(automaton), equalTo(true));

        automaton = new RegExp("".*foo"").toAutomaton();
        assertThat(AutomatonHitEnum.hasLeadingWildcard(automaton), equalTo(true));

        automaton = new RegExp(""(foo|.*bar)"").toAutomaton();
        assertThat(AutomatonHitEnum.hasLeadingWildcard(automaton), equalTo(true));
    }",Eager Test
"@Test
    public void leadingWildcardPerformance() {
        String source = makeLongSource();
        SourceExtracter<String> extracter = new StringSourceExtracter(source);
        HitEnum e = AutomatonHitEnum.factory("".*(hero|legend)"", Operations.DEFAULT_MAX_DETERMINIZED_STATES).build(source);
        long start = System.nanoTime();
        assertThat(e, advances());
        assertThat(e, hit(0, extracter, containsString(""legend"")));
        assertThat(e, isEmpty());
        // Implementation of backwards/forward pass reduced
        // this from ~4500ms to ~15ms.
        Duration took = Duration.ofNanos(System.nanoTime() - start);
        assertThat(took.toMillis(), lessThan(200L));
        // System.out.println(took.toMillis());
    }",Eager Test
"@Test
    public void partialWithStar() {
        String source = ""hero of legend"";
        SourceExtracter<String> extracter = new StringSourceExtracter(source);
        HitEnum e = AutomatonHitEnum.factory(""her.*f"", Operations.DEFAULT_MAX_DETERMINIZED_STATES).build(source);
        assertThat(e, advances());
        assertThat(e, hit(0, extracter, equalTo(""hero of"")));
        assertThat(e, isEmpty());

        e = AutomatonHitEnum.factory(""her.*o"", Operations.DEFAULT_MAX_DETERMINIZED_STATES).build(source);
        assertThat(e, advances());
        assertThat(e, hit(0, extracter, equalTo(""hero o"")));
        assertThat(e, isEmpty());
    }",Eager Test
"@Test
    public void specificWords() {
        String source = ""hero of legend"";
        SourceExtracter<String> extracter = new StringSourceExtracter(source);
        HitEnum e = AutomatonHitEnum.factory(""hero|legend"", Operations.DEFAULT_MAX_DETERMINIZED_STATES).build(source);
        assertThat(e, advances());
        assertThat(e, hit(0, extracter, equalTo(""hero"")));
        assertThat(e, advances());
        assertThat(e, hit(1, extracter, equalTo(""legend"")));
        assertThat(e, isEmpty());
    }",Eager Test
"@Test
    public void twoPhaseMatchCorrectness() {
        // Correctness is also checked via parent class, since self::buildEnum matches the two-phase
        // conditions
        String source = ""some words will do wherever they queue"";
        SourceExtracter<String> extracter = new StringSourceExtracter(source);
        HitEnum e = AutomatonHitEnum.factory("".*w"", Operations.DEFAULT_MAX_DETERMINIZED_STATES).build(source);
        assertThat(e, advances());
        assertThat(e, hit(0, extracter, equalTo(""some words will do w"")));
        assertThat(e, isEmpty());

        e = AutomatonHitEnum.factory("".*w"", Operations.DEFAULT_MAX_DETERMINIZED_STATES).build(source);
        assertThat(e, advances());
        assertThat(e, hit(0, extracter, equalTo(""some words will do w"")));
        assertThat(e, isEmpty());
    }",Eager Test
"@Test
    public void boostQuery() {
        Callback callback = mock(Callback.class);
        BoostQuery bq = new BoostQuery(new TermQuery(bar), 2f);
        new QueryFlattener().flatten(bq, null, callback);
        verify(callback).flattened(bar.bytes(), 2f, null);
    }",Eager Test
"@Test
    public void commonTermsQueryNoRemove() {
        IndexReader reader = readerWithTerms(bar, randomIntBetween(1, 20), baz, randomIntBetween(1, 20));
        Callback callback = mock(Callback.class);
        CommonTermsQuery q = new CommonTermsQuery(Occur.SHOULD, Occur.MUST, 10f);
        q.add(bar);
        q.add(baz);
        new QueryFlattener(100, false, false).flatten(q, reader, callback);
        verify(callback).flattened(bar.bytes(), 1f, null);
        verify(callback).flattened(baz.bytes(), 1f, null);
    }",Eager Test
"@Test
    public void fuzzyQueryShorterThenPrefix() {
        Callback callback = mock(Callback.class);
        new QueryFlattener().flatten(new FuzzyQuery(bar, 2, 100), null, callback);
        verify(callback).flattened(bar.bytes(), 1f, null);
        verify(callback, never()).flattened(any(Automaton.class), anyFloat(), anyInt());
    }",No Smells
"@Test
    public void termQuery() {
        Callback callback = mock(Callback.class);
        new QueryFlattener().flatten(new TermQuery(bar), null, callback);
        verify(callback).flattened(bar.bytes(), 1f, null);
    }",No Smells
"@Test
    public void testSynonym() {
        Callback callback = mock(Callback.class);
        SynonymQuery.Builder synonymBuilder = new SynonymQuery.Builder(""foo"");
        new QueryFlattener().flatten(synonymBuilder.addTerm(bar).addTerm(baz).build(), null, callback);
        verify(callback).flattened(bar.bytes(), 1f, null);
        verify(callback).flattened(baz.bytes(), 1f, null);
    }",No Smells
"@Test
    public void aCoupleWordsUnrepaired() {
        String source = ""hero of legend"";
        BreakIterator itr = BreakIterator.getWordInstance(Locale.ENGLISH);
        itr.setText(source);
        SourceExtracter<String> extracter = new StringSourceExtracter(source);
        HitEnum e = new BreakIteratorHitEnum(itr);
        assertThat(e, advances());
        assertThat(e, hit(0, extracter, equalTo(""hero"")));
        assertThat(e, advances());
        assertThat(e, hit(1, extracter, equalTo("" "")));
        assertThat(e, advances());
        assertThat(e, hit(2, extracter, equalTo(""of"")));
        assertThat(e, advances());
        assertThat(e, hit(3, extracter, equalTo("" "")));
        assertThat(e, advances());
        assertThat(e, hit(4, extracter, equalTo(""legend"")));
        assertThat(e, isEmpty());
    }",Eager Test
"@Test
    public void compareToReplaying() {
        List<HitEnumAndLength> allEnumsForReplaying = new ArrayList<HitEnumAndLength>();
        List<HitEnumAndLength> allEnumsForConcat = new ArrayList<HitEnumAndLength>();
        for (int i = 0; i < 100; i++) {
            ReplayingHitEnum inputForReplaying = new ReplayingHitEnum();
            ReplayingHitEnum inputForConcat = new ReplayingHitEnum();
            for (int j = 0; j < 100; j++) {
                int position = randomInt();
                int startOffset = randomInt();
                int endOffset = randomInt();
                float queryWeight = randomFloat();
                float corpusWeight = randomFloat();
                int source = randomInt();
                inputForReplaying.recordHit(position, startOffset, endOffset, queryWeight, corpusWeight, source);
                inputForConcat.recordHit(position, startOffset, endOffset, queryWeight, corpusWeight, source);
            }",Eager Test
"@Test
    public void ofCollectionOfEmpty() {
        Collection<? extends HitEnum> enums = Arrays.asList(
                EmptyHitEnum.INSTANCE,
                EmptyHitEnum.INSTANCE,
                EmptyHitEnum.INSTANCE);
        assertFalse(new MergingHitEnum(enums, HitEnum.LessThans.POSITION).next());
    }",No Smells
"@Test
    public void single() {
        List<Integer> expectedPositions = new ArrayList<Integer>();
        int max = between(500, 10000);
        for (int i = 0; i < max; i++) {
            expectedPositions.add(getRandom().nextInt());
        }",Eager Test
"@Test
    public void empty() {
        ReplayingHitEnum replaying = new ReplayingHitEnum();
        HitEnum e = new OverlapMergingHitEnumWrapper(replaying);
        assertThat(e, isEmpty());
    }",No Smells
"@Test
    public void noOverlaps() {
        ReplayingHitEnum replaying = new ReplayingHitEnum();
        replaying.recordHit(0, 0, 2, 0, 1);
        replaying.recordHit(0, 2, 3, 0, 2);
        replaying.recordHit(0, 10, 13, 0, 3);
        HitEnum e = new OverlapMergingHitEnumWrapper(replaying);
        assertThat(e, advances());
        assertThat(e, allOf(atPosition(0), atStartOffset(0), atEndOffset(2), atWeight(0), atSource(1)));
        assertThat(e, advances());
        assertThat(e, allOf(atPosition(0), atStartOffset(2), atEndOffset(3), atWeight(0), atSource(2)));
        assertThat(e, advances());
        assertThat(e, allOf(atPosition(0), atStartOffset(10), atEndOffset(13), atWeight(0), atSource(3)));
        assertThat(e, isEmpty());
    }",No Smells
"@Test
    public void overlapPicksMaxWeightAndSize() {
        ReplayingHitEnum replaying = new ReplayingHitEnum();
        // The first overlapping hit has corpus weight of 3
        replaying.recordHit(0, 0, 5, 2, 3, 1);
        // The second has query weight of 3
        replaying.recordHit(0, 1, 3, 3, 2, 2);
        HitEnum e = new OverlapMergingHitEnumWrapper(replaying);
        assertThat(e, advances());
        assertThat(e, allOf(
                // So together they should have a multiplied weight of 9 (3*3)
                atWeight(9), atPosition(0), atStartOffset(0), atEndOffset(5), atSource(33)));
        assertThat(e, isEmpty());
    }",Eager Test
"@Test
    public void single() {
        ReplayingHitEnum replaying = new ReplayingHitEnum();
        replaying.recordHit(0, 0, 2, 1.7f, 1);
        HitEnum e = new OverlapMergingHitEnumWrapper(replaying);
        assertThat(e, advances());
        assertThat(e, allOf(atPosition(0), atStartOffset(0), atEndOffset(2), atWeight(1.7f), atSource(1)));
        assertThat(e, isEmpty());
    }",Eager Test
"@Test
    public void basic() {
        phrase(0, 0, 2);
        inputs(0, 0, 1);
        result(2, 2, 1);
    }",No Smells
"@Test
    public void largeAndBasicSpeedTest() {
        int size = 1000000;
        phrase(0, 0, 0, 0, 2);
        int[] inputs = new int[size];
        for (int i = 0; i < size; i++) {
            inputs[i] = 0;
        }",Eager Test
"@Test
    public void multi() {
        phrase(0, new int[] {0, 1}",No Smells
"@Test
    public void slop() {
        slop(1);
        phrase(0, 0, 2);
        inputs(0, 1, 0, 1);
        result(2, 1, 2, 1);

        inputs(0, 1, 1, 0, 1);
        result(1, 1, 1, 1, 1);
    }",No Smells
"@Test
    public void startOver() {
        phrase(1, 1, 2, 3, 4, 2);
        inputs(1, 1, 1, 2, 3, 4);
        result(1, 2, 2, 2, 2, 2);
    }",No Smells
"@Test
    public void specificWords() {
        String source = ""hero of legend"";
        SourceExtracter<String> extracter = new StringSourceExtracter(source);
        HitEnum e = new RegexHitEnum(Pattern.compile(""hero|legend"").matcher(source));
        assertThat(e, advances());
        assertThat(e, hit(0, extracter, equalTo(""hero"")));
        assertThat(e, advances());
        assertThat(e, hit(1, extracter, equalTo(""legend"")));
        assertThat(e, isEmpty());
    }",Eager Test
"@Test
    public void aFew() {
        ReplayingHitEnum e = new ReplayingHitEnum();
        e.recordHit(0, 0, 2, 0, 1);
        e.recordHit(0, 0, 2, 0, 2);
        e.recordHit(0, 0, 2, 0, 3);
        assertEquals(e.waiting(), 3);
        assertThat(e, advances());
        assertThat(e, allOf(atPosition(0), atStartOffset(0), atEndOffset(2), atWeight(0), atSource(1)));
        assertEquals(e.waiting(), 2);
        assertThat(e, advances());
        assertThat(e, allOf(atPosition(0), atStartOffset(0), atEndOffset(2), atWeight(0), atSource(2)));
        assertEquals(e.waiting(), 1);
        assertThat(e, advances());
        assertThat(e, allOf(atPosition(0), atStartOffset(0), atEndOffset(2), atWeight(0), atSource(3)));
        assertThat(e, isEmpty());
        assertEquals(e.waiting(), 0);
    }",No Smells
"@Test
    public void empty() {
        ReplayingHitEnum e = new ReplayingHitEnum();
        assertThat(e, isEmpty());
    }",No Smells
"@Test
    public void empty() {
        WeightFilteredHitEnumWrapper e = new WeightFilteredHitEnumWrapper(EmptyHitEnum.INSTANCE, 0);
        assertThat(e, isEmpty());
    }",No Smells
"@Test
    public void filtersAll() {
        ReplayingHitEnum replaying = new ReplayingHitEnum();
        replaying.recordHit(0, 0, 2, 1.7f, 1);
        replaying.recordHit(1, 0, 2, 0f, 2);
        replaying.recordHit(2, 0, 2, 1.7f, 3);
        WeightFilteredHitEnumWrapper e = new WeightFilteredHitEnumWrapper(replaying, 2f);
        assertThat(e, isEmpty());
    }",No Smells
"@Test
    public void single() {
        ReplayingHitEnum replaying = new ReplayingHitEnum();
        replaying.recordHit(0, 0, 2, 1.7f, 0);
        WeightFilteredHitEnumWrapper e = new WeightFilteredHitEnumWrapper(replaying, 0);
        assertThat(e, advances());
        assertThat(e, allOf(atPosition(0), atStartOffset(0), atEndOffset(2), atWeight(1.7f), atSource(0)));
        assertThat(e, isEmpty());
    }",No Smells
"@Test
    public void basic() {
        for (boolean scoreOrdered : new boolean[] {true, false}",Eager Test
"@Test
    public void empty() {
        setup("""");
        assertTrue(segmenter.acceptable(0, 0));
        assertThat(segmenter.memo(0, 0).pickBounds(0, Integer.MAX_VALUE), extracted(extracter, """"));
        assertFalse(segmenter.acceptable(0, 1));
    }",No Smells
"@Test
    public void sentenceBreaks() {
        setup(""One sentence.  Two sentence.  Red sentence, blue sentence."");
        assertTrue(segmenter.acceptable(0, 12));
        assertThat(segmenter.memo(0, 7).pickBounds(0, 37), extracted(extracter, ""One sentence.  ""));
        assertTrue(segmenter.acceptable(17, 25));
        assertThat(segmenter.memo(17, 25).pickBounds(0, 1237), extracted(extracter, ""Two sentence.  ""));
        assertFalse(segmenter.acceptable(0, 28));
        // 15 is right on the ""T"" in ""Two"" and 27-29 are the end of that
        // sentence.
        for (int end = 27; end <= 29; end++) {
            assertTrue(segmenter.acceptable(15, end));
            assertThat(segmenter.memo(15, end).pickBounds(0, Integer.MAX_VALUE),
                    extracted(extracter, ""Two sentence.  ""));
        }",Eager Test
"@Test
    public void singleChar() {
        setup(""a"");
        assertTrue(segmenter.acceptable(0, 1));
        assertThat(segmenter.memo(0, 1).pickBounds(0, Integer.MAX_VALUE), extracted(extracter, ""a""));
        assertFalse(segmenter.acceptable(0, 2));
    }",No Smells
"@Test
    public void shortString() {
        setup(""short"");
        int end = source.length();
        for (int i = 0; i < end; i++) {
            assertTrue(segmenter.acceptable(0, i));
            assertThat(segmenter.memo(0, i).pickBounds(0, Integer.MAX_VALUE),
                    extracted(extracter, equalTo(""short"")));

            assertTrue(segmenter.acceptable(i, end));
            assertThat(segmenter.memo(i, end).pickBounds(0, Integer.MAX_VALUE),
                    extracted(extracter, equalTo(""short"")));
        }",Eager Test
"@Test
    public void wordBreaksOnlyBetweenMinAndMax() {
        setup(""The quick brown fox jumped over the lazy dog."", 0, 10);

        // Find break while scanning from expanded start to beginning
        assertThat(segmenter.memo(4, 5).pickBounds(1, Integer.MAX_VALUE),
                extracted(extracter, equalTo(""quick"")));
        // Don't find break while scanning from expanded start to beginning
        assertThat(segmenter.memo(2, 5).pickBounds(1, Integer.MAX_VALUE),
                extracted(extracter, equalTo(""he quick"")));

        // Scanning backwards doesn't find the break but scanning forwards does
        setup(""Thequickbrown fox jumped over the lazy dog."", 10, 10);
        assertThat(segmenter.memo(15, 19).pickBounds(0, Integer.MAX_VALUE),
                extracted(extracter, equalTo(""fox jumped"")));

        // Scanning neither backwards nor forwards finds the break but we hit
        // the maxStart so use that
        setup(""Thequickbrown fox jumped over the lazy dog."", 0, 10);
        assertThat(segmenter.memo(12, 19).pickBounds(0, Integer.MAX_VALUE),
                extracted(extracter, equalTo(""n fox jumped"")));

        // Scanning neither backwards nor forwards finds the break and we
        // don't hit maxStart so just use the expanded start
        setup(""Thequickbrownfoxjumpedover the lazy dog."", 10, 2);
        assertThat(segmenter.memo(12, 16).pickBounds(0, Integer.MAX_VALUE),
                extracted(extracter, equalTo(""rownfoxjum"")));


        // Now repeat for the end offset...
        setup(""The quick brown fox jumped over the lazy dog."", 0, 10);

        // Find break while scanning from expanded end to end
        assertThat(segmenter.memo(4, 5).pickBounds(1, Integer.MAX_VALUE),
                extracted(extracter, equalTo(""quick"")));
        // Don't find break while scanning from expanded end to end
        assertThat(segmenter.memo(4, 5).pickBounds(1, 6),
                extracted(extracter, equalTo(""qu"")));

        // Scanning forwards doesn't find the break but scanning backwards does
        setup(""The quick brown foxjumpedoverthelazy dog."", 10, 10);
        assertThat(segmenter.memo(10, 14).pickBounds(0, Integer.MAX_VALUE),
                extracted(extracter, equalTo(""quick brown"")));

        // Scanning neither forwards nor backwards finds the break but we hit
        // the maxEnd so use that
        setup(""The quick brownfoxjumpedoverthelazy dog."", 0, 10);
        assertThat(segmenter.memo(10, 14).pickBounds(0, Integer.MAX_VALUE),
                extracted(extracter, equalTo(""brow"")));

        // Scanning neither backwards nor forwards finds the break and we
        // don't hit maxStart so just use the expanded end
        setup(""Thequickbrownfoxjumpedover the lazy dog."", 10, 2);
        assertThat(segmenter.memo(1, 2).pickBounds(0, Integer.MAX_VALUE),
                extracted(extracter, equalTo(""Thequickb"")));
    }",No Smells
"@Test
    public void uniqueSources() {
        assertEquals(3.3, weigh(1.1f, hit(1f, 0), hit(1f, 1), hit(1f, 2)), .00001f);
        assertEquals(1.1 * 13, weigh(1.1f, hit(1f, 0), hit(5f, 1), hit(7f, 2)), .00001f);
    }",No Smells
"@Test
    public void singleEmptyString() {
        setup("""");
        assertFalse(segmenter.acceptable(0, 1));
        // Check again now that we don't have to pick a new segmenter
        assertFalse(segmenter.acceptable(0, 1));
    }",No Smells
"@Test
    public void startWithSomeEmptyThenSingleChar() {
        setup("""", """", """", ""a"");
        assertTrue(segmenter.acceptable(offsetGap * 3, offsetGap * 3 + 1));
        assertThat(segmenter.memo(offsetGap * 3, offsetGap * 3 + 1)
                .pickBounds(0, Integer.MAX_VALUE), extracted(extracter, equalTo(""a"")));
        if (offsetGap > 0) {
            assertFalse(segmenter.acceptable(0, 1));
        }",Eager Test
"@Test
    public void tooLong() {
        String ten = ""aaaaaaaaa "";
        setup(Strings.repeat(ten, 10), Strings.repeat(ten, 20));

        // Only lengths up to 100 are acceptable but we had a bug where we'd
        // shift the end backwards but not the beginning.
        assertFalse(segmenter.acceptable(110, 300));
    }",No Smells
"@Test
    public void twoSentences() {
        setup(""a very simple test"", ""with two fields to test"");
        // Grab some matches from the first string
        assertTrue(segmenter.acceptable(14, 18));
        assertThat(segmenter.memo(14, 18).pickBounds(0, Integer.MAX_VALUE),
                extracted(extracter, equalTo(""a very simple test"")));
        assertFalse(segmenter.acceptable(16, 25));

        // Now jump to the second
        assertTrue(segmenter.acceptable(offsetGap + 34, offsetGap + 38));
        assertThat(segmenter.memo(offsetGap + 34, offsetGap + 38).pickBounds(0, Integer.MAX_VALUE),
                extracted(extracter, equalTo(""with two fields to test"")));
    }",No Smells
"@Test
    public void empty() {
        setup("""");
        assertTrue(segmenter.acceptable(0, 0));
        assertThat(segmenter.memo(0, 0).pickBounds(0, Integer.MAX_VALUE), extracted(extracter, """"));
        assertFalse(segmenter.acceptable(0, 1));
    }",No Smells
"@Test
    public void singleSentence() {
        setup(""More stuff!  More stuff too."");
        int end = source.length() - 1;
        for (int i = 0; i < end; i++) {
            assertTrue(segmenter.acceptable(0, i));
            assertThat(segmenter.memo(0, i).pickBounds(0, Integer.MAX_VALUE),
                    extracted(extracter, source));

            assertTrue(segmenter.acceptable(i, end));
            assertThat(segmenter.memo(i, end).pickBounds(0, Integer.MAX_VALUE),
                    extracted(extracter, source));
        }",Eager Test
"@Test
    public void outOfBounds() {
        assertEquals(""01"", source.extract(-1, 2));
        assertEquals("""", source.extract(3, 2));
        assertEquals(""0123456789"", source.extract(0, 11));

        assertEquals(""01"", safeSubstring(-1, 2, sourceText));
        assertEquals("""", safeSubstring(3, 2, sourceText));
        assertEquals(""0123456789"", safeSubstring(0, 11, sourceText));
    }",No Smells
"@Test
    public void getObjectNameTest() {
        FieldErrorVM vm = new FieldErrorVM(null, null, null);
        assertThat(vm.getObjectName()).isNull();
        vm = new FieldErrorVM(""dto"", ""field"", ""message"");
        assertThat(vm.getObjectName()).isEqualTo(""dto"");
    }",No Smells
"@Test
    public void getMessageTest() {
        ParameterizedErrorVM vm = new ParameterizedErrorVM(null, null);
        assertThat(vm.getMessage()).isNull();
        Map<String, String> paramMap = new HashMap<>();
        paramMap.put(""param1"", ""param1"");
        paramMap.put(""param2"", ""param2"");
        vm = new ParameterizedErrorVM(""message"", paramMap);
        assertThat(vm.getMessage()).isEqualTo(""message"");
    }",Eager Test
"@Test
    public void getApplicationsTest() {
        List<Map<String, Object>> list = eureka.getApplications();
        assertThat(list).isNull();

        eureka.setApplications(initFakeApplicationsList());

        list = eureka.getApplications();
        assertThat(list).isNotNull();
        assertThat(list).hasSize(2);
    }",No Smells
"@Test
    public void setApplicationsTest() {
        assertThat(eureka.getApplications()).isNull();
        eureka.setApplications(initFakeApplicationsList());
        assertThat(eureka.getApplications()).isNotNull();

        List<Map<String, Object>> newList = new ArrayList<>();
        eureka.setApplications(newList);
        assertThat(eureka.getApplications()).isEqualTo(newList);
    }",No Smells
"@Test
    public void setStatusTest() {
        assertThat(eureka.getStatus()).isNull();
        eureka.setStatus(initFakeStatus());
        assertThat(eureka.getStatus()).isNotNull();

        Map<String, Object> newStatus = new HashMap<>();
        eureka.setStatus(newStatus);
        assertThat(eureka.getStatus()).isEqualTo(newStatus);
    }",No Smells
"@Test
    public void setRememberMeTest() {
        LoginVM vm = new LoginVM();
        vm.setRememberMe(false);
        assertThat(vm.isRememberMe()).isFalse();
        vm.setRememberMe(true);
        assertThat(vm.isRememberMe()).isTrue();
    }",No Smells
"@Test
	public void testResolveFault() {

		FaultAwareWebServiceMessage messageMock = createMock(FaultAwareWebServiceMessage.class);
		String message = ""message"";
		expect(messageMock.getFaultReason()).andReturn(message);

		replay(messageMock);

		assertThatExceptionOfType(WebServiceFaultException.class).isThrownBy(() -> resolver.resolveFault(messageMock))
				.withMessage(message);

		verify(messageMock);
	}",No Smells
"@Test
	public void testMarshalAndSendNoUnmarshallerSet() throws Exception {

		connectionMock.close();

		template.setUnmarshaller(null);
		assertThatIllegalStateException().isThrownBy(() -> template.marshalSendAndReceive(new Object()));
	}",Eager Test + Mystery Guest
"@Test
	public void testSendAndReceiveMarshalNoResponse() throws Exception {

		Marshaller marshallerMock = mock(Marshaller.class);
		template.setMarshaller(marshallerMock);
		marshallerMock.marshal(isA(Object.class), isA(Result.class));

		connectionMock.send(isA(WebServiceMessage.class));
		when(connectionMock.hasError()).thenReturn(false);
		when(connectionMock.receive(messageFactory)).thenReturn(null);
		connectionMock.close();

		Object result = template.marshalSendAndReceive(new Object());

		assertThat(result).isNull();
	}",Eager Test + Mystery Guest
"@Test
	public void testSendAndReceiveMessageNoResponse() throws Exception {

		WebServiceMessageExtractor extractorMock = mock(WebServiceMessageExtractor.class);

		connectionMock.send(isA(WebServiceMessage.class));
		when(connectionMock.hasError()).thenReturn(false);
		when(connectionMock.receive(messageFactory)).thenReturn(null);
		connectionMock.close();

		Object result = template.sendAndReceive(null, extractorMock);

		assertThat(result).isNull();
	}",Eager Test + Mystery Guest
"@Test
	public void testSendAndReceiveResultNoResponse() throws Exception {

		connectionMock.send(isA(WebServiceMessage.class));
		when(connectionMock.hasError()).thenReturn(false);
		when(connectionMock.receive(messageFactory)).thenReturn(null);
		connectionMock.close();

		StringResult result = new StringResult();
		boolean b = template.sendSourceAndReceiveToResult(new StringSource(""<request />""), result);

		assertThat(b).isFalse();
	}",Eager Test + Mystery Guest
"@Test
	public void testHandleInvalidResponse() throws Exception {

		MockWebServiceMessage request = new MockWebServiceMessage();
		context = new DefaultMessageContext(request, new MockWebServiceMessageFactory());
		MockWebServiceMessage response = (MockWebServiceMessage) context.getResponse();
		response.setPayload(new ClassPathResource(INVALID_MESSAGE, getClass()));

		boolean result = interceptor.handleResponse(context);

		assertThat(result).isFalse();
	}",No Smells
"@Test
	public void interceptors() {

		PayloadRootAnnotationMethodEndpointMapping endpointMapping = this.applicationContext
				.getBean(PayloadRootAnnotationMethodEndpointMapping.class);

		assertThat(endpointMapping.getOrder()).isEqualTo(0);

		EndpointInterceptor[] interceptors = endpointMapping.getInterceptors();

		assertThat(interceptors).hasSize(1);
		assertThat(interceptors[0]).isInstanceOf(MyInterceptor.class);
	}",No Smells
"@Test
	public void ordering() {

		ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
				""interceptorsBeanDefinitionParserOrderTest.xml"", getClass());

		List<DelegatingSmartEndpointInterceptor> interceptors = new ArrayList<DelegatingSmartEndpointInterceptor>(
				applicationContext.getBeansOfType(DelegatingSmartEndpointInterceptor.class).values());

		assertThat(interceptors).hasSize(6);

		for (int i = 0; i < interceptors.size(); i++) {

			DelegatingSmartEndpointInterceptor delegatingInterceptor = interceptors.get(i);
			MyInterceptor interceptor = (MyInterceptor) delegatingInterceptor.getDelegate();

			assertThat(interceptor.getOrder()).isEqualTo(i);
		}",Eager Test + Mystery Guest
"@Test
	public void testProperties() {

		assertThat(context.getPropertyNames()).hasSize(0);

		String name = ""name"";

		assertThat(context.containsProperty(name)).isFalse();

		String value = ""value"";
		context.setProperty(name, value);

		assertThat(context.containsProperty(name)).isTrue();
		assertThat(context.getPropertyNames()).containsExactly(name);
		assertThat(context.getProperty(name)).isEqualTo(value);

		context.removeProperty(name);

		assertThat(context.containsProperty(name)).isFalse();
		assertThat(context.getPropertyNames()).isEmpty();
	}",Eager Test
"@Test
	public void testRequest() {
		assertThat(context.getRequest()).isEqualTo(request);
	}",Eager Test
"@Test
	public void testResponse() {

		WebServiceMessage response = new MockWebServiceMessage();
		expect(factoryMock.createWebServiceMessage()).andReturn(response);
		replay(factoryMock);

		WebServiceMessage result = context.getResponse();

		assertThat(result).isEqualTo(response);

		verify(factoryMock);
	}",Eager Test
"@Test
	public void supportsSupported() {

		expect(argumentResolver1.supportsParameter(isA(MethodParameter.class))).andReturn(true);
		expect(argumentResolver1.supportsParameter(isA(MethodParameter.class))).andReturn(false);
		expect(argumentResolver2.supportsParameter(isA(MethodParameter.class))).andReturn(true);
		expect(returnValueHandler.supportsReturnType(isA(MethodParameter.class))).andReturn(true);

		replay(argumentResolver1, argumentResolver2, returnValueHandler);

		boolean result = adapter.supports(supportedEndpoint);

		assertThat(result).isTrue();

		verify(argumentResolver1, argumentResolver2, returnValueHandler);
	}",No Smells
"@Test
	public void testNoResponse() throws Exception {

		WebServiceMessage messageMock = createMock(WebServiceMessage.class);
		expect(messageMock.getPayloadSource()).andReturn(new StringSource(""<request/>""));
		WebServiceMessageFactory factoryMock = createMock(WebServiceMessageFactory.class);
		MessageContext messageContext = new DefaultMessageContext(messageMock, factoryMock);

		Method noResponse = getClass().getMethod(""noResponse"", MyGenericType.class);
		MethodEndpoint methodEndpoint = new MethodEndpoint(this, noResponse);
		expect(unmarshallerMock.unmarshal(isA(Source.class))).andReturn(new MyGenericType<MyType>());

		replay(marshallerMock, unmarshallerMock, messageMock, factoryMock);

		assertThat(noResponseInvoked).isFalse();

		adapter.invoke(messageContext, methodEndpoint);

		assertThat(noResponseInvoked).isTrue();

		verify(marshallerMock, unmarshallerMock, messageMock, factoryMock);
	}",Eager Test
"@Test
	public void testUnsupportedMethodMultipleParams() throws NoSuchMethodException {

		Method unsupported = getClass().getMethod(""unsupportedMultipleParams"", String.class, String.class);

		replay(marshallerMock, unmarshallerMock);

		assertThat(adapter.supportsInternal(new MethodEndpoint(this, unsupported))).isFalse();

		verify(marshallerMock, unmarshallerMock);
	}",Eager Test
"@Test
	public void testUnsupportedMethodWrongReturnType() throws NoSuchMethodException {

		Method unsupported = getClass().getMethod(""unsupportedWrongParam"", String.class);
		expect(marshallerMock.supports(unsupported.getGenericReturnType())).andReturn(false);

		replay(marshallerMock, unmarshallerMock);

		assertThat(adapter.supportsInternal(new MethodEndpoint(this, unsupported))).isFalse();

		verify(marshallerMock, unmarshallerMock);
	}",Eager Test
"@Test
	public void testNoResponse() throws Exception {

		Method noResponse = getClass().getMethod(""noResponse"", new Class[] { MyType.class }",Eager Test
"@Test
	public void testResponse() throws Exception {

		Method response = getClass().getMethod(""response"", new Class[] { MyType.class }",Eager Test
"@Test
	public void testSupports() {
		assertThat(adapter.supports(endpointMock)).isTrue();
	}",No Smells
"@Test
	public void testUnsupportedMethodWrongParam() throws NoSuchMethodException {

		assertThat(
				adapter.supportsInternal(new MethodEndpoint(this, ""unsupportedWrongParam"", new Class[] { String.class }",No Smells
"@Test
	public void handleReturnValueString() throws Exception {

		MessageContext messageContext = new DefaultMessageContext(new MockWebServiceMessageFactory());

		String s = ""Foo"";
		JAXBElement<String> element = new JAXBElement<>(new QName(""http://springframework.org"", ""string""), String.class, s);
		processor.handleReturnValue(messageContext, stringReturnType, element);

		assertThat(messageContext.hasResponse()).isTrue();

		MockWebServiceMessage response = (MockWebServiceMessage) messageContext.getResponse();

		XmlAssert.assertThat(response.getPayloadAsString()).and(""<string xmlns='http://springframework.org'>Foo</string>"")
				.ignoreWhitespace().areIdentical();
	}",Eager Test
"@Test
	public void resolveArgument() throws JAXBException {

		WebServiceMessage request = new MockWebServiceMessage(
				""<myType xmlns='http://springframework.org'><string>Foo</string></myType>"");
		MessageContext messageContext = new DefaultMessageContext(request, new MockWebServiceMessageFactory());

		JAXBElement<?> result = processor.resolveArgument(messageContext, supportedParameter);

		assertThat(result.getValue()).isInstanceOf(MyType.class);

		MyType type = (MyType) result.getValue();

		assertThat(type.getString()).isEqualTo(""Foo"");
	}",Eager Test
"@Test
	public void supportsReturnType() {
		assertThat(processor.supportsReturnType(supportedReturnType)).isTrue();
	}",Eager Test
"@Test
	public void resolveArgumentFromCustomSAXSource() throws JAXBException {

		// Create a custom SAXSource that generates an appropriate sequence of events.
		XMLReader xmlReader = new AbstractXmlReader() {

			@Override
			public void parse(String systemId) throws SAXException {
				parse();
			}",Eager Test
"@Test
	public void handleReturnValue() throws Exception {

		MyObject returnValue = new MyObject();

		marshaller.marshal(eq(returnValue), isA(Result.class));

		replay(marshaller, unmarshaller);
		MessageContext messageContext = createMockMessageContext();

		processor.handleReturnValue(messageContext, supportedReturnType, returnValue);

		verify(marshaller, unmarshaller);
	}",No Smells
"@Test
	public void resolveArgumentNoUnmarshaller() {

		assertThatIllegalStateException().isThrownBy(() -> {

			processor = new MarshallingPayloadMethodProcessor();
			processor.setMarshaller(marshaller);

			replay(marshaller, unmarshaller);

			MessageContext messageContext = createMockMessageContext();

			processor.resolveArgument(messageContext, supportedParameter);
		}",No Smells
"@Test
	public void supportsParameterNoUnmarshallerSupported() {

		processor = new MarshallingPayloadMethodProcessor();
		processor.setMarshaller(marshaller);

		replay(marshaller, unmarshaller);

		assertThat(processor.supportsParameter(supportedParameter)).isFalse();

		verify(marshaller, unmarshaller);
	}",No Smells
"@Test
	public void supportsReturnTypeNoMarshaller() {

		processor = new MarshallingPayloadMethodProcessor();
		processor.setUnmarshaller(unmarshaller);

		replay(marshaller, unmarshaller);

		assertThat(processor.supportsReturnType(supportedReturnType)).isFalse();

		verify(marshaller, unmarshaller);
	}",No Smells
"@Test
	public void resolveEventReaderAxiomNonCaching() throws Exception {

		MessageContext messageContext = createNonCachingAxiomMessageContext();

		Object result = resolver.resolveArgument(messageContext, eventParameter);

		testEventReader(result);
	}",No Smells
"@Test
	public void resolveStreamReaderStream() throws Exception {

		MessageContext messageContext = createMockMessageContext();

		Object result = resolver.resolveArgument(messageContext, streamParameter);

		testStreamReader(result);
	}",No Smells
"@Test
	public void resolveConvertedType() throws Exception {

		MockWebServiceMessage request = new MockWebServiceMessage(CONTENTS);
		MessageContext messageContext = new DefaultMessageContext(request, new MockWebServiceMessageFactory());

		Object result = resolver.resolveArgument(messageContext, convertedParameter);

		assertThat(result).isInstanceOf(Integer.class);
		assertThat(result).isEqualTo(42);
	}",Eager Test
"@Test
	public void resolveNamespacesMethod() throws Exception {

		MockWebServiceMessage request = new MockWebServiceMessage(
				""<root xmlns=\""http://springframework.org/spring-ws\"">text</root>"");
		MessageContext messageContext = new DefaultMessageContext(request, new MockWebServiceMessageFactory());

		Object result = resolver.resolveArgument(messageContext, namespaceMethodParameter);

		assertThat(result).isInstanceOf(String.class);
		assertThat(result).isEqualTo(""text"");
	}",Eager Test
"@Test
	public void resolveString() throws Exception {

		MockWebServiceMessage request = new MockWebServiceMessage(CONTENTS);
		MessageContext messageContext = new DefaultMessageContext(request, new MockWebServiceMessageFactory());

		Object result = resolver.resolveArgument(messageContext, stringParameter);

		assertThat(result).isInstanceOf(String.class);

		String s = (String) result;

		assertThat(s).isEqualTo(""text"");
	}",Eager Test
"@Test
	public void testInvokeNoResponse() throws Exception {

		MockWebServiceMessage request = new MockWebServiceMessage(""<request/>"");
		MessageContext messageContext = new DefaultMessageContext(request, new MockWebServiceMessageFactory());
		expect(endpointMock.invoke(isA(Source.class))).andReturn(null);

		replay(endpointMock);

		adapter.invoke(messageContext, endpointMock);

		verify(endpointMock);

		assertThat(messageContext.hasResponse()).isFalse();
	}",No Smells
"@Test
	public void testUnsupportedMethodMultipleParams() throws NoSuchMethodException {

		assertThat(adapter.supportsInternal(
				new MethodEndpoint(this, ""unsupportedMultipleParams"", new Class[] { Source.class, Source.class }",No Smells
"@Test
	public void testSupportsSource() throws NoSuchMethodException {

		MethodEndpoint endpoint = new MethodEndpoint(this, ""supportedSource"", new Class[] { String.class }",No Smells
"@Test
	public void testSupportsVoid() throws NoSuchMethodException {

		MethodEndpoint endpoint = new MethodEndpoint(this, ""supportedVoid"", new Class[] { String.class }",No Smells
"@Test
	public void testNoStylesheetsSet() {
		assertThatIllegalArgumentException().isThrownBy(() -> interceptor.afterPropertiesSet());
	}",No Smells
"@Test
	public void endpointInvalidBeanName() throws Exception {

		StaticApplicationContext applicationContext = new StaticApplicationContext();
		applicationContext.registerSingleton(""endpoint"", Object.class);

		AbstractEndpointMapping mapping = new AbstractEndpointMapping() {

			@Override
			protected Object getEndpointInternal(MessageContext message) throws Exception {
				assertThat(message).isEqualTo(messageContext);
				return ""noSuchBean"";
			}",Eager Test
"@Test
	public void rootElement() throws NoSuchMethodException {

		Method rootElement = getClass().getMethod(""rootElement"", MyRootElement.class);
		QName name = mapping.getLookupKeyForMethod(rootElement);

		assertThat(name).isEqualTo(new QName(""myNamespace"", ""myRoot""));
	}",No Smells
"@Test
	public void invoke() throws Exception {

		MessageFactory messageFactory = MessageFactory.newInstance();
		SOAPMessage request = messageFactory.createMessage();
		request.getSOAPBody().addBodyElement(QName.valueOf(""{http://springframework.org/spring-ws}",Eager Test + Mystery Guest
"@Test
	public void registrationSingle() throws NoSuchMethodException {

		MethodEndpoint endpoint = mapping.lookupEndpoint(new QName(""http://springframework.org/spring-ws"", ""Request""));

		assertThat(endpoint).isNotNull();

		Method doIt = MyEndpoint.class.getMethod(""doIt"", Source.class);
		MethodEndpoint expected = new MethodEndpoint(""endpoint"", applicationContext, doIt);

		assertThat(endpoint).isEqualTo(expected);
	}",Eager Test + Mystery Guest
"@Test
	public void testGetLookupKeyForMessageNoNamespace() throws Exception {

		MockWebServiceMessage request = new MockWebServiceMessage(""<MyRequest/>"");
		MessageContext messageContext = new DefaultMessageContext(request, new MockWebServiceMessageFactory());

		assertThat(mapping.getLookupKeyForMessage(messageContext)).isEqualTo(""MyRequest"");
	}",No Smells
"@Test
	public void testGetLookupKeyForMessage() throws Exception {

		mapping.setExpression(""/root/text()"");
		mapping.afterPropertiesSet();

		MockWebServiceMessage request = new MockWebServiceMessage(""<root>value</root>"");
		MessageContext context = new DefaultMessageContext(request, new MockWebServiceMessageFactory());

		String result = mapping.getLookupKeyForMessage(context);

		assertThat(result).isNotNull();
		assertThat(result).isEqualTo(""value"");
	}",Eager Test
"@Test
	public void testGetters() {

		assertThat(endpoint.getBean()).isEqualTo(this);
		assertThat(endpoint.getMethod()).isEqualTo(method);
	}",Eager Test
"@Test
	public void getNamespaceContextClass() throws NoSuchMethodException {

		Method method = getClass().getMethod(""getNamespaceContextClass"");
		NamespaceContext namespaceContext = NamespaceUtils.getNamespaceContext(method);

		assertThat(namespaceContext.getNamespaceURI(""prefix1"")).isEqualTo(""class1"");
		assertThat(namespaceContext.getNamespaceURI(XMLConstants.DEFAULT_NS_PREFIX)).isEqualTo(""class2"");

	}",No Smells
"@Test
	public void testGetQNameForNullSource() throws Exception {

		QName qName = PayloadRootUtils.getPayloadRootQName(null, TransformerFactoryUtils.newInstance());

		assertThat(qName).isNull();
	}",No Smells
"@Test
	public void testGetQNameForStaxSourceEventReader() throws Exception {

		String contents = ""<prefix:localname xmlns:prefix='namespace'/>"";
		XMLInputFactory inputFactory = XMLInputFactoryUtils.newInstance();
		XMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(contents));
		Source source = StaxUtils.createStaxSource(eventReader);
		QName qName = PayloadRootUtils.getPayloadRootQName(source, TransformerFactoryUtils.newInstance());

		assertThat(qName).isNotNull();
		assertThat(qName.getLocalPart()).isEqualTo(""localname"");
		assertThat(qName.getNamespaceURI()).isEqualTo(""namespace"");
		assertThat(qName.getPrefix()).isEqualTo(""prefix"");
	}",Eager Test
"@Test
	public void testGetEndpointAdapterSupportedEndpoint() {

		EndpointAdapter adapterMock = createMock(EndpointAdapter.class);
		dispatcher.setEndpointAdapters(Collections.singletonList(adapterMock));

		Object endpoint = new Object();
		expect(adapterMock.supports(endpoint)).andReturn(true);

		replay(adapterMock, factoryMock);

		EndpointAdapter result = dispatcher.getEndpointAdapter(endpoint);

		verify(adapterMock, factoryMock);

		assertThat(result).isEqualTo(adapterMock);
	}",Eager Test
"@Test
	public void testGetEndpointAdapterUnsupportedEndpoint() {

		EndpointAdapter adapterMock = createMock(EndpointAdapter.class);
		dispatcher.setEndpointAdapters(Collections.singletonList(adapterMock));

		Object endpoint = new Object();
		expect(adapterMock.supports(endpoint)).andReturn(false);

		replay(adapterMock, factoryMock);

		assertThatIllegalStateException().isThrownBy(() -> dispatcher.getEndpointAdapter(endpoint));

		verify(adapterMock, factoryMock);
	}",Eager Test
"@Test
	public void testInterceptedRequestFlow() throws Exception {

		EndpointAdapter adapterMock = createMock(EndpointAdapter.class);
		dispatcher.setEndpointAdapters(Collections.singletonList(adapterMock));

		EndpointMapping mappingMock = createMock(EndpointMapping.class);
		dispatcher.setEndpointMappings(Collections.singletonList(mappingMock));

		EndpointInterceptor interceptorMock1 = createStrictMock(""interceptor1"", EndpointInterceptor.class);
		EndpointInterceptor interceptorMock2 = createStrictMock(""interceptor2"", EndpointInterceptor.class);

		Object endpoint = new Object();

		expect(interceptorMock1.handleRequest(messageContext, endpoint)).andReturn(false);
		expect(interceptorMock1.handleResponse(messageContext, endpoint)).andReturn(true);
		interceptorMock1.afterCompletion(messageContext, endpoint, null);

		EndpointInvocationChain chain = new EndpointInvocationChain(endpoint,
				new EndpointInterceptor[] { interceptorMock1, interceptorMock2 }",Eager Test
"@Test
	public void testNormalFlow() throws Exception {

		EndpointAdapter adapterMock = createMock(EndpointAdapter.class);
		dispatcher.setEndpointAdapters(Collections.singletonList(adapterMock));

		Object endpoint = new Object();
		expect(adapterMock.supports(endpoint)).andReturn(true);

		EndpointMapping mappingMock = createMock(EndpointMapping.class);
		dispatcher.setEndpointMappings(Collections.singletonList(mappingMock));

		EndpointInterceptor interceptorMock1 = createStrictMock(""interceptor1"", EndpointInterceptor.class);
		EndpointInterceptor interceptorMock2 = createStrictMock(""interceptor2"", EndpointInterceptor.class);

		expect(interceptorMock1.handleRequest(messageContext, endpoint)).andReturn(true);
		expect(interceptorMock2.handleRequest(messageContext, endpoint)).andReturn(true);

		adapterMock.invoke(messageContext, endpoint);

		expect(interceptorMock2.handleResponse(messageContext, endpoint)).andReturn(true);
		expect(interceptorMock1.handleResponse(messageContext, endpoint)).andReturn(true);

		interceptorMock2.afterCompletion(messageContext, endpoint, null);
		interceptorMock1.afterCompletion(messageContext, endpoint, null);

		EndpointInvocationChain chain = new EndpointInvocationChain(endpoint,
				new EndpointInterceptor[] { interceptorMock1, interceptorMock2 }",Eager Test
"@Test
	public void testProcessUnsupportedEndpointException() {

		EndpointExceptionResolver resolverMock = createMock(EndpointExceptionResolver.class);
		dispatcher.setEndpointExceptionResolvers(Collections.singletonList(resolverMock));

		Object endpoint = new Object();
		Exception ex = new Exception();

		expect(resolverMock.resolveException(messageContext, endpoint, ex)).andReturn(false);

		replay(factoryMock, resolverMock);

		try {
			dispatcher.processEndpointException(messageContext, endpoint, ex);
		}",Eager Test
"@Test
	public void testResolveException() throws Exception {

		final Exception ex = new Exception();

		EndpointMapping endpointMapping = messageContext -> {
			throw ex;
		}",Eager Test
"@Test
	public void testResolveExceptionsWithInterceptors() throws Exception {

		EndpointAdapter adapterMock = createMock(EndpointAdapter.class);
		dispatcher.setEndpointAdapters(Collections.singletonList(adapterMock));

		Object endpoint = new Object();
		expect(adapterMock.supports(endpoint)).andReturn(true);

		EndpointMapping mappingMock = createMock(EndpointMapping.class);
		dispatcher.setEndpointMappings(Collections.singletonList(mappingMock));

		EndpointExceptionResolver resolverMock = createMock(EndpointExceptionResolver.class);
		dispatcher.setEndpointExceptionResolvers(Collections.singletonList(resolverMock));

		EndpointInterceptor interceptorMock = createStrictMock(""interceptor1"", EndpointInterceptor.class);

		expect(interceptorMock.handleRequest(messageContext, endpoint)).andReturn(true);

		adapterMock.invoke(messageContext, endpoint);
		RuntimeException exception = new RuntimeException();
		expectLastCall().andThrow(exception);

		expect(resolverMock.resolveException(messageContext, endpoint, exception)).andReturn(true);

		expect(interceptorMock.handleResponse(messageContext, endpoint)).andReturn(true);

		interceptorMock.afterCompletion(messageContext, endpoint, null);

		EndpointInvocationChain chain = new EndpointInvocationChain(endpoint,
				new EndpointInterceptor[] { interceptorMock }",Eager Test
"@Test
	public void testNoMatch() throws Exception {

		SaajSoapMessage message = loadSaajMessage(""200408/response-no-message-id.xml"");
		MessageContext messageContext = new DefaultMessageContext(message, new SaajSoapMessageFactory(messageFactory));

		EndpointInvocationChain endpoint = mapping.getEndpoint(messageContext);

		assertThat(endpoint).isNull();
	}",Eager Test + Mystery Guest + Resource Optimism
"@Test
	public void testToName() throws Exception {

		SOAPMessage message = messageFactory.createMessage();
		QName qName = new QName(""localPart"");
		SOAPEnvelope envelope = message.getSOAPPart().getEnvelope();
		Name name = SaajUtils.toName(qName, envelope);

		assertThat(name).isNotNull();
		assertThat(name.getLocalName()).isEqualTo(qName.getLocalPart());
		assertThat(StringUtils.hasLength(name.getPrefix())).isFalse();
		assertThat(StringUtils.hasLength(name.getURI())).isFalse();
	}",Eager Test
"@Test
	public void testToNameNamespace() throws Exception {

		SOAPMessage message = messageFactory.createMessage();
		QName qName = new QName(""namespace"", ""localPart"");
		SOAPEnvelope envelope = message.getSOAPPart().getEnvelope();
		envelope.addNamespaceDeclaration(""prefix"", ""namespace"");
		Name name = SaajUtils.toName(qName, envelope);

		assertThat(name).isNotNull();
		assertThat(name.getURI()).isEqualTo(qName.getNamespaceURI());
		assertThat(name.getLocalName()).isEqualTo(qName.getLocalPart());
		assertThat(name.getPrefix()).isEqualTo(""prefix"");
	}",Eager Test
"@Test
	public void testToNameNamespacePrefix() throws Exception {

		SOAPMessage message = messageFactory.createMessage();
		QName qName = new QName(""namespace"", ""localPart"", ""prefix"");
		SOAPEnvelope envelope = message.getSOAPPart().getEnvelope();
		Name name = SaajUtils.toName(qName, envelope);

		assertThat(name).isNotNull();
		assertThat(name.getURI()).isEqualTo(qName.getNamespaceURI());
		assertThat(name.getLocalName()).isEqualTo(qName.getLocalPart());
		assertThat(name.getPrefix()).isEqualTo(qName.getPrefix());
	}",Eager Test
"@Test
	public void testToQNamePrefixNamespace() throws Exception {

		SOAPMessage message = messageFactory.createMessage();
		Name name = message.getSOAPPart().getEnvelope().createName(""localPart"", ""prefix"", ""namespace"");
		QName qName = SaajUtils.toQName(name);

		assertThat(qName).isNotNull();
		assertThat(qName.getNamespaceURI()).isEqualTo(name.getURI());
		assertThat(qName.getLocalPart()).isEqualTo(name.getLocalName());
		assertThat(qName.getPrefix()).isEqualTo(name.getPrefix());
	}",Eager Test
"@Test
	public void algorithm() throws Exception {

		KeyManagersFactoryBean factoryBean = new KeyManagersFactoryBean();
		factoryBean.setAlgorithm(""PKIX"");
		factoryBean.afterPropertiesSet();
		KeyManager[] keyManagers = factoryBean.getObject();

		assertThat(keyManagers).isNotNull();
		assertThat(keyManagers).hasSize(1);
	}",Eager Test
"@Test
	public void testHandleKeyName() throws Exception {

		callbackHandler.handleInternal(callback);

		assertThat(callback.getKey()).isNotNull();
	}",No Smells
"@Test
	public void testProperties() throws Exception {

		factoryBean.setKeyStoreType(""jceks"");
		factoryBean.setKeyStorePassword(""123456"");
		factoryBean.setKeyStoreLocation(new ClassPathResource(""private.jks""));
		factoryBean.afterPropertiesSet();
		Object result = factoryBean.getObject();

		assertThat(result).isNotNull();
		assertThat(result).isInstanceOf(Merlin.class);
	}",No Smells
"@Test
	public void supportsParameter() {

		assertThat(resolver.supportsParameter(soapHeaderElementParameter)).isTrue();
		assertThat(resolver.supportsParameter(soapHeaderElementListParameter)).isTrue();
	}",No Smells
"@Test
	public void resolveSoapEnvelopeSaaj() throws Exception {

		MessageContext messageContext = createSaajMessageContext();
		Object result = resolver.resolveArgument(messageContext, soapEnvelopeParameter);

		assertThat(result).isEqualTo(((SoapMessage) messageContext.getRequest()).getEnvelope());
	}",No Smells
"@Test
	public void shouldInterceptFullMatch() {

		PayloadRootSmartSoapEndpointInterceptor interceptor = new PayloadRootSmartSoapEndpointInterceptor(delegate,
				namespaceUri, localPart);

		boolean result = interceptor.shouldIntercept(messageContext, null);

		assertThat(result).isTrue();
	}",No Smells
"@Test
	public void testHandleValidRequest() throws Exception {

		MockWebServiceMessage request = new MockWebServiceMessage();
		request.setPayload(new ClassPathResource(VALID_MESSAGE, getClass()));
		context = new DefaultMessageContext(request, new MockWebServiceMessageFactory());
		boolean result = interceptor.handleRequest(context);

		assertThat(result).isTrue();
		assertThat(context.hasResponse()).isFalse();
	}",Eager Test
"@Test
	public void testHandleValidResponse() throws Exception {

		MockWebServiceMessage request = new MockWebServiceMessage();
		context = new DefaultMessageContext(request, new MockWebServiceMessageFactory());
		MockWebServiceMessage response = (MockWebServiceMessage) context.getResponse();
		response.setPayload(new ClassPathResource(VALID_MESSAGE, getClass()));
		boolean result = interceptor.handleResponse(context);

		assertThat(result).isTrue();
	}",Eager Test
"@Test
	public void testNonExistingSchema() throws Exception {

		assertThatIllegalArgumentException().isThrownBy(() -> {

			interceptor.setSchema(new ClassPathResource(""invalid""));
			interceptor.afterPropertiesSet();
		}",No Smells
"@Test
	public void shouldInterceptMatch() {

		SoapActionSmartEndpointInterceptor interceptor = new SoapActionSmartEndpointInterceptor(delegate, soapAction);

		boolean result = interceptor.shouldIntercept(messageContext, null);

		assertThat(result).isTrue();
	}",No Smells
"@Test
	public void testValidateLookupKey() {
		assertThat(mapping.validateLookupKey(""SoapAction"")).isTrue();
	}",No Smells
"@Test
	public void testResolveExceptionDefault() throws Exception {

		SoapFaultDefinition defaultFault = new SoapFaultDefinition();
		defaultFault.setFaultCode(SoapFaultDefinition.CLIENT);
		defaultFault.setFaultStringOrReason(""faultstring"");
		resolver.setDefaultFault(defaultFault);
		MessageFactory saajFactory = MessageFactory.newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
		SoapMessageFactory factory = new SaajSoapMessageFactory(saajFactory);
		MessageContext context = new DefaultMessageContext(factory);

		boolean result = resolver.resolveException(context, null, new NonAnnotatedException());

		assertThat(result).isTrue();
		assertThat(context.hasResponse()).isTrue();

		SoapMessage response = (SoapMessage) context.getResponse();

		assertThat(response.getSoapBody().hasFault()).isTrue();

		Soap11Fault fault = (Soap11Fault) response.getSoapBody().getFault();

		assertThat(fault.getFaultCode()).isEqualTo(SoapVersion.SOAP_11.getClientOrSenderFaultName());
		assertThat(fault.getFaultStringOrReason()).isEqualTo(""faultstring"");
		assertThat(fault.getFaultDetail()).isNull();
	}",Eager Test
"@Test
	public void testResolveExceptionReceiverSoap12() throws Exception {

		MessageFactory saajFactory = MessageFactory.newInstance(SOAPConstants.SOAP_1_2_PROTOCOL);
		SOAPMessage message = saajFactory.createMessage();
		SoapMessageFactory factory = new SaajSoapMessageFactory(saajFactory);
		MessageContext context = new DefaultMessageContext(new SaajSoapMessage(message), factory);

		boolean result = resolver.resolveException(context, null, new MyReceiverException());

		assertThat(result).isTrue();
		assertThat(context.hasResponse()).isTrue();

		SoapMessage response = (SoapMessage) context.getResponse();

		assertThat(response.getSoapBody().hasFault()).isTrue();

		Soap12Fault fault = (Soap12Fault) response.getSoapBody().getFault();

		assertThat(fault.getFaultCode()).isEqualTo(SoapVersion.SOAP_12.getServerOrReceiverFaultName());
		assertThat(fault.getFaultReasonText(Locale.ENGLISH)).isEqualTo(""Receiver error"");
		assertThat(fault.getFaultDetail()).isNull();
	}",Eager Test
"@Test
	public void testResolveExceptionServerSoap11() throws Exception {

		MessageFactory saajFactory = MessageFactory.newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
		SoapMessageFactory factory = new SaajSoapMessageFactory(saajFactory);
		MessageContext context = new DefaultMessageContext(factory);

		boolean result = resolver.resolveException(context, null, new MyServerException());

		assertThat(result).isTrue();
		assertThat(context.hasResponse()).isTrue();

		SoapMessage response = (SoapMessage) context.getResponse();

		assertThat(response.getSoapBody().hasFault()).isTrue();

		Soap11Fault fault = (Soap11Fault) response.getSoapBody().getFault();

		assertThat(fault.getFaultCode()).isEqualTo(SoapVersion.SOAP_11.getServerOrReceiverFaultName());
		assertThat(fault.getFaultStringOrReason()).isEqualTo(""Server error"");
		assertThat(fault.getFaultDetail()).isNull();
	}",Eager Test
"@Test
	public void testSetAsTextNoLocale() {

		editor.setAsText(""Server, Server error"");
		SoapFaultDefinition definition = (SoapFaultDefinition) editor.getValue();

		assertThat(definition).isNotNull();
		assertThat(definition.getFaultCode()).isEqualTo(new QName(""Server""));
		assertThat(definition.getFaultStringOrReason()).isEqualTo(""Server error"");
		assertThat(definition.getLocale()).isEqualTo(Locale.ENGLISH);
	}",No Smells
"@Test
	public void testSetAsTextReceiver() {

		editor.setAsText(""RECEIVER, Server error"");
		SoapFaultDefinition definition = (SoapFaultDefinition) editor.getValue();

		assertThat(definition).isNotNull();
		assertThat(definition.getFaultCode()).isEqualTo(SoapFaultDefinition.RECEIVER);
		assertThat(definition.getFaultStringOrReason()).isEqualTo(""Server error"");
	}",No Smells
"@Test
	public void testGetDepth() {

		assertThat(resolver.getDepth(""java.lang.Exception"", new Exception())).isEqualTo(0);
		assertThat(resolver.getDepth(""java.lang.Exception"", new IllegalArgumentException())).isEqualTo(2);
		assertThat(resolver.getDepth(""IllegalArgumentException"", new IllegalStateException())).isEqualTo(-1);
	}",No Smells
"@Test
	public void testResolveExceptionClientSoap11() throws Exception {

		Properties mappings = new Properties();
		mappings.setProperty(Exception.class.getName(), ""SERVER, Server error"");
		mappings.setProperty(RuntimeException.class.getName(), ""CLIENT, Client error"");
		resolver.setExceptionMappings(mappings);

		MessageFactory messageFactory = MessageFactory.newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
		SOAPMessage message = messageFactory.createMessage();
		SoapMessageFactory factory = new SaajSoapMessageFactory(messageFactory);
		MessageContext context = new DefaultMessageContext(new SaajSoapMessage(message), factory);

		boolean result = resolver.resolveException(context, null, new IllegalArgumentException(""bla""));

		assertThat(result).isTrue();
		assertThat(context.hasResponse()).isTrue();

		SoapMessage response = (SoapMessage) context.getResponse();

		assertThat(response.getSoapBody().hasFault()).isTrue();

		Soap11Fault fault = (Soap11Fault) response.getSoapBody().getFault();

		assertThat(fault.getFaultCode()).isEqualTo(SoapVersion.SOAP_11.getClientOrSenderFaultName());
		assertThat(fault.getFaultStringOrReason()).isEqualTo(""Client error"");
		assertThat(fault.getFaultDetail()).isNull();
	}",Eager Test
"@Test
	public void testResolveExceptionReceiverSoap12() throws Exception {

		Properties mappings = new Properties();
		mappings.setProperty(Exception.class.getName(), ""SENDER, Sender error"");
		mappings.setProperty(RuntimeException.class.getName(), ""RECEIVER, Receiver error"");
		resolver.setExceptionMappings(mappings);

		MessageFactory messageFactory = MessageFactory.newInstance(SOAPConstants.SOAP_1_2_PROTOCOL);
		SOAPMessage message = messageFactory.createMessage();
		SoapMessageFactory factory = new SaajSoapMessageFactory(messageFactory);
		MessageContext context = new DefaultMessageContext(new SaajSoapMessage(message), factory);

		boolean result = resolver.resolveException(context, null, new IllegalArgumentException(""bla""));

		assertThat(result).isTrue();
		assertThat(context.hasResponse()).isTrue();

		SoapMessage response = (SoapMessage) context.getResponse();

		assertThat(response.getSoapBody().hasFault()).isTrue();

		Soap12Fault fault = (Soap12Fault) response.getSoapBody().getFault();

		assertThat(fault.getFaultCode()).isEqualTo(SoapVersion.SOAP_12.getServerOrReceiverFaultName());
		assertThat(fault.getFaultReasonText(Locale.ENGLISH)).isEqualTo(""Receiver error"");
		assertThat(fault.getFaultDetail()).isNull();
	}",Eager Test
"@Test
	public void testProcessMustUnderstandHeadersForActorSoap11() throws Exception {

		MessageFactory messageFactory = MessageFactory.newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
		SOAPMessage request = messageFactory.createMessage();
		SOAPHeaderElement header = request.getSOAPHeader()
				.addHeaderElement(new QName(""http://www.springframework.org"", ""Header"", ""spring-ws""));
		String headerActor = ""http://www/springframework.org/role"";
		header.setActor(headerActor);
		header.setMustUnderstand(true);
		SoapMessageFactory factory = new SaajSoapMessageFactory(messageFactory);
		MessageContext context = new DefaultMessageContext(new SaajSoapMessage(request), factory);
		expect(interceptorMock.understands(isA(SoapHeaderElement.class))).andReturn(true);

		replay(interceptorMock);

		SoapEndpointInvocationChain chain = new SoapEndpointInvocationChain(new Object(),
				new SoapEndpointInterceptor[] { interceptorMock }",Eager Test + Mystery Guest
"@Test
	public void testProcessMustUnderstandHeadersNotUnderstoodSoap12() throws Exception {

		MessageFactory messageFactory = MessageFactory.newInstance(SOAPConstants.SOAP_1_2_PROTOCOL);
		SOAPMessage request = messageFactory.createMessage();
		SOAPHeaderElement header = request.getSOAPHeader()
				.addHeaderElement(new QName(""http://www.springframework.org"", ""Header"", ""spring-ws""));
		header.setMustUnderstand(true);
		header.setRole(SOAPConstants.URI_SOAP_1_2_ROLE_NEXT);
		SoapMessageFactory factory = new SaajSoapMessageFactory(messageFactory);
		MessageContext context = new DefaultMessageContext(new SaajSoapMessage(request), factory);
		expect(interceptorMock.understands(isA(SoapHeaderElement.class))).andReturn(false);

		replay(interceptorMock);

		SoapEndpointInvocationChain chain = new SoapEndpointInvocationChain(new Object(),
				new SoapEndpointInterceptor[] { interceptorMock }",Eager Test + Mystery Guest
"@Test
	public void testExtractActionFromContentType() {

		String soapAction = ""http://springframework.org/spring-ws/Action"";

		String contentType = ""application/soap+xml; action="" + soapAction;
		String result = SoapUtils.extractActionFromContentType(contentType);

		assertThat(result).isEqualTo(soapAction);

		contentType = ""application/soap+xml; action	  = "" + soapAction;
		result = SoapUtils.extractActionFromContentType(contentType);

		assertThat(result).isEqualTo(soapAction);

		contentType = ""application/soap+xml; action="" + soapAction + "" ; charset=UTF-8"";
		result = SoapUtils.extractActionFromContentType(contentType);

		assertThat(result).isEqualTo(soapAction);

		contentType = ""application/soap+xml; charset=UTF-8; action="" + soapAction;
		result = SoapUtils.extractActionFromContentType(contentType);

		assertThat(result).isEqualTo(soapAction);
	}",Eager Test
"@Test
	public void testSetActionInContentType() {

		String soapAction = ""http://springframework.org/spring-ws/Action"";
		String contentType = ""application/soap+xml"";

		String result = SoapUtils.setActionInContentType(contentType, soapAction);

		assertThat(SoapUtils.extractActionFromContentType(result)).isEqualTo(soapAction);

		String anotherSoapAction = ""http://springframework.org/spring-ws/AnotherAction"";
		String contentTypeWithAction = ""application/soap+xml; action=http://springframework.org/spring-ws/Action"";
		result = SoapUtils.setActionInContentType(contentTypeWithAction, anotherSoapAction);

		assertThat(SoapUtils.extractActionFromContentType(result)).isEqualTo(anotherSoapAction);
	}",Eager Test
"@Test
	public void testGetDefaultStrategyMoreThanOne() {

		Properties strategies = new Properties();
		strategies.put(Strategy.class.getName(),
				StrategyImpl.class.getName() + "","" + ContextAwareStrategyImpl.class.getName());
		DefaultStrategiesHelper helper = new DefaultStrategiesHelper(strategies);

		StaticApplicationContext applicationContext = new StaticApplicationContext();
		applicationContext.registerSingleton(""strategy1"", StrategyImpl.class);
		applicationContext.registerSingleton(""strategy2"", ContextAwareStrategyImpl.class);

		assertThatExceptionOfType(BeanInitializationException.class)
				.isThrownBy(() -> helper.getDefaultStrategy(Strategy.class, applicationContext));
	}",Eager Test
"@Test
	public void testResourceConstructor() {

		Resource resource = new ClassPathResource(""strategies.properties"", getClass());
		new DefaultStrategiesHelper(resource);
	}",No Smells
"@Test
	public void testUnmarshalMime() throws Exception {

		MimeUnmarshaller unmarshallerMock = createMock(MimeUnmarshaller.class);
		MimeMessage messageMock = createMock(MimeMessage.class);

		Source source = new StringSource("""");
		Object unmarshalled = new Object();
		expect(messageMock.getPayloadSource()).andReturn(source);
		expect(unmarshallerMock.unmarshal(eq(source), isA(MimeContainer.class))).andReturn(unmarshalled);

		replay(unmarshallerMock, messageMock);

		Object result = MarshallingUtils.unmarshal(unmarshallerMock, messageMock);

		assertThat(result).isEqualTo(unmarshalled);

		verify(unmarshallerMock, messageMock);
	}",Eager Test
"@Test
	public void callback() throws IOException {

		String errorMessage = ""Error message"";
		ErrorResponseCreator callback = new ErrorResponseCreator(errorMessage);
		callback.createResponse(null, null, null);

		assertThat(callback.getErrorMessage()).isEqualTo(errorMessage);
	}",No Smells
"@Test
	public void createServerApplicationContextWebServiceTemplate() {

		StaticApplicationContext applicationContext = new StaticApplicationContext();
		applicationContext.registerSingleton(""webServiceTemplate"", WebServiceTemplate.class);
		applicationContext.refresh();

		MockWebServiceServer server = MockWebServiceServer.createServer(applicationContext);

		assertThat(server).isNotNull();
	}",No Smells
"@Test
	public void payloadMatch() {

		Source request = new StringSource(""<request xmlns='http://example.com'/>"");
		Source response = new StringSource(""<response xmlns='http://example.com'/>"");

		server.expect(payload(request)).andRespond(withPayload(response));

		StringResult result = new StringResult();
		template.sendSourceAndReceiveToResult(request, result);

		XmlAssert.assertThat(response.toString()).and(result.toString()).ignoreWhitespace().areSimilar();
	}",Eager Test
"@Test
	public void payloadNonMatch() {

		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {

			Source expected = new StringSource(""<request xmlns='http://example.com'/>"");

			server.expect(payload(expected));

			StringResult result = new StringResult();
			String actual = ""<request xmlns='http://other.com'/>"";
			template.sendSourceAndReceiveToResult(new StringSource(actual), result);
		}",Eager Test
"@Test
	public void xpathExistsMatch() {

		final Map<String, String> ns = Collections.singletonMap(""ns"", ""http://example.com"");

		server.expect(xpath(""/ns:request"", ns).exists());

		template.sendSourceAndReceiveToResult(new StringSource(""<request xmlns='http://example.com'/>""),
				new StringResult());
	}",Eager Test
"@Test
	public void xsdMatch() throws Exception {

		Resource schema = new ByteArrayResource(
				""<schema xmlns=\""http://www.w3.org/2001/XMLSchema\"" targetNamespace=\""http://example.com\"" elementFormDefault=\""qualified\""><element name=\""request\""/></schema>""
						.getBytes());

		server.expect(validPayload(schema));

		StringResult result = new StringResult();
		String actual = ""<request xmlns='http://example.com'/>"";
		template.sendSourceAndReceiveToResult(new StringSource(actual), result);
	}",Eager Test
"@Test
	public void withMustUnderstandFault() throws Exception {

		String faultString = ""Foo"";
		ResponseCreator responseCreator = ResponseCreators.withMustUnderstandFault(faultString, Locale.ENGLISH);

		testFault(responseCreator, faultString, SoapVersion.SOAP_11.getMustUnderstandFaultName());
	}",No Smells
"@Test
	public void withSoapEnvelopeResource() throws Exception {

		StringBuilder xmlBuilder = new StringBuilder();
		xmlBuilder.append(""<?xml version='1.0'?>"");
		xmlBuilder.append(""<soap:Envelope xmlns:soap='http://www.w3.org/2003/05/soap-envelope'>"");
		xmlBuilder.append(""<soap:Header><header xmlns='http://springframework.org'/></soap:Header>"");
		xmlBuilder.append(""<soap:Body><payload xmlns='http://springframework.org'/></soap:Body>"");
		xmlBuilder.append(""</soap:Envelope>"");
		String envelope = xmlBuilder.toString();
		ResponseCreator responseCreator = ResponseCreators
				.withSoapEnvelope(new ByteArrayResource(envelope.getBytes(StandardCharsets.UTF_8)));
		WebServiceMessage response = responseCreator.createResponse(null, null, messageFactory);

		XmlAssert.assertThat(getSoapEnvelopeAsString((SoapMessage) response)).and(envelope).ignoreWhitespace().areSimilar();
	}",Eager Test
"@Test
	public void createServerApplicationContextDefaults() {

		StaticApplicationContext applicationContext = new StaticApplicationContext();
		applicationContext.refresh();

		MockWebServiceClient client = MockWebServiceClient.createClient(applicationContext);

		assertThat(client).isNotNull();
	}",No Smells
"@Test
	public void match() throws IOException {

		adaptee.match(message);

		replay(message, adaptee);

		adapter.match(null, message);

		verify(message, adaptee);
	}",No Smells
"@Test
	public void multipleSchemaDifferentOrderNotOk() throws AssertionError {

		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {

			expect(message.getPayloadSource()).andReturn(
					new StringSource(""<test xmlns=\""http://www.example.org/schema\""><number>a</number><text>text</text></test>""))
					.times(2);

			SchemaValidatingMatcher matcher = new SchemaValidatingMatcher(schema1, schema2);

			replay(message);

			matcher.match(message);

			verify(message);
		}",No Smells
"@Test
	public void match() throws Exception {

		StringBuilder xmlBuilder = new StringBuilder();
		xmlBuilder.append(""<?xml version='1.0'?>"");
		xmlBuilder.append(""<soap:Envelope xmlns:soap='http://www.w3.org/2003/05/soap-envelope'>"");
		xmlBuilder.append(""<soap:Header><header xmlns='http://example.com'/></soap:Header>"");
		xmlBuilder.append(""<soap:Body><payload xmlns='http://example.com'/></soap:Body>"");
		xmlBuilder.append(""</soap:Envelope>"");
		String xml = xmlBuilder.toString();
		DOMResult result = new DOMResult();
		TransformerHelper transformerHelper = new TransformerHelper();
		transformerHelper.transform(new StringSource(xml), result);
		SoapMessage message = createMock(SoapMessage.class);
		expect(message.getDocument()).andReturn((Document) result.getNode()).once();
		replay(message);

		SoapEnvelopeDiffMatcher matcher = new SoapEnvelopeDiffMatcher(new StringSource(xml));
		matcher.match(message);

		verify(message);
	}",Eager Test
"@Test
	public void nonMatch() {

		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {

			StringBuilder xmlBuilder = new StringBuilder();
			xmlBuilder.append(""<?xml version='1.0'?>"");
			xmlBuilder.append(""<soap:Envelope xmlns:soap='http://www.w3.org/2003/05/soap-envelope'>"");
			xmlBuilder.append(""<soap:Header><header xmlns='http://example.com'/></soap:Header>"");
			xmlBuilder.append(""<soap:Body><payload%s xmlns='http://example.com'/></soap:Body>"");
			xmlBuilder.append(""</soap:Envelope>"");
			String xml = xmlBuilder.toString();
			String actual = String.format(xml, ""1"");
			DOMResult result = new DOMResult();
			TransformerHelper transformerHelper = new TransformerHelper();
			transformerHelper.transform(new StringSource(actual), result);
			SoapMessage message = createMock(SoapMessage.class);
			expect(message.getDocument()).andReturn((Document) result.getNode()).once();
			replay(message);

			String expected = String.format(xml, ""2"");
			SoapEnvelopeDiffMatcher matcher = new SoapEnvelopeDiffMatcher(new StringSource(expected));
			matcher.match(message);
		}",Eager Test
"@Test
	public void doesNotExistNonMatch() throws AssertionError {

		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {

			XPathExpectationsHelper helper = new XPathExpectationsHelper(""//a"");
			WebServiceMessageMatcher matcher = helper.doesNotExist();

			assertThat(matcher).isNotNull();

			WebServiceMessage message = createMock(WebServiceMessage.class);
			expect(message.getPayloadSource()).andReturn(new StringSource(""<a><b/></a>"")).times(2);

			replay(message);

			matcher.match(message);
		}",Eager Test
"@Test
	public void evaluatesToIntegerNonMatch() throws AssertionError {

		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {

			XPathExpectationsHelper helper = new XPathExpectationsHelper(""//b"");
			WebServiceMessageMatcher matcher = helper.evaluatesTo(2);

			assertThat(matcher).isNotNull();

			WebServiceMessage message = createMock(WebServiceMessage.class);
			expect(message.getPayloadSource()).andReturn(new StringSource(""<a><b>1</b></a>"")).times(2);

			replay(message);

			matcher.match(message);
		}",Eager Test
"@Test
	public void evaluatesToTrueNonMatch() throws AssertionError {

		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {

			XPathExpectationsHelper helper = new XPathExpectationsHelper(""//b=2"");
			WebServiceMessageMatcher matcher = helper.evaluatesTo(true);

			assertThat(matcher).isNotNull();

			WebServiceMessage message = createMock(WebServiceMessage.class);
			expect(message.getPayloadSource()).andReturn(new StringSource(""<a><b>1</b></a>"")).times(2);

			replay(message);

			matcher.match(message);
		}",Eager Test
"@Test
	public void many() {

		assertThatExceptionOfType(BeanInitializationException.class).isThrownBy(() -> {

			StaticApplicationContext applicationContext = new StaticApplicationContext();
			applicationContext.registerSingleton(""myBean1"", MyBean.class);
			applicationContext.registerSingleton(""myBean2"", MyBean.class);

			MockStrategiesHelper helper = new MockStrategiesHelper(applicationContext);
			helper.getStrategy(IMyBean.class);
		}",No Smells
"@Test
	public void receive() throws Exception {

		byte[] bytes = SOAP_CONTENT.getBytes(StandardCharsets.UTF_8);
		httpServletRequest.addHeader(""Content-Type"", ""text/xml"");
		httpServletRequest.addHeader(""Content-Length"", Integer.toString(bytes.length));
		httpServletRequest.addHeader(HEADER_NAME, HEADER_VALUE);
		httpServletRequest.setContent(bytes);
		SaajSoapMessage message = (SaajSoapMessage) connection.receive(messageFactory);

		assertThat(message).isNotNull();

		StringResult result = new StringResult();
		Transformer transformer = transformerFactory.newTransformer();
		transformer.transform(message.getPayloadSource(), result);

		XmlAssert.assertThat(result.toString()).and(CONTENT).ignoreWhitespace().areIdentical();

		SOAPMessage saajMessage = message.getSaajMessage();
		String[] headerValues = saajMessage.getMimeHeaders().getHeader(HEADER_NAME);

		assertThat(headerValues).isNotNull();
		assertThat(headerValues).hasSize(1);
		assertThat(headerValues[0]).isEqualTo(HEADER_VALUE);
	}",Eager Test
"@Test
	public void testStreamSource() throws Exception {

		long result = LastModifiedHelper.getLastModified(new StreamSource(resource.getFile()));

		assertThat(result).isEqualTo(expected);
	}",No Smells
"@Test
	public void testDefaultStrategies() throws ServletException {

		servlet.setContextClass(StaticWebApplicationContext.class);
		servlet.init(config);
		MessageDispatcher messageDispatcher = (MessageDispatcher) servlet.getMessageReceiver();

		assertThat(messageDispatcher).isNotNull();
	}",No Smells
"@Test
	public void testDetectWsdlDefinitions() throws Exception {

		servlet.setContextClass(WsdlDefinitionWebApplicationContext.class);
		servlet.init(config);
		MockHttpServletRequest request = new MockHttpServletRequest(HttpTransportConstants.METHOD_GET, ""/definition.wsdl"");
		MockHttpServletResponse response = new MockHttpServletResponse();
		servlet.service(request, response);
		DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactoryUtils.newInstance();
		documentBuilderFactory.setNamespaceAware(true);
		DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
		Document result = documentBuilder.parse(new ByteArrayInputStream(response.getContentAsByteArray()));
		Document expected = documentBuilder.parse(getClass().getResourceAsStream(""wsdl11-input.wsdl""));

		XmlAssert.assertThat(result).and(expected).ignoreWhitespace().areIdentical();
	}",Eager Test + Mystery Guest
"@Test
	public void handleGet() throws Exception {

		request.setMethod(HttpTransportConstants.METHOD_GET);
		String definition = ""<definition xmlns='http://schemas.xmlsoap.org/wsdl/'/>"";
		expect(definitionMock.getSource()).andReturn(new StringSource(definition));

		replay(definitionMock);

		adapter.handle(request, response, definitionMock);

		XmlAssert.assertThat(response.getContentAsString()).and(definition).ignoreWhitespace().areIdentical();

		verify(definitionMock);
	}",Eager Test
"@Test
	public void handleSimpleWsdl11DefinitionWithTransformLocation() throws Exception {

		adapter.setTransformLocations(true);
		adapter.setTransformSchemaLocations(true);

		request.setMethod(HttpTransportConstants.METHOD_GET);
		request.setScheme(""http"");
		request.setServerName(""example.com"");
		request.setServerPort(80);
		request.setContextPath(""/context"");
		request.setServletPath(""/service.wsdl"");
		request.setPathInfo(null);
		request.setRequestURI(""/context/service.wsdl"");

		SimpleWsdl11Definition definition = new SimpleWsdl11Definition(
				new ClassPathResource(""echo-input.wsdl"", getClass()));

		adapter.handle(request, response, definition);

		InputStream inputStream = new ByteArrayInputStream(response.getContentAsByteArray());
		DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactoryUtils.newInstance();
		documentBuilderFactory.setNamespaceAware(true);
		DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
		Document resultingDocument = documentBuilder.parse(inputStream);

		documentBuilder = documentBuilderFactory.newDocumentBuilder();
		Document expectedDocument = documentBuilder.parse(getClass().getResourceAsStream(""echo-expected.wsdl""));

		XmlAssert.assertThat(resultingDocument).and(expectedDocument).ignoreWhitespace().areIdentical();
	}",Eager Test
"@Test
	public void transformLocationEmptyContextRelativeUrl() throws Exception {

		request.setScheme(""http"");
		request.setServerName(""example.com"");
		request.setServerPort(8080);
		request.setContextPath("""");
		request.setRequestURI(""/service.wsdl"");
		String oldLocation = ""/service"";

		String result = adapter.transformLocation(oldLocation, request);

		assertThat(result).isNotNull();
		assertThat(new URI(result)).isEqualTo(new URI(""http://example.com:8080/service""));
	}",No Smells
"@Test
	public void getDestinationName() throws Exception {

		URI uri = new URI(""jms:RequestQueue?replyToName=RESP_QUEUE"");
		String destinationName = JmsTransportUtils.getDestinationName(uri);

		assertThat(destinationName).isEqualTo(""RequestQueue"");

		uri = new URI(""jms:RequestQueue"");
		destinationName = JmsTransportUtils.getDestinationName(uri);

		assertThat(destinationName).isEqualTo(""RequestQueue"");
	}",Eager Test
"@Test
	public void getReplyToName() throws Exception {

		URI uri = new URI(""jms:RequestQueue?replyToName=RESP_QUEUE"");
		String replyToName = JmsTransportUtils.getReplyToName(uri);

		assertThat(replyToName).isEqualTo(""RESP_QUEUE"");

		uri = new URI(""jms:RequestQueue?priority=5"");
		replyToName = JmsTransportUtils.getReplyToName(uri);

		assertThat(replyToName).isNull();
	}",Eager Test
"@Test
	public void jndi() throws Exception {

		URI uri = new URI(""jms:jms/REQUEST_QUEUE?replyToName=jms/REPLY_QUEUE"");
		String destination = JmsTransportUtils.getDestinationName(uri);

		assertThat(destination).isEqualTo(""jms/REQUEST_QUEUE"");

		String replyTo = JmsTransportUtils.getReplyToName(uri);

		assertThat(replyTo).isEqualTo(""jms/REPLY_QUEUE"");
	}",Eager Test
"@Test
	public void handleConnectionResponse() throws Exception {

		when(connectionMock.receive(messageFactory)).thenReturn(request);

		connectionMock.setFaultCode(null);
		connectionMock.send(isA(WebServiceMessage.class));
		connectionMock.close();

		WebServiceMessageReceiver receiver = new WebServiceMessageReceiver() {

			@Override
			public void receive(MessageContext messageContext) throws Exception {
				assertThat(messageContext).isNotNull();
				messageContext.getResponse();
			}",No Smells
"@Test
	public void noHost() {
		assertThatIllegalArgumentException().isThrownBy(() -> factoryBean.afterPropertiesSet());
	}",No Smells
"@Test
	public void testPopulateBinding() throws Exception {

		String namespace = ""http://springframework.org/spring-ws"";
		definition.addNamespace(""tns"", namespace);
		definition.setTargetNamespace(namespace);

		PortType portType = definition.createPortType();
		portType.setQName(new QName(namespace, ""PortType""));
		portType.setUndefined(false);
		definition.addPortType(portType);
		Operation operation = definition.createOperation();
		operation.setName(""Operation"");
		operation.setUndefined(false);
		operation.setStyle(OperationType.REQUEST_RESPONSE);
		portType.addOperation(operation);
		Input input = definition.createInput();
		input.setName(""Input"");
		operation.setInput(input);
		Output output = definition.createOutput();
		output.setName(""Output"");
		operation.setOutput(output);
		Fault fault = definition.createFault();
		fault.setName(""Fault"");
		operation.addFault(fault);

		Properties soapActions = new Properties();
		soapActions.setProperty(""Operation"", namespace + ""/Action"");
		provider.setSoapActions(soapActions);

		provider.setServiceName(""Service"");

		String locationUri = ""http://localhost:8080/services"";
		provider.setLocationUri(locationUri);

		provider.setCreateSoap11Binding(true);
		provider.setCreateSoap12Binding(true);

		provider.addBindings(definition);
		provider.addServices(definition);

		Binding binding = definition.getBinding(new QName(namespace, ""PortTypeSoap11""));

		assertThat(binding).isNotNull();

		binding = definition.getBinding(new QName(namespace, ""PortTypeSoap12""));

		assertThat(binding).isNotNull();

		Service service = definition.getService(new QName(namespace, ""Service""));

		assertThat(service).isNotNull();
		assertThat(service.getPorts()).hasSize(2);

		Port port = service.getPort(""PortTypeSoap11"");

		assertThat(port).isNotNull();

		port = service.getPort(""PortTypeSoap12"");

		assertThat(port).isNotNull();
	}",Eager Test + Mystery Guest
"@Test
	public void testAddMessages() throws Exception {

		String definitionNamespace = ""http://springframework.org/spring-ws"";
		definition.addNamespace(""tns"", definitionNamespace);
		definition.setTargetNamespace(definitionNamespace);
		String schemaNamespace = ""http://www.springframework.org/spring-ws/schema"";
		definition.addNamespace(""schema"", schemaNamespace);

		Resource resource = new ClassPathResource(""schema.xsd"", getClass());
		Document schemaDocument = documentBuilder.parse(SaxUtils.createInputSource(resource));
		Types types = definition.createTypes();
		definition.setTypes(types);
		Schema schema = (Schema) definition.getExtensionRegistry().createExtension(Types.class,
				new QName(""http://www.w3.org/2001/XMLSchema"", ""schema""));
		types.addExtensibilityElement(schema);
		schema.setElement(schemaDocument.getDocumentElement());

		provider.addMessages(definition);

		assertThat(definition.getMessages()).hasSize(2);

		Message message = definition.getMessage(new QName(definitionNamespace, ""GetOrderRequest""));

		assertThat(message).isNotNull();

		Part part = message.getPart(""GetOrderRequest"");

		assertThat(part).isNotNull();
		assertThat(part.getElementName()).isEqualTo(new QName(schemaNamespace, ""GetOrderRequest""));

		message = definition.getMessage(new QName(definitionNamespace, ""GetOrderResponse""));

		assertThat(message).isNotNull();

		part = message.getPart(""GetOrderResponse"");

		assertThat(part).isNotNull();
		assertThat(part.getElementName()).isEqualTo(new QName(schemaNamespace, ""GetOrderResponse""));
	}",Eager Test + Mystery Guest
"@Test
	public void testContentHandlerDocumentNamespacePrefixes() throws Exception {

		xmlReader.setFeature(""http://xml.org/sax/features/namespace-prefixes"", true);
		handler = new DomContentHandler(result);
		expected = documentBuilder.parse(new InputSource(new StringReader(XML_1)));
		xmlReader.setContentHandler(handler);
		xmlReader.parse(new InputSource(new StringReader(XML_1)));

		assertThat(result).and(expected).areSimilar();
	}",Eager Test
"@Test
	public void testContentHandlerDocumentNoNamespacePrefixes() throws Exception {

		handler = new DomContentHandler(result);
		expected = documentBuilder.parse(new InputSource(new StringReader(XML_1)));
		xmlReader.setContentHandler(handler);
		xmlReader.parse(new InputSource(new StringReader(XML_1)));

		assertThat(result).and(expected).areSimilar();
	}",Eager Test
"@Test
	public void testContentHandlerElement() throws Exception {

		Element rootElement = result.createElementNS(""namespace"", ""root"");
		result.appendChild(rootElement);
		handler = new DomContentHandler(rootElement);
		expected = documentBuilder.parse(new InputSource(new StringReader(XML_2_EXPECTED)));
		xmlReader.setContentHandler(handler);
		xmlReader.parse(new InputSource(new StringReader(XML_2_SNIPPET)));

		assertThat(result).and(expected).areSimilar();
	}",Eager Test
"@Test
	public void testGetQNameForNodeNoNamespace() throws Exception {

		DocumentBuilderFactory factory = DocumentBuilderFactoryUtils.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		Document document = builder.newDocument();
		Element element = document.createElement(""localname"");
		QName qName = QNameUtils.getQNameForNode(element);

		assertThat(qName).isNotNull();
		assertThat(qName.getLocalPart()).isEqualTo(""localname"");
		assertThat(qName.getNamespaceURI()).isEmpty();
		assertThat(qName.getPrefix()).isEmpty();
	}",Eager Test
"@Test
	public void testInvalidQNames() {

		assertThat(QNameUtils.validateQName(null)).isFalse();
		assertThat(QNameUtils.validateQName("""")).isFalse();
		assertThat(QNameUtils.validateQName(""{namespace}",No Smells
"@Test
	public void testToQNameNoPrefix() {

		QName result = QNameUtils.toQName(""namespace"", ""localName"");

		assertThat(result.getNamespaceURI()).isEqualTo(""namespace"");
		assertThat(result.getPrefix()).isEqualTo("""");
		assertThat(result.getLocalPart()).isEqualTo(""localName"");
	}",No Smells
"@Test
	public void testStringResult() throws Exception {

		Document document = DocumentBuilderFactoryUtils.newInstance().newDocumentBuilder().newDocument();
		Element element = document.createElementNS(""namespace"", ""prefix:localName"");
		document.appendChild(element);

		Transformer transformer = TransformerFactoryUtils.newInstance().newTransformer();
		StringResult result = new StringResult();
		transformer.transform(new DOMSource(document), result);

		assertThat(result.toString()).and(""<prefix:localName xmlns:prefix='namespace'/>"").ignoreWhitespace().areIdentical();
	}",Eager Test + Mystery Guest
"@Test
	public void testDoWithSaxSource() throws Exception {

		XMLReader reader = XMLReaderFactory.createXMLReader();
		InputSource inputSource = new InputSource();

		TraxUtils.SourceCallback mock = createMock(TraxUtils.SourceCallback.class);
		mock.saxSource(reader, inputSource);

		replay(mock);

		TraxUtils.doWithSource(new SAXSource(reader, inputSource), mock);

		verify(mock);
	}",Eager Test
"@Test
	public void testDoWithStaxResultEventWriter() throws Exception {

		XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
		XMLEventWriter eventWriter = outputFactory.createXMLEventWriter(new StringWriter());

		TraxUtils.ResultCallback mock = createMock(TraxUtils.ResultCallback.class);
		mock.staxResult(eventWriter);

		replay(mock);

		TraxUtils.doWithResult(StaxUtils.createStaxResult(eventWriter), mock);

		verify(mock);
	}",Eager Test
"@Test
	public void testDoWithStaxResultStreamWriter() throws Exception {

		XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
		XMLStreamWriter streamWriter = outputFactory.createXMLStreamWriter(new StringWriter());

		TraxUtils.ResultCallback mock = createMock(TraxUtils.ResultCallback.class);
		mock.staxResult(streamWriter);

		replay(mock);

		TraxUtils.doWithResult(StaxUtils.createStaxResult(streamWriter), mock);

		verify(mock);
	}",Eager Test
"@Test
	public void testGetDocument() throws Exception {

		DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactoryUtils.newInstance();
		documentBuilderFactory.setNamespaceAware(true);
		DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
		Document document = documentBuilder.newDocument();

		assertThat(TraxUtils.getDocument(new DOMSource(document))).isSameAs(document);

		Element element = document.createElement(""element"");
		document.appendChild(element);

		assertThat(TraxUtils.getDocument(new DOMSource(element))).isSameAs(document);
	}",Eager Test
"@Test
	public void testLoadMultipleSchemas() throws Exception {

		Resource envelope = new ClassPathResource(""envelope.xsd"", getClass());
		Resource encoding = new ClassPathResource(""encoding.xsd"", getClass());
		Schema schema = SchemaLoaderUtils.loadSchema(new Resource[] { envelope, encoding }",Eager Test
"@Test
	public void testLoadNonExistantSchema() throws Exception {

		assertThatIllegalArgumentException().isThrownBy(() -> {
			Resource nonExistent = new ClassPathResource(""bla"");
			SchemaLoaderUtils.loadSchema(nonExistent, XMLConstants.W3C_XML_SCHEMA_NS_URI);
		}",No Smells
"@Test
	public void testLoadNullSchema() throws Exception {

		assertThatIllegalArgumentException()
				.isThrownBy(() -> SchemaLoaderUtils.loadSchema((Resource) null, XMLConstants.W3C_XML_SCHEMA_NS_URI));
	}",No Smells
"@Test
	public void testLoadSchema() throws Exception {

		Resource resource = new ClassPathResource(""schema.xsd"", getClass());
		Schema schema = SchemaLoaderUtils.loadSchema(resource, XMLConstants.W3C_XML_SCHEMA_NS_URI);

		assertThat(schema).isNotNull();
		assertThat(resource.isOpen()).isFalse();
	}",Mystery Guest
"@Test
	public void testCreateValidator() throws Exception {

		Resource resource = new ClassPathResource(""schema.xsd"", AbstractValidatorFactoryTestCase.class);
		XmlValidator validator = XmlValidatorFactory.createValidator(resource, XmlValidatorFactory.SCHEMA_W3C_XML);

		assertThat(validator).isNotNull();
	}",No Smells
"@Test
	public void testCreateEmptyXPathExpression() {
		assertThatIllegalArgumentException().isThrownBy(() -> XPathExpressionFactory.createXPathExpression(""""));
	}",No Smells
"@Test
	public void testIncludesAndImports() throws Exception {

		Resource hr = new ClassPathResource(""hr.xsd"", getClass());
		collection.setXsds(hr);
		collection.setInline(true);
		collection.afterPropertiesSet();

		XsdSchema[] schemas = collection.getXsdSchemas();

		assertThat(schemas).hasSize(2);
		assertThat(schemas[0].getTargetNamespace()).isEqualTo(""http://mycompany.com/hr/schemas"");

		Resource hr_employee = new ClassPathResource(""hr_employee.xsd"", getClass());
		Document expected = documentBuilder.parse(SaxUtils.createInputSource(hr_employee));
		DOMResult domResult = new DOMResult();
		transformer.transform(schemas[0].getSource(), domResult);

		XmlAssert.assertThat(domResult.getNode()).and(expected).ignoreWhitespace().areIdentical();
		assertThat(schemas[1].getTargetNamespace()).isEqualTo(""http://mycompany.com/hr/schemas/holiday"");

		Resource holiday = new ClassPathResource(""holiday.xsd"", getClass());
		expected = documentBuilder.parse(SaxUtils.createInputSource(holiday));
		domResult = new DOMResult();
		transformer.transform(schemas[1].getSource(), domResult);

		XmlAssert.assertThat(domResult.getNode()).and(expected).ignoreWhitespace().areIdentical();
	}",Eager Test
"@Test
  public void testGetProtocol() throws Exception {
    Draft_6455 draft_6455 = new Draft_6455(Collections.<IExtension>emptyList(),
        Collections.<IProtocol>emptyList());
    assertNull(draft_6455.getProtocol());
    draft_6455.acceptHandshakeAsServer(handshakedataProtocolExtension);
    assertNull(draft_6455.getProtocol());
    draft_6455 = new Draft_6455(Collections.<IExtension>emptyList(),
        Collections.<IProtocol>singletonList(new Protocol(""chat"")));
    assertNull(draft_6455.getProtocol());
    draft_6455.acceptHandshakeAsServer(handshakedataProtocolExtension);
    assertNotNull(draft_6455.getProtocol());
  }",Eager Test
"@Test
  public void createFramesBinary() throws Exception {
    Draft_6455 draft_6455 = new Draft_6455();
    BinaryFrame curframe = new BinaryFrame();
    ByteBuffer test0 = ByteBuffer.wrap(""Test0"".getBytes());
    curframe.setPayload(test0);
    curframe.setTransferemasked(false);
    List<Framedata> createdFrame = draft_6455.createFrames(test0, false);
    assertEquals(1, createdFrame.size());
    assertEquals(curframe, createdFrame.get(0));
    curframe = new BinaryFrame();
    ByteBuffer test1 = ByteBuffer.wrap(""Test1"".getBytes());
    curframe.setPayload(test1);
    curframe.setTransferemasked(true);
    createdFrame = draft_6455.createFrames(test1, true);
    assertEquals(1, createdFrame.size());
    assertEquals(curframe, createdFrame.get(0));
  }",Eager Test
"@Test
  public void createFramesText() throws Exception {
    Draft_6455 draft_6455 = new Draft_6455();
    TextFrame curframe = new TextFrame();
    curframe.setPayload(ByteBuffer.wrap(Charsetfunctions.utf8Bytes(""Test0"")));
    curframe.setTransferemasked(false);
    List<Framedata> createdFrame = draft_6455.createFrames(""Test0"", false);
    assertEquals(1, createdFrame.size());
    assertEquals(curframe, createdFrame.get(0));
    curframe = new TextFrame();
    curframe.setPayload(ByteBuffer.wrap(Charsetfunctions.utf8Bytes(""Test0"")));
    curframe.setTransferemasked(true);
    createdFrame = draft_6455.createFrames(""Test0"", true);
    assertEquals(1, createdFrame.size());
    assertEquals(curframe, createdFrame.get(0));
  }",Eager Test
"@Test
  public void testConstructor() throws Exception {
    try {
      Draft_6455 draft_6455 = new Draft_6455(null, null);
      fail(""IllegalArgumentException expected"");
    }",Eager Test
"@Test
  public void testCopyInstance() throws Exception {
    Draft_6455 draft_6455 = new Draft_6455(
        Collections.<IExtension>singletonList(new TestExtension()),
        Collections.<IProtocol>singletonList(new Protocol(""chat"")));
    Draft_6455 draftCopy = (Draft_6455) draft_6455.copyInstance();
    draft_6455.acceptHandshakeAsServer(handshakedataProtocolExtension);
    assertNotEquals(draft_6455, draftCopy);
    assertEquals(draft_6455.getKnownProtocols(), draftCopy.getKnownProtocols());
    assertEquals(draft_6455.getKnownExtensions(), draftCopy.getKnownExtensions());
    assertNotEquals(draft_6455.getProtocol(), draftCopy.getProtocol());
    assertNotEquals(draft_6455.getExtension(), draftCopy.getExtension());
  }",No Smells
"@Test
  public void testGetCloseHandshakeType() throws Exception {
    Draft_6455 draft_6455 = new Draft_6455();
    assertEquals(CloseHandshakeType.TWOWAY, draft_6455.getCloseHandshakeType());
  }",No Smells
"@Test
  public void testHashCode() throws Exception {
    Draft draft0 = new Draft_6455();
    Draft draft1 = draft0.copyInstance();
    Draft draft2 = new Draft_6455(Collections.<IExtension>emptyList(),
        Collections.<IProtocol>singletonList(new Protocol(""chat"")));
    Draft draft3 = draft2.copyInstance();
    assertEquals(draft2.hashCode(), draft3.hashCode());
    assertEquals(draft0.hashCode(), draft2.hashCode());
    assertEquals(draft0.hashCode(), draft1.hashCode());
    //Hashcode changes for draft2 due to a provided protocol
    draft2.acceptHandshakeAsServer(handshakedataProtocolExtension);
    draft1.acceptHandshakeAsServer(handshakedataProtocolExtension);
    assertNotEquals(draft2.hashCode(), draft3.hashCode());
    assertNotEquals(draft0.hashCode(), draft2.hashCode());
    assertEquals(draft0.hashCode(), draft1.hashCode());
    draft2 = draft2.copyInstance();
    draft1 = draft1.copyInstance();
    //Hashcode changes for draft draft2 due to a provided protocol
    draft2.acceptHandshakeAsServer(handshakedataProtocol);
    draft1.acceptHandshakeAsServer(handshakedataProtocol);
    assertNotEquals(draft2.hashCode(), draft3.hashCode());
    assertNotEquals(draft0.hashCode(), draft2.hashCode());
    assertEquals(draft0.hashCode(), draft1.hashCode());
    draft2 = draft2.copyInstance();
    draft1 = draft1.copyInstance();
    //Hashcode changes for draft draft0 due to a provided protocol (no protocol)
    draft2.acceptHandshakeAsServer(handshakedataExtension);
    draft1.acceptHandshakeAsServer(handshakedataExtension);
    assertEquals(draft2.hashCode(), draft3.hashCode());
    assertEquals(draft0.hashCode(), draft2.hashCode());
    // THIS IS A DIFFERENCE BETWEEN equals and hashcode since the hashcode of an empty string = 0
    assertEquals(draft0.hashCode(), draft1.hashCode());
    draft2 = draft2.copyInstance();
    draft1 = draft1.copyInstance();
    //Hashcode changes for draft draft0 due to a provided protocol (no protocol)
    draft2.acceptHandshakeAsServer(handshakedata);
    draft1.acceptHandshakeAsServer(handshakedata);
    assertEquals(draft2.hashCode(), draft3.hashCode());
    assertEquals(draft0.hashCode(), draft2.hashCode());
    // THIS IS A DIFFERENCE BETWEEN equals and hashcode since the hashcode of an empty string = 0
    assertEquals(draft0.hashCode(), draft1.hashCode());
  }",Eager Test
"@Test
  public void testGetProvidedExtensionAsServer() throws Exception {
    DefaultExtension defaultExtension = new DefaultExtension();
    assertEquals("""", defaultExtension.getProvidedExtensionAsServer());
  }",No Smells
"@Test
  public void testConstructor() {
    BinaryFrame frame = new BinaryFrame();
    assertEquals(""Opcode must be equal"", Opcode.BINARY, frame.getOpcode());
    assertEquals(""Fin must be set"", true, frame.isFin());
    assertEquals(""TransferedMask must not be set"", false, frame.getTransfereMasked());
    assertEquals(""Payload must be empty"", 0, frame.getPayloadData().capacity());
    assertEquals(""RSV1 must be false"", false, frame.isRSV1());
    assertEquals(""RSV2 must be false"", false, frame.isRSV2());
    assertEquals(""RSV3 must be false"", false, frame.isRSV3());
    try {
      frame.isValid();
    }",No Smells
"@Test
  public void testIsValid() {
    ContinuousFrame frame = new ContinuousFrame();
    try {
      frame.isValid();
    }",No Smells
"@Test
  public void testConstructor() {
    PingFrame frame = new PingFrame();
    assertEquals(""Opcode must be equal"", Opcode.PING, frame.getOpcode());
    assertEquals(""Fin must be set"", true, frame.isFin());
    assertEquals(""TransferedMask must not be set"", false, frame.getTransfereMasked());
    assertEquals(""Payload must be empty"", 0, frame.getPayloadData().capacity());
    assertEquals(""RSV1 must be false"", false, frame.isRSV1());
    assertEquals(""RSV2 must be false"", false, frame.isRSV2());
    assertEquals(""RSV3 must be false"", false, frame.isRSV3());
    try {
      frame.isValid();
    }",No Smells
"@Test
  public void testExtends() {
    PongFrame frame = new PongFrame();
    assertEquals(""Frame must extend dataframe"", true, frame instanceof ControlFrame);
  }",No Smells
"@Test
  public void testConstructor() {
    TextFrame frame = new TextFrame();
    assertEquals(""Opcode must be equal"", Opcode.TEXT, frame.getOpcode());
    assertEquals(""Fin must be set"", true, frame.isFin());
    assertEquals(""TransferedMask must not be set"", false, frame.getTransfereMasked());
    assertEquals(""Payload must be empty"", 0, frame.getPayloadData().capacity());
    assertEquals(""RSV1 must be false"", false, frame.isRSV1());
    assertEquals(""RSV2 must be false"", false, frame.isRSV2());
    assertEquals(""RSV3 must be false"", false, frame.isRSV3());
    try {
      frame.isValid();
    }",No Smells
"@Test
  public void testToString() throws Exception {
    Protocol protocol0 = new Protocol("""");
    assertEquals("""", protocol0.getProvidedProtocol());
    Protocol protocol1 = new Protocol(""protocol"");
    assertEquals(""protocol"", protocol1.getProvidedProtocol());
  }",No Smells
"@Test
  public void testEmptyByteBufferCapacity() {
    ByteBuffer byteBuffer = ByteBufferUtils.getEmptyByteBuffer();
    assertEquals(""capacity must be 0"", 0, byteBuffer.capacity());
  }",No Smells
"@Test
  public void testTransferByteBufferCheckNullSource() {
    ByteBuffer dest = ByteBuffer.wrap(smallArray);
    try {
      ByteBufferUtils.transferByteBuffer(null, dest);
      fail(""IllegalArgumentException should be thrown"");
    }",No Smells
"@Test
    public void should_generate_manager_class_for_index_dsl() throws Exception {
        setExec(aptUtils -> {

            final GlobalParsingContext globalContext = new GlobalParsingContext(
                    V3_7.INSTANCE,
                    InsertStrategy.ALL_FIELDS,
                    new LowerCaseNaming(),
                    FieldFilter.EXPLICIT_ENTITY_FIELD_FILTER,
                    FieldFilter.EXPLICIT_UDT_FIELD_FILTER,
                    Optional.empty());

            final String className = TestEntityWithSASI.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);

            final EntityParser entityParser = new EntityParser(aptUtils);

            final EntityMetaSignature entityMetaSignature = entityParser.parseEntity(typeElement, globalContext);

            final ManagerAndDSLClasses managerAndDSLClasses = ManagerCodeGen.buildManager(globalContext, aptUtils, entityMetaSignature);

            final StringBuilder builder = new StringBuilder();
            try {
                JavaFile.builder(TypeUtils.GENERATED_PACKAGE, managerAndDSLClasses.managerClass)
                        .build()
                        .writeTo(builder);
            }",Eager Test + Mystery Guest
"@Test
    public void should_build_entity_with_static_counter_column() throws Exception {
        setExec(aptUtils -> {
            final String className = TestEntityWithStaticCounterColumn.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);

            final EntityMetaCodeGen builder = new EntityMetaCodeGen(aptUtils);
            final List<FieldParser.FieldMetaSignature> parsingResults = getTypeParsingResults(aptUtils, typeElement, context);
            final TypeSpec typeSpec = builder.buildEntityMeta(EntityType.TABLE, typeElement, context, parsingResults, emptyList()).sourceCode;

            assertThat(buildSource(typeSpec)).isEqualTo(
                    readCodeBlockFromFile(""expected_code/entity_meta_builder/should_build_entity_with_static_counter_column.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_build_view_meta() throws Exception {
        setExec(aptUtils -> {
            final String className = TestViewSensorByType.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);

            final EntityMetaCodeGen builder = new EntityMetaCodeGen(aptUtils);
            final List<FieldParser.FieldMetaSignature> parsingResults = getTypeParsingResults(aptUtils, typeElement, context);
            final TypeSpec typeSpec = builder.buildEntityMeta(EntityType.VIEW, typeElement, context, parsingResults, emptyList()).sourceCode;

            assertThat(buildSource(typeSpec)).isEqualTo(
                    readCodeBlockFromFile(""expected_code/entity_meta_builder/should_build_view_meta.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_fail_building_abstract_class() throws Exception {
        setExec(aptUtils -> {
            final String className = TestEntityWithAbstractClass.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);

            final EntityMetaCodeGen builder = new EntityMetaCodeGen(aptUtils);
            final List<FieldParser.FieldMetaSignature> parsingResults = getTypeParsingResults(aptUtils, typeElement, context);
            builder.buildEntityMeta(EntityType.TABLE, typeElement, context, parsingResults, emptyList());

        }",Eager Test
"@Test
    public void should_fail_building_class_with_no_partition_key() throws Exception {
        setExec(aptUtils -> {
            final String className = TestEntityWithNoPartitionKey.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);

            final EntityMetaCodeGen builder = new EntityMetaCodeGen(aptUtils);
            final List<FieldParser.FieldMetaSignature> parsingResults = getTypeParsingResults(aptUtils, typeElement, context);
            builder.buildEntityMeta(EntityType.TABLE, typeElement, context, parsingResults, emptyList());
        }",Eager Test
"@Test
    public void should_fail_building_class_with_wrong_composite_partition_key_order() throws Exception {
        setExec(aptUtils -> {
            final String className = TestEntityWithWrongCompositePartitionKey.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);

            final EntityMetaCodeGen builder = new EntityMetaCodeGen(aptUtils);
            final List<FieldParser.FieldMetaSignature> parsingResults = getTypeParsingResults(aptUtils, typeElement, context);
            builder.buildEntityMeta(EntityType.TABLE, typeElement, context, parsingResults, emptyList());
        }",Eager Test
"@Test
    public void should_fail_building_view_meta_without_view_annotation() throws Exception {
        setExec(aptUtils -> {
            final String className = TestEntityWithSimplePartitionKey.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);

            final EntityMetaCodeGen builder = new EntityMetaCodeGen(aptUtils);
            final List<FieldParser.FieldMetaSignature> parsingResults = getTypeParsingResults(aptUtils, typeElement, context);
            builder.buildEntityMeta(EntityType.VIEW, typeElement, context, parsingResults, emptyList());

        }",Eager Test
"@Test
    public void should_generate_udt_property_class() throws Exception {
        setExec(aptUtils -> {
            final String className = TestUDT.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);

            final UDTMetaCodeGen builder = new UDTMetaCodeGen(aptUtils);

            final GlobalParsingContext globalContext = GlobalParsingContext.defaultContext();
            final EntityParsingContext context = new EntityParsingContext(typeElement,
                    ClassName.get(TestUDT.class), new LowerCaseNaming(), globalContext);
            final List<FieldMetaSignature> parsingResults = getTypeParsingResults(aptUtils, typeElement, globalContext);

            final TypeSpec typeSpec = builder.buildUDTClassProperty(typeElement, context, parsingResults, Collections.emptyList());

            assertThat(typeSpec.toString().trim()).isEqualTo(
                    readCodeBlockFromFile(""expected_code/udt_meta_builder/should_generate_udt_property_class.txt""));

        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_generate_udt_with_custom_constructor_property_class() throws Exception {
        setExec(aptUtils -> {
            final String className = TestUDTWithCustomConstructor.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);

            final UDTMetaCodeGen builder = new UDTMetaCodeGen(aptUtils);

            final GlobalParsingContext globalContext = GlobalParsingContext.defaultContext();
            final EntityParsingContext context = new EntityParsingContext(typeElement,
                    ClassName.get(TestUDT.class), new LowerCaseNaming(), globalContext);
            final List<AccessorsExclusionContext> exclusionContexts = Arrays.asList(
                    new AccessorsExclusionContext(""name"", false, true),
                    new AccessorsExclusionContext(""list"", false, true));
            final List<FieldMetaSignature> fieldMetaSignatures = getTypeParsingResults(aptUtils, typeElement, exclusionContexts, globalContext);

            final List<FieldMetaSignature> constructorInjectedFieldMetaSignatures = fieldMetaSignatures
                    .stream()
                    .filter(fieldMeta -> !fieldMeta.context.fieldName.equals(""date""))
                    .collect(Collectors.toList());

            final TypeSpec typeSpec = builder.buildUDTClassProperty(typeElement, context, fieldMetaSignatures, constructorInjectedFieldMetaSignatures);

            assertThat(typeSpec.toString().trim()).isEqualTo(
                    readCodeBlockFromFile(""expected_code/udt_meta_builder/should_generate_udt_with_custom_constructor_property_class.txt""));

        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_build_treemap_for_computed_annotation_ecj() throws Exception {
        //Given
        setExec(aptUtils -> {
            try {
                final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
                final VariableElement writetime = findFieldByName(typeElement, ""writetime"");

                // @Computed(function = ""writetime"", alias = ""writetime_col"", cqlClass = Long.class, targetColumns = {""id"", ""value""}",Eager Test
"@Test
    public void should_build_treemap_for_frozen_udt_annotation_ecj() throws Exception {
        //Given
        setExec(aptUtils -> {
            try {
                final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
                final VariableElement testUdt = findFieldByName(typeElement, ""testUdt"");

                // @Frozen
                // private TestUDT testUdt;
                AnnotationTree annotationTree = AnnotationTree.buildFrom(aptUtils, globalParsingContext, testUdt);
                final Set<String> annotationNames = getAnnotationNames(annotationTree.getAnnotations());
                assertThat(isTypeOf(TestUDT.class, annotationTree.getCurrentType())).isTrue();
                assertThat(annotationNames).containsOnly(Frozen.class.getSimpleName());

                final TypedMap typedMap = annotationTree.getAnnotations().get(Frozen.class);
                assertThat(typedMap.isEmpty()).isTrue();

            }",Eager Test
"@Test
    public void should_build_trees_for_other_fields_javac() throws Exception {
        //Given
        setExec(aptUtils -> {
            try {
                final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
                final VariableElement idElm = findFieldByName(typeElement, ""id"");
                final VariableElement timeElm = findFieldByName(typeElement, ""time"");
                final VariableElement listElm = findFieldByName(typeElement, ""list"");
                final VariableElement setElm = findFieldByName(typeElement, ""set"");

                //   @Enumerated(value = Enumerated.Encoding.NAME) private Long id;
                AnnotationTree annotationTree = AnnotationTree.buildFrom(aptUtils, globalParsingContext, idElm);
                Set<String> annotationNames = getAnnotationNames(annotationTree.getAnnotations());
                assertThat(isTypeOf(Long.class, annotationTree.getCurrentType())).isTrue();
                assertThat(annotationNames).containsOnly(Enumerated.class.getSimpleName());

                // private @JSON Date time;
                annotationTree = AnnotationTree.buildFrom(aptUtils, globalParsingContext, timeElm);
                annotationNames = getAnnotationNames(annotationTree.getAnnotations());
                assertThat(isTypeOf(Date.class, annotationTree.getCurrentType())).isTrue();
                assertThat(annotationNames).containsOnly(JSON.class.getSimpleName());

                // private List<Integer> list;
                annotationTree = AnnotationTree.buildFrom(aptUtils, globalParsingContext, listElm);
                annotationNames = getAnnotationNames(annotationTree.getAnnotations());
                assertThat(isTypeOf(List.class, annotationTree.getCurrentType())).isTrue();
                assertThat(annotationNames).isEmpty();

                // private Set<@Enumerated(value = Enumerated.Encoding.NAME) Double> set;
                annotationTree = AnnotationTree.buildFrom(aptUtils, globalParsingContext, setElm);
                annotationNames = getAnnotationNames(annotationTree.getAnnotations());
                assertThat(isTypeOf(Set.class, annotationTree.getCurrentType())).isTrue();
                assertThat(annotationNames).isEmpty();

                // @Enumerated(value = Enumerated.Encoding.NAME) Double
                annotationTree = annotationTree.next();
                annotationNames = getAnnotationNames(annotationTree.getAnnotations());
                assertThat(isTypeOf(Double.class, annotationTree.getCurrentType())).isTrue();
                assertThat(annotationNames).containsOnly(Enumerated.class.getSimpleName());


            }",Eager Test
"@Test
    public void should_build_trees_map_for_level1_nesting_ecj() throws Exception {
        //Given
        setExec(aptUtils -> {
            try {
                final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
                final VariableElement level1NestingElm = findFieldByName(typeElement, ""level1Nesting"");

                // private List<Map<Integer,String>> level1Nesting;
                AnnotationTree annotationTree = AnnotationTree.buildFrom(aptUtils, globalParsingContext, level1NestingElm);
                Set<String> annotationNames = getAnnotationNames(annotationTree.getAnnotations());
                assertThat(isTypeOf(List.class, annotationTree.getCurrentType())).isTrue();
                assertThat(annotationNames).isEmpty();

                // Map<Integer,String>
                annotationTree = annotationTree.next();
                annotationNames = getAnnotationNames(annotationTree.getAnnotations());
                assertThat(isTypeOf(Map.class, annotationTree.getCurrentType())).isTrue();
                assertThat(annotationNames).isEmpty();

                // Integer
                annotationTree = annotationTree.next();
                annotationNames = getAnnotationNames(annotationTree.getAnnotations());
                assertThat(isTypeOf(Integer.class, annotationTree.getCurrentType())).isTrue();
                assertThat(annotationNames).isEmpty();

                // String
                annotationTree = annotationTree.next();
                annotationNames = getAnnotationNames(annotationTree.getAnnotations());
                assertThat(isTypeOf(String.class, annotationTree.getCurrentType())).isTrue();
                assertThat(annotationNames).isEmpty();


            }",Eager Test
"@Test
    public void should_create_codec_for_computed() throws Exception {
        setExec(aptUtils -> {
            final CodecFactory codecFactory = new CodecFactory(aptUtils);
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityForCodecs.class.getCanonicalName());
            final FieldParsingContext context = getFieldParsingContext(aptUtils, typeElement);

            // @Computed(function = ""writetime"",  alias = ""writetime"", targettargetColumnsap""}",Eager Test
"@Test
    public void should_create_codec_for_enumerated() throws Exception {
        setExec(aptUtils -> {
            final CodecFactory codecFactory = new CodecFactory(aptUtils);
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityForCodecs.class.getCanonicalName());
            final FieldParsingContext context = getFieldParsingContext(aptUtils, typeElement);

            // @Enumerated(value = NAME) private ConsistencyLevel consistencyLevel
            final VariableElement elm = findFieldInType(typeElement, ""consistencyLevel"");
            final AnnotationTree tree = AnnotationTree.buildFrom(aptUtils, context.entityContext.globalContext, elm);
            final CodecInfo codecInfo = codecFactory.createCodec(ClassName.get(ConsistencyLevel.class), tree, context, Optional.empty());

            assertThat(codecInfo.sourceType.toString()).isEqualTo(ConsistencyLevel.class.getCanonicalName());
            assertThat(codecInfo.targetType.toString()).isEqualTo(String.class.getCanonicalName());
            assertThat(codecInfo.codecCode.toString()).isEqualTo(
                    ""new info.archinnov.achilles.internals.codec.EnumNameCodec<>(java.util.Arrays.asList(com.datastax.driver.core.ConsistencyLevel.values()), com.datastax.driver.core.ConsistencyLevel.class)"");
        }",Eager Test
"@Test
    public void should_create_codec_for_string() throws Exception {
        setExec(aptUtils -> {
            final CodecFactory codecFactory = new CodecFactory(aptUtils);
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityForCodecs.class.getCanonicalName());
            final FieldParsingContext context = getFieldParsingContext(aptUtils, typeElement);

            // private String value
            final VariableElement elm = findFieldInType(typeElement, ""value"");
            final AnnotationTree tree = AnnotationTree.buildFrom(aptUtils, context.entityContext.globalContext, elm);
            final CodecInfo codecInfo = codecFactory.createCodec(ClassName.get(String.class), tree, context, Optional.empty());

            assertThat(codecInfo.sourceType.toString()).isEqualTo(String.class.getCanonicalName());
            assertThat(codecInfo.targetType.toString()).isEqualTo(String.class.getCanonicalName());
            assertThat(codecInfo.codecCode.toString()).isEqualTo(""new info.archinnov.achilles.internals.codec.FallThroughCodec<>(java.lang.String.class)"");
        }",Eager Test
"@Test
    public void should_create_custom_codec_for_counter() throws Exception {
        setExec(aptUtils -> {
            final CodecFactory codecFactory = new CodecFactory(aptUtils);
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityForCodecs.class.getCanonicalName());
            final FieldParsingContext context = getFieldParsingContext(aptUtils, typeElement);

            // @Counter @Codec(StringToLongCodec.class) private String counterWithCodec;
            final VariableElement elm = findFieldInType(typeElement, ""counterWithCodec"");
            final AnnotationTree tree = AnnotationTree.buildFrom(aptUtils, context.entityContext.globalContext, elm);
            final CodecInfo codecInfo = codecFactory.createCodec(ClassName.get(String.class), tree, context, Optional.empty());

            assertThat(codecInfo.sourceType.toString()).isEqualTo(String.class.getCanonicalName());
            assertThat(codecInfo.targetType.toString()).isEqualTo(Long.class.getCanonicalName());
            assertThat(codecInfo.codecCode.toString()).isEqualTo(
                    ""new "" + StringToLongCodec.class.getCanonicalName() + ""()"");
        }",Eager Test
"@Test
    public void should_create_native_codec_for_computed() throws Exception {
        setExec(aptUtils -> {
            final CodecFactory codecFactory = new CodecFactory(aptUtils);
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityForCodecs.class.getCanonicalName());
            final FieldParsingContext context = getFieldParsingContext(aptUtils, typeElement);

            // @Computed(function = ""writetime"",  alias = ""writetime"", targettargetColumnsap""}",Eager Test
"@Test
    public void should_fail_creating_JavaType_for_wildcard_type() throws Exception {
        final WildcardTypeName wildCardType = WildcardTypeName.subtypeOf(TypeName.OBJECT);
        setExec(aptUtils -> {
            final CodecFactory codecFactory = new CodecFactory(aptUtils);
            codecFactory.buildJavaTypeForJackson(wildCardType);
        }",Eager Test
"@Test
    public void should_fail_because_incorrect_field_type_for_immutable_constructor_param_javac() throws Exception {
        //Given
        setExec(aptUtils -> {
            try {
                final EntityParser parser = new EntityParser(aptUtils);
                final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestImmutableEntityWithWrongParamTypeInConstructor.class.getCanonicalName());
                parser.parseEntity(typeElement, globalParsingContext);
            }",Eager Test
"@Test
    public void should_fail_because_no_matching_field_name_for_constructor_param_javac() throws Exception {
        //Given
        setExec(aptUtils -> {
            try {
                final EntityParser parser = new EntityParser(aptUtils);
                final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityWithNoMatchingFieldForParamInConstructor.class.getCanonicalName());
                parser.parseEntity(typeElement, globalParsingContext);
            }",Eager Test
"@Test
    public void should_generate_meta_signature_for_complex_types_javac() throws Exception {
        //Given
        setExec(aptUtils -> {
            try {
                final EntityParser parser = new EntityParser(aptUtils);
                final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityWithComplexTypes.class.getCanonicalName());
                final EntityMetaCodeGen.EntityMetaSignature metaSignature = parser.parseEntity(typeElement, globalParsingContext);

                assertThat(metaSignature).isNotNull();
            }",Eager Test
"@Test
    public void should_generate_meta_signature_for_view_javac() throws Exception {
        //Given
        setExec(aptUtils -> {
            try {
                final EntityParser parser = new EntityParser(aptUtils);
                final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestViewSensorByType.class.getCanonicalName());
                final EntityMetaCodeGen.EntityMetaSignature metaSignature = parser.parseView(typeElement, globalParsingContext);

                assertThat(metaSignature).isNotNull();
            }",Eager Test
"@Test
    public void should_build_frozen_list_index_info() throws Exception {
        setExec(aptUtils -> {
            final FieldInfoParser parser = new FieldInfoParser(aptUtils);
            final String className = TestEntityForFieldInfo.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext context = new EntityParsingContext(typeElement, ClassName.get(TestEntityForFieldInfo.class), strategy, globalParsingContext);

            // @Index @Frozen private List<String> indexedFrozenList;
            VariableElement elm = findFieldInType(typeElement, ""indexedFrozenList"");
            final AnnotationTree annotationTree = AnnotationTree.buildFrom(aptUtils,  globalParsingContext, elm);

            final CodeBlock codeBlock = parser.buildNativeIndexInfo(annotationTree, elm, context)._1();
            assertThat(codeBlock.toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(
                            ""info.archinnov.achilles.internals.metamodel.index.IndexInfo.forNative(info.archinnov.achilles.internals.metamodel.index.IndexType.FULL, \""indexed_frozen_list_index\"", \""\"", \""\"")"");
        }",Eager Test
"@Test
    public void should_build_list_index_info() throws Exception {
        setExec(aptUtils -> {
            final FieldInfoParser parser = new FieldInfoParser(aptUtils);
            final String className = TestEntityForFieldInfo.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext context = new EntityParsingContext(typeElement, ClassName.get(TestEntityForFieldInfo.class), strategy, globalParsingContext);
            // @Index private List<String> indexedList;
            VariableElement elm = findFieldInType(typeElement, ""indexedList"");
            final AnnotationTree annotationTree = AnnotationTree.buildFrom(aptUtils,  globalParsingContext, elm);

            final CodeBlock codeBlock = parser.buildNativeIndexInfo(annotationTree, elm, context)._1();
            assertThat(codeBlock.toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(""info.archinnov.achilles.internals.metamodel.index.IndexInfo.forNative(info.archinnov.achilles.internals.metamodel.index.IndexType.COLLECTION, \""indexed_list_index\"", \""\"", \""\"")"");
        }",Eager Test
"@Test
    public void should_build_partition_column_info() throws Exception {
        setExec(aptUtils -> {
            final FieldInfoParser parser = new FieldInfoParser(aptUtils);
            final String className = TestEntityForFieldInfo.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final TypeName typeName = ClassName.get(TestEntityForFieldInfo.class);

            // @PartitionKey(1) private Long id;
            VariableElement elm = findFieldInType(typeElement, ""id"");
            AnnotationTree annotationTree = AnnotationTree.buildFrom(aptUtils,  globalParsingContext, elm);
            final Tuple2<CodeBlock, ColumnInfo> codeBlock = parser.buildColumnInfo(globalParsingContext, annotationTree,  elm, ""id"", typeName);
            assertThat(codeBlock._1().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(""new info.archinnov.achilles.internals.metamodel.columns.PartitionKeyInfo(1, false)"");
        }",Eager Test
"@Test
    public void should_build_static_column_info() throws Exception {
        setExec(aptUtils -> {
            final FieldInfoParser parser = new FieldInfoParser(aptUtils);
            final String className = TestEntityForFieldInfo.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final TypeName typeName = ClassName.get(TestEntityForFieldInfo.class);

            // @Static private int staticCol;
            VariableElement elm = findFieldInType(typeElement, ""staticCol"");
            AnnotationTree annotationTree = AnnotationTree.buildFrom(aptUtils,  globalParsingContext, elm);
            final Tuple2<CodeBlock, ColumnInfo> codeBlock = parser.buildColumnInfo(globalParsingContext, annotationTree,  elm, ""staticCol"", typeName);
            assertThat(codeBlock._1().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(""new info.archinnov.achilles.internals.metamodel.columns.ColumnInfo(false)"");
        }",Eager Test
"@Test
    public void should_build_static_column_type() throws Exception {
        setExec(aptUtils -> {
            final FieldInfoParser parser = new FieldInfoParser(aptUtils);
            final String className = TestEntityForFieldInfo.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final TypeName typeName = ClassName.get(TestEntityForFieldInfo.class);

            // @Static private int staticCol;
            VariableElement elm = findFieldInType(typeElement, ""staticCol"");

            final Tuple2<CodeBlock, ColumnType> codeBlock = parser.buildColumnType(globalParsingContext, elm, ""staticCol"", typeName);
            assertThat(codeBlock._1().toString()).isEqualTo(""info.archinnov.achilles.internals.metamodel.columns.ColumnType.STATIC"");
        }",Eager Test
"@Test
    public void should_fail_compilation_when_no_suitable_setter() throws Exception {
        setExec(aptUtils -> {
            FieldInfoParser parser = new FieldInfoParser(aptUtils);
            final String className = TestEntityForFieldInfo.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext context = new EntityParsingContext(typeElement, ClassName.get(TestEntityForFieldInfo.class), strategy, globalParsingContext);

            // private Set<@Enumerated(value = ORDINAL) ConsistencyLevel> set;
            VariableElement elm = findFieldInType(typeElement, ""set"");
            final AnnotationTree annotationTree = AnnotationTree.buildFrom(aptUtils,  globalParsingContext, elm);

            parser.buildFieldInfo(elm, annotationTree, context);
        }",Eager Test
"@Test
    public void should_fail_if_both_partition_and_computed_column() throws Exception {
        setExec(aptUtils -> {
            final FieldInfoParser parser = new FieldInfoParser(aptUtils);
            final String className = TestEntityForFieldInfo.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final TypeName typeName = ClassName.get(TestEntityForFieldInfo.class);

            // @PartitionKey(1) @Computed(function = ""xx"", targettargetColumnsx""}",Eager Test
"@Test
    public void should_fail_if_clustering_column_order_zero() throws Exception {
        setExec(aptUtils -> {
            final FieldInfoParser parser = new FieldInfoParser(aptUtils);
            final String className = TestEntityForFieldInfo.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final TypeName typeName = ClassName.get(TestEntityForFieldInfo.class);

            // @ClusteringColumn(0) private String wrongClusteringOrder;
            VariableElement elm = findFieldInType(typeElement, ""wrongClusteringOrder"");
            AnnotationTree annotationTree = AnnotationTree.buildFrom(aptUtils,  globalParsingContext, elm);
            parser.buildColumnInfo(globalParsingContext, annotationTree,  elm, ""wrongClusteringOrder"", typeName);
        }",Eager Test
"@Test
    public void should_generate_field_info_for_primitiveBoolean() throws Exception {
        setExec(aptUtils -> {
            FieldInfoParser parser = new FieldInfoParser(aptUtils);
            final String className = TestEntityForFieldInfo.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext context = new EntityParsingContext(typeElement, ClassName.get(TestEntityForFieldInfo.class), strategy, globalParsingContext);

            // private boolean primitiveBoolean;
            VariableElement elm = findFieldInType(typeElement, ""primitiveBoolean"");
            final AnnotationTree annotationTree = AnnotationTree.buildFrom(aptUtils,  globalParsingContext, elm);

            FieldInfoContext fieldInfo = parser.buildFieldInfo(elm, annotationTree, context);

            assertThat(fieldInfo.codeBlock.toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/method_parser/should_generate_field_info_for_primitiveBoolean.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_generate_field_info_for_public_final_columns() throws Exception {
        setExec(aptUtils -> {
            final FieldInfoParser parser = new FieldInfoParser(aptUtils);
            final String className = TestEntityForFieldInfo.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final List<AccessorsExclusionContext> exclusionContexts = Arrays.asList(new AccessorsExclusionContext(""immutableColumn"", true, true));
            final EntityParsingContext context = new EntityParsingContext(typeElement,
                    ClassName.get(TestEntityForFieldInfo.class), strategy, exclusionContexts,
                    globalParsingContext);

            VariableElement elm = findFieldInType(typeElement, ""immutableColumn"");

            final AnnotationTree annotationTree = AnnotationTree.buildFrom(aptUtils,  globalParsingContext, elm);

            FieldInfoContext fieldInfo = parser.buildFieldInfo(elm, annotationTree, context);

            assertThat(fieldInfo.codeBlock.toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/method_parser/should_generate_field_info_for_public_final_columns.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_fail_parsing_codec_from_registry() throws Exception {

        setExec(aptUtils -> {
            final GlobalParsingContext globalContext = globalParsingContext;
            new CodecRegistryParser(aptUtils).parseCodecs(env, globalContext);
        }",Eager Test
"@Test
    public void should_fail_parsing_non_frozen_nested_udt() throws Exception {
        setExec(aptUtils -> {
            final GlobalParsingContext globalContext = new GlobalParsingContext(V3_6.INSTANCE, InsertStrategy.ALL_FIELDS, new LowerCaseNaming(),
                    EXPLICIT_ENTITY_FIELD_FILTER, EXPLICIT_UDT_FIELD_FILTER, Optional.empty());
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalContext);

            // @Column
            // private TestNonFrozenNestedUDT nonFrozenNestedUDT;
            VariableElement elm = findFieldInType(typeElement, ""nonFrozenNestedUDT"");

            fieldParser.parse(elm, entityContext);

        }",Eager Test
"@Test
    public void should_fail_parsing_SASI_analyzed_but_not_string() throws Exception {
        setExec(aptUtils -> {
            final GlobalParsingContext globalContext = new GlobalParsingContext(V3_7.INSTANCE, InsertStrategy.ALL_FIELDS, new LowerCaseNaming(),
                    EXPLICIT_ENTITY_FIELD_FILTER, EXPLICIT_UDT_FIELD_FILTER, Optional.empty());
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForSASI.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalContext);

            // @Column
            // @SASI(analyzed = true)
            // private Long analyzedNotString;
            VariableElement elm = findFieldInType(typeElement, ""analyzedNotString"");

            fieldParser.parse(elm, entityContext);

        }",Eager Test
"@Test
    public void should_fail_parsing_SASI_analyzed_but_SPARSE() throws Exception {
        setExec(aptUtils -> {
            final GlobalParsingContext globalContext = new GlobalParsingContext(V3_7.INSTANCE, InsertStrategy.ALL_FIELDS, new LowerCaseNaming(),
                    EXPLICIT_ENTITY_FIELD_FILTER, EXPLICIT_UDT_FIELD_FILTER, Optional.empty());
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForSASI.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalContext);

            // @Column
            // @SASI(analyzed = true, indexMode = SPARSE)
            // private String analyzedSparse;
            VariableElement elm = findFieldInType(typeElement, ""analyzedSparse"");

            fieldParser.parse(elm, entityContext);

        }",Eager Test
"@Test
    public void should_fail_parsing_SASI_lowercase_But_NotAnalyzed() throws Exception {
        setExec(aptUtils -> {
            final GlobalParsingContext globalContext = new GlobalParsingContext(V3_7.INSTANCE, InsertStrategy.ALL_FIELDS, new LowerCaseNaming(),
                    EXPLICIT_ENTITY_FIELD_FILTER, EXPLICIT_UDT_FIELD_FILTER, Optional.empty());
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForSASI.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalContext);

            // @Column
            // @SASI(analyzed = false, analyzerClass = NON_TOKENIZING_ANALYZER, normalization = LOWERCASE)
            // private String normalizationNotAnalyzed
            VariableElement elm = findFieldInType(typeElement, ""normalizationNotAnalyzed"");

            fieldParser.parse(elm, entityContext);

        }",Eager Test
"@Test
    public void should_parse_computed_field_with_codec() throws Exception {

        setExec(aptUtils -> {
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalParsingContext);

            // @Computed(function = ""writetime"",  alias = ""writetime"", targettargetColumnsap""}",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_field_with_case_sensitive_overriden_name() throws Exception {
        setExec(aptUtils -> {
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalParsingContext);

            // @Column(""\""overRiden\"""")
            // private String overridenName;
            VariableElement elm = findFieldInType(typeElement, ""overridenName"");

            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(String.class.getCanonicalName());
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_field_with_case_sensitive_overriden_name.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_list_udt() throws Exception {

        setExec(aptUtils -> {
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalParsingContext);

            // private List<TestUDT> listUdt;
            VariableElement elm = findFieldInType(typeElement, ""listUdt"");
            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(""java.util.List<com.datastax.driver.core.UDTValue>"");
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_list_udt.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_map_udt() throws Exception {

        setExec(aptUtils -> {
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalParsingContext);

            // private Map<Integer, TestUDT> mapUdt;
            VariableElement elm = findFieldInType(typeElement, ""mapUdt"");
            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(""java.util.Map<java.lang.Integer, com.datastax.driver.core.UDTValue>"");
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_map_udt.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_map_with_nested_json() throws Exception {

        setExec(aptUtils -> {
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalParsingContext);

            // private Map<Integer, @JSON List<Map<Integer, String>>> mapWithNestedJson;
            VariableElement elm = findFieldInType(typeElement, ""mapWithNestedJson"");
            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(""java.util.Map<java.lang.Integer, java.lang.String>"");
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_map_with_nested_json.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_nested_int_array() throws Exception {

        setExec(aptUtils -> {
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalParsingContext);

            //  private List<@Frozen Map<@Enumerated ProtocolVersion, List<int[]>>> nestedArrays;
            VariableElement elm = findFieldInType(typeElement, ""nestedArrays"");
            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(""java.util.List<java.util.Map<java.lang.String, java.util.List<int[]>>>"");
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_nested_int_array.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_nested_tuple() throws Exception {

        setExec(aptUtils -> {
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalParsingContext);

            // private Map<Integer, Tuple2<Integer, String>> nestedTuple;
            VariableElement elm = findFieldInType(typeElement, ""nestedTuple"");
            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(""java.util.Map<java.lang.Integer, com.datastax.driver.core.TupleValue>"");
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_nested_tuple.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_nested_udt() throws Exception {

        setExec(aptUtils -> {
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalParsingContext);

            // private TestNestedUDT nestedUDT;
            VariableElement elm = findFieldInType(typeElement, ""nestedUDT"");
            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(UDTValue.class.getCanonicalName());
            assertThat(parsingResult.udtMetaSignature.isPresent()).isTrue();
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_nested_udt.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_non_frozen_udt() throws Exception {
        setExec(aptUtils -> {
            final GlobalParsingContext globalContext = new GlobalParsingContext(V3_6.INSTANCE, InsertStrategy.ALL_FIELDS, new LowerCaseNaming(),
                    EXPLICIT_ENTITY_FIELD_FILTER, EXPLICIT_UDT_FIELD_FILTER, Optional.empty());
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalContext);

            // @Column
            // private TestUDT nonFrozenUDT;
            VariableElement elm = findFieldInType(typeElement, ""nonFrozenUDT"");

            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(UDTValue.class.getCanonicalName());
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_non_frozen_udt.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_optional_protocol_version_from_inline_codec() throws Exception {

        setExec(aptUtils -> {
            final GlobalParsingContext globalContext = globalParsingContext;
            new CodecRegistryParser(aptUtils).parseCodecs(env, globalContext);
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy,
                    globalContext);

            // @Column
            // private Optional<@Enumerated(Encoding.ORDINAL) ProtocolVersion> optionalEncodingAsOrdinal;
            VariableElement elm = findFieldInType(typeElement, ""optionalEncodingAsOrdinal"");
            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(""java.lang.Integer"");
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_optional_protocol_version_from_inline_codec.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_optional_string() throws Exception {

        setExec(aptUtils -> {
            final GlobalParsingContext globalContext = globalParsingContext;
            new CodecRegistryParser(aptUtils).parseCodecs(env, globalContext);
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy,
                    globalContext);

            // @Column
            // private Optional<String> optionalString;
            VariableElement elm = findFieldInType(typeElement, ""optionalString"");
            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(""java.lang.String"");
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_optional_string.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_set_nesting() throws Exception {

        setExec(aptUtils -> {
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalParsingContext);

            // private Set<Map<Integer,String>> setNesting;
            VariableElement elm = findFieldInType(typeElement, ""setNesting"");
            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(""java.util.Set<java.util.Map<java.lang.Integer, java.lang.String>>"");
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_set_nesting.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_set_udt() throws Exception {

        setExec(aptUtils -> {
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalParsingContext);

            // private Set<TestUDT> setUdt;
            VariableElement elm = findFieldInType(typeElement, ""setUdt"");
            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(""java.util.Set<com.datastax.driver.core.UDTValue>"");
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_set_udt.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_parse_tuple_nesting() throws Exception {

        setExec(aptUtils -> {
            final FieldParser fieldParser = new FieldParser(aptUtils);
            final String className = TestEntityForCodecs.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            final EntityParsingContext entityContext = new EntityParsingContext(typeElement, ClassName.get(TestEntityForCodecs.class), strategy, globalParsingContext);

            // private Tuple2<Integer, List<String>> tupleNesting;
            VariableElement elm = findFieldInType(typeElement, ""tupleNesting"");
            FieldMetaSignature parsingResult = fieldParser.parse(elm, entityContext);

            assertThat(parsingResult.targetType.toString()).isEqualTo(TUPLE_VALUE_CLASSNAME);
            assertThat(parsingResult.buildPropertyAsField().toString().trim().replaceAll(""\n"", """"))
                    .isEqualTo(readCodeLineFromFile(""expected_code/field_parser/should_parse_tuple_nesting.txt""));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_fail_parsing_function_forbidden_keyspace_name() throws Exception {
        setExec(aptUtils -> {
            final String className = TestFunctionRegistryWithForbiddenKeyspaceName.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            FunctionParser.parseFunctionRegistryAndValidateTypes(aptUtils, typeElement, context);
        }",Eager Test
"@Test
    public void should_fail_parsing_function_with_unsupported_param_type() throws Exception {
        setExec(aptUtils -> {
            final String className = TestFunctionRegistryWithUnsupportedParamType.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);
            FunctionParser.parseFunctionRegistryAndValidateTypes(aptUtils, typeElement, context);
        }",Eager Test
"@Test
    public void should_parse_function_with_keyspace() throws Exception {
        setExec(aptUtils -> {
            final String className = TestFunctionRegistryWithKeyspaceName.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);

            final List<FunctionSignature> UDFSignatures = FunctionParser.parseFunctionRegistryAndValidateTypes(aptUtils, typeElement, context);

            /**
             * Long toLong(String val);
             * Integer toInt(String val);
             */

            assertThat(UDFSignatures).hasSize(2);
            final FunctionSignature signature1 = UDFSignatures.get(0);
            assertThat(signature1.keyspace.get()).isEqualTo(""ks"");
            assertThat(signature1.name).isEqualTo(""toLong"");
            assertThat(signature1.returnTypeSignature.targetCQLTypeName).isEqualTo(OBJECT_LONG);
            assertThat(signature1.sourceParameterTypes).containsExactly(STRING);

            final FunctionSignature signature2 = UDFSignatures.get(1);
            assertThat(signature2.keyspace.get()).isEqualTo(""ks"");
            assertThat(signature2.name).isEqualTo(""toInt"");
            assertThat(signature2.returnTypeSignature.targetCQLTypeName).isEqualTo(OBJECT_INT);
            assertThat(signature2.sourceParameterTypes).containsExactly(STRING);
        }",Eager Test
"@Test
    public void should_parse_functions_with_complex_return_types_ecj() throws Exception {
        /**
         * Eclipse compiler orders method by their name:
         *
         * 0 complicated
         * 1 doubleArray
         * 2 enumeratedParam
         * 3 floatArray
         * 4 intArray
         * 5 intToStringCodec
         * 6 jdkInstant
         * 7 jdkLocalDate
         * 8 jdkLocalTime
         * 9 jdkOptional
         * 10 jdkZonedDateTime
         * 11 json
         * 12 listOfMap
         * 13 listUDT
         * 14 localDate
         * 15 longArray
         * 16 mapUDT
         * 17 objectByteArray
         * 18 primitiveByteArray
         * 19 setEnum
         * 20 timeuuid
         * 21 tuple1
         * 22 tuple2
         * 23 udf
         */
        //Given
        setExec(aptUtils -> {
            final ClassName testUDTType = ClassName.get(TestUDT.class);
            final String className = TestFunctionRegistryWithComplexReturnTypes.class.getCanonicalName();
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(className);

            final List<FunctionSignature> udfSignatures = FunctionParser.parseFunctionRegistryAndValidateTypes(aptUtils, typeElement, context);

            assertThat(udfSignatures).hasSize(24);
            final FunctionSignature enumeratedParam = udfSignatures.get(2);
            assertThat(enumeratedParam.getFunctionName()).isEqualTo(""enumeratedParam"");
            assertThat(enumeratedParam.parameterSignatures).hasSize(0);
            assertThat(enumeratedParam.returnTypeSignature.sourceTypeName).isEqualTo(CONSISTENCY_LEVEL);
            assertThat(enumeratedParam.returnTypeSignature.targetCQLTypeName).isEqualTo(OBJECT_INT);
            assertThat(enumeratedParam.returnTypeSignature.targetCQLDataType).isEqualTo(""int"");

            final FunctionSignature json = udfSignatures.get(11);
            assertThat(json.returnTypeSignature.sourceTypeName).isEqualTo(JAVA_UTIL_DATE);
            assertThat(json.returnTypeSignature.targetCQLTypeName).isEqualTo(STRING);
            assertThat(json.returnTypeSignature.targetCQLDataType).isEqualTo(""text"");

            final FunctionSignature primitiveByteArray = udfSignatures.get(18);
            assertThat(primitiveByteArray.returnTypeSignature.sourceTypeName).isEqualTo(TypeName.get(byte[].class));
            assertThat(primitiveByteArray.returnTypeSignature.targetCQLTypeName).isEqualTo(BYTE_BUFFER);
            assertThat(primitiveByteArray.returnTypeSignature.targetCQLDataType).isEqualTo(""blob"");

            final FunctionSignature objectByteArray = udfSignatures.get(17);
            assertThat(objectByteArray.returnTypeSignature.sourceTypeName).isEqualTo(TypeName.get(Byte[].class));
            assertThat(objectByteArray.returnTypeSignature.targetCQLTypeName).isEqualTo(BYTE_BUFFER);
            assertThat(objectByteArray.returnTypeSignature.targetCQLDataType).isEqualTo(""blob"");

            final FunctionSignature intToStringCodec = udfSignatures.get(5);
            assertThat(intToStringCodec.returnTypeSignature.sourceTypeName).isEqualTo(OBJECT_INT);
            assertThat(intToStringCodec.returnTypeSignature.targetCQLTypeName).isEqualTo(STRING);
            assertThat(intToStringCodec.returnTypeSignature.targetCQLDataType).isEqualTo(""text"");

            final FunctionSignature udf = udfSignatures.get(23);
            assertThat(udf.returnTypeSignature.sourceTypeName).isEqualTo(testUDTType);
            assertThat(udf.returnTypeSignature.targetCQLTypeName).isEqualTo(JAVA_DRIVER_UDT_VALUE_TYPE);
            assertThat(udf.returnTypeSignature.targetCQLDataType).isEqualTo(""my_type"");

            final FunctionSignature listUDT = udfSignatures.get(13);
            assertThat(listUDT.returnTypeSignature.sourceTypeName).isEqualTo(genericType(LIST, testUDTType));
            assertThat(listUDT.returnTypeSignature.targetCQLTypeName).isEqualTo(genericType(LIST, JAVA_DRIVER_UDT_VALUE_TYPE));
            assertThat(listUDT.returnTypeSignature.targetCQLDataType).isEqualTo(""list<my_type>"");

            final FunctionSignature mapUDT = udfSignatures.get(16);
            assertThat(mapUDT.returnTypeSignature.sourceTypeName).isEqualTo(genericType(MAP, OBJECT_INT, testUDTType));
            assertThat(mapUDT.returnTypeSignature.targetCQLTypeName).isEqualTo(genericType(MAP, OBJECT_INT, JAVA_DRIVER_UDT_VALUE_TYPE));
            assertThat(mapUDT.returnTypeSignature.targetCQLDataType).isEqualTo(""map<int, my_type>"");

            final FunctionSignature setEnum = udfSignatures.get(19);
            assertThat(setEnum.returnTypeSignature.sourceTypeName).isEqualTo(genericType(SET, CONSISTENCY_LEVEL));
            assertThat(setEnum.returnTypeSignature.targetCQLTypeName).isEqualTo(genericType(SET, STRING));
            assertThat(setEnum.returnTypeSignature.targetCQLDataType).isEqualTo(""set<text>"");

            final FunctionSignature listOfMap = udfSignatures.get(12);
            assertThat(listOfMap.returnTypeSignature.sourceTypeName).isEqualTo(genericType(LIST, genericType(MAP, OBJECT_INT, STRING)));
            assertThat(listOfMap.returnTypeSignature.targetCQLTypeName).isEqualTo(genericType(LIST, genericType(MAP, OBJECT_INT, STRING)));
            assertThat(listOfMap.returnTypeSignature.targetCQLDataType).isEqualTo(""list<map<int, text>>"");

            final FunctionSignature tuple1 = udfSignatures.get(21);
            assertThat(tuple1.returnTypeSignature.sourceTypeName).isEqualTo(genericType(TUPLE1, CONSISTENCY_LEVEL));
            assertThat(tuple1.returnTypeSignature.targetCQLTypeName).isEqualTo(JAVA_DRIVER_TUPLE_VALUE_TYPE);
            assertThat(tuple1.returnTypeSignature.targetCQLDataType).isEqualTo(""frozen<tuple<text>>"");

            final FunctionSignature tuple2 = udfSignatures.get(22);
            assertThat(tuple2.returnTypeSignature.sourceTypeName).isEqualTo(genericType(TUPLE2, OBJECT_INT, genericType(LIST, OBJECT_INT)));
            assertThat(tuple2.returnTypeSignature.targetCQLTypeName).isEqualTo(JAVA_DRIVER_TUPLE_VALUE_TYPE);
            assertThat(tuple2.returnTypeSignature.targetCQLDataType).isEqualTo(""frozen<tuple<int, list<text>>>"");

            final FunctionSignature complicated = udfSignatures.get(0);
            assertThat(complicated.returnTypeSignature.sourceTypeName).isEqualTo(genericType(MAP, testUDTType, genericType(MAP, OBJECT_INT, genericType(TUPLE3, OBJECT_INT, OBJECT_INT, CONSISTENCY_LEVEL))));
            assertThat(complicated.returnTypeSignature.targetCQLTypeName).isEqualTo(genericType(MAP, STRING, genericType(MAP, OBJECT_INT, JAVA_DRIVER_TUPLE_VALUE_TYPE)));
            assertThat(complicated.returnTypeSignature.targetCQLDataType).isEqualTo(""map<text, map<int, frozen<tuple<text, int, int>>>>"");

            final FunctionSignature timeuuid = udfSignatures.get(20);
            assertThat(timeuuid.returnTypeSignature.sourceTypeName).isEqualTo(UUID);
            assertThat(timeuuid.returnTypeSignature.targetCQLTypeName).isEqualTo(UUID);
            assertThat(timeuuid.returnTypeSignature.targetCQLDataType).isEqualTo(""timeuuid"");

            final FunctionSignature longArray = udfSignatures.get(15);
            assertThat(longArray.returnTypeSignature.sourceTypeName).isEqualTo(TypeName.get(long[].class));
            assertThat(longArray.returnTypeSignature.targetCQLTypeName).isEqualTo(TypeName.get(long[].class));
            assertThat(longArray.returnTypeSignature.targetCQLDataType).isEqualTo(""list<bigint>"");

            final FunctionSignature intArray = udfSignatures.get(4);
            assertThat(intArray.returnTypeSignature.sourceTypeName).isEqualTo(TypeName.get(int[].class));
            assertThat(intArray.returnTypeSignature.targetCQLTypeName).isEqualTo(TypeName.get(int[].class));
            assertThat(intArray.returnTypeSignature.targetCQLDataType).isEqualTo(""list<int>"");

            final FunctionSignature doubleArray = udfSignatures.get(1);
            assertThat(doubleArray.returnTypeSignature.sourceTypeName).isEqualTo(TypeName.get(double[].class));
            assertThat(doubleArray.returnTypeSignature.targetCQLTypeName).isEqualTo(TypeName.get(double[].class));
            assertThat(doubleArray.returnTypeSignature.targetCQLDataType).isEqualTo(""list<double>"");

            final FunctionSignature floatArray = udfSignatures.get(3);
            assertThat(floatArray.returnTypeSignature.sourceTypeName).isEqualTo(TypeName.get(float[].class));
            assertThat(floatArray.returnTypeSignature.targetCQLTypeName).isEqualTo(TypeName.get(float[].class));
            assertThat(floatArray.returnTypeSignature.targetCQLDataType).isEqualTo(""list<float>"");

            final FunctionSignature localDate = udfSignatures.get(14);
            assertThat(localDate.returnTypeSignature.sourceTypeName).isEqualTo(JAVA_DRIVER_LOCAL_DATE);
            assertThat(localDate.returnTypeSignature.targetCQLTypeName).isEqualTo(JAVA_DRIVER_LOCAL_DATE);
            assertThat(localDate.returnTypeSignature.targetCQLDataType).isEqualTo(""date"");

            final FunctionSignature jdkInstant = udfSignatures.get(6);
            assertThat(jdkInstant.returnTypeSignature.sourceTypeName).isEqualTo(JAVA_TIME_INSTANT);
            assertThat(jdkInstant.returnTypeSignature.targetCQLTypeName).isEqualTo(JAVA_TIME_INSTANT);
            assertThat(jdkInstant.returnTypeSignature.targetCQLDataType).isEqualTo(""timestamp"");

            final FunctionSignature jdkLocalDate = udfSignatures.get(7);
            assertThat(jdkLocalDate.returnTypeSignature.sourceTypeName).isEqualTo(JAVA_TIME_LOCAL_DATE);
            assertThat(jdkLocalDate.returnTypeSignature.targetCQLTypeName).isEqualTo(JAVA_TIME_LOCAL_DATE);
            assertThat(jdkLocalDate.returnTypeSignature.targetCQLDataType).isEqualTo(""date"");

            final FunctionSignature jdkLocalTime = udfSignatures.get(8);
            assertThat(jdkLocalTime.returnTypeSignature.sourceTypeName).isEqualTo(JAVA_TIME_LOCAL_TIME);
            assertThat(jdkLocalTime.returnTypeSignature.targetCQLTypeName).isEqualTo(JAVA_TIME_LOCAL_TIME);
            assertThat(jdkLocalTime.returnTypeSignature.targetCQLDataType).isEqualTo(""time"");

            final FunctionSignature jdkZonedDateTime = udfSignatures.get(10);
            assertThat(jdkZonedDateTime.returnTypeSignature.sourceTypeName).isEqualTo(JAVA_TIME_ZONED_DATE_TME);
            assertThat(jdkZonedDateTime.returnTypeSignature.targetCQLTypeName).isEqualTo(JAVA_TIME_ZONED_DATE_TME);
            assertThat(jdkZonedDateTime.returnTypeSignature.targetCQLDataType).isEqualTo(""tuple<timestamp, varchar>"");

            final FunctionSignature jdkOptional = udfSignatures.get(9);
            assertThat(jdkOptional.returnTypeSignature.sourceTypeName).isEqualTo(genericType(OPTIONAL, STRING));
            assertThat(jdkOptional.returnTypeSignature.targetCQLTypeName).isEqualTo(STRING);
            assertThat(jdkOptional.returnTypeSignature.targetCQLDataType).isEqualTo(""text"");
        }",Eager Test
"@Test
    public void should_fail_validating_an_abstract_class() throws Exception {
        setExec(aptUtils -> {
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityAsAbstract.class.getCanonicalName());
            beanValidator.validateIsAConcreteClass(aptUtils, typeElement);
        }",No Smells
"@Test
    public void should_fail_validating_class_without_default_constructor() throws Exception {
        setExec(aptUtils -> {
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityWithNoPublicConstructor.class.getCanonicalName());
            final TypeName typeName = ClassName.get(TestEntityWithNoPublicConstructor.class);
            beanValidator.validateConstructor(aptUtils, typeName, typeElement);
        }",Eager Test
"@Test
    public void should_validate_entity_with_EntityCreator_constructor() throws Exception {
        setExec(aptUtils -> {
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestEntityWithEntityCreatorConstructor.class.getCanonicalName());
            final TypeName typeName = ClassName.get(TestEntityWithEntityCreatorConstructor.class);
            final ConstructorInfo constructorInfo = beanValidator.validateConstructor(aptUtils, typeName, typeElement);

            assertThat(constructorInfo).isNotNull();
            assertThat(constructorInfo.type).isSameAs(ENTITY_CREATOR);
        }",Eager Test
"@Test
    public void should_validate_immutable_entity() throws Exception {
        setExec(aptUtils -> {
            final TypeElement typeElement = aptUtils.elementUtils.getTypeElement(TestImmutableEntity.class.getCanonicalName());
            final TypeName typeName = ClassName.get(TestImmutableEntity.class);
            final ConstructorInfo constructorInfo = beanValidator.validateConstructor(aptUtils, typeName, typeElement);

            assertThat(constructorInfo).isNotNull();
            assertThat(constructorInfo.type).isSameAs(IMMUTABLE);
        }",Eager Test
"@Test
    public void should_validate_view_against_base_table() throws Exception {
        setExec(aptUtils -> {
            final TypeElement typeElementBase = aptUtils.elementUtils.getTypeElement(TestEntitySensor.class.getCanonicalName());
            final TypeElement typeElementView = aptUtils.elementUtils.getTypeElement(TestViewSensorByType.class.getCanonicalName());

            final EntityMetaCodeGen builder = new EntityMetaCodeGen(aptUtils);
            final EntityMetaCodeGen.EntityMetaSignature baseSignature = builder.buildEntityMeta(TABLE, typeElementBase, context, getTypeParsingResults(aptUtils, typeElementBase, context), emptyList());
            final EntityMetaCodeGen.EntityMetaSignature viewSignature = builder.buildEntityMeta(VIEW, typeElementView, context, getTypeParsingResults(aptUtils, typeElementView, context), emptyList());

            beanValidator.validateViewsAgainstBaseTable(aptUtils, Arrays.asList(viewSignature), Arrays.asList(baseSignature));
        }",Eager Test
"@Test
    public void should_fail_on_invalidLowerBound() throws Exception {
        String object = Object.class.getCanonicalName();
        final TypeName typeName = TypeName.get(TestTypes.class.getDeclaredField(""invalidLowerBound"").getGenericType());
        typeValidator.validateAllowedTypes(aptUtils, typeName, typeName);
        verify(aptUtils, times(1)).validateTrue(eq(true), anyString(), anyVararg());
        verify(aptUtils, times(1)).validateTrue(eq(false), messageCaptor.capture(), objectCaptor.capture(), objectCaptor.capture());

        assertThat(messageCaptor.getValue()).isEqualTo(""Type '%s' in '%s' is not a valid type for CQL"");
        assertThat(objectCaptor.getAllValues()).containsExactly(object, typeName.toString());
    }",Eager Test
"@Test
    public void should_validate_objectByteArray() throws Exception {
        final TypeName typeName = TypeName.get(TestTypes.class.getDeclaredField(""objectByteArray"").getGenericType());
        typeValidator.validateAllowedTypes(aptUtils, typeName, typeName);
        verify(aptUtils).validateTrue(eq(true), anyString(), anyVararg());
    }",No Smells
"@Test
    public void should_return_blank_name_on_null() throws Exception {
        //Given
        String name = null;

        //When
        final String actual = strategy.apply(name);

        //Then
        assertThat(actual).isEmpty();
    }",No Smells
"@Test
    public void should_return_lower_case() throws Exception {
        //Given
        String name = ""ZfrEr_rfR"";

        //When
        final String actual = strategy.apply(name);

        //Then
        assertThat(actual).isEqualTo(""zfrer_rfr"");
    }",No Smells
"@Test
    public void should_return_snake_case() throws Exception {
        //Given
        String name = ""theBigOne__andSmaller_One"";

        //When
        final String actual = strategy.apply(name);

        //Then
        assertThat(actual).isEqualTo(""the_big_one_and_smaller_one"");
    }",No Smells
"@Test
    public void should_convert_type_name_to_string() throws Exception {
        //Given
        final TypeName nativeBool = TypeName.get(boolean.class);
        final TypeName objectLong = TypeName.get(Long.class);
        final TypeName localDate = TypeName.get(LocalDate.class);
        final TypeName bigDecimal = TypeName.get(BigDecimal.class);
        final TypeName listString = genericType(LIST, STRING);
        final TypeName mapStringTuple = genericType(MAP, STRING, JAVA_DRIVER_TUPLE_VALUE_TYPE);
        final TypeName mapStringListUDT = genericType(MAP, STRING, genericType(LIST, JAVA_DRIVER_UDT_VALUE_TYPE));


        //When
        assertThat(TypeNameHelper.asString(nativeBool)).isEqualTo(""Boolean"");
        assertThat(TypeNameHelper.asString(objectLong)).isEqualTo(""Long"");
        assertThat(TypeNameHelper.asString(localDate)).isEqualTo(""DriverLocalDate"");
        assertThat(TypeNameHelper.asString(bigDecimal)).isEqualTo(""BigDecimal"");
        assertThat(TypeNameHelper.asString(listString)).isEqualTo(""List_String"");
        assertThat(TypeNameHelper.asString(mapStringTuple)).isEqualTo(""Map_String_TupleValue"");
        assertThat(TypeNameHelper.asString(mapStringListUDT)).isEqualTo(""Map_String_List_UDTValue"");

        //Then
    
    }",Eager Test
"@Test
    public void should_handle_3_levels_of_nesting_udt() throws Exception {
       //Given
       final EntityLayer1 entity = new EntityLayer1(""layer1"", new Layer2(""layer2"", new Layer3(""layer3"")));
       manager.crud().insert(entity).execute();

       //When
       final EntityLayer1 found = manager.crud().findById(""layer1"").get();

       //Then
       assertThat(found).isNotNull();
       assertThat(found.getLayer()).isEqualTo(""layer1"");
       assertThat(found.getLayer2()).isNotNull();
       assertThat(found.getLayer2().getLayer()).isEqualTo(""layer2"");
       assertThat(found.getLayer2().getLayer3()).isNotNull();
       assertThat(found.getLayer2().getLayer3().getLayer()).isEqualTo(""layer3"");
   }",Eager Test
"@Test
    public void should_select_some_columns_from_udt() throws Exception {
        //Given
        final EntityLayer1 entity = new EntityLayer1(""layer1_nested"", new Layer2(""layer2"", new Layer3(""layer3"")));
        manager.crud().insert(entity).execute();

        //When
        final TypedMap found = manager.dsl()
                .select()
                .layer()
                .layer2().layer()
                .layer2().layer3().allColumns()
                .fromBaseTable()
                .where()
                .layer().Eq(entity.getLayer())
                .getTypedMap();

        //Then
        assertThat(found).isNotNull();
        assertThat(found.<String>getTyped(""layer"")).isEqualTo(entity.getLayer());
        assertThat(found.<String>getTyped(""layer2.layer"")).isEqualTo(entity.getLayer2().getLayer());
        assertThat(found.<UDTValue>getTyped(""layer2.layer3"").getString(""layer"")).isEqualTo(entity.getLayer2().getLayer3().getLayer());
    }",Eager Test
"@Test
    public void should_fail_validating_schema_when_partition_key_missing() throws Exception {
        //Given
        final Cluster cluster = CassandraEmbeddedServerBuilder.builder()
                .withScript(""EntityWithMissingPartitionKey/schema.cql"")
                .buildNativeCluster();
        cluster.init();

        //When
        exception.expect(AchillesBeanMappingException.class);
        exception.expectMessage(""The mapped partition key(s) [id] for entity "" +
                ""info.archinnov.achilles.internals.entities.EntityWithMissingPartitionKey "" +
                ""do not correspond to live schema partition key(s) [id, bucket]"");

        //Then
        ManagerFactoryBuilder
                .builder(cluster)
                .withManagedEntityClasses(EntityWithMissingPartitionKey.class)
                .build();
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_insert() throws Exception {
        //Given
        final long id = RandomUtils.nextLong(0L, Long.MAX_VALUE);
        final Tuple2<Integer, Map<Integer, List<String>>> tuple = Tuple2.of(10, ImmutableMap.of(20, asList(""10"", ""20"")));

        final EntityWithComplexTuple entity = new EntityWithComplexTuple(id, tuple);

        //When
        manager
                .crud()
                .insert(entity)
                .execute();

        //Then
        final Row actual = session.execute(""SELECT * FROM complex_tuple WHERE id = "" + id).one();

        assertThat(actual).isNotNull();
        final TupleValue tupleValue = actual.getTupleValue(""tuple"");
        assertThat(tupleValue.getInt(0)).isEqualTo(10);
        final Map<Integer, List<String>> map = tupleValue.getMap(1, new TypeToken<Integer>() {
        }",Eager Test
"@Test
    public void should_insert() throws Exception {
        //Given
        final long id = RandomUtils.nextLong(0L, Long.MAX_VALUE);
        final TestUDT udt = new TestUDT();
        udt.setList(asList(""list""));
        udt.setName(""name"");
        udt.setMap(ImmutableMap.of(1, ""1""));
        UUID timeuuid = UUIDs.timeBased();
        java.time.Instant jdkInstant = Instant.now();
        java.time.LocalDate jdkLocalDate = java.time.LocalDate.now();
        java.time.LocalTime jdkLocalTime = java.time.LocalTime.now();
        java.time.ZonedDateTime jdkZonedDateTime = java.time.ZonedDateTime.now();

        final EntityWithComplexTypes entity = new EntityWithComplexTypes();
        entity.setId(id);
        entity.setCodecOnClass(new ClassAnnotatedByCodec());
        entity.setComplexNestingMap(ImmutableMap.of(udt,
                ImmutableMap.of(1, Tuple3.of(1, 2, ConsistencyLevel.ALL))));
        entity.setConsistencyLevel(ConsistencyLevel.EACH_QUORUM);
        entity.setInteger(123);
        entity.setJsonMap(ImmutableMap.of(1, asList(1, 2, 3)));
        entity.setListNesting(asList(ImmutableMap.of(1, ""one"")));
        entity.setListUdt(asList(udt));
        entity.setMapUdt(ImmutableMap.of(1, udt));
        entity.setMapWithNestedJson(ImmutableMap.of(1, asList(ImmutableMap.of(1, ""one""))));
        entity.setObjectBoolean(new Boolean(true));
        entity.setObjectByte(new Byte(""5""));
        entity.setObjectByteArray(new Byte[]{7}",Eager Test
"@Test
    public void should_search_date_eq() throws Exception {
        //Given
        final Date searchedDate = toDate(""2016-09-26 08:00:00.000Z"");

        //When
        final List<EntityWithDSESearch> actual = manager
                .indexed()
                .select()
                .allColumns_FromBaseTable()
                .where()
                .search_on_date().Eq(searchedDate)
                .getList();

        //Then
        assertThat(actual).hasSize(1);
        assertThat(toString(actual.get(0).getDate())).isEqualTo(""2016-09-26 08:00:00.000Z"");
    }",No Smells
"@Test
    public void should_search_date_gte_and_lte() throws Exception {
        //Given
        final Date searchedDate1 = toDate(""2016-09-25 13:00:00.000Z"");
        final Date searchedDate2 = toDate(""2016-09-26 09:00:00.000Z"");

        //When
        final List<EntityWithDSESearch> actual = manager
                .indexed()
                .select()
                .allColumns_FromBaseTable()
                .where()
                .search_on_date().Gte_And_Lte(searchedDate1, searchedDate2)
                .getList();

        //Then
        assertThat(actual).hasSize(3);
        assertThat(actual.stream()
                .map(EntityWithDSESearch::getDate)
                .map(this::toString)
                .collect(toList()))
                .contains(""2016-09-26 09:00:00.000Z"",
                        ""2016-09-26 08:00:00.000Z"",
                        ""2016-09-25 13:00:00.000Z"");
    }",No Smells
"@Test
    public void should_search_date_lt() throws Exception {
        //Given
        final Date searchedDate = toDate(""2016-09-26 08:00:00.000Z"");

        //When
        final List<EntityWithDSESearch> actual = manager
                .indexed()
                .select()
                .allColumns_FromBaseTable()
                .where()
                .search_on_date().Lt(searchedDate)
                .getList();

        //Then
        assertThat(actual).hasSize(1);
        assertThat(toString(actual.get(0).getDate())).isEqualTo(""2016-09-25 13:00:00.000Z"");
    }",No Smells
"@Test
    public void should_search_using_multiple_predicates() throws Exception {
        //Given
        final Date searchedDate1 = toDate(""2016-09-25 13:00:00.000Z"");
        final Date searchedDate2 = toDate(""2016-09-26 09:00:00.000Z"");

        //When
        final List<EntityWithDSESearch> actual = manager
                .indexed()
                .select()
                .allColumns_FromBaseTable()
                .where()
                .search_on_date().Gte_And_Lte(searchedDate1, searchedDate2)
                .search_on_string().Contains(""run"")
                .search_on_numeric().Gt_And_Lte(80f, 110f)
                .getList();

        //Then
        assertThat(actual).hasSize(1);
        assertThat(actual.get(0).getNumeric()).isEqualTo(87.39f);
    }",No Smells
"@Test
    public void should_search_using_raw_solr_query() throws Exception {
        //Given

        //When
        final List<EntityWithDSESearch> actual = manager
                .indexed()
                .select()
                .allColumns_FromBaseTable()
                .where()
                .rawSolrQuery(""string:*eed?u* OR numeric:[100 TO *]"")
                .getList();

        //Then
        assertThat(actual).hasSize(2);
        assertThat(actual.stream()
                .map(EntityWithDSESearch::getString)
                .collect(toList()))
                .contains(""speedrun"",""speedster"");
    }",No Smells
"@Test
    public void should_search_date_eq_JSON() throws Exception {
        //Given
        final String searchedDate = ""\""2016-09-26 08:00:00.000+0000\"""";

        //When
        final List<EntityWithDSESearchJSON> actual = manager
                .indexed()
                .select()
                .allColumns_FromBaseTable()
                .where()
                .search_on_date().Eq_FromJson(searchedDate)
                .getList();

        //Then
        assertThat(actual).hasSize(1);
        assertThat(toString(actual.get(0).getDate())).isEqualTo(""2016-09-26 08:00:00.000Z"");
    }",No Smells
"@Test
    public void should_query_using_collection_index_fromJSON() throws Exception {
        //Given
        final Long id = RandomUtils.nextLong(0L, Long.MAX_VALUE);
        scriptExecutor.executeScriptTemplate(""EntityWithIndicesForJSON/insertRows.cql"", ImmutableMap.of(""id"", id));

        //When
        final List<EntityWithIndicesForJSON> actual = manager
                .indexed()
                .select()
                .allColumns_FromBaseTable()
                .where()
                .indexed_collectionIndex().Contains_FromJson(""\""4\"""")
                .getList();

        //Then
        assertThat(actual).hasSize(1);
        final EntityWithIndicesForJSON entity = actual.get(0);
        assertThat(entity.getSimpleIndex()).isEqualTo(""411"");
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_query_using_index_and_clustering_column_fromJSON() throws Exception {
        //Given
        final Long id = RandomUtils.nextLong(0L, Long.MAX_VALUE);
        scriptExecutor.executeScriptTemplate(""EntityWithIndicesForJSON/insertRows.cql"", ImmutableMap.of(""id"", id));

        //When
        final List<EntityWithIndicesForJSON> actual = manager
                .indexed()
                .select()
                .allColumns_FromBaseTable()
                .where()
                .indexed_simpleIndex().Eq(""312"")
                .clust1().Eq_FromJson(""3"")
                .clust3().Eq_FromJson(""\""2\"""")
                .getList();

        //Then
        assertThat(actual).hasSize(1);
        final EntityWithIndicesForJSON entity = actual.get(0);
        assertThat(entity.getSimpleIndex()).isEqualTo(""312"");
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void should_build_schema_for_complex_types() throws Exception {
        //Given
        final EntityWithComplexTypes_AchillesMeta meta = new EntityWithComplexTypes_AchillesMeta();
        final CodecRegistry codecRegistry = new CodecRegistry();
        TupleTypeFactory tupleTypeFactory = new TupleTypeFactory(ProtocolVersion.NEWEST_SUPPORTED, codecRegistry);
        UserTypeFactory userTypeFactory = new UserTypeFactory(ProtocolVersion.NEWEST_SUPPORTED, codecRegistry);

        meta.inject(userTypeFactory, tupleTypeFactory);

        //When
        final String actual = meta.generateSchema(context);

        //Then
        assertThat(actual.trim()).isEqualTo(readCodeBlockFromFile(
                ""schema/should_build_schema_for_complex_types.cql""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void should_build_schema_for_entity_with_composite_partition_key() throws Exception {
        //Given
        final EntityWithCompositePartitionKey_AchillesMeta meta = new EntityWithCompositePartitionKey_AchillesMeta();

        //When
        final String actual = meta.generateSchema(context);

        //Then
        assertThat(actual.trim()).isEqualTo(readCodeBlockFromFile(
                ""schema/should_build_schema_for_entity_with_composite_partition_key.cql""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void should_build_schema_for_entity_with_simple_partition_key() throws Exception {
        //Given
        final EntityWithSimplePartitionKey_AchillesMeta meta = new EntityWithSimplePartitionKey_AchillesMeta();

        //When
        final String actual = meta.generateSchema(context);

        //Then
        assertThat(actual.trim()).isEqualTo(readCodeBlockFromFile(
                ""schema/should_build_schema_for_entity_with_simple_partition_key.cql""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void should_build_schema_for_entity_with_static_annotations() throws Exception {
        //Given
        final EntityWithStaticAnnotations_AchillesMeta meta = new EntityWithStaticAnnotations_AchillesMeta();

        //When
        final String actual = meta.generateSchema(context);

        //Then
        assertThat(actual.trim()).isEqualTo(readCodeBlockFromFile(
                ""schema/should_build_schema_for_entity_with_static_annotations.cql""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void should_build_schema_for_entity_with_static_column() throws Exception {
        //Given
        final EntityWithStaticColumn_AchillesMeta meta = new EntityWithStaticColumn_AchillesMeta();

        //When
        final String actual = meta.generateSchema(context);

        //Then
        assertThat(actual.trim()).isEqualTo(readCodeBlockFromFile(
                ""schema/should_build_schema_for_entity_with_static_column.cql""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void should_build_schema_for_simple_entity() throws Exception {
        //Given
        final SimpleEntity_AchillesMeta meta = new SimpleEntity_AchillesMeta();

        //When
        final String actual = meta.generateSchema(context);

        //Then
        assertThat(actual.trim()).isEqualTo(readCodeBlockFromFile(
                ""schema/should_build_schema_for_simple_entity.cql""));
    }",Mystery Guest + Resource Optimism
"@Test
    public void should_build_create_function_statements_from_lines_syntax_2() throws Exception {
        //Given
        List<String> lines = new ArrayList<>();
        lines.add(""CREATE FUNCTION udf.maxof(val1 int, val2 int)"");
        lines.add("" RETURNS NULL ON NULL INPUT"");
        lines.add("" RETURNS int"");
        lines.add(""LANGUAGE java"");
        lines.add(""AS"");
        lines.add(""$$"");
        lines.add(""return Math.max(val1, val2);"");
        lines.add(""$$;"");

        //When
        final List<SimpleStatement> statements = scriptExecutor.buildStatements(lines);

        //Then
        assertThat(statements).hasSize(1);
        assertThat(statements.get(0).getQueryString()).isEqualTo(""CREATE FUNCTION udf.maxof(val1 int, val2 int)  RETURNS NULL ON NULL INPUT  RETURNS int LANGUAGE java AS $$return Math.max(val1, val2);$$;"");
    }",No Smells
"@Test
    public void testKeyEmptyTypes() {
        Policy policy = new Policy();

        String key = target.key(httpServletRequest, null, policy);
        assertThat(key).isEqualTo(""key-prefix"");
    }",No Smells
"@Test
    public void testKeyUrlWithMatcher() {
        Policy policy = new Policy();
        policy.getType().add(new MatchType(RateLimitType.URL, ""matcherURL""));

        String key = target.key(httpServletRequest, route, policy);
        assertThat(key).isEqualTo(""key-prefix:id:/**:matcherURL"");
    }",Eager Test
"@Test
    public void testKeyUserNullPrincipal() {
        Policy policy = new Policy();
        policy.getType().add(new MatchType(RateLimitType.USER, null));

        String key = target.key(httpServletRequest, route, policy);
        assertThat(key).isEqualTo(""key-prefix:id:anonymous"");
    }",Eager Test
"@Test
    public void testKeyUserWithMatcher() {
        Policy policy = new Policy();
        policy.getType().add(new MatchType(RateLimitType.USER, ""matcherUser""));
        when(httpServletRequest.getRemoteUser()).thenReturn(""user"");

        String key = target.key(httpServletRequest, route, policy);
        assertThat(key).isEqualTo(""key-prefix:id:user:matcherUser"");
    }",Eager Test
"@Test
    public void testValidOnPolicyWithLimitAndRole() {
        properties.setKeyPrefix(""prefix"");
        Policy policy = getPolicy(1L, null);
        policy.getType().add(new Policy.MatchType(RateLimitType.ROLE, ""user""));
        properties.getDefaultPolicyList().add(policy);
        properties.getPolicyList().put(""key"", Lists.newArrayList(policy));
        Set<ConstraintViolation<RateLimitProperties>> violations = validator.validate(properties);
        assertThat(violations).isEmpty();
    }",Eager Test
"@Test
    public void testValidOnPolicyWithQuotaNoLimit() {
        properties.setKeyPrefix(""prefix"");
        Policy policy = getPolicy(null, Duration.ofSeconds(1));
        properties.getDefaultPolicyList().add(policy);
        properties.getPolicyList().put(""key"", Lists.newArrayList(policy));
        Set<ConstraintViolation<RateLimitProperties>> violations = validator.validate(properties);
        assertThat(violations).isEmpty();
    }",Eager Test
"@Test
    public void testValidWithNoPolicies() {
        properties.setKeyPrefix(""prefix"");
        Set<ConstraintViolation<RateLimitProperties>> violations = validator.validate(properties);
        assertThat(violations).isEmpty();
    }",No Smells
"@Test
    public void testConsumeRemainingLimitException() {
        doThrow(new RuntimeException()).when(redisTemplate).execute(any(), anyList(), anyString(), anyString());

        Policy policy = new Policy();
        policy.setLimit(100L);
        target.consume(policy, ""key"", 0L);
        verify(rateLimiterErrorHandler).handleError(matches("".* key, .*""), any());
    }",Eager Test
"@Test
    public void testFilterOrder() {
        assertThat(target.filterOrder()).isEqualTo(FilterConstants.SEND_RESPONSE_FILTER_ORDER - 10);
    }",No Smells
"@Test
    public void testShouldFilterOnNoPolicy() {
        rateLimitProperties.setEnabled(true);

        assertThat(target.shouldFilter()).isEqualTo(false);
    }",No Smells
"@Test
    public void testShouldFilterOnNullStartTime() {
        rateLimitProperties.setEnabled(true);
        Policy defaultPolicy = new Policy();
        rateLimitProperties.getDefaultPolicyList().add(defaultPolicy);

        assertThat(target.shouldFilter()).isEqualTo(false);
    }",Eager Test
"@Test
    public void testShouldFilterOnDisabledProperty() {
        assertThat(target.shouldFilter()).isEqualTo(false);
    }",Eager Test
"@Test
    public void testBucket4jJCacheRateLimiterByProperty() {
        contextRunner.withPropertyValues(PREFIX + "".repository=BUCKET4J_JCACHE"")
                .run(context -> assertThat(context).getBean(RateLimiter.class).isExactlyInstanceOf(Bucket4jJCacheRateLimiter.class));
    }",No Smells
"@Test
    public void testZuulFilters() {
        contextRunner.withPropertyValues(PREFIX + "".repository=BUCKET4J_JCACHE"")
                .run(context -> {
                    assertThat(context).getBeanNames(ZuulFilter.class).hasSize(2);
                    assertThat(context).getBeanNames(ZuulFilter.class)
                            .containsExactly(""rateLimiterPreFilter"", ""rateLimiterPostFilter"");
                }",No Smells
"@Test
    public void testExceptionInfo() {
        Throwable cause = target.getCause();
        assertThat(cause).isInstanceOf(ZuulException.class);

        ZuulException zuulException = (ZuulException) cause;
        assertThat(zuulException.getMessage()).contains(""429"");
    }",No Smells
"@Test
    public void testGetPackageFromModule() {
        Assert.assertEquals(CodeGenUtil.getPackageFromModule(""one-sys""), ""com.lcw.one.sys"");
        Assert.assertEquals(CodeGenUtil.getPackageFromModule(""one-code-gen""), ""com.lcw.one.codegen"");
        Assert.assertEquals(CodeGenUtil.getPackageFromModule(""one-test-camel""), ""com.lcw.one.testCamel"");
    }",Mystery Guest
"@Test
    public void testLocalFileStore() throws IOException {
        String randomContent = UUID.randomUUID();
        String relativePath = FileUtil.generateFilePath(""txt"");
        InputStream baos = new ByteArrayInputStream(randomContent.getBytes());
        iFileStore.storeFile(baos, relativePath);
        baos.close();

        // 
        File file = new File(basePath + relativePath);
        Assert.assertTrue(file.exists());

        //  loadFileBytes
        byte[] bytes1 = iFileStore.loadFileBytes(relativePath);
        Assert.assertEquals(new String(bytes1), randomContent);

        //  loadFile
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        iFileStore.loadFile(relativePath, os);
        byte[] bytes2 = os.toByteArray();
        os.close();
        Assert.assertEquals(new String(bytes2), randomContent);

        Assert.assertTrue(file.delete());
        Assert.assertTrue(!file.exists());
    }",Eager Test
"@Test
  public void eq1() throws Throwable {
    // Arrange
    Object a = -1;
    Object b = null;
    // Act
    Class<?> c = Reflector.forName(""com.alibaba.fastjson.JSONPath"");
    Method m = c.getDeclaredMethod(""eq"", Reflector.forName(""java.lang.Object""), Reflector.forName(""java.lang.Object""));
    m.setAccessible(true);
    boolean retval = (Boolean)m.invoke(null, a, b);
    // Assert result
    Assert.assertEquals(false, retval);
  }",Eager Test
"@Test
  public void isEOF2() throws Throwable {
    // Arrange
    Object objectUnderTest = Reflector.getInstance(""com.alibaba.fastjson.JSONPath$JSONPathParser"");
    Reflector.setField(objectUnderTest, ""path"", ""!"");
    Reflector.setField(objectUnderTest, ""pos"", 1);
    Reflector.setField(objectUnderTest, ""level"", 0);
    Reflector.setField(objectUnderTest, ""ch"", '\u0000');
    // Act
    Class<?> c = Reflector.forName(""com.alibaba.fastjson.JSONPath$JSONPathParser"");
    Method m = c.getDeclaredMethod(""isEOF"");
    m.setAccessible(true);
    boolean retval = (Boolean)m.invoke(objectUnderTest);
    // Assert result
    Assert.assertEquals(true, retval);
  }",Eager Test
"@Test
    public void checkDate16() throws Throwable {
        // Arrange
        char y0 = '2';
        char y1 = '0';
        char y2 = '2';
        char y3 = '0';
        char M0 = '1';
        char M1 = '3';
        int d0 = 48;
        int d1 = 52;

        // Act
        Class<?> c = Reflector.forName(""com.alibaba.fastjson.parser.JSONScanner"");
        Method m = c.getDeclaredMethod(""checkDate"", Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""int""), Reflector.forName(""int""));
        m.setAccessible(true);
        boolean retval = (Boolean)m.invoke(null, y0, y1, y2, y3, M0, M1, d0, d1);

        // Assert result
        Assert.assertEquals(false, retval);
    }",Eager Test
"@Test
    public void checkDate3() throws Throwable {
        // Arrange
        char y0 = '2';
        char y1 = '0';
        char y2 = '2';
        char y3 = '0';
        char M0 = '0';
        char M1 = '2';
        int d0 = 48;
        int d1 = 97;

        // Act
        Class<?> c = Reflector.forName(""com.alibaba.fastjson.parser.JSONScanner"");
        Method m = c.getDeclaredMethod(""checkDate"", Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""int""), Reflector.forName(""int""));
        m.setAccessible(true);
        boolean retval = (Boolean)m.invoke(null, y0, y1, y2, y3, M0, M1, d0, d1);

        // Assert result
        Assert.assertEquals(false, retval);
    }",Eager Test
"@Test
    public void checkDate6() throws Throwable {
        // Arrange
        char y0 = '2';
        char y1 = '0';
        char y2 = '2';
        char y3 = '0';
        char M0 = '0';
        char M1 = '2';
        int d0 = 49;
        int d1 = 97;

        // Act
        Class<?> c = Reflector.forName(""com.alibaba.fastjson.parser.JSONScanner"");
        Method m = c.getDeclaredMethod(""checkDate"", Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""char""), Reflector.forName(""int""), Reflector.forName(""int""));
        m.setAccessible(true);
        boolean retval = (Boolean)m.invoke(null, y0, y1, y2, y3, M0, M1, d0, d1);

        // Assert result
        Assert.assertEquals(false, retval);
    }",Eager Test
"@Test
    public void testTypeVariableBean() throws Exception {
        mockMvc.perform(
                (post(""/typeVariableBean"").characterEncoding(""UTF-8"")
                        .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE)
                        .content(""{\""id\"": 1}",No Smells
"@Test
    public void testParameterizedTypeBean() throws Exception {

        String request = ""{\""t\"": \""victor zeng\""}",No Smells
"@Test
    public void test() {

        final String reponse = target(""book1392"").path(""123"").request().accept(""application/javascript"").get(String.class);
        System.out.println(reponse);
        Assert.assertTrue(reponse.indexOf(""Python"") > 0);
        Assert.assertTrue(reponse.indexOf("""") > 0);
    }",No Smells
"@Test
    public void test_1() {
        User user = serializer.deserialize(serializer.serialize(new User(1, """", 25)));
        Assert.assertTrue(Objects.equal(user.getId(), 1));
        Assert.assertTrue(Objects.equal(user.getName(), """"));
        Assert.assertTrue(Objects.equal(user.getAge(), 25));
    }",No Smells
"@Test
    public void test_1() {
        User user = (User) serializer.deserialize(serializer.serialize(new User(1, """", 25)));
        Assert.assertTrue(Objects.equal(user.getId(), 1));
        Assert.assertTrue(Objects.equal(user.getName(), """"));
        Assert.assertTrue(Objects.equal(user.getAge(), 25));
    }",No Smells
"@Test
	public void test2() throws Exception {
		
		String jsonStr = ""[{\""name\"":\""p1\"",\""sonList\"":[{\""name\"":\""s1\""}",No Smells
"@Test
  public void shouldToStringOnArrays() {
    String[][] data = { { ""One"" }",No Smells
"@Test
  public void testIncompleteObject() {
    try {
      BusinessIdentity.areEqual(new Person(null, ""MiddleName"", null), new Person(null, ""MiddleName"", null));
      Assert.fail(""Expected Exception due to required BusinessKeys not fullfilled"");
    }",No Smells
"@Test
  public void caseInsensitiveArraysHaveTheSameHashCode() {
    StringArrayCaseInsensitive firstInstance = new StringArrayCaseInsensitive(new String[] { ""fIrSt"", ""MiDdLe"", ""LaSt"" }",No Smells
"@Test
  public void emptyArrayHashCode_isNotSameAsNullHashCode() {
    StringArrayCaseSensitive instance = new StringArrayCaseSensitive(new String[] { null }",No Smells
"@Test
  public void whenArraysOfNonEqualLength_thenPojosAreNotEqual() {
    StringArrayCaseSensitive firstInstance = new StringArrayCaseSensitive(new String[] { ""First"", ""Second"" }",No Smells
"@Test
  public void whenBusinessKeysAreOfCaseInsensitiveArraysOfArrays_thenPojosAreEqual() {
    StringArrayOfArrayCaseInsensitive firstInstance = new StringArrayOfArrayCaseInsensitive(
        new String[][] { { ""first"" }",No Smells
"@Test
  public void whenNoIdentityHandlerFoundShouldThrowException() {
    Object o = new Object();
    List<IdentityHandler> identityHandlers = new ArrayList<IdentityHandler>();

    try {
      while (IdentityFactory.getIdentityHandler(o) != null) {
        identityHandlers.add(IdentityFactory.getIdentityHandler(o));
        IdentityFactory.unregisterIdentityHandler(IdentityFactory.getIdentityHandler(o));

      }",No Smells
"@Test
  public void shouldReturnTemporalCache() {
    CacheStorage<String> keyValuePairCache = CacheStorageFactory.getTemporalCacheStorage();
    String expectedKey = ""SomeKey"";
    String expectedValue = ""SomeValue"";
    keyValuePairCache.add(expectedKey, expectedValue);
    Assert.assertEquals(expectedValue, keyValuePairCache.get(expectedKey));
    System.gc();
    Assert.assertNull(keyValuePairCache.get(expectedKey));
  }",No Smells
"@Test
  public void validate() {
    PojoClass pojoClass = PojoClassFactory.getPojoClass(DirtTruck.class);
    Validator pojoValidator = ValidatorBuilder.create()
        .with(new SetterMustExistRule())
        .with(new GetterMustExistRule())
        .with(new GetterTester())
        .with(new SetterTester())
        .build();

    pojoValidator.validate(pojoClass);
  }",No Smells
"@Test
  public void shouldTestError() {
    init();
    for (LoggerVarArgsTestData variance : getVarArgsVariations()) {
      log.error(variance.getMessage(), variance.getParams());
      logEvents = LogHelper.getFatalEvents(getMockAppender(), getCategory());

      Affirm.affirmEquals(String.format(""Lost [%s] message?"", ""ERROR""), count + 1, logEvents.size());
      Affirm.affirmEquals(""Error wired?"", 0, LogHelper.getErrorEvents(getMockAppender(), getCategory()).size());
      Affirm.affirmEquals(""Message malformed"", variance.getExpected(), logEvents.get(count).getMessage());

      count++;
    }",Eager Test
"@Test
  public void shouldBeAbleToCreate() {
    Assert.assertNotNull(CollectionRandomGenerator.getInstance());
    Assert.assertEquals(CollectionRandomGenerator.class, CollectionRandomGenerator.getInstance().getClass());
  }",No Smells
"@Test
  public void shouldGenerateCorrectTypeCollectionForRequestedCollection() {
    Collection someObject = randomGenerator.doGenerate(expectedTypeClass);
    Assert.assertNotNull(""Should not be null"", someObject);
    Assert.assertEquals(""Should be a "" + expectedTypeClass.getName(), expectedTypeClass, someObject.getClass());
    Assert.assertTrue(""Should not be Empty"", someObject.size() > 0);
  }",No Smells
"@Test
  public void endToEnd() {
    Collection<?> generatedCollection = RandomFactory.getRandomValue(expectedTypeClass);
    assertCollectionHasExpectedTypes(generatedCollection, SomeRole.class);
  }",No Smells
"@Test
  public void constructorShouldBePrivate() {
    PojoClass randomGeneratorPojo = PojoClassFactory.getPojoClass(randomGenerator.getClass());

    List<PojoMethod> constructors = new ArrayList<PojoMethod>();

    for (PojoMethod constructor : randomGeneratorPojo.getPojoConstructors()) {
      if (!constructor.isSynthetic())
        constructors.add(constructor);
    }",No Smells
"@Test
  public void endToEnd() {
    Collection<?> generatedCollection = RandomFactory.getRandomValue(expectedTypeClass);
    assertCollectionHasExpectedTypes(generatedCollection, SomeRole.class);
  }",No Smells
"@Test
  public void shouldGenerateCorrectTypeCollectionForRequestedCollection() {
    Collection someObject = randomGenerator.doGenerate(expectedTypeClass);
    Assert.assertNotNull(""Should not be null"", someObject);
    Assert.assertEquals(""Should be a "" + expectedTypeClass.getName(), expectedTypeClass, someObject.getClass());
    Assert.assertTrue(""Should not be Empty"", someObject.size() > 0);
  }",No Smells
"@Test
  public void shouldBeAbleToCreate() {
    Assert.assertEquals(RoleUnresolvedListRandomGenerator.class, randomGenerator.getClass());
  }",No Smells
"@Test
  public void shouldGenerateCorrectTypeCollectionForRequestedCollection() {
    Collection someObject = randomGenerator.doGenerate(expectedTypeClass);
    Assert.assertNotNull(""Should not be null"", someObject);
    Assert.assertEquals(""Should be a "" + expectedTypeClass.getName(), expectedTypeClass, someObject.getClass());
    Assert.assertTrue(""Should not be Empty"", someObject.size() > 0);
  }",No Smells
"@Test
  public void constructorShouldBePrivate() {
    final Class<?> randomGeneratorClass = getGeneratorClass();
    PojoClass randomGeneratorPojo = PojoClassFactory.getPojoClass(randomGeneratorClass);

    List<PojoMethod> constructors = new ArrayList<PojoMethod>();

    for (PojoMethod constructor : randomGeneratorPojo.getPojoConstructors()) {
      if (!constructor.isSynthetic())
        constructors.add(constructor);
    }",No Smells
"@Test
  public void shouldOnlyReturnCollectionClassFromGetTypes() {
    Collection<Class<?>> types = getInstance().getTypes();
    Assert.assertNotNull(""Should not be null"", types);
    Assert.assertEquals(""Should only have one type"", 1, types.size());
    Assert.assertEquals(""Should only be "" + getExpectedTypeClass().getName(), getExpectedTypeClass(), types.iterator().next());
  }",No Smells
"@Test
  public void shouldReturnANewInstanceEveryTime() {
    Affirm.affirmFalse(""Same instance returned or faulty equality implementation on proxy"",
        aSimpleInterface.equals(proxyGenerator.doGenerate(ASimpleInterface.class)));
  }",No Smells
"@Test
  public void shouldReturnFalseWithNullEquals() {
    Affirm.affirmFalse(""Should be false"", aSimpleInterface.equals(null));
  }",No Smells
"@Test
  public void testGetTypes() {
    CommonCode.testGetType(objectRandomGenerator, objectClass, EXPECTED_COUNT);
  }",No Smells
"@Test
  public void constructorIsPrivate() {
    PojoClass uriPojoClass = PojoClassFactory.getPojoClass(URIRandomGenerator.class);
    for (PojoMethod constructor : uriPojoClass.getPojoConstructors()) {
      if (!constructor.isSynthetic())
        assertTrue(constructor + "" should be private"", constructor.isPrivate());
    }",No Smells
"@Test
  public void generatedURIIsRandom() {
    URI firstURI = (URI) URIRandomGenerator.getInstance().doGenerate(URI.class);
    assertNotNull(firstURI);
    URI secondURI = (URI) URIRandomGenerator.getInstance().doGenerate(URI.class);

    if (secondURI.equals(firstURI)) // in the 1 in a million chance this is true, try again
      secondURI = (URI) URIRandomGenerator.getInstance().doGenerate(URI.class);

    assertNotEquals(firstURI, secondURI);
  }",No Smells
"@Test
  public void shouldIgnoreTypeParameter() {
    URI generatedURI = (URI) URIRandomGenerator.getInstance().doGenerate(this.getClass());
    assertNotNull(generatedURI);
  }",No Smells
"@Test
  public void end2endTest() {
    URL generatedURL = RandomFactory.getRandomValue(URL.class);
    assertNotNull(generatedURL);
  }",No Smells
"@Test
  public void generatedURLIsRandom() {
    URL firstURL = (URL) URLRandomGenerator.getInstance().doGenerate(URL.class);
    assertNotNull(firstURL);
    URL secondURL = (URL) URLRandomGenerator.getInstance().doGenerate(URL.class);

    if (secondURL.equals(firstURL)) // in the 1 in a million chance this is true, try again
      secondURL = (URL) URLRandomGenerator.getInstance().doGenerate(URL.class);

    assertNotEquals(firstURL, secondURL);
  }",No Smells
"@Test
  public void getTypesReturnsURLTypeOnly() {
    Collection<Class<?>> types = URLRandomGenerator.getInstance().getTypes();

    assertNotNull(types);
    assertEquals(1, types.size());
    assertEquals(URL.class, types.toArray()[0]);
  }",No Smells
"@Test
  public void shouldIgnoreTypeParameter() {
    UUID generatedUUID = (UUID) UUIDRandomGenerator.getInstance().doGenerate(this.getClass());
    assertNotNull(generatedUUID);
  }",No Smells
"@Test
  public void testGetInstance() {
    Assert.assertNotNull(""Null object returned for VoidRandomGenerator.getInstance()"", voidRandomGenerator);
    Assert.assertTrue(String.format(""Incorrect type returned=[%s] for requested type=[%s]"",
            voidRandomGenerator.getClass(), VoidRandomGenerator.class),
        voidRandomGenerator instanceof VoidRandomGenerator);
  }",No Smells
"@Test
  public void endToEnd() {
    Map<?, ?> generatedMap = RandomFactory.getRandomValue(getExpectedTypeClass());
    assertMapHasExpectedTypes(generatedMap, getDefaultType1(), getDefaultType2());
  }",No Smells
"@Test
  public void endToEnd() {
    Map<?, ?> generatedMap = RandomFactory.getRandomValue(getExpectedTypeClass());
    assertMapHasExpectedTypes(generatedMap, getDefaultType1(), getDefaultType2());
  }",No Smells
"@Test
  public void shouldBeAbleToCreate() {
    final RandomGenerator instance = getInstance();
    Assert.assertNotNull(instance);
    Assert.assertEquals(getGeneratorClass(), instance.getClass());
  }",No Smells
"@Test
  public void shouldGenerateCorrectTypeMapForRequestedMap() {
    Map someObject = (Map) getInstance().doGenerate(getExpectedTypeClass());
    Assert.assertNotNull(""Should not be null"", someObject);
    Assert.assertEquals(""Should be a "" + getGeneratedTypeClass().getName(), getGeneratedTypeClass(), someObject.getClass());
    Assert.assertTrue(""Should not be Empty"", someObject.size() > 0);
  }",No Smells
"@Test
  public void generateRandomWithNoRegisteredRandomGenerator() {
    final Class<?> clazz = AClassWithNoRegisteredRandomGenerator.class;

    final Object someInstance = RandomFactory.getRandomValue(clazz);

    Affirm.affirmNotNull(String.format(""Null value returned for random instance of [%s]"", clazz.getName()), someInstance);

    Affirm.affirmFalse(String.format(""Non randomized instance returned (i.e. same object) for [%s]"", clazz.getName()),
        someInstance.equals(RandomFactory.getRandomValue(clazz)));
  }",No Smells
"@Test
  public void shouldPopulateFieldsWithBusinessKeys() {
    AClassWithBusinessKey classWithBusinessKey = RandomFactory.getRandomValue(AClassWithBusinessKey.class);
    Assert.assertThat(classWithBusinessKey.getSomeKey(), notNullValue());
  }",No Smells
"@Test
  public void defaultRandomGeneratorMustNotBeInitialized() {
    Affirm.affirmNull(String.format(""defaultRandomGenerator must be initialized to null for [%s]"",
        defaultRandomGeneratorService), defaultRandomGeneratorService.getDefaultRandomGenerator());
  }",No Smells
"@Test
  public void shouldGetRandomGeneratorBasedOnAssignability() {
    final Class<?> type = LinkedList.class;

    final DummyRandomGenerator dummyRandomGenerator = new DummyRandomGenerator();
    dummyRandomGenerator.setTypes(new Class<?>[] { type }",No Smells
"@Test
  public void shouldReturnNameBasedOnClassName() {
    Affirm.affirmEquals(""Name returned doesn't match class name"", DefaultRandomGeneratorService.class.getName(),
        defaultRandomGeneratorService.getName());
  }",No Smells
"@Test
  public void shouldSetAndGetDefaultRandomGenerator() {
    final RandomGenerator randomGenerator = RandomFactory.getRandomValue(RandomGenerator.class);
    defaultRandomGeneratorService.setDefaultRandomGenerator(randomGenerator);

    Affirm.affirmEquals(""Setter & Getter must match passed in value"", randomGenerator,
        defaultRandomGeneratorService.getDefaultRandomGenerator());
  }",No Smells
"@Test
  public void shouldSkipMethodsStartingWith__covertura_() {
    Affirm.affirmEquals(""Cobertura methods not filtered?"", 3, coberturaCleanedPojoClass.getPojoMethods().size());
  }",No Smells
"@Test
  public void shouldConstructBasedOnDerivedClass() {
    final PojoClass aClassWithInterfaceBasedConstructor = getPojoClass(ClassWithInterfaceBasedConstructor.class);
    Assert.assertNotNull(InstanceFactory.getInstance(aClassWithInterfaceBasedConstructor, ""SomeString""));
  }",No Smells
"@Test
  public void shouldCreateUsingSingleParameterConstructor() {
    final Class<?> clazz = ClassWithVariousDeclaredContructorsAndMethods.class;
    final String stringParam = RandomFactory.getRandomValue(String.class);
    final ClassWithVariousDeclaredContructorsAndMethods obj1 =
        (ClassWithVariousDeclaredContructorsAndMethods) getInstance(clazz, stringParam);
    Affirm.affirmNotNull(""Should have created using String constructor"", obj1);
    Affirm.affirmEquals(""Incorrect constructor used"", stringParam, obj1.singleStringConstructor);
  }",No Smells
"@Test
  public void shouldInitializeBusinessKeys() {
    final PojoClass pojoClass = getPojoClass(AClassWithOneBusinessKey.class);
    AClassWithOneBusinessKey classWithOneBusinessKey = (AClassWithOneBusinessKey) InstanceFactory.getInstance(pojoClass);
    assertThat(classWithOneBusinessKey.getName(), notNullValue());
  }",No Smells
"@Test
  public void shouldSetPrimitiveBusinessKeys() {
    final PojoClass pojoClass = getPojoClass(AClassWithPrimitiveBusinessKey.class);
    AClassWithPrimitiveBusinessKey instance = (AClassWithPrimitiveBusinessKey) InstanceFactory.getLeastCompleteInstance(pojoClass);
    if (instance.getSomeInt() == 0) // Random chance - try again
      instance = (AClassWithPrimitiveBusinessKey) InstanceFactory.getLeastCompleteInstance(pojoClass);
    assertThat(""Primitive value unchanged for BusinessKey"", instance.getSomeInt(), not(0));

  }",No Smells
"@Test
  public void shouldSkipSyntheticConstructor() {
    final PojoClass classWithStaticConstructorPojo = getPojoClass(ClassWithSyntheticConstructor.class);
    Assert.assertNotNull(InstanceFactory.getMostCompleteInstance(classWithStaticConstructorPojo));
  }",No Smells
"@Test
  public void coverageClassNameIs__com_cenqua_cloverTestNameSniffer() {
    Assert.assertEquals(""com_cenqua_clover.TestNameSniffer"", Clover3.getInstance().getCoverageClassName());
  }",No Smells
"@Test
  public void shouldHaveCloverPojoClassAdapter() {
    Assert.assertEquals(CloverPojoClassAdapter.class, Clover4.getInstance().getPojoClassAdapter().getClass());
  }",No Smells
"@Test
  public void shouldHaveCoberturaPojoClassAdapter() {
    Assert.assertEquals(CoberturaPojoClassAdapter.class, Cobertura.getInstance().getPojoClassAdapter().getClass());
  }",No Smells
"@Test
  public void coverageClassNameIs__orgDOTjacocoDOTagentDOTrtDOTIAgent() {
    Assert.assertEquals(""org.jacoco.agent.rt.IAgent"", Jacoco.getInstance().getCoverageClassName());
  }",No Smells
"@Test
  public void addingArrayWithNullFilters_ignored() {
    PojoClassFilter dummyFilter = new DummyPojoClassFilter();
    FilterChain filter = new FilterChain(dummyFilter, null);
    Assert.assertEquals(1, filter.size());
    Assert.assertTrue(filter.getPojoClassFilters().contains(dummyFilter));
  }",No Smells
"@Test
  public void shouldFilterBasedOnPackageName() {

    // Include classNames that have the word Test in the name.
    final PojoClassFilter filter = new FilterClassName(""^(?:.*\\.)?model(\\..*)+"");

    String[] classNames = new String[] { ""com.model.MyClass"", ""model.pojos.MyClass"", ""com.model.pojos.MyClass"" }",No Smells
"@Test
  public void shouldExcludeSyntheticPojos() {
    PojoClass notSynthetic = PojoStubFactory.getStubPojoClass(true);
    Assert.assertFalse(new FilterSyntheticClasses().include(notSynthetic));
  }",No Smells
"@Test
  public void isPackagePrivateClass() {
    PojoClass pojoclass = getClass(SAMPLE_CLASSES_PKG + "".AccessibilityClass$PackagePrivateClass"");
    Affirm.affirmNotNull(""class not found"", pojoclass);

    Affirm.affirmTrue(""isPackagePrivate() check on class=["" + pojoclass + ""] returned false!!"", pojoclass.isPackagePrivate());
    Affirm.affirmFalse(""isPrivate() check on class=["" + pojoclass + ""] returned true!!"", pojoclass.isPrivate());
    Affirm.affirmFalse(""isProtected() check on class=["" + pojoclass + ""] returned true!!"", pojoclass.isProtected());
    Affirm.affirmFalse(""isPublic() check on class=["" + pojoclass + ""] returned true!!"", pojoclass.isPublic());  }",No Smells
"@Test
  public void shouldCreateInstanceOnAbstract() {
    final PojoClass pojoClass = getPojoClassImplForClass(AnAbstractClass.class);
    Affirm.affirmNotNull(""Should have created instance"", InstanceFactory.getInstance(pojoClass));
  }",No Smells
"@Test
  public void shouldCreateInstanceUsingDeclaredPrivateConstructor() {
    final PojoClass pojoClass = getPojoClassImplForClass(OnePrivateNoParamsConstructor.class);
    final Object instance = InstanceFactory.getInstance(pojoClass);
    Affirm.affirmNotNull(String.format(""Failed to create a new instance using privately declared constructor for "" +
        ""class=[%s]"", pojoClass), instance);
  }",No Smells
"@Test
  public void shouldCreateInstanceUsingDeclaredPublicConstructor() {
    final PojoClass pojoClass = getPojoClassImplForClass(OnePublicNoParamConstructor.class);
    final Object instance = InstanceFactory.getInstance(pojoClass);
    Affirm.affirmNotNull(String.format(""Failed to create a new instance using publicly declared constructor for "" +
        ""class=[%s]"", pojoClass), instance);
  }",No Smells
"@Test
  public void testGetPojoMethodsAnnotatedWith() {
    PojoClass pojoClass = getPojoClassImplForClass(AClassWithAnnotatedMethods.class);
    Affirm.affirmEquals(""Expected 5 methods"", 4 + 1 /* constructor */, pojoClass.getPojoMethods().size());

    List<PojoMethod> annotatedPojoFields = pojoClass.getPojoMethodsAnnotatedWith(SomeAnnotation.class);
    Affirm.affirmEquals(""Expected 2 annotated methods"", 2, annotatedPojoFields.size());

  }",No Smells
"@Test
  public void testIsFinalOnNonFinalClass() {
    final Class<?> aNonFinalClass = ANonFinalClass.class;
    final PojoClass pojoClass = getPojoClassImplForClass(aNonFinalClass);
    Affirm.affirmFalse(String.format(""IsFinal on non-final=[%s] returned true for PojoClass implementation=[%s]!!"",
        aNonFinalClass, pojoClass), pojoClass.isFinal());
  }",No Smells
"@Test
  public void testIsStatic() {
    PojoClass pojoClass = getPojoClassImplForClass(AClassWithTwoChildClassesOneStaticAndOneNot.APublicNonStaticClass.class);
    Affirm.affirmTrue(""Nested class not detected nested"", pojoClass.isNestedClass());
    Affirm.affirmFalse(""Nested non-static nested class detected as static"", pojoClass.isStatic());

    pojoClass = getPojoClassImplForClass(AClassWithTwoChildClassesOneStaticAndOneNot.AStaticClass.class);
    Affirm.affirmTrue(""Nested class not detected nested"", pojoClass.isNestedClass());
    Affirm.affirmTrue(""Nested static class not seen as static"", pojoClass.isStatic());
  }",No Smells
"@Test
  public void canGetEnclosingClass() {
    PojoClass pojoClassWithFields = PojoClassFactory.getPojoClass(AClassWithFields.class);
    Affirm.affirmTrue(""Class should have some fields"", pojoClassWithFields.getPojoFields().size() > 0);
    for (PojoField field : pojoClassWithFields.getPojoFields()) {
      Affirm.affirmEquals(""Failed to get PojoClass from field [""+ field + ""]"", pojoClassWithFields, field.getDeclaringPojoClass());
    }",No Smells
"@Test
  public void testIsPrivate() {
    String prefix = ""private"";
    PojoField pojoField = getFieldStartingWith(prefix);
    Affirm.affirmNotNull(""Field not found ["" + prefix + ""]"", pojoField);
    Affirm.affirmTrue(""isPrivate() check on field=["" + pojoField + ""] returned false!!"", pojoField.isPrivate());
    Affirm.affirmFalse(""isPublic() check on field=["" + pojoField + ""] returned true!!"", pojoField.isPublic());
    Affirm.affirmFalse(""isProtected() check on field=["" + pojoField + ""] returned true!!"", pojoField.isProtected());
    Affirm.affirmFalse(""isPackagePrivate() check on field=["" + pojoField + ""] returned true!!"", pojoField.isPackagePrivate());
  }",No Smells
"@Test
  public void testIsPrivate() {
    String prefix = ""private"";
    PojoField pojoField = getFieldStartingWith(prefix);
    Affirm.affirmNotNull(""Field not found ["" + prefix + ""]"", pojoField);
    Affirm.affirmTrue(""isPrivate() check on field=["" + pojoField + ""] returned false!!"", pojoField.isPrivate());
    Affirm.affirmFalse(""isPublic() check on field=["" + pojoField + ""] returned true!!"", pojoField.isPublic());
    Affirm.affirmFalse(""isProtected() check on field=["" + pojoField + ""] returned true!!"", pojoField.isProtected());
    Affirm.affirmFalse(""isPackagePrivate() check on field=["" + pojoField + ""] returned true!!"", pojoField.isPackagePrivate());
  }",No Smells
"@Test
  public void testIsProtected() {
    String prefix = ""protected"";
    PojoField pojoField = getFieldStartingWith(prefix);
    Affirm.affirmNotNull(""Field not found ["" + prefix + ""]"", pojoField);
    Affirm.affirmTrue(""isProtected() check on field=["" + pojoField + ""] returned false!!"", pojoField.isProtected());
    Affirm.affirmFalse(""isPrivate() check on field=["" + pojoField + ""] returned true!!"", pojoField.isPrivate());
    Affirm.affirmFalse(""isPackagePrivate() check on field=["" + pojoField + ""] returned true!!"", pojoField.isPackagePrivate());
    Affirm.affirmFalse(""isPublic() check on field=["" + pojoField + ""] returned true!!"", pojoField.isPublic());
  }",No Smells
"@Test
  public void testIsPublic() {
    String prefix = ""public"";
    PojoField pojoField = getFieldStartingWith(prefix);
    Affirm.affirmNotNull(""Field not found ["" + prefix + ""]"", pojoField);
    Affirm.affirmTrue(""isPublic() check on field=["" + pojoField + ""] returned false!!"", pojoField.isPublic());
    Affirm.affirmFalse(""isPrivate() check on field=["" + pojoField + ""] returned true!!"", pojoField.isPrivate());
    Affirm.affirmFalse(""isPackagePrivate() check on field=["" + pojoField + ""] returned true!!"", pojoField.isPackagePrivate());
    Affirm.affirmFalse(""isProtected() check on field=["" + pojoField + ""] returned true!!"", pojoField.isProtected());
  }",No Smells
"@Test
  public void testIsTransient() {
    for (PojoField pojoField : pojoClass.getPojoFields()) {
      if (pojoField.getName().equals(""transientString"")) {
        Affirm.affirmTrue(String.format(""isTransient() check on field=[%s] returned false!!"", pojoField), pojoField.isTransient
            ());
      }",No Smells
"@Test
  public void classWithPrivateConstructorAndBuilder_hasSyntheticConstrutor() {
    Assert.assertNotNull(ClassWithSyntheticConstructor.Builder.getInstance());
    PojoClass pojoClass = PojoClassFactory.getPojoClass(ClassWithSyntheticConstructor.class);
    Assert.assertEquals(2, pojoClass.getPojoConstructors().size());
    for (PojoMethod constructor : pojoClass.getPojoMethods()) {
      if (constructor.getParameterTypes().length == 0)
        Assert.assertFalse(""Synthatic constructor found!! ["" + constructor + ""]"", constructor.isSynthetic());
      else
        Assert.assertTrue(""None synthatic constructor found!! ["" + constructor + ""]"", constructor.isSynthetic());
    }",No Smells
"@Test
  public void testIsFinal() {
    for (PojoMethod pojoMethod : pojoMethods) {
      if (pojoMethod.getName().equals(""finalMethod"")) {
        Affirm.affirmTrue(""Failed to check final"", pojoMethod.isFinal());
        return;
      }",No Smells
"@Test
  public void testIsNotStatic() {
    for (PojoMethod pojoMethod : pojoMethods) {
      if (pojoMethod.getName().equals(""nonStaticMethod"")) {
        Affirm.affirmTrue(""Failed to check non static method"", !pojoMethod.isStatic());
        return;
      }",No Smells
"@Test
  public void testIsProtected() {
    String prefix = ""protectedMethod"";
    PojoMethod pojoMethod = getPojoMethodStartingWith(prefix);

    Affirm.affirmNotNull(""method not found ["" + prefix + ""]"", pojoMethod);
    Affirm.affirmTrue(""isProtected() check on method=["" + pojoMethod + ""] returned false!!"", pojoMethod.isProtected());
    Affirm.affirmFalse(""isPrivate() check on method=["" + pojoMethod + ""] returned true!!"", pojoMethod.isPrivate());
    Affirm.affirmFalse(""isPackagePrivate() check on method=["" + pojoMethod + ""] returned true!!"", pojoMethod.isPackagePrivate());
    Affirm.affirmFalse(""isPublic() check on method=["" + pojoMethod + ""] returned true!!"", pojoMethod.isPublic());
  }",No Smells
"@Test
  public void testIsStatic() {
    for (PojoMethod pojoMethod : pojoMethods) {
      if (pojoMethod.getName().equals(""staticMethod"")) {
        Affirm.affirmTrue(""Failed to check static method"", pojoMethod.isStatic());
        return;
      }",No Smells
"@Test
  public void shouldReturnNullAnnotationNoPackageInfo() {
    final PojoPackage pojoPackage = PojoPackageFactory.getPojoPackage(this.getClass().getPackage().getName()
        + "".packagenopackageinfo"");
    Affirm.affirmNull(String.format(""package-info added to package [%s]?"", pojoPackage),
        pojoPackage.getAnnotation(SomeAnnotation.class));
  }",No Smells
"@Test
  public void canGetAllClassNamesInBootClassPath() {
    Set<String> classNames = javaClassPathClassLoader.getClassNames();
    Assert.assertThat(classNames, notNullValue());
    Assert.assertThat(classNames.size(), greaterThan(minExpectedTotalClasses));
  }",No Smells
"@Test
  public void canGetInstance() {
    JavaClassPathClassLoader instance = JavaClassPathClassLoader.getInstance();
    Assert.assertThat(instance, notNullValue());
  }",No Smells
"@Test
  public void end2end_shouldLoadAllClassesInJavaLang() {
    List<PojoClass> types = PojoClassFactory.getPojoClassesRecursively(""java.lang"", null);
    checkListOfPojoClassesContains(types, java.lang.Class.class);
    checkListOfPojoClassesContains(types, java.lang.CharSequence.class);
    checkListOfPojoClassesContains(types, java.lang.Runnable.class);
    checkListOfPojoClassesContains(types, java.lang.Throwable.class);
    checkListOfPojoClassesContains(types, java.lang.Double.class);
    checkListOfPojoClassesContains(types, java.lang.Float.class);
    checkListOfPojoClassesContains(types, java.lang.Object.class);
    checkListOfPojoClassesContains(types, java.lang.Error.class);

    Assert.assertThat(types.size(), greaterThan(minJavaLangClasses));
  }",No Smells
"@Test
  public void invalidURLShouldThrowException() throws MalformedURLException {
    URLToFileSystemAdapter urlToFileSystemAdapter = new URLToFileSystemAdapter(new URL(""file://Not A Parse-able URI""));
    try {
      urlToFileSystemAdapter.getAsURI();
      Assert.fail(""Invalid URL should've failed to transfer to URI"");
    }",No Smells
"@Test
  public void shouldNotFailForEmptyPaths() throws MalformedURLException {
    URL url = new URL(""file://"" + file.getAbsolutePath());
    FileSystemReader fileSystemReader = FileSystemReader.getInstance(url);
    assertThat(fileSystemReader, notNullValue());
    assertThat(fileSystemReader.getSubPackagesOfPackage("""").size(), is(0));
    assertThat(fileSystemReader.getTypesInPackage("""").size(), is(0));
  }",Mystery Guest + Resource Optimism
"@Test
  public void throwsProperException() throws MalformedURLException {
    String anyUrl = anyUrl();
    try {
      FileSystemReader.getInstance(new URL(anyUrl));
      fail(""Expected exception not thrown!"");
    }",Mystery Guest + Resource Optimism
"@Test
  public void shouldHavePrivateConstructor() {
    PojoClass pojoClass = PojoClassFactory.getPojoClass(Primitives.class);
    Affirm.affirmEquals(""Should only have one constructor"", 1, pojoClass.getPojoConstructors().size());
    Affirm.affirmTrue(""Constructor must be private"", pojoClass.getPojoConstructors().get(0).isPrivate());
  }",No Smells
"@Test
  public void v4_2_1ShouldBeLessThan4_2_1_1() {
    Version left = getVersion(""4.2.1"");
    Version right = getVersion(""4.2.1.1"");
    assertThat(left.compareTo(right), is(-1));
    assertThat(right.compareTo(left), is(1));
  }",No Smells
"@Test
  public void v4ShouldBeLessThanV5() {
    Version left = getVersion(""4"");
    Version right = getVersion(""5"");
    assertThat(left.compareTo(right), is(-1));
    assertThat(right.compareTo(left), is(1));
  }",No Smells
"@Test
  public void shouldReturnMajorWhenOnlyMajorPresent() {
    Integer major = 5;

    final List<Integer> versionParts = getVersionParts("""" + major);
    assertThat(versionParts.size(), is(1));
    assertThat(versionParts.get(0), is(major));
  }",No Smells
"@Test
  public void testAffirmContains() {
    List<String> myList = new LinkedList<String>();
    myList.add(""This"");
    myList.add(""is"");
    myList.add(""mylist"");
    Affirm.affirmContains(""should find the word 'is' in my list"", ""is"", myList);

    try {
      Affirm.affirmContains(""should not find the word 'WHAT' in my list"", ""WHAT"", myList);
    }",No Smells
"@Test
  public void testAffirmFalse() {
    Affirm.affirmFalse(""Affirm.affirmFalse on false failed!!"", false);
    try {
      Affirm.affirmFalse(""Affirm.affirmTrue on true passed!!"", true);
    }",No Smells
"@Test
  public void testAffirmSame() {
    Object o = new Object();
    Affirm.affirmSame(""Affirm.affirmSame on same objects failed"", o, o);
    try {
      Affirm.affirmSame(""Affirm.affirmSame on non-same objects should have failed"", new Object(), new Object());
    }",No Smells
"@Test
  public void testFailWithNullMessage() {
    try {
      Affirm.fail(null);
    }",No Smells
"@Test
  public void abstractClassTestingEndToEnd() {
    pojoValidator = ValidatorBuilder.create()
        .with(new GetterTester())
        .with(new SetterTester())
        .build();

    pojoValidator.validate(PojoClassFactory.getPojoClass(AnAbstractClassWithGetterSetter.class));
  }",No Smells
"@Test
  public void shouldInvokeRuleOnAbstract() {
    MethodValueReturn methodValueReturn = new MethodValueReturn();
    methodValueReturn.isAbstract = true;
    RuleTesterMock ruleTesterMock = new RuleTesterMock();

    pojoValidator = ValidatorBuilder.create()
        .with((Tester) ruleTesterMock)
        .build();

    pojoValidator.validate(PojoStubFactory.getStubPojoClass(methodValueReturn));
    Assert.assertTrue(""Tester not called"", ruleTesterMock.runCalled);
  }",No Smells
"@Test
  public void shouldFailOnlyEqualsIsImplemented() {
    PojoClass aClassImplementingEqualsOnly = PojoClassFactory.getPojoClass(AClassImplementingEqualsOnly.class);
    List<PojoMethod> methods = aClassImplementingEqualsOnly.getPojoMethods();

    Assert.assertEquals(2, methods.size());
    boolean constructorFound = false;
    boolean equalsFound = false;

    for (PojoMethod method : methods) {
      if (method.isConstructor())
        constructorFound = true;
      if (method.getName().equals(""equals"")
          && method.getPojoParameters().size() == 1
          && method.getReturnType().equals(boolean.class))
        equalsFound = true;
    }",Eager Test
"@Test
  public void shouldPassWhenEqualsAndHashCodeAreImplemented() {
    PojoClass aClassImplementingEqualsAndHashcode = PojoClassFactory.getPojoClass(AClassImplementingEqualsAndHashCode.class);
    List<PojoMethod> methods = aClassImplementingEqualsAndHashcode.getPojoMethods();

    Assert.assertEquals(3, methods.size());

    boolean constructorFound = false;
    boolean equalsFound = false;
    boolean hashCodeFound = false;

    for (PojoMethod method : methods) {
      if (method.isConstructor())
        constructorFound = true;
      if (method.getName().equals(""hashCode"")
          && method.getPojoParameters().size() == 0
          && method.getReturnType().equals(int.class))
        hashCodeFound = true;
      if (method.getName().equals(""equals"")
          && method.getPojoParameters().size() == 1
          && method.getReturnType().equals(boolean.class))
        equalsFound = true;
    }",Eager Test
"@Test
  public void aChildWithFieldShadowingShouldFail() {
    PojoClass aChildWithFieldShadowing = PojoClassFactory.getPojoClass(NoShadowAChildWithFieldShadowing.class);
    try {
      validator.validate(aChildWithFieldShadowing);
      Assert.fail(""Expected [NoShadowAChildWithFieldShadowing.class] to fail NoFieldShadowRule but didn't"");
    }",No Smells
"@Test
  public void ensureAChildWithFieldShadowingIsAccurateWW() {
    PojoClass aChildWithFieldShadowing = PojoClassFactory.getPojoClass(NoShadowAChildWithFieldShadowing.class);
    List<PojoField> pojoFields = aChildWithFieldShadowing.getPojoFields();
    Assert.assertThat(pojoFields.size(), is(1));
    Assert.assertThat(pojoFields.get(0).getName(), is(""aField""));
  }",No Smells
"@Test
  public void preConfiguredShadowFieldsSkipped() {
    PojoClass aChildWithFieldShadowing = PojoClassFactory.getPojoClass(NoShadowAChildWithFieldShadowing.class);
    validator = ValidatorBuilder
        .create()
        .with(new NoFieldShadowingRule(""aField""))
        .build();
    validator.validate(aChildWithFieldShadowing);
  }",No Smells
"@Test
  public void shouldNotAddserialVersionUIDFromChildOfSerializableWithoutInterfaceToShadowFieldList() {
    validator.validate(PojoClassFactory.getPojoClass(NoShadowChildOfSerializable.class));
  }",No Smells
"@Test
  public void testEvaluate() {
    CommonCode.shouldPassRuleValidation(rule, passClasses);
    CommonCode.shouldFailRuleValidation(rule, failClasses);
  }",No Smells
"@Test
  public void testEvaluate() {
    CommonCode.shouldPassRuleValidation(rule, passClasses);
    CommonCode.shouldFailRuleValidation(rule, failClasses);
  }",No Smells
"@Test
  public void testEvaluate() {
    CommonCode.shouldPassRuleValidation(rule, passClasses);
    CommonCode.shouldFailRuleValidation(rule, failClasses);
  }",No Smells
"@Test
  public void testEvaluate() {
    CommonCode.shouldPassRuleValidation(rule, passClasses);
    CommonCode.shouldFailRuleValidation(rule, failClasses);
  }",No Smells
"@Test
  public void testEvaluate() {
    CommonCode.shouldPassRuleValidation(rule, passClasses);
    CommonCode.shouldFailRuleValidation(rule, failClasses);
  }",No Smells
"@Test
  public void shouldNotFailIfNull() {
    CloseableHelper.closeResources((Closeable[]) null);
  }",No Smells
"@Test
  public void shouldReturnErrorMessageWhenToStringThrowsErrors() {
    assertThat(safeToString(this), is(""Error calling toString: 'java.lang.RuntimeException: "" + anyRandomMessage() + ""'""));
  }",No Smells
"@Test
  public void testIsStaticFinal() {
    PojoClass pojoClass = PojoClassFactory.getPojoClass(StaticFinalData.class);
    List<PojoField> pojoFields = pojoClass.getPojoFields();
    Assert.assertEquals(4, pojoFields.size());
    for (PojoField fieldEntry : pojoFields) {
      if (fieldEntry.getName().equals(""staticAndNotFinal"")) {
        Assert.assertTrue(""Static and not Final test failed!!"",
            fieldEntry.isStatic()
                && !fieldEntry.isFinal()
                && !ValidationHelper.isStaticFinal(fieldEntry));
      }",Eager Test
"@Test
  public void createReturnsValidatorBuilder() {
    Object validatorBuilder = ValidatorBuilder.create();
    Assert.assertNotNull(validatorBuilder);
    Assert.assertTrue(ValidatorBuilder.class.isAssignableFrom(validatorBuilder.getClass()));
  }",No Smells
"@Test
  public void withRules_ignoresNullArrayEntries() {
    ValidatorBuilder validatorBuilder = ValidatorBuilder.create().with(new Rule[] { null, null }",No Smells
"@Test
  public void withRules_persistRules() {
    Rule anyRule = RandomFactory.getRandomValue(Rule.class);
    ValidatorBuilder validatorBuilder = ValidatorBuilder.create().with(anyRule, null);
    Assert.assertEquals(1, validatorBuilder.getRules().size());
  }",No Smells
"@Test
    public void testEarlyInitializable() throws Exception {
        assertTrue(""should being initialized already"", EarlyInitializableBean.initializedEarly);

        EarlyInitializableCheck earlyInitializableCheck = new EarlyInitializableCheck();
        c.inject(earlyInitializableCheck);
        assertEquals(""initialized early"", ((EarlyInitializableBean) earlyInitializableCheck.getEarlyInitializable()).getMessage());
        assertEquals(""initialized early"", ((EarlyInitializableBean) earlyInitializableCheck.getPrototypeEarlyInitializable()).getMessage());

        EarlyInitializableCheck earlyInitializableCheck2 = new EarlyInitializableCheck();
        c.inject(earlyInitializableCheck2);
        assertEquals(""singletons should not being initialized twice"", ""initialized early"",
                ((EarlyInitializableBean) earlyInitializableCheck2.getEarlyInitializable()).getMessage());
        assertEquals(""initialized early"", ((EarlyInitializableBean) earlyInitializableCheck2.getPrototypeEarlyInitializable()).getMessage());

        assertEquals(""singletons should being instantiated once"",
                earlyInitializableCheck.getEarlyInitializable(), earlyInitializableCheck2.getEarlyInitializable());
        assertNotSame(""prototypes should being instantiated for each injection"",
                earlyInitializableCheck.getPrototypeEarlyInitializable(), earlyInitializableCheck2.getPrototypeEarlyInitializable());
    }",No Smells
"@Test
    public void testInitializable() throws Exception {
        assertFalse(""should not being initialized already"", InitializableBean.initialized);

        InitializableCheck initializableCheck = new InitializableCheck();
        c.inject(initializableCheck);
        assertTrue(""should being initialized here"", InitializableBean.initialized);
        assertEquals(""initialized"", ((InitializableBean) initializableCheck.getInitializable()).getMessage());
        assertEquals(""initialized"", ((InitializableBean) initializableCheck.getPrototypeInitializable()).getMessage());

        InitializableCheck initializableCheck2 = new InitializableCheck();
        c.inject(initializableCheck2);
        assertEquals(""singletons should not being initialized twice"", ""initialized"",
                ((InitializableBean) initializableCheck2.getInitializable()).getMessage());
        assertEquals(""initialized"", ((InitializableBean) initializableCheck2.getPrototypeInitializable()).getMessage());
        assertEquals(""threads should not being initialized twice"", ""initialized"",
                ((InitializableBean) initializableCheck2.getThreadInitializable()).getMessage());

        assertEquals(""singletons should being instantiated once"",
                initializableCheck.getInitializable(), initializableCheck2.getInitializable());
        assertNotSame(""prototypes should being instantiated for each injection"",
                initializableCheck.getPrototypeInitializable(), initializableCheck2.getPrototypeInitializable());
        assertEquals(""threads should being instantiated once for each thread"",
                initializableCheck.getThreadInitializable(), initializableCheck2.getThreadInitializable());

        final InitializableCheck initializableCheck3 = new InitializableCheck();
        final TestScopeStrategy testScopeStrategy = new TestScopeStrategy();
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                ContainerBuilder cb2 = new ContainerBuilder();
                cb2.factory(EarlyInitializable.class, EarlyInitializableBean.class, Scope.SINGLETON);
                cb2.factory(Initializable.class, InitializableBean.class, Scope.SINGLETON);
                cb2.factory(EarlyInitializable.class, ""prototypeEarlyInitializable"", EarlyInitializableBean.class, Scope.PROTOTYPE);
                cb2.factory(Initializable.class, ""prototypeInitializable"", InitializableBean.class, Scope.PROTOTYPE);
                cb2.factory(Initializable.class, ""requestInitializable"", InitializableBean.class, Scope.REQUEST);
                cb2.factory(Initializable.class, ""sessionInitializable"", InitializableBean.class, Scope.SESSION);
                cb2.factory(Initializable.class, ""threadInitializable"", InitializableBean.class, Scope.THREAD);
                cb2.factory(Initializable.class, ""wizardInitializable"", InitializableBean.class, Scope.WIZARD);
                Container c2 = cb2.create(false);
                c2.setScopeStrategy(testScopeStrategy);
                c2.inject(initializableCheck3);
            }",No Smells
"@Test
    public void testMiddleOfInheritanceExclusion1() throws Exception {
        // given
        String propertyName = ""fooLogic"";
        Member member = FooBar.class.getMethod(propertyName);

        sma.useExcludedClasses(BarInterface.class.getName());

        // when
        boolean accessible = sma.isAccessible(context, target, member, propertyName);

        // then
        assertTrue(""fooLogic() from FooInterface isn't accessible!!!"", accessible);
    }",Redundent Print
"@Test
    public void testPackageNameExclusion() throws Exception {
        // given
        sma.useExcludedPackageNames(FooBar.class.getPackage().getName());

        String propertyName = ""stringField"";
        Member member = FooBar.class.getMethod(formGetterName(propertyName));

        // when
        boolean actual = sma.isAccessible(context, target, member, propertyName);

        // then
        assertFalse(""stringField is accessible!"", actual);
    }",No Smells
"@Test
    public void testCompile() {
        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();

        assertNull(matcher.compilePattern(null));
        assertNull(matcher.compilePattern(""""));

        CompiledPattern pattern = matcher.compilePattern(""action.{format}",Eager Test
"@Test
    public void testCollectionObject() throws Exception {
        // given
        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);
        rfv.setValueStack(ActionContext.getContext().getValueStack());
        rfv.setFieldName(""shorts"");
        rfv.setDefaultMessage(""${fieldName}",No Smells
"@Test
  public void invalidArgument() {
    assertThat(isValidArg(""abcdefg""), is(false));
  }",No Smells
"@Test
  public void verifyCloseDoesNotStopJobs() throws Exception {
    startAgent();

    start(FOO_JOB);
    sut.stopAsync().awaitTerminated();
    verify(fooSupervisor).close();
    verify(fooSupervisor).join();
    verify(fooSupervisor, never()).setGoal(STOP);
  }",No Smells
"@Test
  public void verifyReactorIsUpdatedWhenListenerIsCalled() throws Exception {
    startAgent();
    listener.tasksChanged(model);
    verify(reactor, times(2)).signal();
  }",No Smells
"@Test
  public void alreadyRegistered_SameHostId() throws Exception {
    final boolean success = registrar.tryToRegister(client);
    assertTrue(success);

    // no need to re-write the id path
    verify(client, never()).createAndSetData(idPath, hostId.getBytes());
  }",No Smells
"@Test
  public void testTimeouts() throws Exception {
    when(metrics.getDockerTimeoutRates()).thenReturn(BAD_RATE); // start out as many timeouts
    when(metrics.getContainersThrewExceptionRates()).thenReturn(ZERO_RATE);
    when(metrics.getSupervisorRunRates()).thenReturn(RUN_RATE);

    checker.start();
    assertFalse(checker.check().isHealthy());

    when(metrics.getDockerTimeoutRates()).thenReturn(BETWEEN_RATE);
    Thread.sleep(2);
    assertFalse(checker.check().isHealthy());

    when(metrics.getDockerTimeoutRates()).thenReturn(OK_RATE);
    assertTrue(checker.check().isHealthy());
  }",No Smells
"@Test
  public void testEnterAndExitFlapping() throws Exception {
    final FlapController controller = FlapController.newBuilder()
        .setClock(clock)
        .setRestartCount(2)
        .setTimeRangeMillis(1000)
        .build();

    assertFalse(controller.isFlapping());
    when(clock.now()).thenReturn(new Instant(0));

    controller.started();
    when(clock.now()).thenReturn(new Instant(1));
    controller.exited(); // 1 second of runtime T=1
    assertFalse(controller.isFlapping());

    controller.started();
    when(clock.now()).thenReturn(new Instant(2));
    controller.exited(); // total of 2ms of runtime T=2
    assertTrue(controller.isFlapping()); // next time job would start would be at t=7 seconds

    controller.started();
    when(clock.now()).thenReturn(new Instant(8));
    controller.exited(); // total of 3ms of runtime T=8 (5 of that is throttle)
    assertTrue(controller.isFlapping()); // next time job would start would be at t=13

    controller.started();
    when(clock.now()).thenReturn(new Instant(1034));
    controller.exited(); // ran 1021ms additionally here, so should disengage flapping T=1034
    assertFalse(controller.isFlapping());
  }",No Smells
"@Test
  public void verifyDockerExceptionSetsTaskStatusToFailed() throws Exception {
    verifyExceptionSetsTaskStatusToFailed(new DockerException(""FAIL""));
  }",No Smells
"@Test
  public void verifyDockerExceptionSetsTaskStatusToFailed() throws Exception {
    verifyExceptionSetsTaskStatusToFailed(new DockerException(""FAIL""));
  }",No Smells
"@Test
  public void verifySupervisorStopsDockerContainerWithConfiguredKillTime() throws Exception {
    final String containerId = ""deadbeef"";

    final Job longKillTimeJob = Job.newBuilder()
        .setName(NAME)
        .setCommand(COMMAND)
        .setImage(IMAGE)
        .setVersion(VERSION)
        .setSecondsToWaitBeforeKill(30)
        .build();

    mockTaskStatus(longKillTimeJob.getId());

    final Supervisor longKillTimeSupervisor = createSupervisor(longKillTimeJob);

    when(docker.createContainer(any(ContainerConfig.class), any(String.class)))
        .thenReturn(ContainerCreation.builder().id(containerId).build());

    final ImageInfo imageInfo = mock(ImageInfo.class);
    when(docker.inspectImage(IMAGE)).thenReturn(imageInfo);

    // Have waitContainer wait forever.
    final SettableFuture<ContainerExit> waitFuture = SettableFuture.create();
    when(docker.waitContainer(containerId)).thenAnswer(futureAnswer(waitFuture));

    // Start the job (so that a runner exists)
    longKillTimeSupervisor.setGoal(START);
    when(docker.inspectContainer(eq(containerId))).thenReturn(runningResponse);

    // This is already verified above, but it works as a hack to wait for the model/docker state
    // to converge in such a way that a setGoal(STOP) will work. :|
    verify(docker, timeout(30000)).waitContainer(containerId);

    // Stop the job
    longKillTimeSupervisor.setGoal(STOP);
    verify(docker, timeout(30000)).stopContainer(
        eq(containerId), eq(longKillTimeJob.getSecondsToWaitBeforeKill()));

    // Change docker container state to stopped now that it was killed
    when(docker.inspectContainer(eq(containerId))).thenReturn(stoppedResponse);
  }",No Smells
"@Test
  public void testRegistrationWithHttpHealthCheck() throws Exception {
    final String path = ""/health"";

    final Job job = JOB.toBuilder()
        .setHealthCheck(HealthCheck.newHttpHealthCheck()
            .setPath(path)
            .setPort(PORT_NAME).build())
        .build();

    final TaskConfig taskConfig = TaskConfig.builder()
        .namespace(""test"")
        .host(HOST)
        .job(job)
        .build();

    final ServiceRegistration.Endpoint endpoint = taskConfig.registration().getEndpoints().get(0);
    assertEquals(path, endpoint.getHealthCheck().getPath());
    assertEquals(EndpointHealthCheck.HTTP, endpoint.getHealthCheck().getType());
    assertEquals(EXTERNAL_PORT, endpoint.getPort());
  }",No Smells
"@Test
  public void testSimpleWorkage() throws Exception {
    writer.saveHistoryItem(TASK_STATUS, TIMESTAMP);

    final TaskStatusEvent historyItem = Iterables.getOnlyElement(awaitHistoryItems());
    assertEquals(JOB_ID, historyItem.getStatus().getJob().getId());
  }",No Smells
"@Test
  public void testWriteWithZooKeeperDown() throws Exception {
    zk.stop();
    writer.saveHistoryItem(TASK_STATUS, TIMESTAMP);
    zk.start();
    final TaskStatusEvent historyItem = Iterables.getOnlyElement(awaitHistoryItems());
    assertEquals(JOB_ID, historyItem.getStatus().getJob().getId());
  }",No Smells
"@Test
  public void testWriteWithZooKeeperDownAndInterveningCrash() throws Exception {
    zk.stop();
    writer.saveHistoryItem(TASK_STATUS, TIMESTAMP);
    // simulate a crash by recreating the writer
    writer.stopAsync().awaitTerminated();
    makeWriter(client);
    zk.start();
    final TaskStatusEvent historyItem = Iterables.getOnlyElement(awaitHistoryItems());
    assertEquals(JOB_ID, historyItem.getStatus().getJob().getId());
  }",No Smells
"@Test
  public void verifyMonitorPropagatesImageMissing() throws Exception {
    sut.failed(new ImageNotFoundException(""foobar"", ""not found""), ""container error"");
    verify(statusUpdater).setThrottleState(IMAGE_MISSING);
    verify(statusUpdater).setState(FAILED);
    verify(statusUpdater).setContainerError(""container error"");
    verify(statusUpdater).update();
  }",No Smells
"@Test
  public void verifyMonitorPropagatesImagePullFailed() throws Exception {
    sut.failed(new ImagePullFailedException(""foobar"", ""failure""), ""container error"");
    verify(statusUpdater).setThrottleState(IMAGE_PULL_FAILED);
    verify(statusUpdater).setState(FAILED);
    verify(statusUpdater).setContainerError(""container error"");
    verify(statusUpdater).update();
  }",Redundent Print
"@Test
  public void verifyMonitorUsesFlapController() {
    sut.running();
    verify(statusUpdater, never()).setThrottleState(FLAPPING);
    verify(flapController).started();

    sut.exited(17);
    verify(flapController).exited();
  }",No Smells
"@Test
  public void testPullTimeoutVariation() throws Throwable {
    doThrow(new DockerTimeoutException(""x"", new URI(""http://example.com""), null))
        .when(mockDocker).pull(IMAGE);

    doThrow(new ImageNotFoundException(""not found""))
        .when(mockDocker).inspectImage(IMAGE);

    final TaskRunner tr = TaskRunner.builder()
        .delayMillis(0)
        .config(TaskConfig.builder()
            .namespace(""test"")
            .host(HOST)
            .job(JOB)
            .containerDecorators(ImmutableList.of(containerDecorator))
            .build())
        .docker(mockDocker)
        .listener(new TaskRunner.NopListener())
        .build();

    tr.run();

    try {
      tr.resultFuture().get();
      fail(""this should throw"");
    }",No Smells
"@Test
  public void testComputeTargetsSingleEndpoint() throws Exception {
    final CliParser cliParser = new CliParser(toArray(singleEndpointArgs));
    final List<Target> targets = cliParser.getTargets();

    // We expect the specified master endpoint target
    final List<Target> expectedTargets =
        ImmutableList.of(Target.from(URI.create(ENDPOINTS[0])));
    assertEquals(expectedTargets, targets);
  }",No Smells
"@Test
  public void testInsecureHttpsDisabledByDefault() throws Exception {
    final CliParser parser = new CliParser(toArray(singleEndpointArgs));

    assertFalse(""GlobalArg 'insecure' should default to false"",
        parser.getNamespace().getBoolean(""insecure""));
  }",No Smells
"@Test
  public void testDeploymentGroupInspectCommandJson() throws Exception {
    when(options.getString(""name"")).thenReturn(NAME);
    final int ret = command.run(options, client, out, true, null);

    assertEquals(0, ret);
    final DeploymentGroup output = Json.read(baos.toString(), DeploymentGroup.class);

    assertEquals(DEPLOYMENT_GROUP, output);
  }",No Smells
"@Test
  public void testDeploymentGroupStatusWithError() throws Exception {
    final List<DeploymentGroupStatusResponse.HostStatus> hostStatuses = Lists.newArrayList();
    hostStatuses.add(new DeploymentGroupStatusResponse.HostStatus(
        ""host1"", JOB_ID, TaskStatus.State.RUNNING));
    hostStatuses.add(new DeploymentGroupStatusResponse.HostStatus(
        ""host2"", JOB_ID, TaskStatus.State.PULLING_IMAGE));
    hostStatuses.add(new DeploymentGroupStatusResponse.HostStatus(
        ""host3"", null, null));

    final DeploymentGroupStatusResponse status = new DeploymentGroupStatusResponse(
        DEPLOYMENT_GROUP, DeploymentGroupStatusResponse.Status.ROLLING_OUT, ""Oops!"",
        hostStatuses, null);

    when(client.deploymentGroupStatus(GROUP_NAME)).thenReturn(Futures.immediateFuture(status));
    when(options.getString(""name"")).thenReturn(GROUP_NAME);
    final int ret = command.run(options, client, out, false, null);

    assertEquals(0, ret);
    final String output = baos.toString().replaceAll(""\\s+"", """");

    final String expected =
        format(""Name: %s""
               + ""Job Id: %s""
               + ""Status: ROLLING_OUT""
               + ""Host selectors:""
               + ""  a = b""
               + ""  foo = bar""
               + ""Error: Oops!""
               + ""HOST UP-TO-DATE JOB STATE""
               + ""host1. X %s RUNNING""
               + ""host2. X %s PULLING_IMAGE""
               + ""host3. - -"",
            GROUP_NAME, JOB_ID, JOB_ID, JOB_ID).replace("" "", """");

    assertEquals(expected, output);
  }",No Smells
"@Test
  public void testPatternFilter() throws Exception {
    final String hostname = ""host1.example.com"";
    final List<String> hosts = ImmutableList.of(hostname);
    when(client.listHosts(""host1"")).thenReturn(Futures.immediateFuture(hosts));

    final Map<String, HostStatus> statusResponse = ImmutableMap.of(hostname, upStatus);

    when(client.hostStatuses(eq(hosts), anyMapOf(String.class, String.class)))
        .thenReturn(Futures.immediateFuture(statusResponse));

    final int ret = runCommand(""host1"");
    assertEquals(0, ret);

    assertEquals(ImmutableList.of(""HOST"", hostname + "".""),
        TestUtils.readFirstColumnFromOutput(baos.toString(), false));
  }",No Smells
"@Test
  public void testSelectorSlurping() throws Exception {
    final List<String> hosts = ImmutableList.of(""host-1"");

    when(client.hostStatuses(eq(hosts), anyMapOf(String.class, String.class)))
        .thenReturn(Futures.immediateFuture(Collections.<String, HostStatus>emptyMap()));

    when(client.listHosts(""blah"", ImmutableSet.of(""foo=bar"")))
        .thenReturn(Futures.immediateFuture(hosts));

    assertThat(runCommand(""-s"", ""foo=bar"", ""blah""), equalTo(0));
    assertThat(runCommand(""blah"", ""-s"", ""foo=bar""), equalTo(0));

    when(client.listHosts(""blarp"", ImmutableSet.of(""a=b"", ""z=1"")))
        .thenReturn(Futures.immediateFuture(hosts));

    assertThat(runCommand(""-s"", ""a=b"", ""-s"", ""z=1"", ""blarp""), equalTo(0));
    assertThat(runCommand(""blarp"", ""--selector"", ""a=b"", ""--selector"", ""z=1""), equalTo(0));
  }",No Smells
"@Test
  public void testAddMetadataFromJsonFile() throws Exception {
    when(options.getString(""id"")).thenReturn(JOB_ID);
    when(options.getString(""image"")).thenReturn(""foobar"");

    when(options.get(""file""))
        .thenReturn(new File(""src/test/resources/job_config_extra_metadata.json""));

    final List<Object> value = new ArrayList<>();
    value.add(""baz=qux2"");
    when(options.getList(""metadata"")).thenReturn(value);

    assertEquals(0, runCommand());

    final Map<String, String> of = ImmutableMap.of(""foo"", ""bar"", ""baz"", ""qux2"");
    verify(client).createJob(argThat(hasMetadata(equalTo(of))));
  }",No Smells
"@Test
  public void testLabelsFromJsonFile() throws Exception {
    when(options.getString(""id"")).thenReturn(JOB_ID);
    when(options.getString(""image"")).thenReturn(""foobar"");

    when(options.get(""file""))
        .thenReturn(new File(""src/test/resources/job_config_extra_labels.json""));

    when(options.getList(""labels"")).thenReturn(Collections.emptyList());

    assertEquals(0, runCommand());

    verify(client).createJob(argThat(hasLabels(ImmutableMap.of(""foo"", ""bar"", ""baz"", ""qux""))
    ));
  }",No Smells
"@Test
  public void test() throws Exception {
    when(options.getString(""job"")).thenReturn(JOB_NAME_VERSION);
    final int ret = command.run(options, client, out, false, null);

    assertEquals(0, ret);
    final String output = baos.toString();
    assertThat(output, containsString(""Created: Thu, 1 Jan 1970 00:00:00 +0000""));
    assertThat(output, containsString(""Expires: Thu, 1 Jan 1970 00:00:00 +0000""));
    assertThat(output, containsString(""Time to wait before kill (seconds): 10""));
    assertThat(output, containsString(""Add capabilities: cap1, cap2""));
    assertThat(output, containsString(""Drop capabilities: cap3, cap4""));
    assertThat(output, containsString(""Ports: bar=0.0.0.0:123:456/tcp""));
    assertThat(output, containsString(""foo=127.0.0.1:80:8080/udp""));
    assertThat(output, containsString(""Runtime: nvidia""));
    assertThat(output, containsString(""Rollout options (null options will fallback to defaults ""
                                      + ""at rolling-update time): timeout: 250, parallelism: 2, ""
                                      + ""migrate: true, overlap: true, token: foobar, ""
                                      + ""ignoreFailures: true""));
  }",No Smells
"@Test
  public void testParsePortMappingGoodSpecs() throws Exception {
    for (final TestData d : GOOD_SPECS) {
      final PortMappingWithName mappingWithName = PortMappingParser.parsePortMapping(d.getSpec());
      final PortMapping portMapping = mappingWithName.portMapping();
      assertThat(mappingWithName.name(), equalTo(d.getName()));
      assertThat(portMapping.getInternalPort(), equalTo(d.getPortMapping().getInternalPort()));
      assertThat(portMapping.getExternalPort(), equalTo(d.getPortMapping().getExternalPort()));
      assertThat(portMapping.getProtocol(), equalTo(d.getPortMapping().getProtocol()));
    }",No Smells
"@Test
  public void testParsePortMappings() throws Exception {
    final Map<String, PortMapping> mappings =
        PortMappingParser.parsePortMappings(testDataToSpecs(GOOD_SPECS));
    final Map<String, PortMapping> expectedMappings = new HashMap<>();
    for (final TestData d : GOOD_SPECS) {
      expectedMappings.put(d.getName(), d.getPortMapping());
    }",No Smells
"@Test
  public void testCommandLineOptions() throws Exception {
    when(client.rollingUpdate(anyString(), any(JobId.class), any(RolloutOptions.class)))
        .thenReturn(immediateFuture(new RollingUpdateResponse(RollingUpdateResponse.Status.OK)));

    when(client.deploymentGroupStatus(GROUP_NAME)).then(new ResponseAnswer(
        statusResponse(DeploymentGroupStatusResponse.Status.ACTIVE, null,
            makeHostStatus(""host1"", JOB_ID, TaskStatus.State.RUNNING))
    ));

    String optionString = ""(parallelism=1, timeout=300, overlap=false, token=my_token, ""
                          + ""ignoreFailures=false, migrate=false)"";

    command.runWithJob(options, client, out, false, JOB, null);

    assertThat(baos.toString(), containsString(optionString));
  }",No Smells
"@Test
  public void testRollingUpdateAsync() throws Exception {
    when(client.rollingUpdate(anyString(), any(JobId.class), any(RolloutOptions.class)))
        .thenReturn(immediateFuture(new RollingUpdateResponse(RollingUpdateResponse.Status.OK)));

    when(options.getBoolean(""async"")).thenReturn(true);

    final int ret = command.runWithJob(options, client, out, false, JOB, null);
    final String output = baos.toString();

    verify(client).rollingUpdate(GROUP_NAME, JOB_ID, OPTIONS);
    assertEquals(0, ret);

    final String expected =
        ""Rolling update (async) started: my_group -> foo:2:1212121 (parallelism=1, timeout=300, ""
        + ""overlap=false, token="" + TOKEN + "", ignoreFailures=false, migrate=false)\n"";

    assertEquals(expected, output);
  }",No Smells
"@Test
  public void testRollingUpdateAsyncJson() throws Exception {
    when(client.rollingUpdate(anyString(), any(JobId.class), any(RolloutOptions.class)))
        .thenReturn(immediateFuture(new RollingUpdateResponse(RollingUpdateResponse.Status.OK)));

    when(options.getBoolean(""async"")).thenReturn(true);

    final int ret = command.runWithJob(options, client, out, true, JOB, null);
    final String output = baos.toString();

    verify(client).rollingUpdate(GROUP_NAME, JOB_ID, OPTIONS);
    assertEquals(0, ret);

    assertJsonOutputEquals(output, ImmutableMap.<String, Object>builder()
        .put(""status"", ""OK"")
        .put(""parallelism"", PARALLELISM)
        .put(""timeout"", TIMEOUT)
        .put(""overlap"", false)
        .put(""token"", TOKEN)
        .put(""ignoreFailures"", false)
        .put(""migrate"", false)
        .build()
    );
  }",No Smells
"@Test
  public void testRollingUpdateFailed() throws Exception {
    when(client.rollingUpdate(anyString(), any(JobId.class), any(RolloutOptions.class)))
        .thenReturn(immediateFuture(new RollingUpdateResponse(RollingUpdateResponse.Status.OK)));

    when(client.deploymentGroupStatus(GROUP_NAME)).then(new ResponseAnswer(
        statusResponse(DeploymentGroupStatusResponse.Status.ROLLING_OUT, null,
            makeHostStatus(""host1"", JOB_ID, TaskStatus.State.PULLING_IMAGE),
            makeHostStatus(""host2"", null, null)),
        statusResponse(DeploymentGroupStatusResponse.Status.FAILED, ""foobar"",
            makeHostStatus(""host1"", JOB_ID, TaskStatus.State.RUNNING),
            makeHostStatus(""host2"", null, null))
    ));

    final int ret = command.runWithJob(options, client, out, false, JOB, null);
    final String output = baos.toString();

    verify(client).rollingUpdate(GROUP_NAME, JOB_ID, OPTIONS);
    assertEquals(1, ret);
  }",No Smells
"@Test
  public void testRollingUpdateFailsOnRolloutTimeout() throws Exception {
    when(client.rollingUpdate(anyString(), any(JobId.class), any(RolloutOptions.class)))
        .thenReturn(immediateFuture(new RollingUpdateResponse(RollingUpdateResponse.Status.OK)));

    when(client.deploymentGroupStatus(GROUP_NAME)).then(new ResponseAnswer(
        statusResponse(DeploymentGroupStatusResponse.Status.ROLLING_OUT, null,
            makeHostStatus(""host1"", null, null),
            makeHostStatus(""host2"", null, null)),
        statusResponse(DeploymentGroupStatusResponse.Status.ROLLING_OUT, null,
            makeHostStatus(""host1"", JOB_ID, TaskStatus.State.PULLING_IMAGE),
            makeHostStatus(""host2"", null, null))
    ));

    final int ret = command.runWithJob(options, client, out, false, JOB, null);
    final String output = baos.toString();

    verify(client).rollingUpdate(GROUP_NAME, JOB_ID, OPTIONS);
    assertEquals(1, ret);
  }",No Smells
"@Test
  public void testAccessToken_ResponseIsOk() throws Exception {
    final AuthenticatingHttpConnector authConnector =
        createAuthenticatingConnectorWithAccessToken(
            Optional.<AgentProxy>absent(), ImmutableList.<Identity>of());

    final String path = ""/foo/bar"";

    final HttpsURLConnection connection = mock(HttpsURLConnection.class);
    when(connector.connect(argThat(matchesAnyEndpoint(path)),
        eq(method),
        eq(entity),
        argThat(hasKeys(Collections.singletonList(""Authorization""))))
    ).thenReturn(connection);
    when(connection.getResponseCode()).thenReturn(200);

    final URI uri = new URI(""https://helios"" + path);
    final HttpURLConnection returnedConnection =
        authConnector.connect(uri, method, entity, headers);

    assertSame(returnedConnection, connection);
  }",No Smells
"@Test
  public void testSupplierFactory() throws Exception {
    final DnsResolver resolver = mock(DnsResolver.class);
    when(resolver.resolve(""example.com"")).thenReturn(IPS_1);
    when(resolver.resolve(""example.net"")).thenReturn(IPS_2);
    final Supplier<List<URI>> uriSupplier = Suppliers.ofInstance(uris);
    final Supplier<List<Endpoint>> endpointSupplier = Endpoints.of(uriSupplier, resolver);
    final List<Endpoint> endpoints = endpointSupplier.get();

    assertThat(endpoints.size(), equalTo(4));
    assertThat(endpoints.get(0).getUri(), equalTo(uri1));
    assertThat(endpoints.get(0).getIp(), equalTo(IP_A));
    assertThat(endpoints.get(1).getUri(), equalTo(uri1));
    assertThat(endpoints.get(1).getIp(), equalTo(IP_B));
    assertThat(endpoints.get(2).getUri(), equalTo(uri2));
    assertThat(endpoints.get(2).getIp(), equalTo(IP_C));
    assertThat(endpoints.get(3).getUri(), equalTo(uri2));
    assertThat(endpoints.get(3).getIp(), equalTo(IP_D));
  }",No Smells
"@Test
  public void testGetWithCredentials() throws IOException {
    final GoogleCredentials credentials = mock(GoogleCredentials.class);
    final GoogleCredentialsAccessTokenSupplier supplier = new GoogleCredentialsAccessTokenSupplier(
        true, null, null, credentials);
    supplier.get();
    verify(credentials).refreshIfExpired();
  }",No Smells
"@Test
  public void listHostsFilterByNamePattern() throws Exception {
    final List<String> hosts = ImmutableList.of(""foo1"", ""foo2"", ""foo3"");

    mockResponse(""GET"",
        allOf(hasPath(""/hosts/""), containsQuery(""namePattern=foo"")),
        response(""GET"", 200, hosts));

    assertThat(client.listHosts(""foo"").get(), equalTo(hosts));
  }",No Smells
"@Test
  public void listJobsWithJobFilter() throws Exception {
    final Map<JobId, Job> jobs = fakeJobs(JobId.parse(""foobar:v1""));

    mockResponse(""GET"",
        allOf(
            hasPath(""/jobs""),
            containsQuery(""q=foo"")
        ),
        response(""GET"", 200, jobs)
    );

    assertThat(client.jobs(""foo"").get(), is(jobs));
  }",No Smells
"@Test
  public void testSuccess() throws Exception {
    when(delegate.request(any(URI.class), anyString(), any(byte[].class),
        Matchers.<Map<String, List<String>>>any()))
        .thenReturn(Futures.<Response>immediateFuture(null));

    when(clock.now()).thenReturn(new Instant(0));

    dispatcher.request(new URI(""http://example.com""), ""GET"", null,
        Collections.<String, List<String>>emptyMap());

    // Verify the delegate was only called once if it returns successfully on the first try
    verify(delegate, times(1)).request(any(URI.class), anyString(), any(byte[].class),
        Matchers.<Map<String, List<String>>>any());
  }",No Smells
"@Test
  public void testExecHealthCheckBuilder() {
    final ExecHealthCheck healthCheck = HealthCheck.newExecHealthCheck()
        .setCommand(Collections.singletonList(""whoami"")).build();
    assertEquals(""cmd"", healthCheck.getCommand(), ImmutableList.of(""whoami""));
  }",No Smells
"@Test
  public void testTcpHealthCheckBuilder() {
    final TcpHealthCheck healthCheck =
        HealthCheck.newTcpHealthCheck().setPort(""http-admin"").build();
    assertEquals(""port"", ""http-admin"", healthCheck.getPort());
  }",No Smells
"@Test
  public void testInOperatorSerialization() throws Exception {
    final HostSelector orig = HostSelector.parse(""a in (foo,bar)"");
    final HostSelector parsed = Json.read(Json.asString(orig), HostSelector.class);
    assertEquals(orig, parsed);
  }",No Smells
"@Test
  public void testNotInOperator() {
    final HostSelector hostSelector = HostSelector.parse(""a notin (foo, bar)"");
    assertFalse(hostSelector.matches(""foo""));
    assertFalse(hostSelector.matches(""bar""));
    assertTrue(hostSelector.matches(""baz""));

    final HostSelector hostSelector2 = HostSelector.parse(""a notin(foo,bar)"");
    assertFalse(hostSelector2.matches(""foo""));
    assertFalse(hostSelector2.matches(""bar""));
    assertTrue(hostSelector2.matches(""baz""));

    final HostSelector hostSelector3 = HostSelector.parse(""a notin(foo)"");
    assertFalse(hostSelector3.matches(""foo""));
    assertTrue(hostSelector3.matches(""baz""));
  }",No Smells
"@Test
  public void testNotInOperatorEmptySet() {
    final HostSelector hostSelector = HostSelector.parse(""a notin ()"");
    assertTrue(hostSelector.matches(""foo""));
    assertTrue(hostSelector.matches(""bar""));
    assertTrue(hostSelector.matches(""baz""));

    final HostSelector hostSelector2 = HostSelector.parse(""a notin()"");
    assertTrue(hostSelector2.matches(""foo""));
    assertTrue(hostSelector2.matches(""bar""));
    assertTrue(hostSelector2.matches(""baz""));
  }",No Smells
"@Test
  public void testParseAllowedCharacters() {
    assertEquals(new HostSelector(""foo"", HostSelector.Operator.EQUALS, ""123""),
        HostSelector.parse(""foo=123""));
    assertEquals(new HostSelector(""_abc"", HostSelector.Operator.NOT_EQUALS, ""d-e""),
        HostSelector.parse(""_abc!=d-e""));
  }",No Smells
"@Test
  public void testParseNotEquals() {
    assertEquals(new HostSelector(""A"", HostSelector.Operator.NOT_EQUALS, ""B""),
        HostSelector.parse(""A!=B""));
    assertEquals(new HostSelector(""A"", HostSelector.Operator.NOT_EQUALS, ""B""),
        HostSelector.parse(""A != B""));
    assertEquals(new HostSelector(""A"", HostSelector.Operator.NOT_EQUALS, ""B""),
        HostSelector.parse(""A !=B""));
    assertEquals(new HostSelector(""A"", HostSelector.Operator.NOT_EQUALS, ""B""),
        HostSelector.parse(""A!= B""));
    assertEquals(new HostSelector(""A"", HostSelector.Operator.NOT_EQUALS, ""B""),
        HostSelector.parse(""A\t\t!=  B""));
  }",No Smells
"@Test
  public void testHasExternalPorts() {
    final Job.Builder builder = Job.newBuilder().setName(""foo"").setVersion(""1"").setImage(""foobar"");

    final Job noPorts = builder.build();
    assertThat(noPorts.hasExternalPorts(), equalTo(false));

    final Job noExternalPorts = builder
        .setPorts(ImmutableMap.of(
            ""add_ports1"", PortMapping.of(1234),
            ""add_ports2"", PortMapping.of(2345)
        ))
        .build();
    assertThat(noExternalPorts.hasExternalPorts(), equalTo(false));

    final Job externalPorts = builder
        .setPorts(ImmutableMap.of(
            ""add_ports1"", PortMapping.of(1234),
            ""add_ports2"", PortMapping.of(2345, 9090)
        ))
        .build();
    assertThat(externalPorts.hasExternalPorts(), equalTo(true));
  }",No Smells
"@Test
  public void verifyCanParseJobWithMissingEnv() throws Exception {
    final Job job = Job.newBuilder()
        .setCommand(asList(""foo"", ""bar""))
        .setImage(""foobar:4711"")
        .setName(""foozbarz"")
        .setVersion(""17"")
        .build();

    removeFieldAndParse(job, ""env"");
  }",No Smells
"@Test
  public void verifySha1Id() throws IOException {
    final Map<String, Object> expectedConfig = map(""command"", asList(""foo"", ""bar""),
        ""image"", ""foobar:4711"",
        ""name"", ""foozbarz"",
        ""version"", ""17"");

    final String expectedInput = ""foozbarz:17:"" + hex(Json.sha1digest(expectedConfig));
    final String expectedDigest = hex(Hash.sha1digest(expectedInput.getBytes(UTF_8)));
    final JobId expectedId = JobId.fromString(""foozbarz:17:"" + expectedDigest);

    final Job job = Job.newBuilder()
        .setCommand(asList(""foo"", ""bar""))
        .setImage(""foobar:4711"")
        .setName(""foozbarz"")
        .setVersion(""17"")
        .build();

    assertEquals(expectedId, job.getId());
  }",No Smells
"@Test
  public void testJsonSerializationWithDefaults() throws Exception {
    final PortMapping pm = PortMapping.builder()
        .internalPort(456)
        .externalPort(123)
        .build();
    final String json = toJson(pm);
    assertThat(json, equalTo(stringFromResource(""portmapping-defaults.json"")));
  }",No Smells
"@Test
  public void testCanDeserializeStringlyTypedFields() throws Exception {
    final ObjectMapper mapper = new ObjectMapper();
    final ObjectNode node = mapper.createObjectNode()
        .put(""migrate"", ""false"")
        .put(""parallelism"", ""2"")
        .put(""timeout"", ""1000"");

    final RolloutOptions options = Json.read(node.toString(), RolloutOptions.class);

    assertThat(options.getMigrate(), is(Boolean.FALSE));
    assertThat(options.getParallelism(), is(2));
    assertThat(options.getTimeout(), is(1000L));
  }",No Smells
"@Test
  public void testSerializationOfEnvironment() throws Exception {

    final byte[] bytes = Json.asBytes(STATUS);

    final TaskStatus read = Json.read(bytes, TaskStatus.class);
    assertEquals(1, read.getEnv().size());
    assertEquals(""VALUE"", read.getEnv().get(""VAR""));
  }",No Smells
"@Test
  public void testInvalidImagesFail() throws Exception {
    final Job.Builder b = Job.newBuilder().setName(""foo"").setVersion(""1"");

    assertEquals(newHashSet(""Tag cannot be empty""),
        validator.validate(b.setImage(""repo:"").build()));

    assertEquals(newHashSet(""Tag cannot be empty""),
        validator.validate(b.setImage(""repo:"").build()));

    assertEquals(newHashSet(""Tag cannot be empty""),
        validator.validate(b.setImage(""repo:""
            + ""@sha256:2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae"").build()));

    assertEquals(newHashSet(""Digest cannot be empty""),
        validator.validate(b.setImage(""foo@"").build()));

    assertEquals(newHashSet(""Illegal digest: \"":123\""""),
        validator.validate(b.setImage(""foo@:123"").build()));

    assertEquals(newHashSet(""Illegal digest: \"":123\""""),
        validator.validate(b.setImage(""foo:bar@:123"").build()));

    assertEquals(newHashSet(""Illegal digest: \""sha256:\""""),
        validator.validate(b.setImage(""foo@sha256:"").build()));

    assertEquals(newHashSet(""Illegal digest: \""sha256:\""""),
        validator.validate(b.setImage(""foo:bar@sha256:"").build()));

    assertEquals(newHashSet(""Illegal digest: \""sha256:\""""),
        validator.validate(b.setImage(""foo:4711/baz:bar@sha256:"").build()));

    assertFalse(validator.validate(b.setImage(""repo:/"").build()).isEmpty());

    assertEquals(newHashSet(""Invalid domain name: \""1.2.3.4.\""""),
        validator.validate(b.setImage(""1.2.3.4.:4711/namespace/repo"").build()));

    assertEquals(newHashSet(""Invalid domain name: \"" reg.istry\""""),
        validator.validate(b.setImage("" reg.istry:4711/repo"").build()));

    assertEquals(newHashSet(""Invalid domain name: \""reg .istry\""""),
        validator.validate(b.setImage(""reg .istry:4711/repo"").build()));

    assertEquals(newHashSet(""Invalid domain name: \""reg.istry \""""),
        validator.validate(b.setImage(""reg.istry :4711/repo"").build()));

    assertEquals(newHashSet(""Invalid domain name: \""1.2.3.4.\""""),
        validator.validate(b.setImage(""1.2.3.4.:4711/namespace/repo""
            + ""@sha256:2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae"").build()));

    assertEquals(newHashSet(""Invalid port in endpoint: \""reg.istry: 4711\""""),
        validator.validate(b.setImage(""reg.istry: 4711/repo"").build()));

    assertEquals(newHashSet(""Invalid port in endpoint: \""reg.istry:4711 \""""),
        validator.validate(b.setImage(""reg.istry:4711 /repo"").build()));

    assertEquals(newHashSet(""Invalid port in endpoint: \""reg.istry:4711 \""""),
        validator.validate(b.setImage(""reg.istry:4711 /repo""
            + ""@sha256:2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae"").build()));

    assertEquals(newHashSet(""Invalid image name (reg.istry:4711/ repo), only ^([a-z0-9._-]+)$ is ""
                            + ""allowed for each slash-separated name component ""
                            + ""(failed on \"" repo\"")""),
        validator.validate(b.setImage(""reg.istry:4711/ repo"").build()));

    assertEquals(newHashSet(""Invalid image name (reg.istry:4711/namespace /repo), only ""
                            + ""^([a-z0-9._-]+)$ is allowed for each slash-separated name component ""
                            + ""(failed on \""namespace \"")""),
        validator.validate(b.setImage(""reg.istry:4711/namespace /repo"").build()));

    assertEquals(newHashSet(""Invalid image name (reg.istry:4711/namespace/ repo), only ""
                            + ""^([a-z0-9._-]+)$ is allowed for each slash-separated name component ""
                            + ""(failed on \"" repo\"")""),
        validator.validate(b.setImage(""reg.istry:4711/namespace/ repo"").build()));

    assertEquals(newHashSet(""Invalid image name (reg.istry:4711/namespace/repo ), only ""
                            + ""^([a-z0-9._-]+)$ is allowed for each slash-separated name component ""
                            + ""(failed on \""repo \"")""),
        validator.validate(b.setImage(""reg.istry:4711/namespace/repo "").build()));

    assertEquals(newHashSet(""Invalid image name (reg.istry:4711/namespace/ repo""
            + ""@sha256:2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae), only ""
                            + ""^([a-z0-9._-]+)$ is allowed for each slash-separated name component ""
                            + ""(failed on \"" repo\"")""),
        validator.validate(b.setImage(""reg.istry:4711/namespace/ repo""
            + ""@sha256:2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae"").build()));

    assertEquals(newHashSet(""Invalid domain name: \""foo-.ba|z\""""),
        validator.validate(b.setImage(""foo-.ba|z/namespace/baz"").build()));

    assertEquals(newHashSet(""Invalid domain name: \""reg..istry\""""),
        validator.validate(b.setImage(""reg..istry/namespace/baz"").build()));

    assertEquals(newHashSet(""Invalid domain name: \""reg..istry\""""),
        validator.validate(b.setImage(""reg..istry/namespace/baz"").build()));

    assertEquals(newHashSet(""Invalid domain name: \""reg..istry\""""),
        validator.validate(b.setImage(""reg..istry/namespace/baz:foo"").build()));

    assertEquals(newHashSet(""Invalid domain name: \""reg..istry\""""),
        validator.validate(b.setImage(""reg..istry/namespace/baz:foo""
            + ""@sha256:2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae"").build()));

    assertEquals(newHashSet(""Invalid domain name: \""reg..istry\""""),
        validator.validate(b.setImage(""reg..istry/namespace/baz""
            + ""@sha256:2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae"").build()));

    assertEquals(newHashSet(""Invalid port in endpoint: \""foo:345345345\""""),
        validator.validate(b.setImage(""foo:345345345/namespace/baz"").build()));

    assertEquals(newHashSet(""Invalid port in endpoint: \""foo:345345345\""""),
        validator.validate(b.setImage(""foo:345345345/namespace/baz:bar"").build()));

    assertEquals(newHashSet(""Invalid port in endpoint: \""foo:345345345\""""),
        validator.validate(b.setImage(""foo:345345345/namespace/baz:bar""
            + ""@sha256:2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae"").build()));

    assertEquals(newHashSet(""Invalid port in endpoint: \""foo:-17\""""),
        validator.validate(b.setImage(""foo:-17/namespace/baz"").build()));

    final String foos = Strings.repeat(""foo"", 100);
    final String image = foos + ""/bar"";
    assertEquals(newHashSet(""Invalid image name ("" + image + ""), repository name cannot be larger""
                            + "" than 255 characters""),
        validator.validate(b.setImage(image).build()));
  }",Eager Test
"@Test
  public void testJobFromJsonWithInvalidRegistration() throws Exception {
    final URL resource = getClass().getResource(""job-with-bad-registration.json"");
    final byte[] bytes = Resources.toByteArray(resource);
    final Job job = Json.read(bytes, Job.class);

    assertThat(validator.validate(job),
        contains(""registration for 'volumes' is malformed: does not have a port mapping""));
  }",No Smells
"@Test
  public void testValidNamesPass() {
    final Job.Builder b = Job.newBuilder().setVersion(""1"").setImage(""bar"");
    assertThat(validator.validate(b.setName(""foo"").build()), is(empty()));
    assertThat(validator.validate(b.setName(""17"").build()), is(empty()));
    assertThat(validator.validate(b.setName(""foo17.bar-baz_quux"").build()), is(empty()));
  }",No Smells
"@Test
  public void testObjectSha1() throws Exception {
    final Bar bar = new Bar() {
      {
        c = ""bar"";
        foo = new Foo() {
          {
            b = 17;
            a = ""hello"";
            c = new LinkedHashMap<String, Object>() {
              {
                put(""2"", ""two"");
                put(""1"", 1);
              }",No Smells
"@Test
  public void testServiceDiscovery() throws Exception {
    // start a container that runs nginx and registers with SkyDNS
    final TemporaryJob nginx = jobs.job()
        .image(NGINX)
        .port(""http"", 80, ports.localPort(""http""))
        .registration(""nginx"", ""http"", ""http"")
        .deploy();

    // run a container that does SRV lookup to find the nginx service and then curl's it
    final TemporaryJob alpine = jobs.job()
        .image(ALPINE)
        .port(""nc"", 4711, ports.localPort(""nc""))
        .command(""sh"", ""-c"",
            ""apk add --update bind-tools ""
            + ""&& export SRV=$(dig -t SRV +short _nginx._http.test.$SPOTIFY_DOMAIN) ""
            + ""&& export HOST=$(echo $SRV | cut -d' ' -f4) ""
            + ""&& export PORT=$(echo $SRV | cut -d' ' -f3) ""
            + ""&& nc -lk -p 4711 -e curl http://$HOST:$PORT""
        )
        .deploy();

    final HostAndPort alpineAddress = alpine.address(""nc"");

    // Connect to alpine container to get the curl response. If we get back the nginx welcome page
    // we know that helios properly registered the nginx service in SkyDNS.
    final Callable<String> socketResponse = () -> {
      try (final Socket s = new Socket(alpineAddress.getHost(), alpineAddress.getPort())) {
        return IOUtils.toString(s.getInputStream(), Charsets.UTF_8).trim();
      }",Eager Test
"@Test
  public void testTcpHealthcheck() {
    jobs.job()
        .image(""nginx:1.9.9"")
        .port(""http"", 80)
        .tcpHealthCheck(""http"")
        .deploy();
  }",No Smells
"@Test
  public void testAllHealthy() {
    final HealthCheckRegistry registry = new HealthCheckRegistry();
    registry.register(""pass1"", stubHealthCheck(HealthCheck.Result.healthy()));
    registry.register(""pass2"", stubHealthCheck(HealthCheck.Result.healthy()));

    final TotalHealthCheckGauge gauge = new TotalHealthCheckGauge(registry);
    assertThat(gauge.getValue(), is(1));
  }",No Smells
"@Test
  public void testOneFails() {
    final HealthCheckRegistry registry = new HealthCheckRegistry();
    registry.register(""pass1"", stubHealthCheck(HealthCheck.Result.healthy()));
    registry.register(""fail1"", stubHealthCheck(HealthCheck.Result.unhealthy(""error"")));

    final TotalHealthCheckGauge gauge = new TotalHealthCheckGauge(registry);
    assertThat(gauge.getValue(), is(0));
  }",No Smells
"@Test
  public void jobDeployedWithHistoryLastUsedRecentlyNotReaped() throws Exception {
    final MasterModel masterModel = mock(MasterModel.class);
    testReap(name.getMethodName(), deployments(JobId.fromString(name.getMethodName()), 3),
        events(ImmutableList.of(HOURS.toMillis(20), HOURS.toMillis(40))), null, masterModel, false);
  }",Eager Test
"@Test
  public void jobDeployedWithHistoryLastUsedTooLongAgoNotReaped() throws Exception {
    final MasterModel masterModel = mock(MasterModel.class);
    testReap(name.getMethodName(), deployments(JobId.fromString(name.getMethodName()), 3),
        events(ImmutableList.of(HOURS.toMillis(20), HOURS.toMillis(22))), null, masterModel, false);
  }",Eager Test
"@Test
  public void testGetNonExistingDeploymentGroup() throws Exception {
    when(model.getDeploymentGroup(anyString())).thenThrow(
        new DeploymentGroupDoesNotExistException(""""));

    final Response response = resource.getDeploymentGroup(""foobar"");
    assertEquals(Response.Status.NOT_FOUND.getStatusCode(), response.getStatus());
  }",No Smells
"@Test
  public void testRollingUpdateJobDoesNotExist() throws Exception {
    doThrow(new JobDoesNotExistException("""")).when(model).rollingUpdate(
        any(DeploymentGroup.class), any(JobId.class), any(RolloutOptions.class));

    final Response response = resource.rollingUpdate(
        ""foo"", new RollingUpdateRequest(new JobId(""foo"", ""0.3"", ""1234""),
            RolloutOptions.getDefault()));

    assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());
    assertEquals(new RollingUpdateResponse(RollingUpdateResponse.Status.JOB_NOT_FOUND),
        response.getEntity());
  }",No Smells
"@Test
  public void listHosts() {
    assertThat(resource.list(null, NO_SELECTOR_ARG), equalTo(hosts));
  }",No Smells
"@Test
  public void listHostsNameAndSelectorFilter() {
    when(model.listHosts(""foo.example.com"")).thenReturn(hosts);
    assertThat(resource.list(""foo.example.com"", ImmutableList.of(""site=foo"")), equalTo(hosts));

    when(model.listHosts(""host3"")).thenReturn(ImmutableList.of(""host3.foo.example.com""));
    assertThat(resource.list(""host3"", ImmutableList.of(""index =2"")), empty());

    assertThat(resource.list(""host3"", ImmutableList.of(""index!=2"")),
        contains(""host3.foo.example.com""));
  }",No Smells
"@Test
  public void listHostsSelectorFilterMissingStatus() {
    when(model.getHostLabels(hosts.get(0))).thenReturn(emptyMap());
    assertThat(resource.list(null, ImmutableList.of(""site=foo"")),
        equalTo(hosts.subList(1, hosts.size())));

    assertThat(resource.list(null, ImmutableList.of(""site=bar"")), empty());
    assertThat(resource.list(null, ImmutableList.of(""site!=foo"")), empty());

    assertThat(resource.list(null, ImmutableList.of(""index in (1,2)"")),
        contains(""host2.foo.example.com""));

    assertThat(resource.list(null, ImmutableList.of(""site=foo"", ""index in (1,2)"")),
        contains(""host2.foo.example.com""));
  }",No Smells
"@Test
  public void testCreateJobWithNoRolloutOptions() throws Exception {
    final JobId jobId = JobId.parse(""foobar:1"");
    final Job job = Job.newBuilder()
        .setName(""foobar"")
        .setVersion(""1"")
        .setImage(""busybox:latest"")
        .setCreatingUser(""user1"")
        .setCreated(0L)
        .build();

    final CreateJobResponse jobResponse = resource.post(job, ""user1"");
    assertThat(jobResponse,
        new CustomTypeSafeMatcher<CreateJobResponse>(""CreateJobResponse that is OK"") {
          @Override
          protected boolean matchesSafely(final CreateJobResponse response) {
            return response.getStatus() == OK
                   && response.getErrors().isEmpty()
                   && response.getId().contains(jobId.toString());
          }",No Smells
"@Test
  public void testCreateJobWithPartialRolloutOptions() throws Exception {
    final JobId jobId = JobId.parse(""foobar:1"");
    final Job job = Job.newBuilder()
        .setName(""foobar"")
        .setVersion(""1"")
        .setImage(""busybox:latest"")
        .setRolloutOptions(RolloutOptions.newBuilder()
            .setTimeout(null)
            .setParallelism(2)
            .setMigrate(null)
            .setOverlap(true)
            .setToken(null)
            .setIgnoreFailures(null)
            .build())
        .setCreatingUser(""user1"")
        .setCreated(0L)
        .build();

    final CreateJobResponse jobResponse = resource.post(job, ""user1"");
    assertThat(jobResponse,
        new CustomTypeSafeMatcher<CreateJobResponse>(""CreateJobResponse that is OK"") {
          @Override
          protected boolean matchesSafely(final CreateJobResponse response) {
            return response.getStatus() == OK
                   && response.getErrors().isEmpty()
                   && response.getId().contains(jobId.toString());
          }",Eager Test
"@Test
  public void testStartManualNoHosts() throws Exception {
    // Create a DeploymentGroupTasks object with no rolloutTasks (defaults to empty list).
    final DeploymentGroupTasks deploymentGroupTasks = DeploymentGroupTasks.newBuilder()
        .setDeploymentGroup(MANUAL_DEPLOYMENT_GROUP)
        .build();

    final RollingUpdateOpFactory opFactory = new RollingUpdateOpFactory(
        deploymentGroupTasks, eventFactory);
    final ZooKeeperClient client = mock(ZooKeeperClient.class);
    when(client.exists(anyString())).thenReturn(null);
    final RollingUpdateOp op = opFactory.start(MANUAL_DEPLOYMENT_GROUP, client);

    // Three ZK operations should return:
    // * create tasks node
    // * delete the tasks
    // * set the status to DONE
    assertEquals(
        ImmutableSet.of(
            new CreateEmpty(""/status/deployment-group-tasks/my_group""),
            new Delete(""/status/deployment-group-tasks/my_group""),
            new SetData(""/status/deployment-groups/my_group"", DeploymentGroupStatus.newBuilder()
                .setState(DeploymentGroupStatus.State.DONE)
                .setError(null)
                .build()
                .toJsonBytes())),
        ImmutableSet.copyOf(op.operations()));

    // Two events should return: rollingUpdateStarted and rollingUpdateDone
    assertEquals(2, op.events().size());
    verify(eventFactory).rollingUpdateStarted(MANUAL_DEPLOYMENT_GROUP);
    verify(eventFactory).rollingUpdateDone(MANUAL_DEPLOYMENT_GROUP);
  }",Eager Test
"@Test
  public void testTransitionToFailed() {
    final DeploymentGroupTasks deploymentGroupTasks = DeploymentGroupTasks.newBuilder()
        .setTaskIndex(0)
        .setRolloutTasks(Lists.newArrayList(
            RolloutTask.of(RolloutTask.Action.UNDEPLOY_OLD_JOBS, ""host1""),
            RolloutTask.of(RolloutTask.Action.AWAIT_RUNNING, ""host1""),
            RolloutTask.of(RolloutTask.Action.DEPLOY_NEW_JOB, ""host1"")))
        .setDeploymentGroup(MANUAL_DEPLOYMENT_GROUP)
        .build();

    final RollingUpdateOpFactory opFactory = new RollingUpdateOpFactory(
        deploymentGroupTasks, eventFactory);
    final RollingUpdateOp op = opFactory.error(""foo"", ""host1"", RollingUpdateError.HOST_NOT_FOUND);

    final Map<String, Object> failEvent = Maps.newHashMap();
    when(eventFactory.rollingUpdateTaskFailed(
        any(DeploymentGroup.class), any(RolloutTask.class),
        anyString(), any(RollingUpdateError.class))).thenReturn(failEvent);

    // When state -> FAILED we expected
    //  * deployment group tasks are deleted
    //  * deployment group status is updated (to FAILED)
    assertEquals(
        ImmutableSet.of(
            new SetData(""/status/deployment-groups/my_group"", DeploymentGroupStatus.newBuilder()
                .setState(DeploymentGroupStatus.State.FAILED)
                .setError(""host1: foo"")
                .build()
                .toJsonBytes()),
            new Delete(""/status/deployment-group-tasks/my_group"")),
        ImmutableSet.copyOf(op.operations()));

    // ...and that a failed-task event and a rolling-update failed event are emitted
    assertEquals(2, op.events().size());

    verify(eventFactory).rollingUpdateTaskFailed(
        eq(MANUAL_DEPLOYMENT_GROUP),
        eq(deploymentGroupTasks.getRolloutTasks().get(deploymentGroupTasks.getTaskIndex())),
        anyString(),
        eq(RollingUpdateError.HOST_NOT_FOUND),
        eq(Collections.<String, Object>emptyMap()));

    verify(eventFactory).rollingUpdateFailed(
        eq(MANUAL_DEPLOYMENT_GROUP),
        eq(failEvent));
  }",Eager Test
"@Test
  public void testSerialRollout() {
    final DeploymentGroup deploymentGroup = DeploymentGroup.newBuilder()
        .setRolloutOptions(RolloutOptions.newBuilder()
            .setParallelism(1)
            .build())
        .build();

    final RolloutPlanner rolloutPlanner = RollingUpdatePlanner.of(deploymentGroup);

    final List<RolloutTask> tasks = rolloutPlanner.plan(HOSTS);

    final List<RolloutTask> expected = Lists.newArrayList(
        RolloutTask.of(RolloutTask.Action.UNDEPLOY_OLD_JOBS, ""agent1""),
        RolloutTask.of(RolloutTask.Action.DEPLOY_NEW_JOB, ""agent1""),
        RolloutTask.of(RolloutTask.Action.AWAIT_RUNNING, ""agent1""),
        RolloutTask.of(RolloutTask.Action.UNDEPLOY_OLD_JOBS, ""agent2""),
        RolloutTask.of(RolloutTask.Action.DEPLOY_NEW_JOB, ""agent2""),
        RolloutTask.of(RolloutTask.Action.AWAIT_RUNNING, ""agent2""),
        RolloutTask.of(RolloutTask.Action.UNDEPLOY_OLD_JOBS, ""agent3""),
        RolloutTask.of(RolloutTask.Action.DEPLOY_NEW_JOB, ""agent3""),
        RolloutTask.of(RolloutTask.Action.AWAIT_RUNNING, ""agent3""),
        RolloutTask.of(RolloutTask.Action.UNDEPLOY_OLD_JOBS, ""agent4""),
        RolloutTask.of(RolloutTask.Action.DEPLOY_NEW_JOB, ""agent4""),
        RolloutTask.of(RolloutTask.Action.AWAIT_RUNNING, ""agent4""));

    assertEquals(expected, tasks);
  }",No Smells
"@Test
  public void verifyListenerCalledOnNodeAdd() throws Exception {
    final DataPojo created = new DataPojo(""foo"");
    ensure(""/foos/foo"", created);
    verify(listener, timeout(60000).atLeastOnce()).nodesChanged(cache);
    final DataPojo read = Iterables.getOnlyElement(cache.getNodes().values());
    assertEquals(created, read);
  }",No Smells
"@Test
  public void verifyListenerCalledOnNodeChange() throws Exception {
    final DataPojo created = new DataPojo(""foo"");
    ensure(""/foos/foo"", created);
    verify(listener, timeout(60000).atLeastOnce()).nodesChanged(cache);
    reset(listener);
    final DataPojo changed = new DataPojo(""foo-changed"");
    zk.curatorWithSuperAuth().setData().forPath(""/foos/foo"", Json.asBytesUnchecked(changed));
    verify(listener, timeout(60000).atLeastOnce()).nodesChanged(cache);
    final DataPojo read = Iterables.getOnlyElement(cache.getNodes().values());
    assertEquals(changed, read);
  }",No Smells
"@Test
  public void verifyListenerCalledOnNodeRemoved() throws Exception {
    ensure(""/foos/foo"", new DataPojo(""foo""));
    verify(listener, timeout(60000).atLeastOnce()).nodesChanged(cache);
    reset(listener);
    try {
      zk.curatorWithSuperAuth().delete().forPath(""/foos/foo"");
    }",No Smells
"@Test
  public void verifyRecoversFromBackupRestoreOffline() throws Exception {
    // Create backup
    try {
      zk.curatorWithSuperAuth().create().forPath(""/version"", ""1"".getBytes());
    }",Eager Test
"@Test
  public void testDefaultAcl() {
    final RuleBasedZooKeeperAclProvider aclProvider = RuleBasedZooKeeperAclProvider.builder()
        .defaultAcl(ZooDefs.Ids.CREATOR_ALL_ACL)
        .build();

    assertEquals(ZooDefs.Ids.CREATOR_ALL_ACL, aclProvider.getDefaultAcl());
  }",No Smells
"@Test
  public void testNoMatchingRules() {
    final Id id = new Id(""some_scheme"", ""id"");
    final RuleBasedZooKeeperAclProvider aclProvider = RuleBasedZooKeeperAclProvider.builder()
        .rule(""/foo/bar/baz"", WRITE, id)
        .build();

    assertNull(aclProvider.getAclForPath(""/foo/bar""));
  }",No Smells
"@Test
  public void testAttributesIncludeAdditionalAttributes() throws Exception {
    // a counter to keep track of how often the Supplier is called
    final AtomicInteger counter = new AtomicInteger(0);
    final Supplier<Map<String, String>> additionalAttributes = () -> {
      final int count = counter.incrementAndGet();
      return ImmutableMap.of(""foo"", ""bar"", ""counter"", String.valueOf(count));
    }",Eager Test
"@Test
  public void testAttributesIncludeHeliosVersion() throws Exception {
    metricRegistry.register(""something"", (Gauge<Integer>) () -> 1);

    reporter.reportOnce();

    verify(ffwd).send(argThat(containsAttributes(""helios_version"", Version.POM_VERSION)));
  }",No Smells
"@Test
  public void testCounter() throws Exception {
    metricRegistry.counter(""counting.is.fun"")
        .inc(7982);

    reporter.reportOnce();

    verify(ffwd).send(argThat(allOf(
        hasKey(""helios.test""),
        containsAttributes(""what"", ""counting.is.fun"", ""metric_type"", ""counter""),
        hasValue(7982)
    )));
  }",No Smells
"@Test
  public void testGauges() throws Exception {
    metricRegistry.register(""some.gauge1"", (Gauge<Integer>) () -> 1);
    metricRegistry.register(""some.gauge2"", (Gauge<Integer>) () -> 2);

    reporter.reportOnce();

    verify(ffwd).send(argThat(allOf(
        hasKey(""helios.test""),
        containsAttributes(""what"", ""some.gauge1"", ""metric_type"", ""gauge""),
        hasValue(1)
    )));

    verify(ffwd).send(argThat(allOf(
        hasKey(""helios.test""),
        containsAttributes(""what"", ""some.gauge2"", ""metric_type"", ""gauge""),
        hasValue(2)
    )));
  }",No Smells
"@Test
  public void testHistogram() throws Exception {
    final Histogram h = metricRegistry.histogram(""histo.gram"");
    IntStream.range(1, 10).forEach(h::update);

    reporter.reportOnce();

    verifyHistogramStats(""histo.gram"", ""histogram"");
  }",No Smells
"@Test
  public void testMeter() throws Exception {
    metricRegistry.meter(""the-meter"");

    reporter.reportOnce();

    verifyMeterStats(""the-meter"", ""meter"");
  }",No Smells
"@Test
  public void testDefaultAcl() {
    assertEquals(
        newHashSet(new ACL(READ, AGENT_ID), new ACL(CREATE | READ | WRITE | DELETE, MASTER_ID)),
        newHashSet(aclProvider.getDefaultAcl()));
  }",No Smells
"@Test
  public void testShutdown() throws Exception {
    final ZooKeeperRegistrar zooKeeperRegistrar = createStubRegistrar(true);

    final ZooKeeperRegistrarService init = ZooKeeperRegistrarService.newBuilder()
        .setZooKeeperClient(zkClient)
        .setZooKeeperRegistrar(zooKeeperRegistrar)
        .build();

    init.startUp();

    assertNull(complete.get(3000, MILLISECONDS));

    // if this throws exception something is bonkers
    init.shutDown();

    assertNull(shutdownComplete.get(3000, MILLISECONDS));
  }",No Smells
"@Test
  public void testExecHealthCheckBuilder() {
    final ExecHealthCheck healthCheck = HealthCheck.newExecHealthCheck()
        .setCommand(Collections.singletonList(""whoami"")).build();
    assertEquals(""cmd"", healthCheck.getCommand(), ImmutableList.of(""whoami""));
  }",Eager Test
"@Test
  public void testHttpHealthCheckBuilder() {
    final HttpHealthCheck.Builder builder = HealthCheck.newHttpHealthCheck();

    // Input to setXXX
    final String setPort = ""http-admin"";
    final String setPath = ""/healthcheck"";

    // Check setXXX methods
    builder.setPort(setPort);
    builder.setPath(setPath);

    assertEquals(""port"", setPort, builder.getPort());
    assertEquals(""path"", setPath, builder.getPath());

    // Check final output
    final HttpHealthCheck healthCheck = builder.build();
    assertEquals(""port"", setPort, healthCheck.getPort());
    assertEquals(""path"", setPath, healthCheck.getPath());
  }",No Smells
"@Test
  public void testMajorVersion() throws Exception {
    final String newVersion = (current.getMajor() + 1) + "".0.0"";
    final HttpURLConnection connection = doVersionRequest(newVersion);
    assertResponseCodeType(connection, 4);
    assertServerVersion(connection);
    assertVersionStatus(connection, ""INCOMPATIBLE"");
  }",No Smells
"@Test
  public void testFailsOnAllDown() throws Exception {
    final DefaultDeployer sut = new DefaultDeployer(client, EMPTY_JOBS_LIST, PICK_FIRST, """",
        TIMEOUT);

    // hosta is down, hostb is down too. 
    when(client.hostStatus(HOSTA)).thenReturn(DOWN_STATUS);
    when(client.hostStatus(HOSTB)).thenReturn(DOWN_STATUS);

    exception.expect(AssertionError.class);

    sut.pickHost(HOSTS);
  }",No Smells
"@Test
  public void testTryAgainOnHostDown() throws Exception {
    // hosta is down, hostb is up.
    when(client.hostStatus(HOSTA)).thenReturn(DOWN_STATUS);
    when(client.hostStatus(HOSTB)).thenReturn(UP_STATUS);

    assertEquals(HOSTB, deployer.pickHost(HOSTS));
  }",No Smells
"@Test
  public void testConfigHasGoogleContainerRegistryCredentials() throws Exception {
    // generate a file that we will pretend contains GCR credentials, in order to verify that
    // HeliosSoloDeployment sets up the expected environment variables and volume binds
    // when this config value exists (and is a real file)
    final File credentialsFile = temporaryFolder.newFile(""fake-credentials"");
    final String credentialsPath = credentialsFile.getPath();

    final String image = ""helios-test"";

    final Config config = ConfigFactory.empty()
        .withValue(""helios.solo.profile"", ConfigValueFactory.fromAnyRef(""test""))
        .withValue(""helios.solo.profiles.test.image"", ConfigValueFactory.fromAnyRef(image))
        .withValue(""helios.solo.profiles.test.google-container-registry.credentials"",
            ConfigValueFactory.fromAnyRef(credentialsPath)
        );

    buildHeliosSoloDeployment(new HeliosSoloDeployment.Builder(null, config));

    ContainerConfig soloContainerConfig = null;
    for (final ContainerConfig cc : containerConfig.getAllValues()) {
      if (cc.image().contains(image)) {
        soloContainerConfig = cc;
      }",Eager Test
"@Test
  public void testUndeployLeftoverJobs() throws Exception {
    final HeliosSoloDeployment solo = buildHeliosSoloDeployment();

    final ListenableFuture<List<String>> hostsFuture = Futures.<List<String>>immediateFuture(
        ImmutableList.of(HOST1, HOST2));
    when(heliosClient.listHosts()).thenReturn(hostsFuture);

    // These futures represent HostStatuses when the job is still deployed
    final ListenableFuture<HostStatus> statusFuture11 = Futures.immediateFuture(
        HostStatus.newBuilder()
            .setStatus(Status.UP)
            .setStatuses(ImmutableMap.of(JOB_ID1, TASK_STATUS1))
            .setJobs(ImmutableMap.of(JOB_ID1, Deployment.of(JOB_ID1, Goal.START)))
            .build());
    final ListenableFuture<HostStatus> statusFuture21 = Futures.immediateFuture(
        HostStatus.newBuilder()
            .setStatus(Status.UP)
            .setStatuses(ImmutableMap.of(JOB_ID2, TASK_STATUS2))
            .setJobs(ImmutableMap.of(JOB_ID2, Deployment.of(JOB_ID2, Goal.START)))
            .build());

    // These futures represent HostStatuses when the job is undeployed
    final ListenableFuture<HostStatus> statusFuture12 = Futures.immediateFuture(
        HostStatus.newBuilder()
            .setStatus(Status.UP)
            .setStatuses(Collections.<JobId, TaskStatus>emptyMap())
            .setJobs(ImmutableMap.of(JOB_ID1, Deployment.of(JOB_ID1, Goal.START)))
            .build());
    final ListenableFuture<HostStatus> statusFuture22 = Futures.immediateFuture(
        HostStatus.newBuilder()
            .setStatus(Status.UP)
            .setStatuses(Collections.<JobId, TaskStatus>emptyMap())
            .setJobs(ImmutableMap.of(JOB_ID2, Deployment.of(JOB_ID2, Goal.START)))
            .build());
    //noinspection unchecked
    when(heliosClient.hostStatus(HOST1)).thenReturn(statusFuture11);
    //noinspection unchecked
    when(heliosClient.hostStatus(HOST2)).thenReturn(statusFuture21);

    final ListenableFuture<JobUndeployResponse> undeployFuture1 = Futures.immediateFuture(
        new JobUndeployResponse(JobUndeployResponse.Status.OK, HOST1, JOB_ID1));
    final ListenableFuture<JobUndeployResponse> undeployFuture2 = Futures.immediateFuture(
        new JobUndeployResponse(JobUndeployResponse.Status.OK, HOST2, JOB_ID2));

    // when undeploy is called, respond correctly & patch the mock to return
    // the undeployed HostStatus
    when(heliosClient.undeploy(JOB_ID1, HOST1)).thenAnswer(
        new Answer<ListenableFuture<JobUndeployResponse>>() {
          @Override
          public ListenableFuture<JobUndeployResponse> answer(final InvocationOnMock invocation)
              throws Throwable {
            when(heliosClient.hostStatus(HOST1)).thenReturn(statusFuture12);
            return undeployFuture1;
          }",Eager Test
"@Test
  public void testDeterministicOneHost() {
    final Set<String> chosenHosts = Sets.newHashSet();
    final HostPickingStrategy strategy1 = HostPickingStrategies.deterministicOneHost("""");
    for (int i = 0; i < NUM_ITERATIONS; i++) {
      chosenHosts.add(strategy1.pickHost(HOSTS));
    }",No Smells
"@Test
  public void testFollow() throws Exception {
    final Iterator<LogMessage> messages = Iterators.forArray(
        asMessage(LogMessage.Stream.STDOUT, ""hello ""),
        asMessage(LogMessage.Stream.STDERR, ""error 1""),
        asMessage(LogMessage.Stream.STDOUT, ""world"")
    );

    follower.followLog(jobId, ""1234abcd"", messages);

    assertThat(new String(follower.getStdout(jobId)), is(""hello world""));
    assertThat(new String(follower.getStderr(jobId)), is(""error 1""));
  }",No Smells
"@Test
  public void testTwoLinesNoNewline() throws Exception {
    final Iterator<LogMessage> stream = stream(stdout(""abc123\n123abc""));

    final LoggingLogStreamFollower sut = LoggingLogStreamFollower.create(log);
    sut.followLog(JobId.fromString(""a:b:c""), ""d"", stream);

    assertThat(appender.events(),
        contains(event(Level.INFO, ""[a] [d] 1 abc123""),
            event(Level.INFO, ""[a] [d] 1 123abc"")));
  }",No Smells
"@Test
  public void testOverrideDefaultProber() throws Exception {
    assertThat(testResult(OverrideDefaultProberTest.class), isSuccessful());
  }",No Smells
"@Test
    public void testFindBeanManager() {
        assertNotNull(new CdiObjectFactory().findBeanManager());
    }",Redundent Print
"@Test
    public void testGetBean() throws Exception {
        final CdiObjectFactory cdiObjectFactory = new CdiObjectFactory();
        FooConsumer fooConsumer = (FooConsumer) cdiObjectFactory.buildBean(FooConsumer.class.getCanonicalName(), null, false);
        assertNotNull(fooConsumer);
        assertNotNull(fooConsumer.fooService);
    }",Redundent Print
"@Test
    public void testConstructor() throws Exception {
        Class<TestBean> expectedClass = TestBean.class;

        BeanConfig beanConfig = new BeanConfig(expectedClass);

        Assert.assertEquals(expectedClass, beanConfig.getClazz());
        Assert.assertEquals(Container.DEFAULT_NAME, beanConfig.getName());
        Assert.assertEquals(Scope.SINGLETON, beanConfig.getScope());
        Assert.assertEquals(expectedClass, beanConfig.getType());
        Assert.assertFalse(beanConfig.isOnlyStatic());
        Assert.assertFalse(beanConfig.isOptional());
    }",No Smells
"@Test
    public void convertUploadedFileToFile() {
        // given
        UploadedFileConverter ufc = new UploadedFileConverter();
        UploadedFile uploadedFile = StrutsUploadedFile.Builder.create(tempFile).withContentType(this.contentType).withOriginalName(this.originalName).build();

        // when
        Object result = ufc.convertValue(context, target, member, propertyName, uploadedFile, File.class);

        // then
        assertThat(result).isInstanceOf(File.class);
        File file = (File) result;
        assertThat(file.length()).isEqualTo(tempFile.length());
        assertThat(file.getAbsolutePath()).isEqualTo(tempFile.getAbsolutePath());
    }",No Smells
"@Test
    public void testWrite() throws Exception {
        Bean bean1 = new Bean();
        bean1.setStringField(""str"");
        bean1.setBooleanField(true);
        bean1.setCharField('s');
        bean1.setDoubleField(10.1);
        bean1.setFloatField(1.5f);
        bean1.setIntField(10);
        bean1.setLongField(100);
        bean1.setEnumField(AnEnum.ValueA);
        bean1.setEnumBean(AnEnumBean.Two);

        JSONWriter jsonWriter = new DefaultJSONWriter();
        jsonWriter.setEnumAsBean(false);
        String json = jsonWriter.write(bean1);
        TestUtils.assertEquals(DefaultJSONWriter.class.getResource(""jsonwriter-write-bean-01.txt""), json);
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testWriteBeanWithList() throws Exception {
        BeanWithList bean1 = new BeanWithList();
        bean1.setStringField(""str"");
        bean1.setBooleanField(true);
        bean1.setCharField('s');
        bean1.setDoubleField(10.1);
        bean1.setFloatField(1.5f);
        bean1.setIntField(10);
        bean1.setLongField(100);
        bean1.setEnumField(AnEnum.ValueA);
        bean1.setEnumBean(AnEnumBean.Two);
        List<String> errors = new ArrayList<String>();
        errors.add(""Field is required"");
        bean1.setErrors(errors);

        JSONWriter jsonWriter = new DefaultJSONWriter();
        jsonWriter.setEnumAsBean(false);
        jsonWriter.setIgnoreHierarchy(false);
        String json = jsonWriter.write(bean1);
        TestUtils.assertEquals(DefaultJSONWriter.class.getResource(""jsonwriter-write-bean-04.txt""), json);
    }",Mystery Guest
"@Test
	public void testSanitizeInputPathShouldAllowSimpleParameter() throws Exception {
		assertEquals(""foo"", fileDownloadAction.sanitizeInputPath(""foo""));
	}",No Smells
"@Test
	public void testSanitizeInputPathShouldReturnNullForLeadingWebInf() throws Exception {
		assertNull(fileDownloadAction.sanitizeInputPath(""WEB-INF/foo""));
	}",No Smells
"@Test
	public void testSanitizeInputPathShouldReturnNullForNullInput() throws Exception {
		assertNull(fileDownloadAction.sanitizeInputPath(null));
	}",No Smells
"@Test
    public void findAnnotationSingleAction() {
        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();
        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotation(), null);
        Assert.assertNotNull(tilesDefinition);
        Assert.assertEquals(""definition-name"", tilesDefinition.name());
    }",No Smells
"@Test
  public void doNotModifyUrlsWhenAlreadyRelative() throws Exception {
    setupIndexMock(INDEX_YAML_NO_ABSOLUTE_URLS);
    TempBlob newTempBlob = underTest.removeUrlsFromIndexYamlAndWriteToTempBlob(tempBlob, repository);
    assertThat(newTempBlob.get(), is(instanceOf(InputStream.class)));
    checkThatAbsoluteUrlRemoved(newTempBlob.get());
  }",No Smells
"@Test
  public void ensureNoExclamationMarksInYaml() throws Exception {
    setupIndexMock(INDEX_YAML);
    TempBlob newTempBlob = underTest.removeUrlsFromIndexYamlAndWriteToTempBlob(tempBlob, repository);
    BufferedReader reader = new BufferedReader(new InputStreamReader(tempBlob.get()));
    String line;
    while ((line = reader.readLine()) != null) {
      line = line.trim();
      assertThat(line, is(not(""!"")));
    }",No Smells
"@Test
  public void filename() throws Exception {
    Map<String, String> map = new HashMap<>();
    map.put(""filename"", FILENAME);
    when(state.getTokens()).thenReturn(map);
    String result = underTest.filename(state);
    assertThat(result, is(equalTo(FILENAME)));
  }",No Smells
"@Test
  public void getYamlFromTgzTestCustomArchive() throws Exception {
    InputStream is = getClass().getResourceAsStream(""mongodb-4.0.4.tgz"");
    InputStream chartFromInputStream = underTest.getChartFromInputStream(is);
    String fileContent = IOUtils.toString(new InputStreamReader(chartFromInputStream));

    String expected = ""appVersion: 3.6.6\n""
        + ""description: NoSQL document-oriented database that stores JSON-like documents with\n""
        + ""  dynamic schemas, simplifying the integration of data in content-driven applications.\n""
        + ""engine: gotpl\n""
        + ""home: https://mongodb.org\n""
        + ""icon: https://bitnami.com/assets/stacks/mongodb/img/mongodb-stack-220x234.png\n""
        + ""keywords:\n""
        + ""- mongodb\n""
        + ""- database\n""
        + ""- nosql\n""
        + ""- cluster\n""
        + ""- replicaset\n""
        + ""- replication\n""
        + ""maintainers:\n""
        + ""- email: containers@bitnami.com\n""
        + ""  name: Bitnami\n""
        + ""name: mongodb\n""
        + ""sources:\n""
        + ""- https://github.com/bitnami/bitnami-docker-mongodb\n""
        + ""version: 4.0.4\n"";
    assertThat(fileContent, is(expected));
  }",Mystery Guest
"@Test
	public void testBrokenStatement() {

		List<Statement> brokenSg1Statements = new ArrayList<>();
		brokenSg1Statements.add(getTestStatement(2,
				5, 1, EntityIdValue.ET_ITEM));
		brokenSg1Statements.add(getBrokenStatement());
		brokenSg1Statements.add(getTestStatement(2,
				5, 2, EntityIdValue.ET_ITEM));
		StatementGroup brokenSg1 = Datamodel
				.makeStatementGroup(brokenSg1Statements);

		List<Statement> fixedSg1Statements = new ArrayList<>();
		fixedSg1Statements.add(getTestStatement(2, 5,
				1, EntityIdValue.ET_ITEM));
		fixedSg1Statements.add(getTestStatement(2, 5,
				2, EntityIdValue.ET_ITEM));
		StatementGroup fixedSg1 = Datamodel
				.makeStatementGroup(fixedSg1Statements);

		StatementGroup sg2 = getTestStatementGroup(2,
				5, 1, EntityIdValue.ET_ITEM);

		List<StatementGroup> brokenSgs = new ArrayList<>();
		brokenSgs.add(brokenSg1);
		brokenSgs.add(sg2);
		List<StatementGroup> fixedSgs = new ArrayList<>();
		fixedSgs.add(fixedSg1);
		fixedSgs.add(sg2);

		ItemDocument brokenId = Datamodel.makeItemDocument(
				getTestItemIdValue(2),
				Collections.emptyList(),
				Collections.emptyList(),
				Collections.emptyList(), brokenSgs,
				Collections.emptyMap());

		ItemDocument fixedId = Datamodel.makeItemDocument(
				getTestItemIdValue(2),
				Collections.emptyList(),
				Collections.emptyList(),
				Collections.emptyList(), fixedSgs,
				Collections.emptyMap());

		DatamodelConverter dmc = new DatamodelConverter(
				new DataObjectFactoryImpl());

		assertEquals(fixedId, dmc.copy(brokenId));
	}",Eager Test
"@Test
	public void testGenerationFromOtherItemDocument() {
		ItemDocument item = Datamodel.makeItemDocument(
				Datamodel.makeWikidataItemIdValue(""Q42""),
				Collections.singletonList(Datamodel.makeMonolingualTextValue(""en"", ""label"")),
				Collections.singletonList(Datamodel.makeMonolingualTextValue(""en"", ""desc"")),
				Collections.singletonList(Datamodel.makeMonolingualTextValue(""en"", ""alias"")),
				Collections.emptyList(),
				Collections.singletonMap(""enwiki"", Datamodel.makeSiteLink(""foo"", ""enwiki"", Collections.emptyList()))
		);

		DatamodelConverter converter = new DatamodelConverter(new DataObjectFactoryImpl());
		assertEquals(item, converter.copy(item));
	}",No Smells
"@Test
	public void testItemDocumentToJson() throws JsonProcessingException {
		ItemDocument id = Datamodel.makeItemDocument(
				Datamodel.makeWikidataItemIdValue(""Q42""),
				Collections.emptyList(),
				Collections.emptyList(),
				Collections.emptyList(),
				Collections.emptyList(),
				Collections.emptyMap());
		String json = ""{\""type\"":\""item\"",\""id\"":\""Q42\"",\""labels\"":{}",No Smells
"@Test
	public void testSerializer() throws IOException {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		JsonSerializer serializer = new JsonSerializer(out);

		ItemIdValue qid1 = Datamodel.makeWikidataItemIdValue(""Q1"");
		ItemDocument id1 = Datamodel.makeItemDocument(
				qid1,
				Collections.singletonList(Datamodel.makeMonolingualTextValue(""Label1"", ""lang1"")),
				Collections.emptyList(), Collections.emptyList(),
				Collections.singletonList(Datamodel.makeStatementGroup(Collections.singletonList(
						Datamodel.makeStatement(qid1,
								Datamodel.makeNoValueSnak(Datamodel.makeWikidataPropertyIdValue(""P42"")),
								Collections.emptyList(), Collections.emptyList(),
								StatementRank.NORMAL, ""MyId""
				)))), Collections.emptyMap(), 1234);
		ItemDocument id2 = Datamodel.makeItemDocument(
				Datamodel.makeWikidataItemIdValue(""Q2""),
				Collections.emptyList(), Collections.emptyList(), Collections.emptyList(),
				Collections.emptyList(), Collections.emptyMap(), 12);
		PropertyDocument pd1 = Datamodel.makePropertyDocument(
				Datamodel.makeWikidataPropertyIdValue(""P1""),
				Collections.emptyList(), Collections.emptyList(),
				Collections.singletonList(Datamodel.makeMonolingualTextValue(""Alias1"", ""lang1"")),
				Collections.emptyList(), Datamodel.makeDatatypeIdValue(DatatypeIdValue.DT_COMMONS_MEDIA),
				3456);

		serializer.open();
		serializer.processItemDocument(id1);
		serializer.processItemDocument(id2);
		serializer.processPropertyDocument(pd1);
		serializer.close();

		List<EntityDocument> inputDocuments = Arrays.asList(id1, id2, pd1);

		List<EntityDocument> outputDocuments = new ArrayList<>();

		ObjectMapper mapper = new DatamodelMapper(""http://www.wikidata.org/entity/"");
		ObjectReader documentReader = mapper.readerFor(EntityDocumentImpl.class);

		MappingIterator<EntityDocument> documentIterator = documentReader.readValues(out.toString());
		while (documentIterator.hasNextValue()) {
			outputDocuments.add(documentIterator.nextValue());
		}",Eager Test
"@Test
	public void testEmptyStatement() {
		ItemIdValue i = ItemIdValue.NULL;
		PropertyIdValue p = PropertyIdValue.NULL;

		Statement stmt1 = Datamodel.makeStatement(
				i, Datamodel.makeSomeValueSnak(p),
				Collections.emptyList(), Collections.emptyList(),
				StatementRank.NORMAL, """");
		Statement stmt2 = StatementBuilder.forSubjectAndProperty(i, p).build();

		assertEquals(stmt1, stmt2);
	}",No Smells
"@Test
	public void testNoValueStatement() {
		ItemIdValue i = ItemIdValue.NULL;
		PropertyIdValue p = PropertyIdValue.NULL;

		Statement stmt1 = Datamodel.makeStatement(
				i, Datamodel.makeNoValueSnak(p),
				Collections.emptyList(), Collections.emptyList(),
				StatementRank.NORMAL, """");
		Statement stmt2 = StatementBuilder.forSubjectAndProperty(i, p)
				.withNoValue().build();

		assertEquals(stmt1, stmt2);
	}",No Smells
"@Test
	public void accessSnakGroups() {
		EntityIdValue value1 = new ItemIdValueImpl(""Q1"",
				""http://wikidata.org/entity/"");
		EntityIdValue value2 = new ItemIdValueImpl(""Q2"",
				""http://wikidata.org/entity/"");
		PropertyIdValue property1 = new PropertyIdValueImpl(""P1"", ""http://wikidata.org/entity/"");
		PropertyIdValue property2 = new PropertyIdValueImpl(""P2"", ""http://wikidata.org/entity/"");
		Snak snak1 = new ValueSnakImpl(property1, value1);
		Snak snak2 = new ValueSnakImpl(property1, value2);
		Snak snak3 = new ValueSnakImpl(property2, value2);

		List<Snak> snakList1 = new ArrayList<>();
		snakList1.add(snak1);
		snakList1.add(snak2);

		SnakGroup snakGroup1 = new SnakGroupImpl(snakList1);
		SnakGroup snakGroup2 = new SnakGroupImpl(
				Collections.singletonList(snak3));
		List<SnakGroup> snakGroups = new ArrayList<>();
		snakGroups.add(snakGroup1);
		snakGroups.add(snakGroup2);

		Claim claim = new ClaimImpl(subject, mainSnak, snakGroups);

		Iterator<Snak> snaks = claim.getAllQualifiers();

		assertTrue(snaks.hasNext());
		assertEquals(snak1, snaks.next());
		assertTrue(snaks.hasNext());
		assertEquals(snak2, snaks.next());
		assertTrue(snaks.hasNext());
		assertEquals(snak3, snaks.next());
		assertFalse(snaks.hasNext());
	}",Eager Test
"@Test
	public void equalityBasedOnContent() {
		Claim cDiffSubject, cDiffMainSnak, cDiffQualifiers;
		EntityIdValue subject2 = new ItemIdValueImpl(""Q43"",
				""http://wikidata.org/entity/"");
		PropertyIdValue property = new PropertyIdValueImpl(
				""P43"", ""http://wikidata.org/entity/"");
		ValueSnak mainSnak2 = new ValueSnakImpl(property, subject2);

		cDiffSubject = new ClaimImpl(subject2, mainSnak,
				Collections.emptyList());
		cDiffMainSnak = new ClaimImpl(subject, mainSnak2,
				Collections.emptyList());
		cDiffQualifiers = new ClaimImpl(subject, mainSnak,
				Collections.singletonList(new SnakGroupImpl(
						Collections. singletonList(mainSnak))));

		assertEquals(c1, c1);
		assertEquals(c1, c2);
		assertNotEquals(c1, cDiffSubject);
		assertNotEquals(c1, cDiffMainSnak);
		assertNotEquals(c1, cDiffQualifiers);
		assertNotEquals(c1, null);
		assertNotEquals(c1, this);
	}",No Smells
"@Test
	public void gettersWorking() {
		assertEquals(c1.getSubject(), subject);
		assertEquals(c1.getMainSnak(), mainSnak);
		assertEquals(c1.getQualifiers(), Collections.emptyList());
	}",No Smells
"@Test
	public void equalityBasedOnContent() {
		assertEquals(d1, d1);
		assertEquals(d1, d2);
		assertNotEquals(d1, d3);
		assertNotEquals(d1, null);
		assertNotEquals(d1, new StringValueImpl(""foo""));
	}",No Smells
"@Test
	public void hashBasedOnContent() {
		assertEquals(d1.hashCode(), d2.hashCode());
	}",No Smells
"@Test
	public void testFromIdItem() {
		assertEquals(new ItemIdValueImpl(""Q42"", ""http://foo/""), EntityIdValueImpl.fromId(""Q42"", ""http://foo/""));
	}",No Smells
"@Test
	public void testFromIdSense() {
		assertEquals(new SenseIdValueImpl(""L42-S1"", ""http://foo/""), EntityIdValueImpl.fromId(""L42-S1"", ""http://foo/""));
	}",No Smells
"@Test
	public void testRedirectToJson() throws JsonProcessingException {
		JsonComparator.compareJsonStrings(JSON_ITEM_REDIRECT, mapper.writeValueAsString(itemRedirect));
	}",No Smells
"@Test
	public void grammaticalFeaturesCanBeNull() {
		FormDocument doc = new FormDocumentImpl(fid, repList, null, statementGroups, 1234);
		assertTrue(doc.getGrammaticalFeatures().isEmpty());
	}",No Smells
"@Test
	public void iterateOverAllStatements() {
		Iterator<Statement> statements = fd1.getAllStatements();

		assertTrue(statements.hasNext());
		assertEquals(s, statements.next());
		assertFalse(statements.hasNext());
	}",No Smells
"@Test
	public void testFormToJson() throws JsonProcessingException {
		JsonComparator.compareJsonStrings(JSON_FORM, mapper.writeValueAsString(fd1));
	}",No Smells
"@Test
	public void lexemeIdIsCorrect() {
		assertEquals(form1.getLexemeId(), new LexemeIdValueImpl(""L42"", ""http://www.wikidata.org/entity/""));
	}",No Smells
"@Test
	public void siteIriIsCorrect() {
		assertEquals(form1.getSiteIri(), ""http://www.wikidata.org/entity/"");
	}",No Smells
"@Test
	public void testToJava() throws IOException {
		assertEquals(form1, mapper.readValue(JSON_FORM_ID_VALUE, ValueImpl.class));
	}",No Smells
"@Test
	public void getGlobeItemId() {
		assertEquals(new ItemIdValueImpl(""Q2"", ""http://www.wikidata.org/entity/""), c1.getGlobeItemId());
	}",No Smells
"@Test
	public void equalityBasedOnContent() {
		ItemDocument irDiffLabel = new ItemDocumentImpl(iid,
				Collections.emptyList(), descList, aliasList,
				statementGroups, sitelinks, 1234);
		ItemDocument irDiffDesc = new ItemDocumentImpl(iid,
				labelList, Collections.emptyList(), aliasList,
				statementGroups, sitelinks, 1234);
		ItemDocument irDiffAlias = new ItemDocumentImpl(iid,
				labelList, descList, Collections.emptyList(),
				statementGroups, sitelinks, 1234);
		ItemDocument irDiffStatementGroups = new ItemDocumentImpl(iid,
				labelList, descList, aliasList,
				Collections.emptyList(), sitelinks, 1234);
		ItemDocument irDiffSiteLinks = new ItemDocumentImpl(iid,
				labelList, descList, aliasList,
				statementGroups, Collections.emptyList(),
				1234);
		ItemDocument irDiffRevisions = new ItemDocumentImpl(iid,
				labelList, descList, aliasList,
				statementGroups, sitelinks, 1235);

		PropertyDocument pr = new PropertyDocumentImpl(
				new PropertyIdValueImpl(""P42"", ""foo""),
				labelList, descList, aliasList,
				Collections.emptyList(),
				new DatatypeIdImpl(DatatypeIdValue.DT_STRING), 1234);

		// we need to use empty lists of Statement groups to test inequality
		// based on different item ids with all other data being equal
		ItemDocument irDiffItemIdValue = new ItemDocumentImpl(
				new ItemIdValueImpl(""Q23"", ""http://example.org/""),
				labelList, descList, aliasList,
				Collections.emptyList(), sitelinks, 1234);

		assertEquals(ir1, ir1);
		assertEquals(ir1, ir2);
		assertNotEquals(ir1, irDiffLabel);
		assertNotEquals(ir1, irDiffDesc);
		assertNotEquals(ir1, irDiffAlias);
		assertNotEquals(ir1, irDiffStatementGroups);
		assertNotEquals(ir1, irDiffSiteLinks);
		assertNotEquals(ir1, irDiffRevisions);
		assertNotEquals(irDiffStatementGroups, irDiffItemIdValue);
		assertNotEquals(ir1, pr);
		assertNotEquals(ir1, null);
		assertNotEquals(ir1, this);
	}",Eager Test
"@Test
	public void statementGroupsCanBeNull() {
		ItemDocument doc = new ItemDocumentImpl(iid,
				Collections.emptyList(),
				Collections.emptyList(),
				Collections.emptyList(), null,
				sitelinks, 1234);
		assertTrue(doc.getStatementGroups().isEmpty());
	}",No Smells
"@Test
	public void testAliasesToJava() throws IOException {
		ItemDocumentImpl document = new ItemDocumentImpl(iid,
				Collections.emptyList(), Collections.emptyList(), aliasList,
				Collections.emptyList(), Collections.emptyList(), 0);
		assertEquals(document, mapper.readValue(JSON_ITEM_ALIASES, ItemDocumentImpl.class));
	}",No Smells
"@Test
	public void testDeleteStatements() {
		Statement toRemove = statementGroups.get(0).getStatements().get(0);
		ItemDocument withoutStatement = ir1.withoutStatementIds(Collections.singleton(toRemove.getStatementId()));
		assertNotEquals(withoutStatement, ir1);
	}",No Smells
"@Test
	public void testSiteLinksToJava() throws IOException {
		ItemDocumentImpl document = new ItemDocumentImpl(iid,
				Collections.emptyList(), Collections.emptyList(), Collections.emptyList(),
				Collections.emptyList(), sitelinks, 0);
		assertEquals(document, mapper.readValue(JSON_ITEM_SITELINKS, ItemDocumentImpl.class));
	}",No Smells
"@Test
	public void testStatementsToJava() throws IOException {
		ItemDocumentImpl document = new ItemDocumentImpl(iid,
				Collections.emptyList(), Collections.emptyList(), Collections.emptyList(),
				statementGroups, Collections.emptyList(), 0);
		assertEquals(document, mapper.readValue(JSON_ITEM_STATEMENTS, ItemDocumentImpl.class));
	}",No Smells
"@Test
	public void testWithDescriptionInNewLanguage() {
		MonolingualTextValue newDescription = new MonolingualTextValueImpl(
				""l'item 42 bien connu"", ""fr"");
		ItemDocument withDescription = ir1.withDescription(newDescription);
		assertEquals(""l'item 42 bien connu"", withDescription.findDescription(""fr""));
	}",No Smells
"@Test
	public void testToJava() throws IOException {
		assertEquals(item1, mapper.readValue(JSON_ITEM_ID_VALUE, ValueImpl.class));
	}",No Smells
"@Test
	public void testToJavaWrongID() throws IOException {
		Value unsupported = mapper.readValue(JSON_ITEM_ID_VALUE_WRONG_ID, ValueImpl.class);
		assertTrue(unsupported instanceof UnsupportedEntityIdValue);
	}",No Smells
"@Test
	public void fieldsAreCorrect() {
		assertEquals(ld1.getEntityId(), lid);
		assertEquals(ld1.getLanguage(), language);
		assertEquals(ld1.getLexicalCategory(), lexCat);
		assertEquals(ld1.getLemmas(), Collections.singletonMap(lemma.getLanguageCode(), lemma));
		assertEquals(ld1.getStatementGroups(), statementGroups);
		assertEquals(ld1.getForms(), forms);
	}",No Smells
"@Test
	public void formsCanBeNull() {
		LexemeDocument doc = new LexemeDocumentImpl(lid, lexCat, language, lemmaList, statementGroups, null,  senses, 1234);
		assertTrue(doc.getForms().isEmpty());
	}",No Smells
"@Test
	public void senseGetter() {
		assertEquals(sense, ld1.getSense(sense.getEntityId()));
	}",No Smells
"@Test
	public void entityTypeIsLexeme() {
		assertEquals(lexeme1.getEntityType(), EntityIdValue.ET_LEXEME);
	}",No Smells
"@Test
	public void testToJava() throws IOException {
		assertEquals(lexeme1, mapper.readValue(JSON_LEXEME_ID_VALUE, ValueImpl.class));
	}",No Smells
"@Test
	public void equalityBasedOnContent() {
		MonolingualTextValue mtDiffString = new MonolingualTextValueImpl(
				""another string"", ""en"");
		MonolingualTextValue mtDiffLanguageCode = new MonolingualTextValueImpl(
				""some string"", ""en-GB"");

		assertEquals(mt1, mt1);
		assertEquals(mt1, mt2);
		assertNotEquals(mt1, mtDiffString);
		assertNotEquals(mt1, mtDiffLanguageCode);
		assertNotEquals(mt1, null);
		assertNotEquals(mt1, this);
	}",No Smells
"@Test
	public void testToJava() throws IOException {
		assertEquals(mt1, mapper.readValue(JSON_MONOLINGUAL_TEXT_VALUE, MonolingualTextValueImpl.class));
	}",No Smells
"@Test
	public void aliasesCanBeNull() {
		PropertyDocument doc = new PropertyDocumentImpl(pid, labelList, descList, null,
				statementGroups, datatypeId, 1234);
		assertEquals(Collections.emptyMap(), doc.getAliases());
	}",No Smells
"@Test
	public void testDeleteStatements() {
		Statement toRemove = statementGroups.get(0).getStatements().get(0);
		PropertyDocument withoutStatement = pd1.withoutStatementIds(Collections.singleton(toRemove.getStatementId()));
		assertNotEquals(withoutStatement, pd1);
	}",No Smells
"@Test
	public void testPropertyToJson() throws JsonProcessingException {
		JsonComparator.compareJsonStrings(JSON_PROPERTY, mapper.writeValueAsString(pd1));
	}",No Smells
"@Test
	public void testWithDescriptionInNewLanguage() {
		MonolingualTextValue newDescription = new MonolingualTextValueImpl(
				""Beschreibung"", ""de"");
		PropertyDocument withDescription = pd1.withDescription(newDescription);
		assertEquals(""des"", withDescription.findDescription(""fr""));
		assertEquals(""Beschreibung"", withDescription.findDescription(""de""));
	}",No Smells
"@Test
	public void testWithOverridenAliases() {
		MonolingualTextValue newAlias = new MonolingualTextValueImpl(
				""A new alias of P42"", ""en"");

		PropertyDocument withAlias = pd1.withAliases(""en"", Collections.singletonList(newAlias));
		assertEquals(Collections.singletonList(newAlias), withAlias.getAliases().get(""en""));
	}",No Smells
"@Test
	public void testWithRevisionId() {
		assertEquals(1235L, pd1.withRevisionId(1235L).getRevisionId());
		assertEquals(pd1, pd1.withRevisionId(1325L).withRevisionId(pd1.getRevisionId()));
	}",No Smells
"@Test
	public void hashBasedOnContent() {
		assertEquals(prop1.hashCode(), prop2.hashCode());
	}",No Smells
"@Test
	public void iriIsCorrect() {
		assertEquals(prop1.getIri(), ""http://www.wikidata.org/entity/P42"");
		assertEquals(prop4.getIri(), ""http://www.example.org/entity/P42"");
	}",No Smells
"@Test
	public void testToJavaWithoutNumericalID() throws IOException {
		assertEquals(prop1, mapper.readValue(JSON_PROPERTY_ID_VALUE_WITHOUT_NUMERICAL_ID, ValueImpl.class));
	}",No Smells
"@Test
	public void gettersWorking() {
		assertEquals(q1.getNumericValue(), nv);
		assertEquals(q1.getLowerBound(), lb);
		assertEquals(q1.getUpperBound(), ub);
	}",No Smells
"@Test
	public void numValueNotNull() {
		assertThrows(NullPointerException.class, () -> new QuantityValueImpl(null, lb, ub, unitMeterId));
	}",No Smells
"@Test
	public void testToJson() throws JsonProcessingException {
		JsonComparator.compareJsonStrings(JSON_QUANTITY_VALUE, mapper.writeValueAsString(q1));
	}",No Smells
"@Test
	public void testUnboundedToJava() throws IOException {
		assertEquals(q3, mapper.readValue(JSON_UNBOUNDED_QUANTITY_VALUE, ValueImpl.class));
	}",No Smells
"@Test
	public void equalityBasedOnContent() {
		Reference r3 = new ReferenceImpl(Collections.emptyList());

		assertEquals(r1, r1);
		assertEquals(r1, r2);
		assertNotEquals(r1, r3);
		assertNotEquals(r1, null);
		assertNotEquals(r1, this);
	}",No Smells
"@Test
	public void hashBasedOnContent() {
		assertEquals(r1.hashCode(), r2.hashCode());
	}",No Smells
"@Test
	public void idIsCorrect() {
		assertEquals(sense1.getId(), ""L42-S1"");
	}",No Smells
"@Test
	public void siteIriIsCorrect() {
		assertEquals(sense1.getSiteIri(), ""http://www.wikidata.org/entity/"");
	}",No Smells
"@Test
	public void testToJson() throws JsonProcessingException {
		JsonComparator.compareJsonStrings(JSON_SENSE_ID_VALUE, mapper.writeValueAsString(sense1));
	}",No Smells
"@Test
	public void siteLinkIri() {
		SiteLink sSpecialChar = new SiteLinkImpl(""&"", ""dewiki"",
				Collections.emptyList());
		assertEquals(SitesImpl.DEFAULT_PROTOCOL_PREFIX
				+ ""//de.wikipedia.org/wiki/%26"",
				this.sites.getSiteLinkUrl(sSpecialChar));

		SiteLink sSpecialChar2 = new SiteLinkImpl(""Bjrk"", ""enwiki"",
				Collections.emptyList());
		assertEquals(""http://en.wikipedia.org/wiki/Bj%C3%B6rk"",
				this.sites.getSiteLinkUrl(sSpecialChar2));
	}",No Smells
"@Test
	public void equalityBasedOnContent() {
		List<Snak> snaks = new ArrayList<>();
		snaks.add(snak1);
		snaks.add(snak2);
		SnakGroup sg3 = new SnakGroupImpl(snaks);

		assertEquals(sg1, sg1);
		assertEquals(sg1, sg2);
		assertNotEquals(sg1, sg3);
		assertNotEquals(sg1, null);
		assertNotEquals(sg1, this);
	}",No Smells
"@Test
	public void implementsCollection() {
		assertFalse(sg1.isEmpty());
		assertEquals(1, sg1.size());
		assertTrue(sg1.contains(snak1));
		assertFalse(sg1.contains(snak2));
		assertTrue(sg1.iterator().hasNext());
		assertEquals(sg1.iterator().next(), snak1);
		assertArrayEquals(new Snak[] {snak1}",No Smells
"@Test
	public void propertyIsCorrect() {
		assertEquals(sg1.getProperty(), property);
	}",No Smells
"@Test
	public void testMonolingualTextValueSnakToJson() throws JsonProcessingException {
		JsonComparator.compareJsonStrings(JSON_MONOLINGUAL_TEXT_VALUE_SNAK, mapper.writeValueAsString(vsmt1));
		JsonComparator.compareJsonStrings(JSON_MONOLINGUAL_TEXT_VALUE_SNAK, mapper.writeValueAsString(vsmt2));
	}",No Smells
"@Test
	public void testValueSnakToJava() throws IOException {
		assertEquals(vs1, mapper.readValue(JSON_VALUE_SNAK, SnakImpl.class));
	}",No Smells
"@Test
	public void getBestStatementsWithoutPreferred() {
		assertEquals(
				new StatementGroupImpl(Collections.singletonList(statement1)),
				new StatementGroupImpl(Collections.singletonList(statement1)).getBestStatements()
		);
	}",No Smells
"@Test
	public void gettersWorking() {
		assertEquals(s1.getClaim(), claim);
		assertEquals(s1.getMainSnak(), mainSnak);
		assertEquals(s1.getQualifiers(), qualifiers);
		assertEquals(s1.getReferences(), references);
		assertEquals(s1.getRank(), StatementRank.PREFERRED);
		assertEquals(s1.getStatementId(), ""MyId"");
		assertEquals(s1.getValue(), value);
		assertEquals(s1.getSubject(), subjet);
	}",No Smells
"@Test
	public void referencesCanBeNull() {
		Statement statement = new StatementImpl(""MyId"", StatementRank.NORMAL, mainSnak,  Collections.emptyList(), null, value);
		assertTrue(statement.getReferences().isEmpty());
	}",No Smells
"@Test
	public void testStatementToJson() throws JsonProcessingException {
		JsonComparator.compareJsonStrings(JSON_STATEMENT, mapper.writeValueAsString(s1));
	}",No Smells
"@Test
	public void equalityBasedOnContent() {
		StringValue s3 = new StringValueImpl(""another string"");

		assertEquals(s1, s1);
		assertEquals(s1, s2);
		assertNotEquals(s1, s3);
		assertNotEquals(s1, null);
		assertNotEquals(s1, this);
	}",Eager Test
"@Test
	public void addSameStatementWithoutId() {
		Map<String, List<Statement>> added = TermedStatementDocumentImpl.addStatementToGroups(statementEmptyId, initialStatements);
		assertNotEquals(initialStatements, added);
	}",No Smells
"@Test
	public void dataIsCorrect() {
		assertEquals(mt1.getText(), ""some string"");
		assertEquals(mt1.getLanguageCode(), ""en"");
	}",No Smells
"@Test
	public void testToJava() throws IOException {
		assertEquals(mt1, mapper.readValue(JSON_TERM, TermImpl.class));
	}",No Smells
"@Test
	public void testToJson() throws JsonProcessingException {
		JsonComparator.compareJsonStrings(JSON_TERM, mapper.writeValueAsString(mt1));
	}",No Smells
"@Test
	public void getPreferredCalendarModelItemId() {
		assertEquals(new ItemIdValueImpl(""Q1985727"", ""http://www.wikidata.org/entity/""), t1.getPreferredCalendarModelItemId());
	}",No Smells
"@Test
	public void testToJson() throws JsonProcessingException {
		JsonComparator.compareJsonStrings(JSON_TIME_VALUE, mapper.writeValueAsString(t1));
	}",No Smells
"@Test
	public void getAllFullDumps() throws IOException {
		wrf.setWebResourceContentsFromResource(
				""https://dumps.wikimedia.org/wikidatawiki/"",
				""/wikidatawiki-index-old.html"", this.getClass());

		setLocalDump(""20140210"", DumpContentType.FULL, false);
		setLocalDump(""20140123"", DumpContentType.FULL, true);
		setLocalDump(""20140106"", DumpContentType.CURRENT, true);
		setLocalDump(""20131201"", DumpContentType.FULL, true);
		setLocalDump(""nodate"", DumpContentType.FULL, true);

		WmfDumpFileManager dumpFileManager = new WmfDumpFileManager(
				""wikidatawiki"", dm, wrf);

		List<? extends MwDumpFile> dumpFiles = dumpFileManager
				.findAllDumps(DumpContentType.FULL);

		String[] dumpDates = { ""20140210"", ""20140123"", ""20140106"", ""20131221"",
				""20131201"" }",Mystery Guest
"@Test
	public void emptyFullDumpIsDone() throws IOException {
		wrf.setWebResourceContentsFromResource(
				""http://dumps.wikimedia.org/wikidatawiki/20140210/"",
				""/wikidatawiki-20140210-index.html"", this.getClass());
		MwDumpFile dump = new WmfOnlineStandardDumpFile(""20140210"",
				""wikidatawiki"", wrf, dm, DumpContentType.FULL);

		assertFalse(dump.isAvailable());
		assertEquals(""20140210"", dump.getDateStamp());
		assertEquals(DumpContentType.FULL, dump.getDumpContentType());
	}",No Smells
"@Test
	public void inaccessibleCurrentDumpProperties() throws IOException {
		wrf.setWebResourceContentsFromResource(
				""http://dumps.wikimedia.org/wikidatawiki/20140210/"",
				""/wikidatawiki-20140210-index.html"", this.getClass());
		wrf.setWebResourceContents(
				""http://dumps.wikimedia.org/wikidatawiki/20140210/wikidatawiki-20140210-pages-meta-current.xml.bz2"",
				""Line1"");
		wrf.setWebResourceContentsFromResource(
				""http://dumps.wikimedia.org/wikidatawiki/20140210/wikidatawiki-20140210-md5sums.txt"",
				""/wikidatawiki-20140210-md5sums.txt"", this.getClass());
		wrf.setReturnFailingReaders(true);

		MwDumpFile dump = new WmfOnlineStandardDumpFile(""20140210"",
				""wikidatawiki"", wrf, dm, DumpContentType.CURRENT);

		assertFalse(dump.isAvailable());
	}",No Smells
"@Test
	public void validCurrentDumpPropertiesOldFormat() throws IOException {
		wrf.setWebResourceContentsFromResource(
				""https://dumps.wikimedia.org/wikidatawiki/20140210/"",
				""/wikidatawiki-20140210-index.html"", this.getClass());
		wrf.setWebResourceContents(
				""https://dumps.wikimedia.org/wikidatawiki/20140210/wikidatawiki-20140210-pages-meta-current.xml.bz2"",
				""Line1"", CompressionType.BZ2);
		wrf.setWebResourceContentsFromResource(
				""https://dumps.wikimedia.org/wikidatawiki/20140210/wikidatawiki-20140210-md5sums.txt"",
				""/wikidatawiki-20140210-md5sums.txt"", this.getClass());
		MwDumpFile dump = new WmfOnlineStandardDumpFile(""20140210"",
				""wikidatawiki"", wrf, dm, DumpContentType.CURRENT);

		BufferedReader br = dump.getDumpFileReader();

		assertEquals(br.readLine(), ""Line1"");
		assertNull(br.readLine());
		assertTrue(dump.isAvailable());
		assertEquals(""20140210"", dump.getDateStamp());
		assertEquals(DumpContentType.CURRENT, dump.getDumpContentType());
	}",No Smells
"@Test
	public void testEmptyBitVector() {
		BitVectorImpl bv0 = new BitVectorImpl();
		BitVector bv1 = new BitVectorImpl();
		assertEqualsForBitVector(bv0, bv1);

		BitVectorImpl bv2 = new BitVectorImpl(0);
		assertEqualsForBitVector(bv1, bv2);
	}",No Smells
"@Test
	public void testAdd() {
		BitVectorImpl bv = new BitVectorImpl();
		Assert.assertEquals(0, bv.size());

		bv.addBit(true);
		Assert.assertEquals(1, bv.size());
		Assert.assertTrue(bv.getBit(0));

		bv.addBit(false);
		Assert.assertEquals(2, bv.size());
		Assert.assertFalse(bv.getBit(1));

		bv.addBit(false);
		Assert.assertEquals(3, bv.size());
		Assert.assertFalse(bv.getBit(2));

		for (int i = 3; i < 0x1000; i++) {
			boolean value = (i % 3) == 0;
			bv.addBit(value);
			Assert.assertEquals(value, bv.getBit(i));
		}",No Smells
"@Test
	public void testAdd() {
		RankedBitVectorImpl bv = new RankedBitVectorImpl();
		Assert.assertEquals(0, bv.size());

		bv.addBit(true);
		Assert.assertEquals(1, bv.size());
		Assert.assertTrue(bv.getBit(0));

		bv.addBit(false);
		Assert.assertEquals(2, bv.size());
		Assert.assertFalse(bv.getBit(1));

		bv.addBit(false);
		Assert.assertEquals(3, bv.size());
		Assert.assertFalse(bv.getBit(2));

		for (int i = 3; i < 0x1000; i++) {
			boolean value = (i % 3) == 0;
			bv.addBit(value);
			Assert.assertEquals(value, bv.getBit(i));
			assertCorrectCount(bv, i);
		}",No Smells
"@Test
	public void createFileFromInputStream() throws IOException {
		InputStream inputStream = MockStringContentFactory
				.newMockInputStream(""New stream contents\nMultiple lines"");
		mdm.createFile(""newfile.txt"", inputStream);
		String content = MockStringContentFactory.getStringFromInputStream(mdm
				.getInputStreamForFile(""newfile.txt"", CompressionType.NONE));
		assertEquals(""New stream contents\nMultiple lines"", content);
	}",No Smells
"@Test
	public void createFileUsingOutputstream() throws IOException {
		OutputStream out = mdm.getOutputStreamForFile(""newfile.txt"");

		BufferedWriter ow = new BufferedWriter(new OutputStreamWriter(out));
		ow.write(""New contents"");
		ow.close();

		String content = MockStringContentFactory.getStringFromInputStream(mdm
				.getInputStreamForFile(""newfile.txt"", CompressionType.NONE));
		assertEquals(""New contents"", content);
	}",No Smells
"@Test
	public void newSubdirectoryManager() throws IOException {
		mdm.getSubdirectoryManager(""newdir"");
		assertTrue(mdm.hasSubdirectory(""newdir""));
	}",No Smells
"@Test
	public void inputStreamForHtml() throws IOException {
		String content = MockStringContentFactory.getStringFromInputStream(mwrf
				.getInputStreamForUrl(""http://example.com/test.html""));
		assertEquals(content, ""Line1\nLine2"");
	}",No Smells
"@Test
	public void setConcentsFromResource() throws IOException {
		mwrf.setWebResourceContentsFromResource(
				""http://example.com/resource.html"", ""/test.txt"",
				this.getClass());
		String content = MockStringContentFactory.getStringFromInputStream(mwrf
				.getInputStreamForUrl(""http://example.com/resource.html""));
		assertEquals(content, ""This file is here\nto test resource loading."");
	}",No Smells
"@Test
	public void testToString() {
		assertEquals(Paths.get(System.getProperty(""user.dir"")).toString(),
				dm.toString());
	}",No Smells
"@Test
	public void testSetProxy() {
		Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(
				""test.adress"", 8080));
		WebResourceFetcherImpl.setProxy(proxy);
		assertTrue(WebResourceFetcherImpl.hasProxy());
		assertEquals(proxy, WebResourceFetcherImpl.getProxy());
	}",No Smells
"@Test
	public void testSetUserAgent() {
		WebResourceFetcherImpl.setUserAgent(""My user agent"");
		assertEquals(""My user agent"", WebResourceFetcherImpl.getUserAgent());
	}",No Smells
"@Test
	public void testDeserialize() throws IOException {
		BasicApiConnection newConnection = mapper.readValue(LOGGED_IN_SERIALIZED_CONNECTION, BasicApiConnection.class);
		assertTrue(newConnection.isLoggedIn());
		assertEquals(""username"", newConnection.getCurrentUser());
		assertEquals(5000, newConnection.getConnectTimeout());
		assertEquals(6000, newConnection.getReadTimeout());
		assertEquals(server.url(""/w/api.php"").toString(), newConnection.getApiBaseUrl());
		List<HttpCookie> cookies = newConnection.getCookies();
		for (HttpCookie cookie : cookies) {
			if (cookie.getName().equals(""GeoIP"")) {
				assertEquals(""DE:13:Dresden:51.0500:13.7500:v4"", cookie.getValue());
			}",No Smells
"@Test
	public void testDeleteAndAdd() {
		// Explicitly deleted statement won't merge
		Reference r1 = ReferenceBuilder.newInstance().withPropertyValue(P1, Q1)
				.build();
		Reference r2 = ReferenceBuilder.newInstance().withPropertyValue(P2, Q2)
				.build();

		Statement s3 = StatementBuilder.forSubjectAndProperty(Q1, P2)
				.withReference(r1).withValue(Q1).withId(""ID-s3"").build();
		Statement s4 = StatementBuilder.forSubjectAndProperty(Q1, P2)
				.withReference(r2).withValue(Q1).withId(""ID-s4"").build();

		ItemDocument currentDocument = ItemDocumentBuilder.forItemId(Q1)
				.withStatement(s4).build();

		List<Statement> addStatements = Collections.singletonList(s3);
		List<Statement> deleteStatements = Collections.singletonList(s4);

		StatementUpdate su = new StatementUpdate(currentDocument,
				addStatements, deleteStatements);

		assertTrue(su.toDelete.contains(""ID-s4""));
		assertTrue(su.toKeep.containsKey(P2));
		assertEquals(1, su.toKeep.get(P2).size());
		assertEquals(s3, su.toKeep.get(P2).get(0).statement);
		assertFalse(su.isEmptyEdit());
	}",Eager Test
"@Test
	public void testDeleteAndAdd() {
		// Explicitly deleted statement won't merge
		Reference r1 = ReferenceBuilder.newInstance().withPropertyValue(P1, Q1)
				.build();
		Reference r2 = ReferenceBuilder.newInstance().withPropertyValue(P2, Q2)
				.build();

		Statement s3 = StatementBuilder.forSubjectAndProperty(Q1, P2)
				.withReference(r1).withValue(Q1).withId(""ID-s3"").build();
		Statement s4 = StatementBuilder.forSubjectAndProperty(Q1, P2)
				.withReference(r2).withValue(Q1).withId(""ID-s4"").build();

		ItemDocument currentDocument = ItemDocumentBuilder.forItemId(Q1)
				.withStatement(s4).build();

		List<Statement> addStatements = Collections.singletonList(s3);
		List<Statement> deleteStatements = Collections.singletonList(s4);

		StatementUpdate su = new StatementUpdate(currentDocument,
				addStatements, deleteStatements);

		assertTrue(su.toDelete.contains(""ID-s4""));
		assertTrue(su.toKeep.containsKey(P2));
		assertEquals(1, su.toKeep.get(P2).size());
		assertEquals(s3, su.toKeep.get(P2).get(0).statement);
		assertFalse(su.isEmptyEdit());
	}",Eager Test
"@Test
	public void testMergeNew() {
		// Additions of duplicates are merged
		Statement s1 = StatementBuilder.forSubjectAndProperty(Q1, P3)
				.withValue(Q1).build();
		Statement s2 = StatementBuilder.forSubjectAndProperty(Q1, P3)
				.withValue(Q1).build();

		ItemDocument currentDocument = ItemDocumentBuilder.forItemId(Q1)
				.build();

		StatementUpdate su = new StatementUpdate(currentDocument,
				Arrays.asList(s1, s2), Collections.emptyList());

		assertEquals(0, su.toDelete.size());
		assertEquals(1, su.toKeep.size());
		assertTrue(su.toKeep.containsKey(P3));
		assertEquals(1, su.toKeep.get(P3).size());
		assertEquals(s1, su.toKeep.get(P3).get(0).statement);
		assertTrue(su.toKeep.get(P3).get(0).write);
		assertFalse(su.isEmptyEdit());
	}",No Smells
"@Test
	public void testNoMergeDiffMainSnak() {
		Statement s1 = StatementBuilder.forSubjectAndProperty(Q1, P1)
				.withValue(Q1).withId(""ID-s1"").build();
		Statement s2 = StatementBuilder.forSubjectAndProperty(Q1, P1)
				.withValue(Q2).build();

		ItemDocument currentDocument = ItemDocumentBuilder.forItemId(Q1)
				.withStatement(s1).build();

		StatementUpdate su = new StatementUpdate(currentDocument,
				Collections.singletonList(s2), Collections.emptyList());

		assertEquals(0, su.toDelete.size());
		assertEquals(1, su.toKeep.size());
		assertTrue(su.toKeep.containsKey(P1));
		assertEquals(2, su.toKeep.get(P1).size());
		assertEquals(s2, su.toKeep.get(P1).get(0).statement);
		assertTrue(su.toKeep.get(P1).get(0).write);
		assertEquals(s1, su.toKeep.get(P1).get(1).statement);
		assertFalse(su.toKeep.get(P1).get(1).write);
	}",No Smells
"@Test
	public void testAddAliasWithoutLabel() {
		ItemDocument currentDocument = ItemDocumentBuilder.forItemId(Q1).build();
		
		MonolingualTextValue alias = Datamodel.makeMonolingualTextValue(""Apfelstrudel"", ""de"");
		TermStatementUpdate su = makeUpdate(currentDocument,
				Collections.emptyList(),
				Collections.emptyList(),
				Collections.singletonList(alias),
				Collections.emptyList());
		
		
		assertEquals(su.getLabelUpdates().keySet(), Collections.singleton(""de""));
		assertEquals(su.getLabelUpdates().get(""de"").getText(), alias.getText());
		assertTrue(su.getAliasUpdates().isEmpty());
		assertTrue(su.getDescriptionUpdates().isEmpty());
		assertFalse(su.isEmptyEdit());
	}",No Smells
"@Test
  public void shouldCreateNullCacheKeyWhenRequestDoesNotGroupName() {
    when(mockGroupExtractor.getGroupName(mockRequest)).thenReturn(null);
    when(mockGroupExtractor.getResourceType(mockRequest)).thenReturn(ResourceType.CSS);
    assertNull(victim.create(mockRequest));
  }",No Smells
"@Test
  public void shouldCreateValidCacheKeyWhenRequestContainsAllRequiredInfo() {
    when(mockGroupExtractor.isMinimized(mockRequest)).thenReturn(true);
    when(mockGroupExtractor.getGroupName(mockRequest)).thenReturn(""g1"");
    when(mockGroupExtractor.getResourceType(mockRequest)).thenReturn(ResourceType.CSS);
    assertEquals(new CacheKey(""g1"", ResourceType.CSS, true), victim.create(mockRequest));
  }",No Smells
"@Test
  public void shouldDecorateCacheStrategy() {
    final CacheStrategy<CacheKey, CacheValue> original = new LruMemoryCacheStrategy<CacheKey, CacheValue>();
    victim = (DefaultSynchronizedCacheStrategyDecorator) DefaultSynchronizedCacheStrategyDecorator.decorate(original);
    assertTrue(victim instanceof DefaultSynchronizedCacheStrategyDecorator);
    assertSame(original, ((ObjectDecorator<?>) victim).getDecoratedObject());
  }",No Smells
"@Test
  public void shouldDestroySchedulerWhenStrategyIsDestroyed() {
    final SchedulerHelper scheduler = Mockito.mock(SchedulerHelper.class);
    victim = new DefaultSynchronizedCacheStrategyDecorator(new MemoryCacheStrategy<CacheKey, CacheValue>()) {
      @Override
      SchedulerHelper newResourceWatcherScheduler() {
        return scheduler;
      }",No Smells
"@Test
  public void shouldNotRedundantlyDecorateCacheStrategy() {
    final CacheStrategy<CacheKey, CacheValue> original = DefaultSynchronizedCacheStrategyDecorator.decorate(new LruMemoryCacheStrategy<CacheKey, CacheValue>());
    victim = (DefaultSynchronizedCacheStrategyDecorator) DefaultSynchronizedCacheStrategyDecorator.decorate(original);
    assertTrue(victim instanceof DefaultSynchronizedCacheStrategyDecorator);
    assertSame(original, victim);
  }",No Smells
"@Test
  public void shouldDifferWhenContainingDifferentAttributes() {
    final CacheKey key1 = createValidCacheKey().addAttribute(""k1"", ""v1"").addAttribute(""k2"", ""v2"");
    final CacheKey key2 = createValidCacheKey().addAttribute(""k1"", ""v1"");
    assertFalse(key1.equals(key2));
    assertFalse(key1.hashCode() == key2.hashCode());
  }",No Smells
"@Test
  public void byDefaultCacheGzippedContentShouldBeDisabled() {
    Assert.assertFalse(Context.get().getConfig().isCacheGzippedContent());
  }",No Smells
"@Test
  public void testConfigurationTypeBackwardCompatibility() {
    Mockito.when(filterConfig.getInitParameter(ConfigConstants.debug.getPropertyKey())).thenReturn(""true"");
    Mockito.when(filterConfig.getInitParameter(FilterConfigWroConfigurationFactory.PARAM_CONFIGURATION)).thenReturn(
    		DeploymentMode.DEPLOYMENT.toString());
    factory = new FilterConfigWroConfigurationFactory(filterConfig);
    final WroConfiguration config = factory.create();
    Assert.assertEquals(false, config.isDebug());
  }",No Smells
"@Test
  public void testConfigureCacheUpdatePeriod() {
    Mockito.when(filterConfig.getInitParameter(ConfigConstants.cacheUpdatePeriod.getPropertyKey())).thenReturn(""10"");
    factory = new FilterConfigWroConfigurationFactory(filterConfig);
    final WroConfiguration config = factory.create();
    Assert.assertEquals(10, config.getCacheUpdatePeriod());
    Assert.assertEquals(true, config.isDebug());
  }",No Smells
"@Test
  public void testConfigureDebug() {
    Mockito.when(filterConfig.getInitParameter(ConfigConstants.debug.getPropertyKey())).thenReturn(""false"");
    factory = new FilterConfigWroConfigurationFactory(filterConfig);
    final WroConfiguration config = factory.create();
    Assert.assertEquals(false, config.isDebug());
  }",No Smells
"@Test
  public void shouldBuildConfigurationEvenWhenDefaultPropertiesFileIsNotAvailable() {
    factory = new PropertiesAndFilterConfigWroConfigurationFactory(filterConfig) {
      @Override
      protected Properties newDefaultProperties(){
        throw new WroRuntimeException(""Cannot build default properties found"");
      }",No Smells
"@Test
  public void testConfigureCacheUpdatePeriodWithPropertiesFileSet() {
    factory = new PropertiesAndFilterConfigWroConfigurationFactory(filterConfig) {
      @Override
      protected Properties newDefaultProperties(){
        final Properties props = new Properties();
        props.put(ConfigConstants.cacheUpdatePeriod.getPropertyKey(), ""15"");
        props.put(ConfigConstants.modelUpdatePeriod.getPropertyKey(), ""30"");
        return props;
      }",No Smells
"@Test
  public void testConfigureDebugWithPropertiesFileSet() {
    factory = new PropertiesAndFilterConfigWroConfigurationFactory(filterConfig) {
      @Override
      protected Properties newDefaultProperties(){
        final Properties props = new Properties();
        props.put(ConfigConstants.debug.getPropertyKey(), Boolean.TRUE.toString());
        return props;
      }",No Smells
"@Test
  public void createDefaultConfig() {
    final WroConfiguration config = factory.create();
    LOG.debug(""config: {}",No Smells
"@Test
  public void invalidBooleanFallbacksToFalse() {
    final Properties props = new Properties();
    props.setProperty(ConfigConstants.cacheGzippedContent.getPropertyKey(), ""INVALID_BOOLEAN"");

    factory = new PropertyWroConfigurationFactory(props);
    final WroConfiguration config = factory.create();

    assertEquals(false, config.isCacheGzippedContent());
  }",No Smells
"@Test
  public void shouldBuildDefaultConfigurationWhenConfigStreamIsNull() {
    Mockito.when(mockServletContext.getResourceAsStream(Mockito.anyString())).thenReturn(null);
    victim = new ServletContextPropertyWroConfigurationFactory(mockServletContext);
    Assert.assertNotNull(victim.create());
  }",No Smells
"@Test
  public void shouldCreateConfigFromValidLocationAndOverrideAProperty()
      throws Exception {
    final long connectionTimeout = 10000;
    final Properties props = new Properties();
    props.setProperty(ConfigConstants.connectionTimeout.getPropertyKey(), String.valueOf(connectionTimeout));
    final StringWriter propertiesWriter = new StringWriter();
    props.store(new WriterOutputStream(propertiesWriter), """");
    Mockito.when(mockServletContext.getResourceAsStream(Mockito.anyString())).thenReturn(
        new ByteArrayInputStream(propertiesWriter.toString().getBytes()));
    Assert.assertEquals(connectionTimeout, victim.create().getConnectionTimeout());
  }",No Smells
"@Test
  public void shouldCreateEmptyMapByDefault() {
    assertTrue(victim.create().isEmpty());
  }",No Smells
"@Test
  public void shouldNotAcceptRequestsWithWrongURI() {
    when(mockRequest.getRequestURI()).thenReturn(""/path/to/anotherURI"");
    assertFalse(victim.accept(mockRequest));
  }",No Smells
"@Test
	public void shouldCreateValidUri() {
		assertEquals(""webjar:/path/to/resource.js"", WebjarUriLocator.createUri(""/path/to/resource.js""));
	}",No Smells
"@Test
  public void defaultModelFactoryIsXml() {
    new BaseWroManagerFactory() {
      @Override
      protected WroModelFactory newModelFactory() {
        final WroModelFactory modelFactory = super.newModelFactory();
        Assert.assertEquals(XmlModelFactory.class, modelFactory.getClass());
        return modelFactory;
      }",No Smells
"@Test
  public void createValidModel() {
    factory = new GroovyModelFactory() {
      @Override
      protected InputStream getModelResourceAsStream()
          throws IOException {
        return TestGroovyModelFactory.class.getResourceAsStream(""wro.groovy"");
      }",Mystery Guest + Resource Optimism
"@Test
  public void createValidModelContainingHiphen() {
    factory = new GroovyModelFactory() {
      @Override
      protected InputStream getModelResourceAsStream()
          throws IOException {
        return getClass().getResourceAsStream(""wroWithHiphen.groovy"");
      }",Mystery Guest + Resource Optimism
"@Test
  public void createIncompleteModel() {
    factory = new JsonModelFactory() {
      @Override
      protected InputStream getModelResourceAsStream()
          throws IOException {
        return getClass().getResourceAsStream(""incomplete-wro.json"");
      }",Mystery Guest + Resource Optimism
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(new LessCssProcessor(), ResourceType.CSS);
  }",No Smells
"@Test
  public void shouldUseFallbackProcessorWhenNodeNotSupported()
      throws Exception {
    when(mockNodeProcessor.isSupported()).thenReturn(false);
    victim.process(mockResource, mockReader, mockWriter);
    verify(mockNodeProcessor, Mockito.never()).process(mockResource, mockReader, mockWriter);
    verify(mockRhinoProcessor, Mockito.times(1)).process(mockResource, mockReader, mockWriter);
  }",No Smells
"@Test
  public void shouldNotFailWhenProcessorIsCreatedConcurrently()
      throws Exception {
    WroTestUtils.runConcurrently(ContextPropagatingCallable.decorate(new Callable<Void>() {
      @Override
      public Void call()
          throws Exception {
        victim.process(new StringReader(""""), new NullWriter());
        return null;
      }",No Smells
"@Test
  public void shouldProcessInvalidJsUnchanged()
      throws Exception {
    final String invalidJs = ""qwertwi42o"";
    final StringWriter writer = new StringWriter();
    victim.process(new StringReader(invalidJs), writer);
    assertEquals(invalidJs, writer.toString());
  }",No Smells
"@Test
  public void testFromFolder()
      throws Exception {
    final URL url = getClass().getResource(""../ngannotate"");

    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""js"", victim);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldProcessInvalidJsUnchanged()
      throws Exception {
    final String invalidJs = ""qwertwi42o"";
    final StringWriter writer = new StringWriter();
    victim.process(new StringReader(invalidJs), writer);
    assertEquals(invalidJs + "";"", writer.toString());
  }",No Smells
"@Test
  public void testFromFolder()
      throws Exception {
    final URL url = getClass().getResource(""../ngmin"");

    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""js"", victim);
  }",Mystery Guest + Resource Optimism
"@Test
  public void emptyStringShouldBeValid()
      throws Exception {
    final String options = null;
    jsHint.setOptions(options);
    jsHint.validate("""");
  }",No Smells
"@Test
  public void shouldValidateWithMultipleOptions()
      throws Exception {
    jsHint.setOptions(""indent"", ""eqeqeq"");
    jsHint.validate(VALID_JS);
  }",No Smells
"@Test
  public void shouldValidateWithNoOptions()
      throws Exception {
    jsHint.validate(VALID_JS);
  }",No Smells
"@Test
  public void testSetNullOptions()
      throws Exception {
    final String options = null;
    jsHint.setOptions(options);
    jsHint.validate(VALID_JS);
  }",No Smells
"@Test
  public void splitingEmptyOption() {
    assertTrue(Arrays.equals(new String[] { """" }",No Smells
"@Test
  public void splitingOneOption() {
    assertTrue(Arrays.equals(new String[] { ""o1"" }",No Smells
"@Test
  public void splitOptionsWithHiphen() {
    final String option = ""ids,adjoining-classes,box-model,box-sizing,compatible-vendor-prefixes,display-property-grouping,duplicate-background-images,duplicate-properties,empty-rules,errors,fallback-colors,floats,font-faces,font-sizes,gradients,import,important,known-properties,outline-none,overqualified-elements,qualified-headings,regex-selectors,rules-count,shorthand,text-indent,unique-headings,universal-selector,unqualified-attributes"";
    final String[] result = optionsBuilder.splitOptions(option);
    assertEquals(28, result.length);
  }",No Smells
"@Test
  public void shouldProcessValidCss()
    throws IOException {
    assertEquals(""#element {\n  color: red; }",No Smells
"@Test
  public void shouldProcessValidNonAsciiSass()
    throws IOException {
    assertEquals(""@charset \""UTF-8\"";\n#element {\n  font-family: \""\uFF2D\uFF33 \uFF30\u30B4\u30B7\u30C3\u30AF\""; }",No Smells
"@Test
  public void shouldReturnEmptyStringWhenEmptyContentIsProcessed() {
    assertEquals(StringUtils.EMPTY, engine.process(""""));
  }",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(new BeautifyJsProcessor(), ResourceType.JS);
  }",No Smells
"@Test
  public void shouldBeThreadSafe() throws Exception {
    genericThreadSafeTest(true);
    genericThreadSafeTest(false);
  }",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(victim, ResourceType.CSS);
  }",No Smells
"@Test
  public void testFromFolder()
      throws IOException {
    final URL url = getClass().getResource(""csslint"");

    final File testFolder = new File(url.getFile());
    WroTestUtils.compareFromSameFolder(testFolder, new WildcardFileFilter(""*.css""), Transformers.noOpTransformer(),
        victim);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldAcceptNullExterns()
      throws IOException {
    victim = new GoogleClosureCompressorProcessor(CompilationLevel.ADVANCED_OPTIMIZATIONS) {
      @Override
      protected SourceFile[] getExterns(final Resource resource) {
        return null;
      }",No Smells
"@Test
  public void shouldMinimizeWhenUsedAsLazyProcessor()
      throws Exception {
    final ResourcePreProcessor victim = new LazyProcessorDecorator(new LazyInitializer<ResourcePreProcessor>() {
      @Override
      protected ResourcePreProcessor initialize() {
        return new GoogleClosureCompressorProcessor();
      }",No Smells
"@Test
  public void testAdvancedOptimization()
      throws IOException {
    victim.setCompilationLevel(CompilationLevel.ADVANCED_OPTIMIZATIONS);
    final URL url = getClass().getResource(""google"");

    final File expectedFolder = new File(url.getFile(), ""expectedAdvanced"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""js"", (ResourcePreProcessor) victim);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldBeThreadSafe() throws Exception {
    final HoganJsProcessor processor = new HoganJsProcessor();
    final Callable<Void> task = new Callable<Void>() {
      @Override
      public Void call() {
        try {
          processor.process(null, new StringReader(""Hello {{name}",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(processor, ResourceType.JS);
  }",No Smells
"@Test
  public void canSetNullOptions()
      throws Exception {
    victim.setOptionsAsString("""");
    victim.process(null, new StringReader(""alert(1);""), new StringWriter());
  }",No Smells
"@Test
  public void testPackFromFolder()
      throws Exception {
    final ResourcePostProcessor processor = JsonHPackProcessor.packProcessor();
    final URL url = getClass().getResource(""jsonhpack"");

    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""pack"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""js"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldBeThreadSafe() throws Exception {
    final Callable<Void> task = new Callable<Void>() {
      @Override
      public Void call() {
        try {
          victim.process(null, new StringReader(""#id {.class {color: red;}",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(new Less4jProcessor(), ResourceType.CSS);
  }",No Smells
"@Test
  public void shouldBeThreadSafe() throws Exception {
    final NodeCoffeeScriptProcessor processor = new NodeCoffeeScriptProcessor() {
      @Override
      protected void onException(final Exception e, final String content) {
        throw WroRuntimeException.wrap(e);
      }",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(new NodeLiterateCoffeeScriptProcessor(), ResourceType.JS);
  }",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(new NodeTypeScriptProcessor(), ResourceType.JS);
  }",No Smells
"@Test
  public void testFromFolder()
      throws Exception {
    final ResourcePostProcessor processor = new NodeTypeScriptProcessor();
    final URL url = getClass().getResource(""typescript"");

    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""js"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldApplyPatternsWhenExcludeNotMatches()
      throws Exception {
    checkThatExclusionNotMatches(""/a/path/to.js"", ""/**/*.less"");
    checkThatExclusionNotMatches(""/b/path/to.css"", ""/a/*/to.*"");
    checkThatExclusionNotMatches(""/a/path/inner/bo.css"", ""/a/**/to.*"");
    checkThatExclusionNotMatches(""/a/b/c/aame.css"", ""/a/**/n?me.css"");
    checkThatExclusionNotMatches(""/a/b/c/name.less"", ""/a/**/n?me.js"", ""/a/**/n?me.c?s"");
  }",No Smells
"@Test
  public void shouldNotApplyPatternsWhenIncludeMatches()
      throws Exception {
    checkThatInclusionNotMatches(""/a/path/to.js"", ""/**/*.less"");
    checkThatInclusionNotMatches(""/b/path/to.css"", ""/a/*/to.*"");
    checkThatInclusionNotMatches(""/a/path/inner/bo.css"", ""/a/**/to.*"");
    checkThatInclusionNotMatches(""/a/b/c/aame.css"", ""/a/**/n?me.css"");
    checkThatInclusionNotMatches(""/a/b/c/name.less"", ""/a/**/n?me.js"", ""/a/**/n?me.c?s"");
  }",No Smells
"@Test
  public void shouldBeThreadSafe()
      throws Exception {
    final RhinoLessCssProcessor processor = new RhinoLessCssProcessor() {
      @Override
      protected void onException(final WroRuntimeException e) {
        throw e;
      }",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(new RhinoLessCssProcessor(), ResourceType.CSS);
  }",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(processor, ResourceType.JS);
  }",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(new RhinoTypeScriptProcessor(), ResourceType.JS);
  }",No Smells
"@Test
  public void executeMultipleTimesDoesntThrowOutOfMemoryException() {
    final RubySassEngine engine = new RubySassEngine();
    for (int i = 0; i < 100; i++) {
      engine.process(""#navbar {width: 80%;}",No Smells
"@Test
  public void shouldBeThreadSafe()
      throws Exception {
    final Callable<Void> task = new Callable<Void>() {
      @Override
      public Void call() {
        try {
          processor.process(new StringReader(
              ""$side: top;$radius: 10px;.rounded-#{$side}",No Smells
"@Test
  public void shouldBeThreadSafeWhenInitializingProcessor()
          throws Exception {
    final RubySassCssProcessor processor = new RubySassCssProcessor();
    final Callable<Void> task = new Callable<Void>() {
      @Override
      public Void call() {
        try {
          // This should be called first time in multi-thread.
          processor.process(new StringReader(
                  ""$side: top;$radius: 10px;.rounded-#{$side}",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(new UglifyJsProcessor(), ResourceType.JS);
  }",No Smells
"@Test
  public void shouldUglifyFiles()
      throws IOException {
    final ResourcePostProcessor processor = new UglifyJsProcessor();
    final URL url = getClass().getResource(""uglify"");

    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""js"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldMininimizeCss()
      throws IOException {
    final URL url = getClass().getResource(""yui"");

    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""css"", victim);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(victim, ResourceType.CSS);
  }",No Smells
"@Test
  public void shouldHaveConfiguredLints() {
    victim.setLints(Arrays.asList(""1"", ""2"", ""3""));
    assertEquals(3, victim.getLints().size());
  }",No Smells
"@Test
  public void shouldHaveUnknownPathWhenNullPathIsSet() {
    victim.setResourcePath(null);
    assertEquals(ResourceLintReport.UNKNOWN_PATH, victim.getResourcePath());
  }",No Smells
"@Test
  public void shouldHavePostProcessors() {
    assertTrue(!victim.providePostProcessors().isEmpty());
  }",No Smells
"@Test
  public void shouldReturnEmptyListByDefault() {
    assertEquals(Collections.EMPTY_LIST, victim.getConfiguredStrategies());
  }",No Smells
"@Test
  public void shouldNotFailWhenEachHandlerIsInvoked() {
    final Map<String, RequestHandler> map = victim.provideRequestHandlers();
    for (final RequestHandler handler : map.values()) {
      WroTestUtils.createInjector().inject(handler);
      handler.accept(mockRequest);
      handler.isEnabled();
    }",No Smells
"@Test
  public void shouldHandleRequest() {
    when(request.getRequestURI()).thenReturn(""wroApi/reloadCache"");
    assertTrue(victim.accept(request));
  }",No Smells
"@Test
  public void shouldAlwaysBeEnabled() {
    assertTrue(victim.isEnabled());
  }",No Smells
"@Test
  public void shouldSetResponseLength()
      throws IOException {
    final String resourceUri = ""classpath:"" + packagePath + ""/"" + ""test.css"";
    when(mockAuthorizationManager.isAuthorized(resourceUri)).thenReturn(true);
    when(request.getParameter(ResourceProxyRequestHandler.PARAM_RESOURCE_ID)).thenReturn(resourceUri);
    when(mockUriLocator.locate(anyString())).thenReturn(new ClasspathUriLocator().locate(resourceUri));

    victim.handle(request, response);
    final int expectedLength = IOUtils.toString(getInputStream(""test.css""), Charset.defaultCharset()).length();

    verify(response, times(1)).setContentLength(expectedLength);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldNotAcceptRequestThatIsNotDispatchedByServer() {
    when(request.getRequestURI()).thenReturn(""wroAPI/resourceWatch"");
    assertFalse(victim.accept(request));
  }",No Smells
"@Test
  public void shouldNotAcceptRequestThatIsNotDispatchedByServer() {
    when(request.getRequestURI()).thenReturn(""wroAPI/resourceWatch"");
    assertFalse(victim.accept(request));
  }",No Smells
"@Test
  public void shouldRedirectStreamWhenSendRedirectIsInvoked() throws Exception {
    final String message = ""Hello world!"";
    victim = new RedirectedStreamServletResponseWrapper(redirectedStream, mockResponse) {
      @Override
      protected UriLocator newExternalResourceLocator() {
        return new ClasspathUriLocator() {
          @Override
          public InputStream locate(final String uri)
              throws IOException {
            return new ByteArrayInputStream(message.getBytes());
          }",No Smells
"@Test
  public void shouldHaveNoConfiguredHeadersWhenDefaultHeadersAreNotSet() {
    victim = ResponseHeadersConfigurer.emptyHeaders();
    assertTrue(victim.getHeadersMap().entrySet().isEmpty());
  }",No Smells
"@Test
  public void shouldLoadWroManagerFactoryFromServletContextAttribute() throws Exception {
    final WroFilter filter = new WroFilter();
    final WroManagerFactory expectedManagerFactory = new BaseWroManagerFactory();
    final ServletContextAttributeHelper helper = new ServletContextAttributeHelper(mockServletContext);
    Mockito.when(mockServletContext.getAttribute(helper.getAttributeName(Attribute.MANAGER_FACTORY))).thenReturn(expectedManagerFactory);
    //reset it because it was initialized in test setup.
    filter.setWroManagerFactory(null);
    filter.init(mockFilterConfig);
    Assert.assertSame(expectedManagerFactory, AbstractDecorator.getOriginalDecoratedObject(filter.getWroManagerFactory()));
  }",No Smells
"@Test
  public void shouldUseConfiguredMBeanNameWhenSet()
      throws Exception {
    final String mbeanName = ""mbean"";
    final ConfigurableWroFilter filter = new SampleConfigurableWroFilter() {
      @Override
      protected void onRequestProcessed() {
        assertEquals(mbeanName, Context.get().getConfig().getMbeanName());
      }",No Smells
"@Test
  public void shouldUseDefaultEncodingWhenNoEncodingIsSet()
      throws Exception {
    final ConfigurableWroFilter filter = new SampleConfigurableWroFilter() {
      @Override
      protected void onRequestProcessed() {
        assertEquals(ConfigConstants.encoding.getDefaultPropertyValue(), Context.get().getConfig().getEncoding());
      }",No Smells
"@Test
  public void testFilterWithPropertiesSet()
      throws Exception {
    final ConfigurableWroFilter filter = new ConfigurableWroFilter() {
      @Override
      protected void onRequestProcessed() {
        assertEquals(10, Context.get().getConfig().getCacheUpdatePeriod());
      }",No Smells
"@Test
  public void shouldNotFailWhenContextInitializedAndDestroyed() {
    victim.contextInitialized(mockServletContextEvent);
    victim.contextDestroyed(mockServletContextEvent);
    victim.contextInitialized(mockServletContextEvent);
  }",No Smells
"@Test
  public void defaultModelFactoryIsXml() {
    new BaseWroManagerFactory() {
      @Override
      protected WroModelFactory newModelFactory() {
        final WroModelFactory modelFactory = super.newModelFactory();
        Assert.assertEquals(XmlModelFactory.class, modelFactory.getClass());
        return modelFactory;
      }",No Smells
"@Test
  public void shouldBeThreadSafe()
      throws Exception {
    // Mockito.when(mockRequest.getRequestURI()).thenReturn(""/a/resource.js"");
    final WroManagerFactory managerFactory = new BaseWroManagerFactory();
    WroTestUtils.runConcurrently(new ContextPropagatingCallable<Void>(new Callable<Void>() {
      public Void call()
          throws Exception {
        // Context.set(Context.webContext(mockRequest, mockResponse, mockFilterConfig));
        managerFactory.create().process();
        // Context.unset();
        return null;
      }",No Smells
"@Test
  public void shouldCreateManager()
      throws Exception {
    final WroManager manager = victim.create();
    Assert.assertNotNull(manager);
    Assert.assertEquals(NoOpNamingStrategy.class, manager.getNamingStrategy().getClass());
  }",No Smells
"@Test
  public void shouldNotFailWhenReloadingModelOutsideOfContext()
      throws Exception {
    Context.unset();
    victim.onModelPeriodChanged(0);
  }",No Smells
"@Test
  public void shouldHaveNoLocatorsWhenNoLocatorsInitParamSet() {
    createManager();
    Mockito.when(mockFilterConfig.getInitParameter(ConfigurableLocatorFactory.PARAM_URI_LOCATORS)).thenReturn("""");
    assertTrue(uriLocatorFactory.getConfiguredStrategies().isEmpty());
  }",No Smells
"@Test
  public void testConfigPropertiesWithValidPostProcessor() {
    final Properties configProperties = new Properties();
    configProperties.setProperty(ConfigurableProcessorsFactory.PARAM_POST_PROCESSORS, ""jsMin"");
    victim.setConfigProperties(configProperties);

    createManager();

    assertEquals(1, processorsFactory.getPostProcessors().size());
    assertEquals(JSMinProcessor.class,
        ((ProcessorDecorator) processorsFactory.getPostProcessors().iterator().next()).getDecoratedObject().getClass());
  }",No Smells
"@Test
  public void testWithEmptyPreProcessors() {
    createManager();

    configureValidUriLocators(mockFilterConfig);
    Mockito.when(mockFilterConfig.getInitParameter(ConfigurableProcessorsFactory.PARAM_PRE_PROCESSORS)).thenReturn("""");
    assertTrue(processorsFactory.getPreProcessors().isEmpty());
  }",No Smells
"@Test
  public void shouldCreateConfigurableManagerFactoryByDefault() {
    assertEquals(ConfigurableWroManagerFactory.class, victim.getFactory().getClass());
  }",No Smells
"@Test
  public void shouldCreateManagerFactory() {
    final WroConfiguration config = new WroConfiguration();
    config.setWroManagerClassName(NoProcessorsWroManagerFactory.class.getName());
    victim = DefaultWroManagerFactory.create(config);
    assertEquals(NoProcessorsWroManagerFactory.class, victim.getFactory().getClass());
  }",No Smells
"@Test
  public void shouldCreateOverridenManagerFactoryWhenManagerClassPropertyIsMissing() {
    victim = new DefaultWroManagerFactory(new Properties()) {
      @Override
      protected WroManagerFactory newManagerFactory() {
        return new ConfigurableWroManagerFactory();
      }",No Smells
"@Test
  public void shouldUseValidModelIsProvidedWhenUsingConfigurableWroManagerFactory() {
    useModelFactoryWithAlias(XmlModelFactory.ALIAS);

  }",No Smells
"@Test
  public void shouldDestroyModelWhenInvokingRun() {
    victim.run();
    Mockito.verify(mockModelFactory).destroy();
  }",No Smells
"@Test
  public void shouldClearAuthorizationManagerWhenModelPeriodChanged() {
    victim.onModelPeriodChanged(1);
    verify(mockAuthorizationManager, atLeastOnce()).clear();
  }",No Smells
"@Test
  public void shouldDestroyDestroyableProcessorWhenManagerIsDestroyed() {
    final DestroyableProcessor preProcessor = Mockito.mock(DestroyableProcessor.class);
    final DestroyableProcessor postProcessor = Mockito.mock(DestroyableProcessor.class);
    victim = new BaseWroManagerFactory().setProcessorsFactory(
        new SimpleProcessorsFactory().addPreProcessor(preProcessor).addPostProcessor(postProcessor)).create();
    victim.destroy();
    Mockito.verify(preProcessor, Mockito.times(1)).destroy();
    Mockito.verify(postProcessor, Mockito.times(1)).destroy();
  }",No Smells
"@Test
  public void shouldRegisterCallback() {
    final LifecycleCallback mockCallback = Mockito.mock(LifecycleCallback.class);
    victim.registerCallback(new ObjectFactory<LifecycleCallback>() {
      public LifecycleCallback create() {
        return mockCallback;
      }",No Smells
"@Test
  public void testAggregatedComputedFolder2()
      throws Exception {
    final HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
    final HttpServletResponse response = Context.get().getResponse();
    Mockito.when(request.getRequestURI()).thenReturn(""/wro4j/wro/path/to/g1.css"");
    Context.unset();
    Context.set(Context.webContext(request, response, Mockito.mock(FilterConfig.class)));

    managerFactory.create().process();

    Assert.assertEquals(""/wro4j/wro/path/to/"", Context.get().getAggregatedFolderPath());
  }",Redundent Print
"@Test
  public void testDuplicatedResourcesShouldBeSkipped()
      throws Exception {
    new GenericTestBuilder().processAndCompare(""/repeatedResources.js"", ""classpath:ro/isdc/wro/manager/repeated-out.js"");
  }",Mystery Guest + Resource Optimism
"@Test
  public void testFromFolder()
      throws Exception {
    final ResourcePreProcessor processor = new WroManagerProcessor();
    final URL url = getClass().getResource(""wroManager"");

    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""js"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testMinimizeAttributeIsTrueOnResource()
      throws Exception {
    new GenericTestBuilder().processAndCompare(""/resourceMinimizeTrue.js"",
        ""classpath:ro/isdc/wro/manager/sample.min.js"");
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldUseTaskExecutorWhenRunningInParallel()
      throws Exception {
    final AtomicBoolean invoked = new AtomicBoolean();
    final TaskExecutor<Void> taskExecutor = new TaskExecutor<Void>() {
      @Override
      public void submit(final Collection<Callable<Void>> callables)
          throws Exception {
        invoked.set(true);
        super.submit(callables);
      }",No Smells
"@Test
  public void shouldUseConfiguredModelFactory()
      throws Exception {
    final Properties configProperties = new Properties();
    configProperties.setProperty(ConfigurableModelFactory.KEY, XmlModelFactory.ALIAS);
    victim.setConfigProperties(configProperties);
    final WroModelFactory actual = ((ConfigurableModelFactory) AbstractDecorator.getOriginalDecoratedObject(victim.create().getModelFactory())).getConfiguredStrategy();
    assertEquals(XmlModelFactory.class, actual.getClass());
  }",No Smells
"@Test
  public void testWhenValidPreProcessorsSet() {
    createManager();

    configureValidUriLocators(mockFilterConfig);
    Mockito.when(mockFilterConfig.getInitParameter(ConfigurableProcessorsFactory.PARAM_PRE_PROCESSORS)).thenReturn(
        ""cssUrlRewriting"");
    assertEquals(1, processorsFactory.getPreProcessors().size());
  }",No Smells
"@Test
  public void testWithEmptyPostProcessors() {
    createManager();

    configureValidUriLocators(mockFilterConfig);
    Mockito.when(mockFilterConfig.getInitParameter(ConfigurableProcessorsFactory.PARAM_POST_PROCESSORS)).thenReturn("""");
    assertTrue(processorsFactory.getPostProcessors().isEmpty());
  }",No Smells
"@Test
  public void shouldBeNullWhenDestinationFolderIsUnrelatedToBuildDirectory() {
    final File unrelatedFolder = new File(getClass().getResource("""").getFile()).getParentFile();
    victim.setDestinationFolder(unrelatedFolder);
    assertEquals(null, victim.resolve());
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldResolveEmptyPathWhenDestinationFolderIsTheSameAsBuildDirectory() {
    assertEquals("""", victim.resolve());
  }",No Smells
"@Test
  public void shouldUseBuildContextIncrementalFlag() {
    initVictimWithBuildContext();
    when(buildContext.isIncremental()).thenReturn(false);
    assertFalse(victim.isIncrementalBuild());
  }",No Smells
"@Test
  public void shouldNotStoreValueAssociatedWithNullKey() {
    victim.setValue(null, VALUE);
    assertNull(victim.getValue(null));
  }",No Smells
"@Test
  public void shouldComputeCorrectTotalResources() {
    final int times = 10;
    for (int i = 0; i < times; i++) {
      victim.onProcessingResource(generateRandomResource());
    }",No Smells
"@Test
  public void shouldConsiderInvalidResourceAsUnchanged() {
    assertEquals(false, victim.isResourceChanged(Resource.create(""/1.js"")));
  }",No Smells
"@Test
  public void shouldAnalyzeValidResources()
      throws Exception {
    mojo.setTargetGroups(""valid"");
    mojo.execute();
  }",No Smells
"@Test
  public void shouldGenerateXmlReportFileWithCheckstyleFormat()
      throws Exception {
    generateAndCompareReportUsingFormat(FormatterType.CHECKSTYLE.getFormat(), ""csslint-checkstyle.xml"");
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldGenerateXmlReportFileWithDefaultFormat()
      throws Exception {
    generateAndCompareReportUsingFormat(null, ""csslint-default.xml"");
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldNotFailWhenThresholdIsGreaterThanNumberOfErrors()
      throws Exception {
    mojo.setFailThreshold(5);
    setWroWithValidResources();
    mojo.execute();
  }",Mystery Guest + Resource Optimism
"@Test
  public void testErrorsWithNoFailFast()
      throws Exception {
    mojo.setFailNever(true);
    mojo.setOptions(""undef, browser"");
    mojo.setTargetGroups(""undef"");
    mojo.execute();
  }",No Smells
"@Test
  public void shouldNotFailWhenThresholdIsGreaterThanNumberOfErrors()
      throws Exception {
    final JsHintMojo jsHintMojo = (JsHintMojo) getMojo();
    jsHintMojo.setFailThreshold(6);
    executeResourcesWithErrors();
  }",No Smells
"@Test
  public void shouldGenerateReportWithDefaultFormat()
      throws Exception {
    generateAndCompareReportFile(null, ""jshint-default.xml"");
  }",Mystery Guest + Resource Optimism
"@Test
  public void usePredefOptions()
      throws Exception {
    getMojo().setOptions(""predef=['YUI','window','document','OnlineOpinion','xui']"");
    getMojo().setTargetGroups(""undef"");
    getMojo().execute();
  }",No Smells
"@Test
  public void shouldGenerateReportWithDefaultFormat() throws Exception {
    generateAndCompareReportFile(null, ""jslint-default.xml"");
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldDetectIncrementalChangeOfImportedCss()
      throws Exception {
    final String importResource = ""imported.css"";

    configureMojoForModelWithImportedCssResource(importResource);
    // incremental build detects no change
    assertTrue(victim.getTargetGroupsAsList().isEmpty());

    when(mockLocator.locate(Mockito.eq(importResource))).thenAnswer(answerWithContent(""Changed""));
    assertFalse(victim.getTargetGroupsAsList().isEmpty());
  }",No Smells
"@Test
  public void testWroXmlWithInvalidResourcesAndIgnoreMissingResourcesTrue()
      throws Exception {
    setWroWithInvalidResources();
    victim.setIgnoreMissingResources(true);
    victim.execute();
  }",Mystery Guest + Resource Optimism
"@Test
  public void testMojoWithConfigurableWroManagerFactoryWithValidAndEmptyConfigFileSet()
      throws Exception {
    setWroWithValidResources();
    victim.setIgnoreMissingResources(true);
    victim.setWroManagerFactory(ConfigurableWroManagerFactory.class.getName());
    victim.execute();
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldDetectIncrementalChange()
      throws Exception {
    victim = new Wro4jMojo() {
      @Override
      protected WroManagerFactory newWroManagerFactory()
          throws MojoExecutionException {
        return new ExtensionsStandaloneManagerFactory().setHashStrategy(mockHashStrategy);
      }",No Smells
"@Test
  public void shouldRefreshParentFolderWhenBuildContextSet() throws Exception {
    final BuildContext buildContext = Mockito.mock(BuildContext.class);
    victim.setBuildContext(buildContext);
    testMojoWithConfigurableWroManagerFactoryWithValidConfigFileSet();
    verify(buildContext, Mockito.atLeastOnce()).refresh(Mockito.eq(destinationFolder));
  }",No Smells
"@Test
  public void shouldReuseGroupNameMappingFileWithIncrementalBuild()
      throws Exception {
    final File groupNameMappingFile = WroUtil.createTempFile();

    final Resource g1Resource = spy(Resource.create(""1.js""));
    try {
      final WroModel model = new WroModel();
      model.addGroup(new Group(""g1"").addResource(g1Resource));
      model.addGroup(new Group(""g2"").addResource(Resource.create(""2.js"")));
      victim = new Wro4jMojo() {
        @Override
        protected WroManagerFactory newWroManagerFactory()
            throws MojoExecutionException {
          final DefaultStandaloneContextAwareManagerFactory managerFactory = new DefaultStandaloneContextAwareManagerFactory();
          managerFactory.setUriLocatorFactory(WroTestUtils.createResourceMockingLocatorFactory());
          managerFactory.setModelFactory(WroTestUtils.simpleModelFactory(model));
          managerFactory.setNamingStrategy(new DefaultHashEncoderNamingStrategy());

          return managerFactory;
        }",Eager Test
"@Test
  public void shouldUseMultipleContextFolders()
      throws Exception {
    final String defaultContextFolder = victim.getContextFoldersAsCSV();
    victim.setTargetGroups(""contextRelative"");

    victim.setContextFolder(""invalid, "" + defaultContextFolder);
    victim.doExecute();

    // reversed order should work the same
    victim.setContextFolder(defaultContextFolder + "", invalid"");
    victim.doExecute();
  }",No Smells
"@Test
  public void testMojoWithCustomManagerFactoryWithInvalidResourceAndIgnoreMissingResources()
      throws Exception {
    setWroWithInvalidResources();
    victim.setIgnoreMissingResources(true);
    victim.setWroManagerFactory(CustomManagerFactory.class.getName());
    victim.execute();
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldDecorateCacheStrategy() {
    final WroModelFactory original = new XmlModelFactory();
    victim = DefaultWroModelFactoryDecorator.decorate(original, emptyTransformers);
    Assert.assertTrue(victim instanceof DefaultWroModelFactoryDecorator);
    Assert.assertSame(original, ((ObjectDecorator<?>) victim).getDecoratedObject());
  }",No Smells
"@Test
  public void shouldChangeTheModelWhenTransformersProvided() {
    final Transformer<WroModel> transformer = new Transformer<WroModel>() {
      public WroModel transform(final WroModel input) {
        return null;
      }",No Smells
"@Test
  public void shouldDetectGroupReferenceFromImportedModel() {
    final WroModel model = loadModelFromLocation(""shouldDetectGroupReferenceFromImportedModel.xml"");
    assertEquals(2, model.getGroups().size());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testTwoConcurrentCreationCalls() {
    testSuccessfulCreation();
    factory.create();
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldReturnEmptyStringWhenGroupHasNoResources() {
    final CacheKey key = new CacheKey(groupName, ResourceType.JS, true);
    Assert.assertEquals(StringUtils.EMPTY, victim.process(key));
  }",No Smells
"@Test
  public void canInjectOutsideOfContext() {
    Context.unset();
    TestProcessor processor = new TestProcessor();
    victim.inject(processor);
  }",No Smells
"@Test
  public void shouldBuildValidInjectorWithBaseWroManagerFactory() {
    final Injector injector = InjectorBuilder.create(new BaseWroManagerFactory()).build();
    assertNotNull(injector);

    final Sample sample = new Sample();
    injector.inject(sample);
    assertNotNull(sample.namingStrategy);
    assertNotNull(sample.preProcessorExecutor);
    assertNotNull(sample.processorsFactory);
    assertNotNull(sample.uriLocatorFactory);
    assertNotNull(sample.callbackRegistry);
    assertSame(injector, sample.injector);
    assertNotNull(sample.groupsProcessor);
    assertNotNull(sample.metaDataFactory);
    assertNotNull(sample.cacheKeyFactory);
    assertNotNull(sample.bundleProcessor);
    assertNotNull(sample.dispatcherLocator);
  }",No Smells
"@Test
  public void processEmptyList()
      throws Exception {
    final List<Resource> resources = new ArrayList<Resource>();
    Assert.assertEquals("""", victim.processAndMerge(resources, true));
    Assert.assertEquals("""", victim.processAndMerge(resources, false));
  }",No Smells
"@Test
  public void shouldReplaceAResourceWithSameResource() {
    final Group group = new Group(""group"");
    final Resource resource = Resource.create(""/path.js"");
    group.addResource(resource);

    final List<Resource> resourceList = new ArrayList<Resource>();
    resourceList.add(resource);

    group.replace(resource, resourceList);
    Assert.assertFalse(group.getResources().isEmpty());
  }",No Smells
"@Test
  public void testNoResorucesOfTypeFound() {
    final Group group = new Group(""group"");
    Assert.assertEquals(false, group.hasResourcesOfType(ResourceType.CSS));
    Assert.assertEquals(false, group.hasResourcesOfType(ResourceType.JS));
  }",No Smells
"@Test
  public void testValidUri()
      throws Exception {
    factory.addLocator(new ClasspathUriLocator());
    assertNotNull(factory.locate(""classpath:"" + WroUtil.toPackageAsFolder(TestUriLocatorFactory.class)));
  }",No Smells
"@Test
  public void shouldNotFailWhenASingleProviderFails() {
    victim = new ConfigurableLocatorFactory() {
      @Override
      protected ProviderFinder<LocatorProvider> getProviderFinder() {
        return mockProviderFinder;
      }",No Smells
"@Test
  public void shouldOverrideAvailableLocator() {
    victim = new ConfigurableLocatorFactory() {
      @Override
      protected void overrideDefaultStrategyMap(final Map<String, UriLocator> map) {
        map.clear();
        map.put(ServletContextUriLocator.ALIAS, mockUriLocator);
      }",No Smells
"@Test
  public void shouldUseDefaultLocatorWhenNoneIsConfigured() {
    final UriLocator locator = victim.getInstance(""/"");
    assertEquals(ServletContextUriLocator.class, locator.getClass());
  }",No Smells
"@Test
  public void shouldHaveSeveralDefaultLocators() {
    assertEquals(8, victim.getUriLocators().size());
  }",No Smells
"@Test
  public void shouldReturnsResourceIncludedByDispatcher()
      throws Exception {
    final String content = ""SomeNonEmptyContent"";
    when(mockRequest.getRequestDispatcher(Mockito.anyString())).thenReturn(mockDispatcher);
    doAnswer(new Answer<Void>() {
      public Void answer(final InvocationOnMock invocation)
          throws Throwable {
        final HttpServletResponse response = (HttpServletResponse) invocation.getArguments()[1];
        response.getOutputStream().write(content.getBytes());
        return null;
      }",No Smells
"@Test
  public void shouldFindWildcardResourcesForFolderContainingSpaces()
      throws IOException {
    victim.locate(createUri(""/folder with spaces/**.css"", ""test""));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testWildcard2Resources()
      throws IOException {
    victim.locate(createUri(""/css/*.cs?""));
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldLocateValidResourceWhenMultipleContextFoldersProvided()
      throws Exception {
    final String defaultContextFolder = standaloneContext.getContextFoldersAsCSV();
    standaloneContext.setContextFoldersAsCSV(""invalid,"" + defaultContextFolder);
    final String validResource = TestStandaloneServletContextUriLocator.class.getSimpleName() + "".class"";
    assertNotNull(victim.locate(validResource));
  }",No Smells
"@Test
  public void shouldLocateWildcard3Resources()
      throws IOException {
    victim.locate(createUri(""*.???""));
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldFindAllChildFoldersAndFiles()
      throws IOException {
    final ThreadLocal<Collection<String>> filenameListHolder = new ThreadLocal<Collection<String>>();
    final UriLocator uriLocator = createJarLocator(filenameListHolder);
    uriLocator.locate(""classpath:com/app/**"");
    final Collection<String> filenameList = filenameListHolder.get();
    assertNotNull(filenameList);
    assertEquals(
            Arrays.toString(new String[]{
                    ""com/app/level1"", ""com/app/level1/level2"", ""com/app/level1/level2/styles"",
                    ""com/app/level1/level2/styles/style.css"", ""com/app/level1/level2/level2.css"", ""com/app/level1/level1.css""
            }",Mystery Guest + Resource Optimism
"@Test
  public void shouldGetJarFileFromFile() {
    final String actual = jarStreamLocator.getJarFile(new File(""file:path/to/file!one/two/three.class"")).getPath();
    final String expected = FilenameUtils.separatorsToSystem(""path/to/file"");
    assertEquals(expected, actual);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testLocateJarStreamDelegate()
      throws IOException {
    final InputStream is = jarStreamLocator.locateStream(""classpath:com/test/app/*.js"", new File(""src/test/resources/""));
    final String content = readLines(is).get(0);
    assertTrue(content.contains(""1.js""));
    assertTrue(content.contains(""2.js""));
    assertTrue(content.contains(""3.js""));
    assertTrue(!content.contains(""1.css""));
    
    closeQuietly(is);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testCopyrightStripperProcessor()
      throws Exception {
    final ResourcePreProcessor decoratedProcessor = new CssMinProcessor();
    final ResourcePreProcessor processor = CopyrightKeeperProcessorDecorator.decorate(decoratedProcessor);
    final URL url = ResourcePreProcessor.class.getResource(""copyright"");

    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""css"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testMinimizeAwareDecorator2() {
    final ResourcePreProcessor decoratedProcessor = new CssUrlRewritingProcessor();
    final ResourcePreProcessor processor = ExtensionsAwareProcessorDecorator.decorate(decoratedProcessor);
    Assert.assertFalse(new ProcessorDecorator(processor).isMinimize());
  }",No Smells
"@Test
  public void shouldInvokePreProcessorWhenImportIsSupported()
      throws Exception {
    final ResourcePreProcessor processor = Mockito.spy(new ImportAwareProcessor());
    victim = new ImportAwareProcessorDecorator(processor, ProcessingType.IMPORT_ONLY);
    initVictim();
    victim.process(mockReader, mockWriter);
    Mockito.verify(processor, Mockito.atLeastOnce()).process((Resource)Mockito.isNull(), Mockito.any(Reader.class),
        Mockito.any(Writer.class));
  }",No Smells
"@Test
  public void shouldInvokeImportAwareProcessor()
      throws Exception {
    mockPreProcessor = Mockito.spy(new ImportAwareProcessor());
    victim = new ImportAwareProcessorDecorator(mockPreProcessor, ProcessingType.IMPORT_ONLY);
    initVictim();
    victim.process(null, mockReader, mockWriter);
    Mockito.verify(mockPreProcessor, Mockito.atLeastOnce()).process((Resource)Mockito.isNull(), Mockito.any(Reader.class),
        Mockito.any(Writer.class));
  }",No Smells
"@Test
  public void shouldLeaveContentUnchangedWhenProcessorIsSkipped()
      throws Exception {
    victim = new ImportAwareProcessorDecorator(mockPreProcessor, ProcessingType.IMPORT_ONLY);
    initVictim();
    final String resourceContent = ""var i      =     1;"";
    final StringWriter writer = new StringWriter();
    victim.process(new StringReader(resourceContent), writer);
    Mockito.verify(mockPostProcessor, Mockito.never()).process(Mockito.any(Reader.class),
        Mockito.any(Writer.class));
    Assert.assertEquals(resourceContent, writer.toString());
  }",No Smells
"@Test
  public void shouldInvokeLazyProcessor()
      throws Exception {
    final ResourceType expectedResourceType = ResourceType.CSS;
    when(mockProcessorDecorator.isMinimize()).thenReturn(true);
    when(mockProcessorDecorator.getSupportedResourceType()).thenReturn(new SupportedResourceType() {
      public Class<? extends Annotation> annotationType() {
        return SupportedResourceType.class;
      }",No Smells
"@Test
  public void shouldInvokePreProcessorWhenMinimizeIsRequired()
      throws Exception {
    victim = new MinimizeAwareProcessorDecorator(mockPreProcessor, true);
    initVictim();
    victim.process(mockReader, mockWriter);
    Mockito.verify(mockPreProcessor, Mockito.atLeastOnce()).process((Resource)Mockito.isNull(),
        Mockito.any(Reader.class), Mockito.any(Writer.class));
  }",No Smells
"@Test
  public void shouldLeaveContentUnchangedWhenProcessorIsSkipped()
      throws Exception {
    final ResourcePreProcessor processor = Mockito.spy(new JSMinProcessor());
    victim = new MinimizeAwareProcessorDecorator(processor, false);
    initVictim();
    final String resourceContent = ""var i      =     1;"";
    final StringWriter writer = new StringWriter();
    victim.process(new StringReader(resourceContent), writer);
    Mockito.verify(mockPostProcessor, Mockito.never()).process(Mockito.any(Reader.class),
        Mockito.any(Writer.class));
    Assert.assertEquals(resourceContent, writer.toString());
  }",No Smells
"@Test
  public void shouldChangeMinimizaFlagWhenInternalMethodIsOverriden() {
    final ResourcePreProcessor processor = new ProcessorDecorator(new JSMinProcessor()) {
      @Override
      protected boolean isMinimizeInternal() {
        return false;
      }",No Smells
"@Test
  public void shouldComputeEligibilityForProcessorWithJsType() {
    assertTrue(new ProcessorDecorator(new SemicolonAppenderPreProcessor()).isEligible(true, ResourceType.JS));
    assertTrue(new ProcessorDecorator(new SemicolonAppenderPreProcessor()).isEligible(false, ResourceType.JS));
    assertFalse(new ProcessorDecorator(new SemicolonAppenderPreProcessor()).isEligible(true, ResourceType.CSS));
    assertFalse(new ProcessorDecorator(new SemicolonAppenderPreProcessor()).isEligible(false, ResourceType.CSS));
  }",No Smells
"@Test
  public void shouldCreateHelperWithPreProcessor() {
    new ProcessorDecorator(new ResourcePreProcessor() {
      public void process(final Resource resource, final Reader reader, final Writer writer)
          throws IOException {
      }",No Smells
"@Test
  public void shouldDecoratePostProcessor() {
    final String expected = ""TestProcessor"";
    final ResourcePostProcessor postProcessor = new ResourcePostProcessor() {
      public void process(final Reader reader, final Writer writer)
          throws IOException {
      }",No Smells
"@Test
  public void testGetValidPreProcessorSet() {
    final Map<String, ResourcePreProcessor> map = new HashMap<String, ResourcePreProcessor>();
    map.put(""valid"", Mockito.mock(ResourcePreProcessor.class));
    final Properties props = new Properties();
    props.setProperty(ConfigurableProcessorsFactory.PARAM_PRE_PROCESSORS, ""valid"");
    victim.setPreProcessorsMap(map);
    victim.setProperties(props);
    assertEquals(1, victim.getPreProcessors().size());
  }",No Smells
"@Test
  public void shouldRemoveOriginalUrl()
      throws Exception {
    compareResultsFromFolderUsingProcessor(""expectedEmptyReplace"", createProcessorWithHandler(new ItemHandler() {
      public String replace(final String originalDeclaration, final String originalUrl) {
        return originalDeclaration.replace(originalUrl, """");
      }",Mystery Guest + Resource Optimism
"@Test
  public void shouldGenerateCorrectDataURIForCSSWithCharset()
      throws IOException {
    final String expected = ""data:text/css;charset=UTF-8;base64,aW5wdXQuYnV0dG9uIHsKCWJhY2tncm91bmQ6IHVybChodHRwOi8vd3JvNGouZ29vZ2xlY29kZS5jb20vc3ZuL3dpa2kvaW1nL2ZvbGRlclN0cnVjdHVyZS5wbmcpOwoJYmFja2dyb3VuZC1pbWFnZTogdXJsKCJodHRwOi8vd3JvNGouZ29vZ2xlY29kZS5jb20vc3ZuL3dpa2kvaW1nL2ZvbGRlclN0cnVjdHVyZS5wbmciKTsKCWZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhSW1hZ2VMb2FkZXIoc3JjPSdodHRwOi8vd3JvNGouZ29vZ2xlY29kZS5jb20vc3ZuL3dpa2kvaW1nL2ZvbGRlclN0cnVjdHVyZS5wbmcnLCBzaXppbmdNZXRob2Q9J3NjYWxlJyk7Cn0KLm11bHRpbGluZUFuZFNwYWNlcyB7CiAgYmFja2dyb3VuZDogCiAgICAgdXJsKCAiaHR0cDovL3dybzRqLmdvb2dsZWNvZGUuY29tL3N2bi93aWtpL2ltZy9mb2xkZXJTdHJ1Y3R1cmUucG5nICIgKTsKICBiYWNrZ3JvdW5kLWltYWdlIDogCiAgICAgdXJsKCAiaHR0cDovL3dybzRqLmdvb2dsZWNvZGUuY29tL3N2bi93aWtpL2ltZy9mb2xkZXJTdHJ1Y3R1cmUucG5nICIgKSAgICAgCn0KQGZvbnQtZmFjZSB7CiAgICBzcmM6IHVybChodHRwOi8vd3JvNGouZ29vZ2xlY29kZS5jb20vc3ZuL3dpa2kvaW1nL2ZvbGRlclN0cnVjdHVyZS5wbmcpOwp9"";
    final String actual = dataUriGenerator.generateDataURI(getInputStream(""dataUri.css""), ""dataUri.css"");
    WroTestUtils.compare(expected, actual);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldGenerateCorrectDataUriForPng()
      throws Exception {
    final String expected = ""data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJIAAAAcCAMAAAC9HxYUAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAwBQTFRFyyst8fLy1CAg13t6sTM16nCI+Nvb/rFV2DY3/7TD9cvL09PT1BwcpKSk6ImI7aKipTY53FZX+uTk/zhfNjY2//z57Z6e/8eF88HBhIuR/+TF9OTyQUxUF7Od9v//4mtr/O7u8LGx3pGVu7u7sLCw3UtLzTI0vInBdXV15HJy/fHxcNDF1ikpZWVl+f79L8Wv7u3uyi4x/vXrlNHMenp6T865+Pj40ojI9PT14WVlmZmZzMzMrERI+f77PUhR8c/rt7e3mkZLiYmJkjk8u0JFQklR/pQW//rz/qc/sTw/VU1V7qioykVIx8rNlJOTkFhcra2t/vr5rS+eW0VMhISExC0u9tPT5Xt8iE1S4uLiukmq//DcfENIob26JSUl3qXW/sN9/fr+8K6u20JCgl1i65aW2tramk5SxMTE8Lm702Jh/IOa//PjXV1dQ0ND6erqakNJ4V5eExMT/rxs/9iqBwcH//7+//z8HBwcvb29S0xM/fb2SVFYjUhN++np6bq3/5Cma0tR/vz//+rS/962/v/7TE1Vqamp+enlo5W93d3dxZ6opmBkRk5W/+3Zb3d6ycnJf4CAVFRUzVlayktSUVRc/fb72HNtn5+fgz1Ce1NY+/7/bG1txjM25ubm/8yR/9Oc1TAx/P77QEtU/p8t0hMTskpN++HfaFBXuzAxdD1Dyzw/T0ZN+/v8xDc8goqPQk1VgExS++zs4JycyjY4yCgr/9HbdX2D/f3+19fX0Cor1iwtVmBov0VHPklRPkpSP0tTQk1WPklSP0pSP0pT4uPli5GXdbG75OXj2tvcz9LU/sLOvkhJg5O0zGtu0mdw88zF31Vhr1NWuFRV4YKEyMbG6rGu/1V2vcHE/6O2kJec6u7s3+Dh9mOA4qClve7l5Kin6KOozkFF0E5PDg4OLy8w07LD9vb/4+Xm/+Tpf4aLsL7Qs7O0t7OxtEdJqmBk78m/s7i76Y+PwZ3LybfMvTk8qa6yRkxTZG1urq2pQU1VQk5WPUhQQ09XAAAA////r0OctQAAB/9JREFUeNrMlntcU+cZx08iIiMBgXGTUi4NREhPWA5SBgQoF2+EhoIIiDoqUG5VAqQCAcEqilg6WkFp0YAIaBEFuSgtlzZAYd26+4Xd7S5d3KVj62bH2KA7z973nFxOIP6xv9bvH0k+7y9vzjfP+5z3PcR/PncQ/28BxZX2Ryq1lCfaDAwMOB0+x81f++bXNvDBLzhfaP/RRSM/rOOM/5MH6xlSvrNRqX7n6HqlNZaWywRJBjo7O/eQpNO5uTUjfwRBKkNTIefHTfFa+7vJEj8Wif+bdabxt8EaS2vruXlPfEdhOWRQSh8gA/P88Kwqz2By6rApjxBo9GoMnWJNqf1df0lWMEuWxNPstI1r8qcvnDp69NS3JKBcb9SSJBb3xFtTKp/qSTb/QonddKIx5wXoNQikFGVFqf3b/icChUI+X4hehIGSEpMTR+mtUx9+uHnz5p9+8dRGpVHqXuDtrtOWSnNzc2vpRL4t91/5+ZKX51h4S2os9ECaElZaGtTRzH7BEOIaBQpJko/WnOTz+fl+nm+2sJFZ6edHv/LUU19C7JCBcs4Sxc7xi57fJZLOcQeJkZGRlYweW8s1r44ky1dHMFhJ75rKu9+UkLC/1FVTW4xzJhpBNZIEIh3SjnSsdq7wJYWByKnOG2dIaU/3Hgg99NYrT3795e3bP/3zk48/vkO5NmJBPEX9Fl66Ix7lDhKrq6uXSf/1fSjJH1hlQEr6zqHmUg2zcEOiNqalmAjV6ASuEWl3smAr+Nr7oXLlj3n+tQ6HuEq7u49d63/lO58+h/jywYPbd/xauWrBza7xyDRo2EQtKzijSGmFcE4DaBbJ8Ivc4JSMysQqVUqhRqPX6Lm9xETRyWPIiO9oWwH+7kjJhcROJ0ueNSid6fbYcuz3Lz89wUypem7fvqctlVqiqdslDv9asr9ExbdwlLy9y5kiqWgRSGmadpWxS2fn5I1BVbrKe4D6yUIJJ31Jfr64j/zBF/KwUj9SIoWRaZ/gdBuEbjm09+wf/vG6adJjB/cpvbmMiscfplTS+r9spcSnzcNIyWlaAs0qmhZF0a4iKS0FQHYQTKwwSk0qqEFGG5W8k1wiUSMJ8yAY8vDC2WIlfoXfV1mlV3df737xGFS5mbfKx5SrHCPF8vjv+mvpSvq1sYvjSS1cpQFnkNO0mhYl0AkgolXoXRoFeWQ6q1QLxVaVZjlK/laU3Dy84Phej2t7OPO4VZotoqi70IkW5n34jZga5SoRwSDKEaGFa2aq1BSlol2DwJ4sZ5RScyLCVXpW6UJKSlRUVMfVjVVyh0h7W76FEnhtefHa2eOh8Agl1NsvnAcHmq78MUjemFpWmJT6+pCSjO2lBKTcBuzCIaU+BGrvBGh21auxUqc6R63Xo1rixFylxSrbTMiUZBqrhNNtcGa3h9eRLV4WN7Kyz8hCXTRx+yWAQjXuXu3fPqLivQ0RUsrwBba9RUyVggDwzedJls8wSnqNA4QnuFYipaHiVo1ao15ilPpMSn5VzPUy0WbJUTpyHXCljrhZVeq7Ih5/Y48WIlS0dKjBJ22RunfaqDQ7a5NvUGqjm0BGq9nZBeTgLAIrqYOyAQT7S0tVmsoHbeqcMsCJuUoG7IUP8xglHA67Xe/Gg43HPc5wlGaNKJaJZ+zBRwtBaMNL8/GxvTQVvcJGSCmRtGWVVIwSzc6uyJhllfAGkFPqMBmmyXGVOsiC6Fp4hJIjuJiUtoXufZUdPuThZUWpiMq42zAR0gsdlcXQGOIDv+oSj86zSgsL6WQBq5TALFwbM9llOnEBYzh29Xp9Ci8CL1CAKgAAJ302Y3hfMitVQVUFXxh54hOcDleb7rTqs2eMi6dcYJm5eY+4eF6b69YL8tL7ENKQqx37HnVHwYTE/Py8jZ2Ebe8g1N4qdqvMmhqcx/Amc6w8nDBRUYFLPp8Umh8h0nzRyeuS/LwOhcPcrj52qMqgNM+yEk10/QR8ctPcgHchfGKooWECSm5T8UxIzMzMpJO+hrmmA8WTTJxh4EG2aEkUJ4pbyuZcg82Kkv3y+fxg81ktROdJXr0OZ8NWH+GU7MR53Nuh4OMTA7+U5rSGN8bExGhzNxFdp3GKlWYSyYeWU23tBnYZlSYvQATaJYZkzUvhZWVXa8qKJw1KM0XuElSnZJPSjXy/vANsNAzZUCgHAbovwuW8bJ5MIOcJjEqKncRH3298PVcbA0s0rS+EXuQEmZemo1fmkdJ7iFgncjGNY+RplzH4HgtPnpL6wf6AlNSOsNIgh7CwKFWpqwMYQl3RVnTy8h0NyyLxdfE/YIiGQQ7FgrKaQiiWN8nl2dkgL6wJVzLZrnqKekIbkpvboIXCB3StDKomtCE+2rtd4sMoJnSY+UQy0NMo5JJFDgzqDPDiUqPCOsMcWvcHSSc7VKogTasqFYyprsj9ROCNG879xueHA8ZgGFIFNXECuRzkcnlNjaAmG70LlEyGetu5vzGmsaqxtxEm//2NRkxvTOP5F3qWFTodq6Sbv5VB5j/0z8z0dI+cnkrcZbpmhAydIM3FqXFLF1KkCSlRYa1NnQFmJeQ0lhUcWVC9zkj3sdVe+hmOZg5QYudNRhYdF40fs35gJ643Kel0uy7bkAwZiYOx5kv+3dov39dxnApOurj022IK6mdMM9vLrMybeJvJrlBi8bg1KDGF/hQRa2Yw/dat9MHY/5FnTTzPHa77+P0NvMMknynidz6KeEVsLPHZ547/CjAAc0REMRZ4hdUAAAAASUVORK5CYII="";
    final String actual = dataUriGenerator.generateDataURI(getInputStream(""dataUri.png""), ""dataUri.png"");
    
    assertEquals(expected, actual);
  }",Mystery Guest + Resource Optimism
"@Test
  public void checkContextRelativeUrlInClasspathCssResource() {
    final String actual = victim.rewrite(ClasspathUriLocator.createUri(DEFAULT_CSS_URI), DEFAULT_IMAGE_URL);
    assertEquals(DEFAULT_IMAGE_URL, actual);
  }",No Smells
"@Test
  public void checkRelativeWithDotsImageUrlInClasspathCssResource() {
    final String actual = victim.rewrite(ClasspathUriLocator.createUri(DEFAULT_CSS_URI), ""../"" + RELATIVE_IMAGE_URL);
    final String expected = DEFAULT_PREFIX + ""classpath:/path/"" + RELATIVE_IMAGE_URL;
    assertEquals(expected, actual);
  }",No Smells
"@Test
  public void testFromFolder()
      throws Exception {
    final URL url = getClass().getResource(""conformColors"");
    
    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""css"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testFromFolder()
      throws Exception {
    final URL url = getClass().getResource(""consoleStripper"");
    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""js"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldCorrectlyDetectImportWithDoubleQuotes()
      throws Exception {
    assertImportDetected(""@import(\""child/style.css\"");"", ""/css/child/style.css"");
  }",No Smells
"@Test
  public void shouldNotComplainAboutRecursiveImportWhenRunningConcurrently() throws Exception {
    final AtomicReference<Map<?, ?>> contextMapRef = new AtomicReference<Map<?,?>>();
    victim = new CssImportPreProcessor() {
      {{
        contextMapRef.set(getContextMap());
      }",No Smells
"@Test
  public void shouldHandleWrongCss()
      throws Exception {
    final ResourcePostProcessor processor = new ExceptionHandlingProcessorDecorator(new CssMinProcessor());
    
    final URL url = getClass().getResource(""cssmin"");
    
    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expectedInvalid"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""css"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void processResourceWithDataUriEncodedValue()
      throws IOException {
    final String resourceUri = ""classpath:cssUrlRewriting-dataUri.css"";
    WroTestUtils.compareProcessedResourceContents(resourceUri, resourceUri, new ResourcePostProcessor() {
      public void process(final Reader reader, final Writer writer)
          throws IOException {
        processor.process(createMockResource(resourceUri), reader, writer);
      }",No Smells
"@Test
  public void processServletContextResourceType()
      throws IOException {
    WroTestUtils.compareProcessedResourceContents(""classpath:"" + CSS_INPUT_NAME,
        ""classpath:cssUrlRewriting-servletContext-outcome.css"", new ResourcePostProcessor() {
          public void process(final Reader reader, final Writer writer)
              throws IOException {
            processor.process(createMockResource(""/static/img/"" + CSS_INPUT_NAME), reader, writer);
          }",No Smells
"@Test
  public void processUrlResourceType()
      throws IOException {
    WroTestUtils.compareProcessedResourceContents(""classpath:"" + CSS_INPUT_NAME,
        ""classpath:cssUrlRewriting-url-outcome.css"", new ResourcePostProcessor() {
          public void process(final Reader reader, final Writer writer)
              throws IOException {
            processor.process(createMockResource(""http://www.site.com/static/css/"" + CSS_INPUT_NAME), reader, writer);
          }",No Smells
"@Test
  public void processWEBINFServletContextResourceType()
      throws IOException {
    WroTestUtils.compareProcessedResourceContents(""classpath:"" + CSS_INPUT_NAME,
        ""classpath:cssUrlRewriting-WEBINFservletContext-outcome.css"", new ResourcePostProcessor() {
          public void process(final Reader reader, final Writer writer)
              throws IOException {
            processor.process(createMockResource(""/WEB-INF/"" + CSS_INPUT_NAME), reader, writer);
          }",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(processor, ResourceType.CSS);
  }",No Smells
"@Test
  public void shouldSupportOnlyCssResources() {
    WroTestUtils.assertProcessorSupportResourceTypes(processor, ResourceType.CSS);
  }",No Smells
"@Test
  public void shouldNotRemoveSpaceBetweenPlusSigns()
      throws Exception {
    assertEquals(""\nconsole.log(1\n+ +1)"", jsmin(""console.log(1\n+ +1)""));
  }",No Smells
"@Test
  public void shouldRemoveByteOrderMark()
      throws Exception {
    assertEquals(""\nvar a=1;"", jsmin(""\uFEFFvar a = 1;""));
  }",No Smells
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(victim, ResourceType.CSS);
  }",No Smells
"@Test
  public void testFromFolder()
      throws Exception {
    Context.get().getConfig().setIgnoreMissingResources(false);
    final URL url = getClass().getResource(""cssImport"");
    
    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expectedLess"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""css"", victim);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(new MultiLineCommentStripperProcessor(), ResourceType.CSS,
        ResourceType.JS);
  }",No Smells
"@Test
  public void testFromFolder()
      throws IOException {
    final ResourcePostProcessor processor = new MultiLineCommentStripperProcessor();
    
    final URL url = getClass().getResource(""multiline"");
    
    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""*"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testProcessor()
      throws Exception {
    final Properties properties = new Properties();
    properties.setProperty(""prop1"", ""value1"");
    properties.setProperty(""prop2"", ""value2"");
    properties.setProperty(""prop3"", ""value3"");
    properties.setProperty(""prop4"", ""value4"");
    final ResourcePreProcessor processor = new PlaceholderProcessor().setPropertiesFactory(WroUtil.simpleObjectFactory(properties));
    final URL url = getClass().getResource(""placeholder"");

    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""css"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testFromFolder()
      throws IOException {
    final ResourcePreProcessor processor = new SemicolonAppenderPreProcessor();
    
    final URL url = getClass().getResource(""semicolonAppender"");
    
    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""js"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(new SingleLineCommentStripperProcessor(), ResourceType.CSS,
        ResourceType.JS);
  }",No Smells
"@Test
  public void testFromFolder()
      throws Exception {
    final URL url = getClass().getResource(""variablizeColors"");
    
    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""css"", processor);
  }",Mystery Guest + Resource Optimism
"@Test
  public void shouldDetectChangeByDefault() {
    assertTrue(victim.isChanged(GROUP1_NAME));
    assertFalse(victim.isChanged(GROUP1_NAME));
  }",No Smells
"@Test
  public void shouldRequireChangeByDefault() {
    assertTrue(victim.isCheckRequiredForGroup(GROUP1_NAME));
  }",No Smells
"@Test
  public void shouldDetectResourceChange()
      throws Exception {
    // flag used to assert that the expected code was invoked
    createDefaultInjector().inject(victim);
    victim.check(cacheKey, resourceWatcherCallback);
    assertFalse(victim.getResourceChangeDetector().checkChangeForGroup(RESOURCE_CSS_URI, GROUP_NAME));

    Mockito.when(mockLocator.locate(Mockito.anyString())).thenReturn(new ByteArrayInputStream(""different"".getBytes()));
    final ArgumentCaptor<CacheKey> argumentCaptor = ArgumentCaptor.forClass(CacheKey.class);

    victim.check(cacheKey);
    assertTrue(victim.getResourceChangeDetector().checkChangeForGroup(RESOURCE_CSS_URI, GROUP_NAME));
    Mockito.verify(resourceWatcherCallback).onGroupChanged(argumentCaptor.capture());
    assertEquals(GROUP_NAME, argumentCaptor.getValue().getGroupName());
  }",No Smells
"@Test
  public void shouldRemoveKeyFromCacheStrategyWhenChangeDetected() {
    victim.check(cacheKey);
    final CacheValue cacheValue = null;
    verify(cacheStrategy).put(Mockito.eq(cacheKey), Mockito.eq(cacheValue));
  }",No Smells
"@Test
  public void shouldHashWithConfiguredStrategy()
      throws Exception {
    Assert.assertEquals(""8151325dcdbae9e0ff95f9f9658432dbedfdb209"",
        victim.getHash(new ByteArrayInputStream(""sample"".getBytes())));
  }",No Smells
"@Test
  public void shouldUseCRC32StrategyForValidAlias() {
    shouldUseCorrectStrategyForValidAlias(CRC32HashStrategy.class, CRC32HashStrategy.ALIAS);
  }",No Smells
"@Test
  public void testSHA1()
      throws Exception {
    final String input = ""testString"";
    fingerprintCreator = new SHA1HashStrategy();
    final String hash = fingerprintCreator.getHash(new ByteArrayInputStream(input.getBytes()));
    assertEquals(""956265657d0b637ef65b9b59f9f858eecf55ed6a"", hash);
  }",No Smells
"@Test
  public void shouldUseNoOpNamingStrategyByDefault() {
    Assert.assertSame(NoOpNamingStrategy.class, victim.getConfiguredStrategy().getClass());
  }",No Smells
"@Test
  public void shouldUseNoOpStrategyForValidAlias() {
    shouldUseCorrectStrategyForValidAlias(NoOpNamingStrategy.class, NoOpNamingStrategy.ALIAS);
  }",No Smells
"@Test
  public void shouldRenameResourceContainedInAFolder()
      throws Exception {
    final String result = namingStrategy.rename(""folder1/folder2/resource.css"",
        new ByteArrayInputStream(""someContent"".getBytes()));
    assertEquals(""folder1/folder2/resource-99ef8ae827896f2af4032d5dab9298ec86309abf.css"", result);
  }",No Smells
"@Test
  public void shouldRenameResourceWithSomeContent()
      throws Exception {
    final String result = namingStrategy.rename(""anotherFile.js"", new ByteArrayInputStream(""someContent"".getBytes()));
    assertEquals(""anotherFile-99ef8ae827896f2af4032d5dab9298ec86309abf.js"", result);
  }",No Smells
"@Test
  public void shouldRenameResourceWithEmptyContent()
      throws Exception {
    final String result = namingStrategy.rename(""fileName"", WroUtil.EMPTY_STREAM);
    assertEquals(""da39a3ee5e6b4b0d3255bfef95601890afd80709/fileName"", result);
  }",No Smells
"@Test
  public void testWithExtension()
      throws Exception {
    final String result = namingStrategy.rename(""fileName.js"", WroUtil.EMPTY_STREAM);
    assertEquals(""fileName-"" + HASH + "".js"", result);
  }",No Smells
"@Test
  public void testNoExtension() throws Exception {
  //second argument doesn't matter.
    final String result = namingStrategy.rename(""fileName"", null);
    assertEquals(""fileName-"" + TIMESTAMP, result);
  }",No Smells
"@Test
  public void shoudlIgnoreQueryPathWhenResourceCheckedForAuthorization() {
    victim.add(""classpath:META-INF/resources/fonts/glyphicons-halflings-regular.eot"");
    assertTrue(victim.isAuthorized(""classpath:META-INF/resources/fonts/glyphicons-halflings-regular.eot?#iefix""));
  }",No Smells
"@Test
  public void shouldAuthorizeAddedResource() {
    final String resource = ""/resource.js"";
    victim.add(resource);
    assertTrue(victim.isAuthorized(resource));
  }",No Smells
"@Test
  public void shouldAllowSettingResourceTypeAndUri() {
    final Resource resource = new Resource();
    final String uri = ""/someUri"";
    resource.setType(ResourceType.CSS);
    resource.setUri(uri);
    assertEquals(ResourceType.CSS, resource.getType());
    assertEquals(uri, resource.getUri());
  }",No Smells
"@Test
  public void shouldCreateResource() {
    Assert.assertNotNull(Resource.create(""resource.js"", ResourceType.JS));
  }",No Smells
"@Test
  public void shouldSetMinimizeFlag() {
    final Resource resource = Resource.create(""resource.js"");
    resource.setMinimize(true);
    assertTrue(resource.isMinimize());
    resource.setMinimize(false);
    assertFalse(resource.isMinimize());
  }",No Smells
"@Test
  public void shouldHaveCorrectNumberOfGrops() {
    assertFalse(victim.getGroups().isEmpty());
    assertEquals(3, victim.getGroups().size());
  }",No Smells
"@Test
  public void shouldMergeNotEmptyModel() {
    victim.merge(new WroModel().addGroup(new Group(""anEmptyGroup"")));
    assertEquals(Arrays.asList(""anEmptyGroup"", ""g1"", ""g2"", ""g3""), new WroModelInspector(victim).getGroupNames());
  }",No Smells
"@Test
  public void shouldNotReturnDuplicatedResources() {
    final WroModel model = new WroModel();

    assertEquals(0, new WroModelInspector(model).getAllUniqueResources().size());

    model.addGroup(new Group(""one"").addResource(Resource.create(""/one.js""))).addGroup(
        new Group(""two"").addResource(Resource.create(""/one.js"")));
    assertEquals(1, new WroModelInspector(model).getAllUniqueResources().size());
  }",No Smells
"@Test
  public void testGetExistingGroup() {
    assertFalse(victim.getGroups().isEmpty());

    final Group group = new WroModelInspector(victim).getGroupByName(""g1"");
    // create a copy of original list
    assertEquals(1, group.getResources().size());
  }",No Smells
"@Test
  public void testGetGroupNames() {
    final List<String> groupNames = victim.getGroupNames();
    Collections.sort(groupNames);
    final List<String> expected = Arrays.asList(""g1"", ""g2"", ""g3"");
    Assert.assertEquals(expected, groupNames);
  }",No Smells
"@Test
  public void shouldPreserveOriginalExceptionMessageWhenWrap() {
    final String message = ""someMessage"";
    Exception e = new IllegalArgumentException(message);
    Exception result = WroRuntimeException.wrap(e);
    assertEquals(e.getMessage(), result.getMessage());
  }",No Smells
"@Test
  public void shouldFindNamingStrategyProviders() {
    victim = ProviderFinder.of(NamingStrategyProvider.class);
    assertEquals(2, victim.find().size());
  }",No Smells
"@Test
  public void shouldNotFindProviderWhenNoneIsAvailable() {
    victim = new ProviderFinder<ProcessorProvider>(ProcessorProvider.class) {
      @Override
      <F> Iterator<F> lookupProviders(final Class<F> clazz) {
        return new ArrayList<F>().iterator();
      }",No Smells
"@Test
  public void shouldInheritInterfacesOfTheObject() {
    final ResourceAuthorizationManager object = new DefaultResourceAuthorizationManager();
    final ResourceAuthorizationManager proxy = ProxyFactory.proxy(
        new TypedObjectFactory<ResourceAuthorizationManager>() {
          public ResourceAuthorizationManager create() {
            return object;
          }",No Smells
"@Test
  public void scheduleWithSamePeriods()
      throws Exception {
    helper = SchedulerHelper.create(new DestroyableLazyInitializer<Runnable>() {
      @Override
      protected Runnable initialize() {
        return createSleepingRunnable(10);
      }",No Smells
"@Test
  public void shouldCleanPathContainingMultipleDoubleDots() {
    final String result = StringUtils.cleanPath(""/a/b/../../d.txt"");
    assertEquals(""/d.txt"", result);
  }",No Smells
"@Test
  public void computePathFromLocationWithDifferentContextRoot() {
    final String result = WroUtil.getPathInfoFromLocation(mockContextPathRequest(""/z""), ""/a/b/c/d"");
    assertEquals(""/a/b/c/d"", result);
  }",No Smells
"@Test
  public void computePathFromSomeLocation() {
    final String result = WroUtil.getPathInfoFromLocation(mockContextPathRequest(null), ""location"");
    assertEquals("""", result);
  }",No Smells
"@Test
  public void computeServletPathFromLocation() {
    final String result = WroUtil.getServletPathFromLocation(mockContextPathRequest(null), ""/a/b/c/d"");
    assertEquals(""/a"", result);
  }",No Smells
"@Test
    public void testWithoutPath() throws Exception {
        controllerRegistry.register(WithoutPathController.class);
        assertThat(getUriPatterns(controllerRegistry), containsInAnyOrder(WithoutPathController.expectedUriPatterns()));
    }",No Smells
"@Test
    public void testWithPathWithMultiValue() throws Exception {
        controllerRegistry.register(WithPathWithMultiValueController.class);
        assertThat(getUriPatterns(controllerRegistry),
                containsInAnyOrder(WithPathWithMultiValueController.expectedUriPatterns()));
    }",No Smells
"@Test
    public void testWithPathWithSingleValue() throws Exception {
        controllerRegistry.register(WithPathWithSingleValueController.class);
        assertThat(getUriPatterns(controllerRegistry),
                containsInAnyOrder(WithPathWithSingleValueController.expectedUriPatterns()));
    }",No Smells
"@Test
    public void shouldGetLanguageOrDefaultForSpecifiedRouteContextFromApplicationLanguages() {
        RouteContext routeContext = mock(RouteContext.class);

        when(mockLanguages.getLanguageOrDefault(any(RouteContext.class))).thenReturn(EXPECTED_LANGUAGE);

        templateEngine.init(mockApplication);

        String language = templateEngine.getLanguageOrDefault(routeContext);

        assertThat(language, is(EXPECTED_LANGUAGE));

        verify(mockLanguages, times(1)).getLanguageOrDefault(eq(routeContext));
        verify(mockApplication, times(1)).getLanguages();
    }",No Smells
"@Test
    public void testPippoRuntimeExceptionHandlerCalledIfPResent() {
        //arrange
        ExceptionHandler pippoRuntimeExceptionExceptionHandler = Mockito.mock
            (ExceptionHandler.class);
        PippoRuntimeException pippoRuntimeException = new
            PippoRuntimeException(""TestException"");
        defaultErrorHandler.setExceptionHandler(PippoRuntimeException.class,
            pippoRuntimeExceptionExceptionHandler);

        //act
        defaultErrorHandler.handle(pippoRuntimeException, routeContext);

        //assert
        Mockito.verify(pippoRuntimeExceptionExceptionHandler, Mockito.times
            (1)).handle(pippoRuntimeException, routeContext);
    }",No Smells
"@Test
    public void testUriForWithSplat() throws Exception {
        UriMatcher.UriPatternBinding binding = uriMatcher.addUriPattern(""/repository/{repo: .*}",No Smells
"@Test
    public void testBigDecimalPtBR() throws Exception {
        final Locale PT_BR = new Locale(""pt"", ""BR"");
        assertEquals(new BigDecimal(0d), new ParameterValue(PT_BR, """").toBigDecimal());
        assertEquals(new BigDecimal(0d), new ParameterValue(PT_BR, "" "").toBigDecimal());
        assertEquals(new BigDecimal(""3.14159""), new ParameterValue(PT_BR, ""3,14159"").toBigDecimal());
        assertEquals(new BigDecimal(""3.14159""), new ParameterValue(PT_BR, ""3,14159"", ""3,14159"", ""3,14159"").toBigDecimal());
        assertArrayEquals(new BigDecimal[]{new BigDecimal(""3.14159""), new BigDecimal(""3.14159""), new BigDecimal(""3.14159"")}",No Smells
"@Test
    public void testDoubleDefaultLocale() throws Exception {
        assertEquals(0d, new ParameterValue("""").toDouble(), 0d);
        assertEquals(0d, new ParameterValue("" "").toDouble(), 0d);

        {
            final double expected = 3.14159d;
            final String numberString = formatDoubleToDefaultLocale(expected);
            assertEquals(expected, new ParameterValue(numberString).toDouble(), 0d);
            assertEquals(expected, new ParameterValue(numberString, numberString, numberString).toDouble(), 0d);
            assertArrayEquals(new Double[]{expected, expected, expected}",No Smells
"@Test
    public void testEncodedArrayList() throws Exception {
        List<Integer> myList = new ArrayList<>(Arrays.asList(600, 400, 200));
        assertEquals(myList, new ParameterValue(""[600, 400, 200]"").toList(Integer.class));
    }",No Smells
"@Test
    public void testEncodedArrayList() throws Exception {
        List<Integer> myList = new ArrayList<>(Arrays.asList(600, 400, 200));
        assertEquals(myList, new ParameterValue(""[600, 400, 200]"").toList(Integer.class));
    }",No Smells
"@Test
    public void testEncodedArrayList3() throws Exception {
        List<Integer> myList = new ArrayList<>(Arrays.asList(600, 400, 200));
        assertEquals(myList, new ParameterValue(""600| 400|200"").toList(Integer.class));
    }",No Smells
"@Test
    public void testIntegerHashSet() throws Exception {
        Set<Integer> mySet = new HashSet<>(Arrays.asList(200, 400, 600));
        assertEquals(mySet, new ParameterValue(""600"", ""200"", ""400"", ""200"").toSet(Integer.class));
    }",No Smells
"@Test
    public void testIntegers() throws Exception {
        assertEquals(0, new ParameterValue("""").toInt());
        assertEquals(0, new ParameterValue("" "").toInt());
        assertEquals(131070, new ParameterValue(""131070"").toInt());
        assertEquals(131070, new ParameterValue(""131070"", ""65535"", ""32767"").toInt());
        assertArrayEquals(new int[]{131070, 65535, 32767}",No Smells
"@Test
    public void testIntegerTreeSet() throws Exception {
        TreeSet<Integer> mySet = new TreeSet<>(Arrays.asList(600, 200, 400, 200));
        assertEquals(mySet, new ParameterValue(""600"", ""200"", ""400"", ""200"").toCollection(TreeSet.class, Integer.class, null));
    }",No Smells
"@Test
    public void testSqlTimestamp() throws Exception {
        assertNull(new ParameterValue("""").toSqlTimestamp());
        assertNull(new ParameterValue("" "").toSqlTimestamp());
        assertEquals(Timestamp.valueOf(""2014-12-25 13:45:20""), new ParameterValue(""2014-12-25 13:45:20"").toSqlTimestamp());
        assertEquals(Timestamp.valueOf(""2014-12-25 13:45:20""), new ParameterValue(""2014-12-25 13:45:20"", ""2014-12-25 8:45:35"", ""2014-12-25 20:45:07"").toSqlTimestamp());
        assertArrayEquals(new Timestamp[]{Timestamp.valueOf(""2014-12-25 13:45:20""), Timestamp.valueOf(""2014-12-25 8:45:35""), Timestamp.valueOf(""2014-12-25 20:45:07"")}",No Smells
"@Test
    public void createEntityTest() {
        // mock servlet request
        HttpServletRequest servletRequest = mock(HttpServletRequest.class);
        when(servletRequest.getParameterNames()).thenReturn(Collections.enumeration(Collections.singletonList(""name"")));
//        when(servletRequest.getParameterValues(""name"")).thenReturn(new String[] { "" "" }",No Smells
"@Test
    public void testResetResponse() {
        HttpServletResponse servletResponse = mock(HttpServletResponse.class);

        doNothing().when(servletResponse).setCharacterEncoding(StandardCharsets.UTF_8.toString());
        doNothing().when(servletResponse).reset();
        doReturn(false).when(servletResponse).isCommitted();
        doNothing().when(servletResponse).setStatus(500);

        Response response = new Response(servletResponse, new Application());
        response.header(""content-type"", ""application/json"");
        response.internalError();
        response.cookie(""user"", ""pippo"");

        assertFalse(response.getCookies().isEmpty());
        assertNotNull(response.getHeader(""content-type""));
        assertEquals(500, response.getStatus());

        response.reset();

        assertTrue(response.getCookies().isEmpty());
        assertNull(response.getHeader(""content-type""));
        assertNotEquals(500, response.getStatus());
    }",No Smells
"@Test
    public void testAddRoute() throws Exception {
        Route route = Route.GET(""/.*"", emptyHandler);
        router.addRoute(route);

        assertEquals(1, router.getRoutes().size());
        assertEquals(1, router.getRoutes(HttpConstants.Method.GET).size());
    }",No Smells
"@Test
    public void testEmptyUriPatternRoute() throws Exception {
        Route route = Route.GET("""", emptyHandler);
        Executable executable = () -> router.addRoute(route);
        Exception exception = assertThrows(Exception.class, executable);
        assertEquals(""The uri pattern cannot be null or empty"", exception.getMessage());
    }",No Smells
"@Test
    public void testExclusionFilter() throws Exception {
        Route route = Route.ANY(""^(?!/(webjars|public)/).*"", emptyHandler);
        router.addRoute(route);

        List<RouteMatch> matches = router.findRoutes(HttpConstants.Method.GET, ""/test/route"");
        assertEquals(1, matches.size());

        matches = router.findRoutes(HttpConstants.Method.GET, ""/webjars/route"");
        assertEquals(0, matches.size());

        matches = router.findRoutes(HttpConstants.Method.GET, ""/public/route"");
        assertEquals(0, matches.size());
    }",No Smells
"@Test
    public void testFindRoutes() throws Exception {
        Route route = Route.GET(""/contact"", emptyHandler);
        router.addRoute(route);

        List<RouteMatch> routeMatches = router.findRoutes(HttpConstants.Method.GET, ""/contact"");
        assertNotNull(routeMatches);
        assertEquals(1, routeMatches.size());

        routeMatches = router.findRoutes(HttpConstants.Method.POST, ""/contact"");
        assertNotNull(routeMatches);
        assertEquals(0, routeMatches.size());

        routeMatches = router.findRoutes(HttpConstants.Method.GET, ""/"");
        assertNotNull(routeMatches);
        assertEquals(0, routeMatches.size());
    }",No Smells
"@Test
    public void testIntIdRoute2() throws Exception {
        Route route = Route.GET(""/contact/{id: [0-9]+}",No Smells
"@Test
    public void testNestGroup() {
        RouteGroup group = new RouteGroup(""/users"");
        RouteGroup child = new RouteGroup(group, ""{id}",No Smells
"@Test
    public void testNullUriPatternRoute() throws Exception {
        Route route = Route.GET(null, emptyHandler);
        Executable executable = () -> router.addRoute(route);
        Exception exception = assertThrows(Exception.class, executable);
        assertEquals(""The uri pattern cannot be null or empty"", exception.getMessage());
    }",No Smells
"@Test
    public void testOptionalSuffixGroup() throws Exception {
        Route route = Route.ANY(""/api/contact/{id: [0-9]+}",No Smells
"@Test
    public void testParametersDontCrossSlashes() throws Exception {
        router.addRoute(Route.GET(""/blah/{id}",No Smells
"@Test
    public void testPathParamsRoute() throws Exception {
        Route route = Route.GET(""/contact/{id}",No Smells
"@Test
    public void testPointsInRegexDontCrashRegexAtEnd() throws Exception {
        router.addRoute(Route.GET(""/blah/{id}",No Smells
"@Test
    public void testPointsInRegexDontCrashRegexInTheMiddleOfTheRoute() throws Exception {
        router.addRoute(Route.GET(""/blah/{id}",No Smells
"@Test
    public void testPosixAlnum() throws Exception {
        Route route = Route.GET(""/user/{login: :alnum:+}",No Smells
"@Test
    public void testPosixDigit() throws Exception {
        Route route = Route.GET(""/contact/{id: :digit:+}",No Smells
"@Test
    public void testPosixHexDigit() throws Exception {
        Route route = Route.GET(""/contact/{id: :xdigit:+}",No Smells
"@Test
    public void testRemoveRoute() throws Exception {
        Route route = Route.GET(""/.*"", emptyHandler);
        router.addRoute(route);

        assertEquals(1, router.getRoutes().size());
        assertEquals(1, router.getRoutes(HttpConstants.Method.GET).size());

        router.removeRoute(route);
        assertEquals(0, router.getRoutes().size());
        assertEquals(0, router.getRoutes(HttpConstants.Method.GET).size());
    }",No Smells
"@Test
    public void testUnderlineInPathParameter() throws Exception {
        router.addRoute(Route.GET(""/{user_id}",No Smells
"@Test
    public void testUnspecifiedMethodRequestRoute() throws Exception {
        Route route = new Route("""", ""/.*"", emptyHandler);
        Executable executable = () -> router.addRoute(route);
        Exception exception = assertThrows(Exception.class, executable);
        assertTrue(exception.getMessage().contains(""Unspecified request method""));
    }",No Smells
"@Test
    public void testUriForWithMultipleRegex() throws Exception {
        Route route = Route.GET(""/user/{email: .*}",No Smells
"@Test
    public void testFromArray() {
        CsvEngine csvEngine = new CsvEngine();
        String generated = csvEngine.toString(Product.get()).replace(""\r\n"", ""\n"").trim();

        assertEquals(""Generated CSV is not the same"", expected, generated);
    }",No Smells
"@Test
    public void testEngine() {
        MyTest test = new MyTest();

        JacksonBaseEngine engine = getEngine();
        engine.init(null);

        String aString = engine.toString(test);

        MyTest result = engine.fromString(aString, MyTest.class);
        assertEquals(test.message, result.message);
    }",No Smells
"@Test
    public void shouldAskRouteContextToRecreateSessionOnRenewSession() {
        when(mockPippoWebContext.getRouteContext()).thenReturn(mockRouteContext);

        PippoSessionStore sessionStore = new PippoSessionStore();

        assertTrue(sessionStore.renewSession(mockPippoWebContext));

        verify(mockRouteContext, times(1)).recreateSession();
        verify(mockPippoWebContext, times(1)).getRouteContext();
    }",No Smells
"@Test
    public void shouldBuildFromProvidedTrackableSession() {
    }",No Smells
"@Test
    public void shouldRemoveExistingEntryWithSpecifiedKeyWhenSpecifiedValueIsNull() {
        String expectedKey = ""FooBar"";

        when(mockRouteContext.getSession()).thenReturn(mockSession);
        when(mockPippoWebContext.getRouteContext()).thenReturn(mockRouteContext);

        PippoSessionStore sessionStore = new PippoSessionStore();

        sessionStore.set(mockPippoWebContext, expectedKey, null);

        verify(mockSession, times(1)).remove(expectedKey);
        verify(mockRouteContext, times(1)).getSession();
        verify(mockPippoWebContext, times(1)).getRouteContext();
    }",No Smells
"@Test
    public void shouldReturnNullValueFromSessionIfNoEntryWithSpecifiedKeyExists() {
        String expectedKey = ""FooBar"";

        when(mockSession.get(anyString())).thenReturn(null);
        when(mockRouteContext.getSession()).thenReturn(mockSession);
        when(mockPippoWebContext.getRouteContext()).thenReturn(mockRouteContext);

        PippoSessionStore sessionStore = new PippoSessionStore();

        assertThat(sessionStore.get(mockPippoWebContext, expectedKey), nullValue());

        verify(mockSession, times(1)).get(expectedKey);
        verify(mockRouteContext, times(1)).getSession();
        verify(mockPippoWebContext, times(1)).getRouteContext();
    }",No Smells
"@Test
    public void shouldAddSpecifiedCookieToUnderlyingResponse() {
        Cookie cookieToAdd = new Cookie(""auth"", ""DEADBEEF"");
        cookieToAdd.setMaxAge(2342);
        cookieToAdd.setSecure(true);
        cookieToAdd.setHttpOnly(true);
        cookieToAdd.setDomain(""foo.example.com"");
        cookieToAdd.setPath(DEFAULT_APPLICATION_PATH);
        cookieToAdd.setComment(""auth cookie"");

        makePippoWebContext().addResponseCookie(cookieToAdd);

        ArgumentCaptor<jakarta.servlet.http.Cookie> cookieArgumentCaptor
            = ArgumentCaptor.forClass(jakarta.servlet.http.Cookie.class);

        response.commit();

        verify(mockHttpResponse, times(1)).addCookie(cookieArgumentCaptor.capture());

        jakarta.servlet.http.Cookie cookieAdded = cookieArgumentCaptor.getValue();

        assertThat(cookieAdded.getName(), is(cookieToAdd.getName()));
        assertThat(cookieAdded.getValue(), is(cookieToAdd.getValue()));
        assertThat(cookieAdded.getMaxAge(), is(cookieToAdd.getMaxAge()));
        assertThat(cookieAdded.getSecure(), is(cookieToAdd.isSecure()));
        assertThat(cookieAdded.isHttpOnly(), is(cookieToAdd.isHttpOnly()));
        assertThat(cookieAdded.getComment(), is(cookieToAdd.getComment()));
        assertThat(cookieAdded.getDomain(), is(cookieToAdd.getDomain()));
        assertThat(cookieAdded.getPath(), is(cookieToAdd.getPath()));
    }",No Smells
"@Test
    public void shouldGetServerPortFromUnderlyingRequest() {
        int expectedServerPort = 8080;

        when(mockHttpRequest.getServerPort()).thenReturn(expectedServerPort);

        PippoWebContext context = makePippoWebContext();

        assertThat(context.getServerPort(), is(expectedServerPort));

        verify(mockHttpRequest, times(1)).getServerPort();
    }",No Smells
"@Test
    public void shouldReturnNullValueIfNoRequestParameterWithSpecifiedNameWasFound() {
        String expectedParameterName = ""foo"";

        when(mockHttpRequest.getParameterNames()).thenReturn(
            makeParameterNamesEnumeration(expectedParameterName));
        when(mockHttpRequest.getParameterValues(anyString())).thenReturn(null);

        PippoWebContext context = makePippoWebContext();

        assertThat(context.getRequestParameter(expectedParameterName),
            is(nullValue()));

        verify(mockHttpRequest, times(1)).getParameterNames();
        verify(mockHttpRequest, times(1)).getParameterValues(expectedParameterName);
    }",No Smells
"@Test
    public void shouldReturnPippoSessionStoreWhenAccessed() {
        PippoWebContext context = makePippoWebContext();

        SessionStore<PippoWebContext> sessionStore = context.getSessionStore();
        assertThat(sessionStore, instanceOf(PippoSessionStore.class));
        assertThat(sessionStore.getTrackableSession(context), is(mockSession));
    }",No Smells
"@Test
    public void shouldThrowUnsupportedOperationExceptionIfSettingSessionStoreIsAttempted() {
        PippoWebContext context = makePippoWebContext();
        assertThrows(UnsupportedOperationException.class, () -> context.setSessionStore(new PippoSessionStore()));
    }",No Smells
"@Test
    public void testGet() {
        System.out.println(""get"");
        EhcacheSessionDataStorage instance = new EhcacheSessionDataStorage();
        SessionData sessionData = instance.create();
        String sessionId = sessionData.getId();
        sessionData.put(KEY, VALUE);
        instance.save(sessionData);
        SessionData saved = instance.get(sessionId);
        assertEquals(sessionData, saved);
        String value1 = sessionData.get(KEY);
        String value2 = saved.get(KEY);
        assertEquals(value1, value2);
    }",No Smells
"@Test
    public void testCreate() {
        System.out.println(""create"");
        HazelcastSessionDataStorage instance = new HazelcastSessionDataStorage(Hazelcast.newHazelcastInstance());
        SessionData sessionData = instance.create();
        sessionData.put(KEY, VALUE);
        assertNotNull(sessionData);
        assertNotNull(sessionData.getId());
        assertNotNull(sessionData.getCreationTime());
        assertEquals(sessionData.get(KEY), VALUE);
    }",No Smells
"@Test
    public void testGetExpired() throws InterruptedException {
        System.out.println(""get expired"");
        HazelcastSessionDataStorage instance = new HazelcastSessionDataStorage(Hazelcast.newHazelcastInstance());
        SessionData sessionData = instance.create();
        String sessionId = sessionData.getId();
        sessionData.put(KEY, VALUE);
        instance.save(sessionData);
        Thread.sleep(2000L); // 2seconds
        SessionData deleted = instance.get(sessionId);
        assertNull(deleted);
    }",No Smells
"@Test
    public void testGetExpired() throws InterruptedException {
        System.out.println(""get expired"");
        InfinispanSessionDataStorage instance = new InfinispanSessionDataStorage(cacheManager);
        SessionData sessionData = instance.create();
        String sessionId = sessionData.getId();
        sessionData.put(KEY, VALUE);
        instance.save(sessionData);
        Thread.sleep(2000L); // 2 seconds
        SessionData deleted = instance.get(sessionId);
        assertNull(deleted);
    }",No Smells
"@Test
    public void testDelete() {
        System.out.println(""delete"");
        JDBCSessionDataStorage instance = new JDBCSessionDataStorage(dataSource);
        SessionData sessionData = instance.create();
        String sessionId = sessionData.getId();
        sessionData.put(KEY, VALUE);
        instance.save(sessionData);
        instance.delete(sessionId);
        SessionData deleted = instance.get(sessionId);
        assertNull(deleted);
    }",No Smells
"@Test
    public void testCreate() {
        System.out.println(""create"");
        JedisSessionDataStorage instance = new JedisSessionDataStorage(jedisPool);
        SessionData sessionData = instance.create();
        sessionData.put(KEY, VALUE);
        assertNotNull(sessionData);
        assertNotNull(sessionData.getId());
        assertNotNull(sessionData.getCreationTime());
        assertEquals(sessionData.get(KEY), VALUE);
    }",No Smells
"@Test
    public void testDelete() {
        System.out.println(""delete"");
        MongoDBSessionDataStorage instance = new MongoDBSessionDataStorage(mongoClient.getDatabase(DATABASE_NAME));
        SessionData sessionData = instance.create();
        String sessionId = sessionData.getId();
        sessionData.put(KEY, VALUE);
        instance.save(sessionData);
        instance.delete(sessionId);
        SessionData deleted = instance.get(sessionId);
        assertNull(deleted);
    }",No Smells
"@Test
    public void testSave() {
        System.out.println(""save"");
        MongoDBSessionDataStorage instance = new MongoDBSessionDataStorage(mongoClient.getDatabase(DATABASE_NAME));
        SessionData sessionData = instance.create();
        String sessionId = sessionData.getId();
        sessionData.put(KEY, VALUE);
        instance.save(sessionData);
        SessionData saved = instance.get(sessionId);
        assertEquals(sessionData, saved);
        String value1 = sessionData.get(KEY);
        String value2 = saved.get(KEY);
        assertEquals(value1, value2);
    }",No Smells
"@Test
  public void testBigInteger() {
    testDoGenerateForClass(basicRandomGenerator, BigInteger.class);
  }",No Smells
"@Test
  public void testCalendar() {
    testDoGenerateForClass(basicRandomGenerator, Calendar.class);
  }",No Smells
"@Test
  public void testDouble() {
    // Double.
    @SuppressWarnings(""unused"")
    double primitiveDouble = (Double) basicRandomGenerator.doGenerate(double.class);
    testDoGenerateForClass(basicRandomGenerator, Double.class);
  }",No Smells
"@Test
  public void testFloat() {
    // Float.
    @SuppressWarnings(""unused"")
    float primitiveFloat = (Float) basicRandomGenerator.doGenerate(float.class);
    testDoGenerateForClass(basicRandomGenerator, Float.class);
  }",No Smells
"@Test
  public void testLong() {
    // Long.
    @SuppressWarnings(""unused"")
    long primitiveLong = (Long) basicRandomGenerator.doGenerate(long.class);
    testDoGenerateForClass(basicRandomGenerator, Long.class);
  }",No Smells
"@Test
  public void testString() {
    testDoGenerateForClass(basicRandomGenerator, String.class);
  }",No Smells
"@Test
  public void testDoGenerate() {
    CommonCode.testDoGenerateForClass(objectRandomGenerator, objectClass);
  }",No Smells
"@Test
  public void constructorShouldBePrivate() {
    final Class<?> mapRandomGeneratorClass = getGeneratorClass();
    PojoClass mapRandomGeneratorPojo = PojoClassFactory.getPojoClass(mapRandomGeneratorClass);

    List<PojoMethod> constructors = new ArrayList<PojoMethod>();

    for (PojoMethod constructor : mapRandomGeneratorPojo.getPojoConstructors()) {
      if (!constructor.isSynthetic())
        constructors.add(constructor);
    }",Eager Test
"@Test
  public void testRollingUpdateMigrateJson() throws Exception {
    when(client.rollingUpdate(anyString(), any(JobId.class), any(RolloutOptions.class)))
        .thenReturn(immediateFuture(new RollingUpdateResponse(RollingUpdateResponse.Status.OK)));

    when(client.deploymentGroupStatus(GROUP_NAME)).then(new ResponseAnswer(
        statusResponse(DeploymentGroupStatusResponse.Status.ACTIVE, null,
            makeHostStatus(""host1"", JOB_ID, TaskStatus.State.RUNNING))
    ));
    when(options.getBoolean(""migrate"")).thenReturn(true);

    final int ret = command.runWithJob(options, client, out, true, JOB, null);
    final String output = baos.toString();

    // Verify that rollingUpdate() was called with migrate=true
    final RolloutOptions rolloutOptions = RolloutOptions.newBuilder()
        .setTimeout(TIMEOUT)
        .setParallelism(PARALLELISM)
        .setMigrate(true)
        .setOverlap(false)
        .setToken(TOKEN)
        .setIgnoreFailures(false)
        .build();
    verify(client).rollingUpdate(GROUP_NAME, JOB_ID, rolloutOptions);
    assertEquals(0, ret);

    assertJsonOutputEquals(output, ImmutableMap.<String, Object>builder()
        .put(""status"", ""DONE"")
        .put(""duration"", 0.00)
        .put(""parallelism"", PARALLELISM)
        .put(""timeout"", TIMEOUT)
        .put(""overlap"", false)
        .put(""token"", TOKEN)
        .put(""ignoreFailures"", false)
        .put(""migrate"", true)
        .build());
  }",No Smells
"@Test
  public void testLotsOfConcurrentJobs() throws Exception {
    startDefaultMaster();

    final HeliosClient client = defaultClient();
    startDefaultAgent(testHost());

    awaitHostRegistered(client, testHost(), LONG_WAIT_SECONDS, SECONDS);
    awaitHostStatus(client, testHost(), UP, LONG_WAIT_SECONDS, SECONDS);

    final int numberOfJobs = 40;
    final List<JobId> jobIds = Lists.newArrayListWithCapacity(numberOfJobs);

    final String jobName = testJobName + ""_"" + toHexString(ThreadLocalRandom.current().nextInt());

    // create and deploy a bunch of jobs
    for (Integer i = 0; i < numberOfJobs; i++) {
      final Job job = Job.newBuilder()
          .setName(jobName)
          .setVersion(i.toString())
          .setImage(BUSYBOX)
          .setCommand(IDLE_COMMAND)
          .setCreatingUser(TEST_USER)
          .build();

      final JobId jobId = job.getId();
      final CreateJobResponse created = client.createJob(job).get();
      assertEquals(CreateJobResponse.Status.OK, created.getStatus());

      final Deployment deployment = Deployment.of(jobId, START, TEST_USER);
      final JobDeployResponse deployed = client.deploy(deployment, testHost()).get();
      assertEquals(JobDeployResponse.Status.OK, deployed.getStatus());

      jobIds.add(jobId);
    }",Eager Test
"@Test
	public void testEmptySiteLinkFilterForItem() {
		SiteLink s1 = Datamodel.makeSiteLink(""Title 1"", ""site1"", Collections.emptyList());
		SiteLink s2 = Datamodel.makeSiteLink(""Title 2"", ""site2"", Collections.emptyList());
		SiteLink s3 = Datamodel.makeSiteLink(""Title 3"", ""site3"", Collections.emptyList());
		SiteLink s4 = Datamodel.makeSiteLink(""Title 4"", ""site4"", Collections.emptyList());

		DocumentDataFilter documentDataFilter = new DocumentDataFilter();
		documentDataFilter.setSiteLinkFilter(Collections.emptySet());
		DatamodelFilter filter = new DatamodelFilter(new DataObjectFactoryImpl(), documentDataFilter);

		Map<String, SiteLink> siteLinks = new HashMap<>();
		siteLinks.put(s1.getSiteKey(), s1);
		siteLinks.put(s2.getSiteKey(), s2);
		siteLinks.put(s3.getSiteKey(), s3);
		siteLinks.put(s4.getSiteKey(), s4);

		ItemDocument itemDocument = Datamodel.makeItemDocument(
				Datamodel.makeWikidataItemIdValue(""Q42""),
				Collections.emptyList(),
				Collections.emptyList(),
				Collections.emptyList(),
				Collections.emptyList(),
				siteLinks
		);

		ItemDocument itemDocumentFiltered = Datamodel.makeItemDocument(Datamodel.makeWikidataItemIdValue(""Q42""),
				Collections.emptyList(), Collections.emptyList(), Collections.emptyList(),
				Collections.emptyList(), Collections.emptyMap()
		);

		assertEquals(itemDocumentFiltered, filter.filter(itemDocument));
	}",Eager Test
"@Test
	public void testPropertyFilterForItem() {
		ItemIdValue s = Datamodel.makeWikidataItemIdValue(""Q42"");
		PropertyIdValue p1 = Datamodel.makeWikidataPropertyIdValue(""P1"");
		PropertyIdValue p2 = Datamodel.makeWikidataPropertyIdValue(""P2"");
		PropertyIdValue p3 = Datamodel.makeWikidataPropertyIdValue(""P3"");
		PropertyIdValue p4 = Datamodel.makeWikidataPropertyIdValue(""P4"");

		Set<PropertyIdValue> propertyFilter = new HashSet<>();
		propertyFilter.add(p1);
		propertyFilter.add(p3);
		DocumentDataFilter documentDataFilter = new DocumentDataFilter();
		documentDataFilter.setPropertyFilter(propertyFilter);
		DatamodelFilter filter = new DatamodelFilter(new DataObjectFactoryImpl(), documentDataFilter);

		ItemDocument itemDocument = Datamodel.makeItemDocument(
				s,
				Collections.emptyList(),
				Collections.emptyList(),
				Collections.emptyList(),
				Arrays.asList(
						makeTestStatementGroup(p1, s),
						makeTestStatementGroup(p2, s),
						makeTestStatementGroup(p3, s),
						makeTestStatementGroup(p4, s)
				),
				Collections.emptyMap()
		);

		ItemDocument itemDocumentFiltered = Datamodel.makeItemDocument(
				s,
				Collections.emptyList(),
				Collections.emptyList(),
				Collections.emptyList(),
				Arrays.asList(
						makeTestStatementGroup(p1, s),
						makeTestStatementGroup(p3, s)
				),
				Collections.emptyMap()
		);

		assertEquals(itemDocumentFiltered, filter.filter(itemDocument));
	}",Eager Test
"@Test
	public void missingDumpFile() {
		MwLocalDumpFile df = new MwLocalDumpFile(
				""/non-existing-dump-file.json.gz"");
		assertFalse(df.isAvailable());
	}",No Smells
"@Test
	public void testGuessCurrentDump() throws IOException {
		this.dm.setFileContents(
				this.dmPath.resolve(""current-dump.xml.bz2""), """");
		MwLocalDumpFile df = new MwLocalDumpFile(
				""/current-dump.xml.bz2"");
		assertTrue(df.isAvailable());
		assertEquals(df.getDumpContentType(), DumpContentType.CURRENT);
	}",Mystery Guest + Resource Optimism
"@Test
	public void testSetBit() {
		long word = 0;

		for (byte i = 0; i < 0x40; i++) {
			word = BitVectorImpl.setBitInWord(i, true, word);
		}",Eager Test
"@Test
	public void shouldFindValidWebjar() throws Exception {
		assertNotEmpty(victim.locate(""webjars:jquery.js""));
		assertNotEmpty(victim.locate(""webjars:jquery/"" + ExternalLibrary.JQUERY.version() + ""/jquery.js""));
		assertNotEmpty(victim.locate(""webjars:/jquery/"" + ExternalLibrary.JQUERY.version() + ""/jquery.js""));
	}",Mystery Guest + Resource Optimism
"@Test
	public void shouldLocateWebjarResourceContainingQuestionMarkInUri() throws Exception {
		victim.locate(""webjars:font-awesome/"" + ExternalLibrary.FONT_AWESOME.version() + ""/webfonts/fa-regular-400.woff?v=""
				+ ExternalLibrary.FONT_AWESOME.version());
	}",Mystery Guest + Resource Optimism
"@Test
	public void shouldNotFailWhenThereIsAWebjarResourceOutsideOfJar() throws IOException {
		assertNotEmpty(victim.locate(""webjars:webjarFail.js""));
	}",Mystery Guest + Resource Optimism
"@Test
  public void shouldOnlyUseLastDot() {
    assertEquals(""image/png"", ContentTypeResolver.get(""somefile.js.png""));
  }",No Smells
"@Test
  public void shouldResolveFontExtensionTtf() {
    assertEquals(""application/octet-stream"", ContentTypeResolver.get(""font.ttf""));
  }",No Smells
"@Test
   public void shouldResolveHTMLUpperCaseExtenstion() {
    assertEquals(""text/css"", ContentTypeResolver.get(""mefile.CSS""));
   }",No Smells
"@Test
  public void shouldResolveJSExtenstion() {
    assertEquals(""application/javascript"", ContentTypeResolver.get(""/ad/df/mefile.js""));
  }",No Smells
"@Test
  public void shouldResolveUnknownExtenstion() {
    assertEquals(""application/octet-stream"", ContentTypeResolver.get(""/ad/df/mefile.unknown""));
  }",No Smells
"@Test
  public void shouldInvokeRegisteredCallbacks() {
    final LifecycleCallback callback = Mockito.mock(LifecycleCallback.class);
    final Resource changedResource = Resource.create(""test.js"");
    registry.registerCallback(factoryFor(callback));
    
    registry.onBeforeModelCreated();
    Mockito.verify(callback).onBeforeModelCreated();
    
    registry.onAfterModelCreated();
    Mockito.verify(callback).onAfterModelCreated();
    
    registry.onBeforePreProcess();
    Mockito.verify(callback).onBeforePreProcess();
    
    registry.onAfterPreProcess();
    Mockito.verify(callback).onAfterPreProcess();
    
    registry.onBeforePostProcess();
    Mockito.verify(callback).onBeforePostProcess();
    
    registry.onAfterPostProcess();
    Mockito.verify(callback).onAfterPostProcess();
    
    registry.onBeforeMerge();
    Mockito.verify(callback).onBeforeMerge();
    
    registry.onAfterMerge();
    Mockito.verify(callback).onAfterMerge();
    
    registry.onProcessingComplete();
    Mockito.verify(callback).onProcessingComplete();
    
    registry.onResourceChanged(changedResource);
    Mockito.verify(callback).onResourceChanged(Mockito.eq(changedResource));
  }",Mystery Guest
"@Test
  public void shouldBuildValidInjectorWithFewFieldsSet()
      throws Exception {
    final NamingStrategy mockNamingStrategy = mock(NamingStrategy.class);
    final ProcessorsFactory mockProcessorsFactory = mock(ProcessorsFactory.class);
    final UriLocatorFactory mockLocatorFactory = mock(UriLocatorFactory.class);
    final MetaDataFactory mockMetaDataFactory = Mockito.mock(MetaDataFactory.class);

    final BaseWroManagerFactory managerFactroy = new BaseWroManagerFactory();
    managerFactroy.setNamingStrategy(mockNamingStrategy);
    managerFactroy.setProcessorsFactory(mockProcessorsFactory);
    managerFactroy.setUriLocatorFactory(mockLocatorFactory);
    managerFactroy.setMetaDataFactory(mockMetaDataFactory);

    final Injector injector = InjectorBuilder.create(managerFactroy).build();
    assertNotNull(injector);

    final Sample sample = new Sample();
    injector.inject(sample);
    assertNotNull(sample.preProcessorExecutor);

    sample.namingStrategy.rename("""", WroUtil.EMPTY_STREAM);
    verify(mockNamingStrategy).rename("""", WroUtil.EMPTY_STREAM);

    sample.processorsFactory.getPostProcessors();
    verify(mockProcessorsFactory).getPostProcessors();

    sample.uriLocatorFactory.getInstance("""");
    verify(mockLocatorFactory).getInstance("""");

    sample.metaDataFactory.create();
    verify(mockMetaDataFactory).create();

    assertNotNull(sample.callbackRegistry);
    assertSame(injector, sample.injector);
    assertNotNull(sample.groupsProcessor);
    assertNotNull(sample.modelFactory);
    assertNotNull(sample.groupExtractor);
    assertNotNull(sample.cacheStrategy);
    assertNotNull(sample.hashBuilder);
    assertNotNull(sample.readOnlyContext);
    assertNotNull(sample.metaDataFactory);
    assertNotNull(sample.cacheKeyFactory);
    assertNotNull(sample.bundleProcessor);
    assertNotNull(sample.dispatcherLocator);
  }",No Smells
"@Test
  public void testNoWildcardPresent2() {
    assertFalse(locator.hasWildcard(""test/resource[a].css""));
  }",No Smells
"@Test
  public void testWildcardLocator()
      throws IOException {
    locator = new DefaultWildcardStreamLocator() {
      @Override
      void triggerWildcardExpander(final Collection<File> allFiles, final WildcardContext wildcardContext)
          throws IOException {
        assertEquals(2, allFiles.size());
      }",Mystery Guest + Resource Optimism
"@Test
  public void testWildcardPresent1() {
    assertTrue(locator.hasWildcard(""test/*.css""));
  }",No Smells
"@Test
  public void testWildcardPresent3() {
    assertTrue(locator.hasWildcard(""test/**.???""));
  }",No Smells
"@Test
  public void shouldRemoveImportsFromComments()
      throws Exception {
    compareResultsFromFolderUsingProcessor(""expectedRemoveImportsFromComments"", createImportsRemovalProcessor());
  }",Mystery Guest + Resource Optimism
"@Test
    public void testString() throws Exception {
        assertEquals(""mtier"", new ParameterValue(""mtier"").toString());
        assertEquals(""fred"", new ParameterValue(""fred"").toString());
        assertEquals(""fred"", new ParameterValue(""fred"", ""wilma"", ""barney"").toString());
        assertArrayEquals(new String[]{""fred"", ""wilma"", ""barney""}",No Smells
"@Test
    public void testIncludeAnt() throws Exception {
        String uri = ""/aaa"";

        String regex = new PathRegexBuilder()
            .includes(
                ""/{id}",No Smells
"@Test
    public void testMultiIncludeAntWithSameRegex() throws Exception {
        String uri = ""/aaa"";

        String regex = new PathRegexBuilder()
            .includes(
                ""/{id}",No Smells
"@Test
    public void testMultiPathParameter() throws Exception {
        String uri = ""/aaa/posts/bbb"";

        String regex = new PathRegexBuilder()
            .includes(
                ""/{id}",No Smells
"@Test
    public void testGetNumber() {
        Mockito.doReturn("" 1234"").when(pippoSettings).getString(""key"", null);
        Mockito.doCallRealMethod().when(pippoSettings).getInteger(""key"", 0);
        Mockito.doCallRealMethod().when(pippoSettings).getLong(""key"", 0);
        Mockito.doCallRealMethod().when(pippoSettings).getFloat(""key"", 0.0f);
        Mockito.doCallRealMethod().when(pippoSettings).getDouble(""key"", 2.4d);

        int valueInt = pippoSettings.getInteger(""key"", 0);
        long valueLong = pippoSettings.getLong(""key"", 0);
        float valueFloat = pippoSettings.getFloat(""key"", 0.0f);
        double valueDouble = pippoSettings.getDouble(""key"", 2.4d);

        assertEquals(1234, valueInt);
        assertEquals(1234L, valueLong);
        assertEquals(Float.parseFloat(""1234""), valueFloat, 0.0f);
        assertEquals(Double.parseDouble(""1234""), valueDouble, 0.0d);

        // case when number followed by some char sequence
        Mockito.doReturn("" 1234 abc"").when(pippoSettings).getString(""key"", null);
        valueInt = pippoSettings.getInteger(""key"", 0);
        valueLong = pippoSettings.getLong(""key"", 0);
        valueFloat = pippoSettings.getFloat(""key"", 0.0f);
        valueDouble = pippoSettings.getDouble(""key"", 2.4d);

        assertEquals(0, valueInt);
        assertEquals(0L, valueLong);
        assertEquals(0.0f, valueFloat, 0.0f);
        assertEquals(2.4d, valueDouble, 0.0d);
    }",Eager Test
"@Test
    public void testIsDevOpsAdmin() throws Throwable {
        Method setAuthCtxMethod = Operation.class.getDeclaredMethod(""setAuthorizationContext"",
                AuthorizationContext.class);

        Claims guestClaims = new Claims.Builder().setSubject(GuestUserService.SELF_LINK)
                .getResult();
        AuthorizationContext guestContext = AuthorizationContext.Builder.create()
                .setClaims(guestClaims).getResult();

        // TODO Currently all authorized non-guest users are devOpsAdmins. Needs to be changed after
        // roles are introduced. Also, a case for developer authorization context and cloud admin
        // need to be added.
        Claims devOpsClaims = new Claims.Builder()
                .setSubject(AuthUtil.buildUserServicePathFromPrincipalId(encode(""some-user@local"")))
                .getResult();
        AuthorizationContext devOpsContext = AuthorizationContext.Builder.create()
                .setClaims(devOpsClaims).getResult();

        setAuthCtxMethod.setAccessible(true);

        Operation op = new Operation();
        setAuthCtxMethod.invoke(op, (AuthorizationContext) null);
        assertEquals(null, op.getAuthorizationContext());
        assertFalse(""<null> authorization context should not be treated as devOps admin context"",
                AuthUtil.isDevOpsAdmin(op));

        setAuthCtxMethod.invoke(op, guestContext);
        assertFalse(""Guest authorization context should not be trated as devOps admin context"",
                AuthUtil.isDevOpsAdmin(op));

        setAuthCtxMethod.invoke(op, devOpsContext);
        assertTrue(""Any non-guest authorized user should be a devOps admin"",
                AuthUtil.isDevOpsAdmin(op));

        setAuthCtxMethod.setAccessible(false);
    }",Mystery Guest + Resource Optimism
"@Test
    public void testDecode_History_UP_DOWN_MULTI() throws IOException{
        AbstractMockChannel channel = getServerSideChannel(url);

        String request1 = ""aaa\n"";
        Object expected1 = request1.replace(""\n"", """");
        //init history
        testDecode_assertEquals(channel, request1, expected1, null);

        String request2 = ""bbb\n"";
        Object expected2 = request2.replace(""\n"", """");
        //init history
        testDecode_assertEquals(channel, request2, expected2, null);

        String request3 = ""ccc\n"";
        Object expected3= request3.replace(""\n"", """");
        //init history
        testDecode_assertEquals(channel, request3, expected3, null);

        byte[] UP = new byte[] {27, 91, 65}",No Smells
"@Test
    public void testExportService() throws InterruptedException {
        int port = NetUtils.getAvailablePort();
        URL serviceurl = URL.valueOf(""dubbo://127.0.0.1:"" + port + ""/test?proxy=jdk&timeout="" + Integer.MAX_VALUE);
        DemoService demo = new DemoServiceImpl();
        Invoker<DemoService> invoker = proxy.getInvoker(demo, DemoService.class, serviceurl);
        protocol.export(invoker);
        synchronized (EnumBak.class) {
            EnumBak.class.wait();
        }",Mystery Guest + Resource Optimism
"@Test
    public void notIn() {
        assertQuery(year.in(1, 2, 3).not(), dbo(""year"", dbo(""$nin"", 1, 2, 3)));
        assertQuery(year.notIn(1, 2, 3), dbo(""year"", dbo(""$nin"", 1, 2, 3)));
    }",No Smells
"@Test
    public void convert() {
        GeometryPath<Geometry> geometry = new GeometryPath<Geometry>(""geometry"");
        assertEquals(new GeometryCollectionPath<GeometryCollection>(""geometry""), geometry.asCollection());
        assertEquals(new LinearRingPath<LinearRing>(""geometry""), geometry.asLinearRing());
        assertEquals(new LineStringPath<LineString>(""geometry""), geometry.asLineString());
        assertEquals(new MultiLineStringPath<MultiLineString>(""geometry""), geometry.asMultiLineString());
        assertEquals(new MultiPointPath<MultiPoint>(""geometry""), geometry.asMultiPoint());
        assertEquals(new MultiPolygonPath<MultiPolygon>(""geometry""), geometry.asMultiPolygon());
        assertEquals(new PointPath<Point>(""geometry""), geometry.asPoint());
        assertEquals(new PolygonPath<Polygon>(""geometry""), geometry.asPolygon());
    }",No Smells
"@Test
  public void testRedactNoCoreDefault() throws Exception {
    Configuration conf = new Configuration(false);
    testRedact(conf);
  }",No Smells
"@Test
  public void testBooleanValues() throws IOException {
    out=new BufferedWriter(new FileWriter(CONFIG));
    startConfig();
    appendProperty(""test.bool1"", ""true"");
    appendProperty(""test.bool2"", ""false"");
    appendProperty(""test.bool3"", ""  true "");
    appendProperty(""test.bool4"", "" false "");
    appendProperty(""test.bool5"", ""foo"");
    appendProperty(""test.bool6"", ""TRUE"");
    appendProperty(""test.bool7"", ""FALSE"");
    appendProperty(""test.bool8"", """");
    endConfig();
    Path fileResource = new Path(CONFIG);
    conf.addResource(fileResource);
    assertEquals(true, conf.getBoolean(""test.bool1"", false));
    assertEquals(false, conf.getBoolean(""test.bool2"", true));
    assertEquals(true, conf.getBoolean(""test.bool3"", false));
    assertEquals(false, conf.getBoolean(""test.bool4"", true));
    assertEquals(true, conf.getBoolean(""test.bool5"", true));
    assertEquals(true, conf.getBoolean(""test.bool6"", false));
    assertEquals(false, conf.getBoolean(""test.bool7"", true));
    assertEquals(false, conf.getBoolean(""test.bool8"", false));
  }",No Smells
"@Test
  public void testClear() {
    Configuration conf = new Configuration(false);
    conf.set(""a"", ""A"");
    conf.set(""b"", ""B"");
    conf.clear();
    assertEquals(0, conf.size());
    assertFalse(conf.iterator().hasNext());
  }",No Smells
"@Test
  public void testCompactFormat() throws IOException {
    out=new BufferedWriter(new FileWriter(CONFIG));
    startConfig();
    appendCompactFormatProperty(""a"", ""b"");
    appendCompactFormatProperty(""c"", ""d"", true);
    appendCompactFormatProperty(""e"", ""f"", false, ""g"");
    endConfig();
    Path fileResource = new Path(CONFIG);
    Configuration conf = new Configuration(false);
    conf.addResource(fileResource);

    assertEquals(""b"", conf.get(""a""));

    assertEquals(""d"", conf.get(""c""));
    Set<String> s = conf.getFinalParameters();
    assertEquals(1, s.size());
    assertTrue(s.contains(""c""));

    assertEquals(""f"", conf.get(""e""));
    String[] sources = conf.getPropertySources(""e"");
    assertEquals(2, sources.length);
    assertEquals(""g"", sources[0]);
    assertEquals(fileResource.toString(), sources[1]);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testConcurrentAccesses() throws Exception {
    out = new BufferedWriter(new FileWriter(CONFIG));
    startConfig();
    declareProperty(""some.config"", ""xyz"", ""xyz"", false);
    endConfig();
    Path fileResource = new Path(CONFIG);
    Configuration conf = new Configuration();
    conf.addResource(fileResource);

    class ConfigModifyThread extends Thread {
      final private Configuration config;
      final private String prefix;

      public ConfigModifyThread(Configuration conf, String prefix) {
        config = conf;
        this.prefix = prefix;
      }",Mystery Guest + Resource Optimism
"@Test
  public void testDoubleValues() throws IOException {
    out=new BufferedWriter(new FileWriter(CONFIG));
    startConfig();
    appendProperty(""test.double1"", ""3.1415"");
    appendProperty(""test.double2"", ""003.1415"");
    appendProperty(""test.double3"", ""-3.1415"");
    appendProperty(""test.double4"", "" -3.1415 "");
    appendProperty(""test.double5"", ""xyz-3.1415xyz"");
    endConfig();
    Path fileResource = new Path(CONFIG);
    conf.addResource(fileResource);
    assertEquals(3.1415, conf.getDouble(""test.double1"", 0.0), DOUBLE_DELTA);
    assertEquals(3.1415, conf.getDouble(""test.double2"", 0.0), DOUBLE_DELTA);
    assertEquals(-3.1415, conf.getDouble(""test.double3"", 0.0), DOUBLE_DELTA);
    assertEquals(-3.1415, conf.getDouble(""test.double4"", 0.0), DOUBLE_DELTA);
    try {
      conf.getDouble(""test.double5"", 0.0);
      fail(""Property had invalid double value, but was read successfully."");
    }",Mystery Guest + Resource Optimism
"@Test
  public void testDumpProperty() throws IOException {
    StringWriter outWriter = new StringWriter();
    ObjectMapper mapper = new ObjectMapper();
    String jsonStr = null;
    String xmlStr = null;
    try {
      Configuration testConf = new Configuration(false);
      out = new BufferedWriter(new FileWriter(CONFIG));
      startConfig();
      appendProperty(""test.key1"", ""value1"");
      appendProperty(""test.key2"", ""value2"", true);
      appendProperty(""test.key3"", ""value3"");
      endConfig();
      Path fileResource = new Path(CONFIG);
      testConf.addResource(fileResource);
      out.close();

      // case 1: dump an existing property
      // test json format
      outWriter = new StringWriter();
      Configuration.dumpConfiguration(testConf, ""test.key2"", outWriter);
      jsonStr = outWriter.toString();
      outWriter.close();
      mapper = new ObjectMapper();
      SingleJsonConfiguration jconf1 =
          mapper.readValue(jsonStr, SingleJsonConfiguration.class);
      JsonProperty jp1 = jconf1.getProperty();
      assertEquals(""test.key2"", jp1.getKey());
      assertEquals(""value2"", jp1.getValue());
      assertEquals(true, jp1.isFinal);
      assertEquals(fileResource.toString(), jp1.getResource());

      // test xml format
      outWriter = new StringWriter();
      testConf.writeXml(""test.key2"", outWriter);
      xmlStr = outWriter.toString();
      outWriter.close();
      Configuration actualConf1 = getActualConf(xmlStr);
      assertEquals(1, actualConf1.size());
      assertEquals(""value2"", actualConf1.get(""test.key2""));
      assertTrue(actualConf1.getFinalParameters().contains(""test.key2""));
      assertEquals(fileResource.toString(),
          actualConf1.getPropertySources(""test.key2"")[0]);

      // case 2: dump an non existing property
      // test json format
      try {
        outWriter = new StringWriter();
        Configuration.dumpConfiguration(testConf,
            ""test.unknown.key"", outWriter);
        outWriter.close();
      }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testEntityReference() throws Exception {
    tearDown();
    out=new BufferedWriter(new FileWriter(CONFIG));
    writeHeader();
    declareEntity(""configuration"", ""d"", ""d"");
    writeConfiguration();
    appendProperty(""a"", ""b"");
    appendProperty(""c"", ""&d;"");
    endConfig();

    // verify that the includes file contains all properties
    Path fileResource = new Path(CONFIG);
    conf.addResource(fileResource);
    assertEquals(conf.get(""a""), ""b"");
    assertEquals(conf.get(""c""), ""d"");
    tearDown();
  }",Mystery Guest + Resource Optimism
"@Test
  public void testEnumFromXml() throws IOException {
    out=new BufferedWriter(new FileWriter(CONFIG_FOR_ENUM));
    startConfig();
    appendProperty(""test.enum"","" \t \n   FOO \t \n"");
    appendProperty(""test.enum2"","" \t \n   Yak.FOO \t \n"");
    endConfig();

    Configuration conf = new Configuration();
    Path fileResource = new Path(CONFIG_FOR_ENUM);
    conf.addResource(fileResource);
    assertSame(Yak.FOO, conf.getEnum(""test.enum"", Yak.FOO));
    boolean fail = false;
    try {
      conf.getEnum(""test.enum2"", Yak.FOO);
    }",Mystery Guest + Resource Optimism
"@Test
  public void testFinalWarningsMultiple() throws Exception {
    // Make a configuration file with a repeated final property
    StringWriter writer = new StringWriter();
    out = new BufferedWriter(writer);
    startConfig();
    declareProperty(""prop"", ""A"", ""A"", true);
    declareProperty(""prop"", ""A"", ""A"", true);
    endConfig();
    byte[] bytes = writer.toString().getBytes();
    InputStream in1 = new ByteArrayInputStream(bytes);

    // Attach our own log appender so we can verify output
    TestAppender appender = new TestAppender();
    final Logger logger = Logger.getRootLogger();
    logger.addAppender(appender);

    try {
      // Add the resource - this should not produce a warning
      conf.addResource(in1);
      assertEquals(""should see the value"", ""A"", conf.get(""prop""));

      List<LoggingEvent> events = appender.getLog();
      for (LoggingEvent loggingEvent : events) {
        System.out.println(""Event = "" + loggingEvent.getRenderedMessage());
      }",No Smells
"@Test
  public void testFinalWarningsMultipleOverride() throws Exception {
    // Make a configuration file with 2 final properties with different values
    StringWriter writer = new StringWriter();
    out = new BufferedWriter(writer);
    startConfig();
    declareProperty(""prop"", ""A"", ""A"", true);
    declareProperty(""prop"", ""BB"", ""BB"", true);
    endConfig();
    byte[] bytes = writer.toString().getBytes();
    InputStream in1 = new ByteArrayInputStream(bytes);

    // Attach our own log appender so we can verify output
    TestAppender appender = new TestAppender();
    final Logger logger = Logger.getRootLogger();
    logger.addAppender(appender);

    try {
      // Add the resource - this should produce a warning
      conf.addResource(in1);
      assertEquals(""should see the value"", ""A"", conf.get(""prop""));

      List<LoggingEvent> events = appender.getLog();
      assertEquals(""overriding a final parameter should cause logging"", 1,
          events.size());
      LoggingEvent loggingEvent = events.get(0);
      String renderedMessage = loggingEvent.getRenderedMessage();
      assertTrue(""did not see expected string inside message ""+ renderedMessage,
          renderedMessage.contains(""an attempt to override final parameter: ""
              + ""prop;  Ignoring.""));
    }",No Smells
"@Test
  public void testGetClassByNameOrNull() throws Exception {
    Configuration config = new Configuration();
    Class<?> clazz = config.getClassByNameOrNull(""java.lang.Object"");
    assertNotNull(clazz);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testGettingPropertiesWithPrefix() throws Exception {
    Configuration conf = new Configuration();
    for (int i = 0; i < 10; i++) {
      conf.set(""prefix."" + ""name"" + i, ""value"" + i);
    }",Eager Test
"@Test
  public void testGetTrimmedStringCollection() {
    Configuration c = new Configuration();
    c.set(""x"", ""a, b, c"");
    Collection<String> strs = c.getStringCollection(""x"");
    assertEquals(3, strs.size());
    assertArrayEquals(new String[]{ ""a"", "" b"", "" c"" }",No Smells
"@Test
  public void testHexValues() throws IOException{
    out=new BufferedWriter(new FileWriter(CONFIG));
    startConfig();
    appendProperty(""test.hex1"", ""0x10"");
    appendProperty(""test.hex2"", ""0xF"");
    appendProperty(""test.hex3"", ""-0x10"");
    // Invalid?
    appendProperty(""test.hex4"", ""-0x10xyz"");
    endConfig();
    Path fileResource = new Path(CONFIG);
    conf.addResource(fileResource);
    assertEquals(16, conf.getInt(""test.hex1"", 0));
    assertEquals(16, conf.getLong(""test.hex1"", 0));
    assertEquals(15, conf.getInt(""test.hex2"", 0));
    assertEquals(15, conf.getLong(""test.hex2"", 0));
    assertEquals(-16, conf.getInt(""test.hex3"", 0));
    assertEquals(-16, conf.getLong(""test.hex3"", 0));
    try {
      conf.getLong(""test.hex4"", 0);
      fail(""Property had invalid long value, but was read successfully."");
    }",Mystery Guest + Resource Optimism
"@Test
  public void testHumanReadableValues() throws IOException {
    out = new BufferedWriter(new FileWriter(CONFIG));
    startConfig();
    appendProperty(""test.humanReadableValue1"", ""1m"");
    appendProperty(""test.humanReadableValue2"", ""1M"");
    appendProperty(""test.humanReadableValue5"", ""1MBCDE"");

    endConfig();
    Path fileResource = new Path(CONFIG);
    conf.addResource(fileResource);
    assertEquals(1048576, conf.getLongBytes(""test.humanReadableValue1"", 0));
    assertEquals(1048576, conf.getLongBytes(""test.humanReadableValue2"", 0));
    try {
      conf.getLongBytes(""test.humanReadableValue5"", 0);
      fail(""Property had invalid human readable value, but was read successfully."");
    }",Mystery Guest + Resource Optimism
"@Test
  public void testIncludesWithFallback() throws Exception {
    tearDown();
    out=new BufferedWriter(new FileWriter(CONFIG2));
    startConfig();
    appendProperty(""a"",""b"");
    appendProperty(""c"",""d"");
    endConfig();

    out=new BufferedWriter(new FileWriter(CONFIG));
    startConfig();
    startInclude(CONFIG2);
    startFallback();
    appendProperty(""a"", ""b.fallback"");
    appendProperty(""c"", ""d.fallback"", true);
    endFallback();
    endInclude();
    appendProperty(""e"",""f"");
    appendProperty(""g"",""h"");
    startInclude(""MissingConfig.xml"");
    startFallback();
    appendProperty(""i"", ""j.fallback"");
    appendProperty(""k"", ""l.fallback"", true);
    endFallback();
    endInclude();
    endConfig();

    // verify that the includes file contains all properties
    Path fileResource = new Path(CONFIG);
    conf.addResource(fileResource);
    assertEquals(""b"", conf.get(""a""));
    assertEquals(""d"", conf.get(""c""));
    assertEquals(""f"", conf.get(""e""));
    assertEquals(""h"", conf.get(""g""));
    assertEquals(""j.fallback"", conf.get(""i""));
    assertEquals(""l.fallback"", conf.get(""k""));
    tearDown();
  }",Mystery Guest + Resource Optimism
"@Test
  public void testInputStreamResource() throws Exception {
    StringWriter writer = new StringWriter();
    out = new BufferedWriter(writer);
    startConfig();
    declareProperty(""prop"", ""A"", ""A"");
    endConfig();

    InputStream in1 = Mockito.spy(new ByteArrayInputStream(
          writer.toString().getBytes()));
    Configuration conf = new Configuration(false);
    conf.addResource(in1);
    assertEquals(""A"", conf.get(""prop""));
    Mockito.verify(in1, Mockito.times(1)).close();
    InputStream in2 = new ByteArrayInputStream(writer.toString().getBytes());
    conf.addResource(in2);
    assertEquals(""A"", conf.get(""prop""));
  }",No Smells
"@Test
  public void testIntegerRanges() {
    Configuration conf = new Configuration();
    conf.set(""first"", ""-100"");
    conf.set(""second"", ""4-6,9-10,27"");
    conf.set(""third"", ""34-"");
    Configuration.IntegerRanges range = conf.getRange(""first"", null);
    System.out.println(""first = "" + range);
    assertEquals(true, range.isIncluded(0));
    assertEquals(true, range.isIncluded(1));
    assertEquals(true, range.isIncluded(100));
    assertEquals(false, range.isIncluded(101));
    range = conf.getRange(""second"", null);
    System.out.println(""second = "" + range);
    assertEquals(false, range.isIncluded(3));
    assertEquals(true, range.isIncluded(4));
    assertEquals(true, range.isIncluded(6));
    assertEquals(false, range.isIncluded(7));
    assertEquals(false, range.isIncluded(8));
    assertEquals(true, range.isIncluded(9));
    assertEquals(true, range.isIncluded(10));
    assertEquals(false, range.isIncluded(11));
    assertEquals(false, range.isIncluded(26));
    assertEquals(true, range.isIncluded(27));
    assertEquals(false, range.isIncluded(28));
    range = conf.getRange(""third"", null);
    System.out.println(""third = "" + range);
    assertEquals(false, range.isIncluded(33));
    assertEquals(true, range.isIncluded(34));
    assertEquals(true, range.isIncluded(100000000));
  }",No Smells
"@Test
  public void testIntegerValues() throws IOException{
    out=new BufferedWriter(new FileWriter(CONFIG));
    startConfig();
    appendProperty(""test.int1"", ""20"");
    appendProperty(""test.int2"", ""020"");
    appendProperty(""test.int3"", ""-20"");
    appendProperty(""test.int4"", "" -20 "");
    appendProperty(""test.int5"", "" -20xyz "");
    endConfig();
    Path fileResource = new Path(CONFIG);
    conf.addResource(fileResource);
    assertEquals(20, conf.getInt(""test.int1"", 0));
    assertEquals(20, conf.getLong(""test.int1"", 0));
    assertEquals(20, conf.getLongBytes(""test.int1"", 0));
    assertEquals(20, conf.getInt(""test.int2"", 0));
    assertEquals(20, conf.getLong(""test.int2"", 0));
    assertEquals(20, conf.getLongBytes(""test.int2"", 0));
    assertEquals(-20, conf.getInt(""test.int3"", 0));
    assertEquals(-20, conf.getLong(""test.int3"", 0));
    assertEquals(-20, conf.getLongBytes(""test.int3"", 0));
    assertEquals(-20, conf.getInt(""test.int4"", 0));
    assertEquals(-20, conf.getLong(""test.int4"", 0));
    assertEquals(-20, conf.getLongBytes(""test.int4"", 0));
    try {
      conf.getInt(""test.int5"", 0);
      fail(""Property had invalid int value, but was read successfully."");
    }",Mystery Guest + Resource Optimism
"@Test
  public void testOverlay() throws IOException{
    out=new BufferedWriter(new FileWriter(CONFIG));
    startConfig();
    appendProperty(""a"",""b"");
    appendProperty(""b"",""c"");
    appendProperty(""d"",""e"");
    appendProperty(""e"",""f"", true);
    endConfig();

    out=new BufferedWriter(new FileWriter(CONFIG2));
    startConfig();
    appendProperty(""a"",""b"");
    appendProperty(""b"",""d"");
    appendProperty(""e"",""e"");
    endConfig();

    Path fileResource = new Path(CONFIG);
    conf.addResource(fileResource);

    //set dynamically something
    conf.set(""c"",""d"");
    conf.set(""a"",""d"");

    Configuration clone=new Configuration(conf);
    clone.addResource(new Path(CONFIG2));

    assertEquals(clone.get(""a""), ""d"");
    assertEquals(clone.get(""b""), ""d"");
    assertEquals(clone.get(""c""), ""d"");
    assertEquals(clone.get(""d""), ""e"");
    assertEquals(clone.get(""e""), ""f"");

  }",Mystery Guest + Resource Optimism
"@Test
  public void testResourceRace() {
    InputStream is =
        new BufferedInputStream(new ByteArrayInputStream(
            ""<configuration></configuration>"".getBytes()));
    Configuration config = new Configuration();
    // Thread 1
    config.addResource(is);
    // Thread 2
    Configuration confClone = new Configuration(conf);
    // Thread 2
    confClone.get(""firstParse"");
    // Thread 1
    config.get(""secondParse"");
  }",No Smells
"@Test
  public void testTimeDuration() {
    Configuration conf = new Configuration(false);

    assertEquals(7000L,
        conf.getTimeDuration(""test.time.a"", 7L, SECONDS, MILLISECONDS));

    conf.setTimeDuration(""test.time.a"", 7L, SECONDS);
    assertEquals(""7s"", conf.get(""test.time.a""));
    assertEquals(0L, conf.getTimeDuration(""test.time.a"", 30, MINUTES));
    assertEquals(0L, conf.getTimeDuration(""test.time.a"", 30, SECONDS, MINUTES));
    assertEquals(7L, conf.getTimeDuration(""test.time.a"", 30, SECONDS));
    assertEquals(7L,
        conf.getTimeDuration(""test.time.a"", 30, MILLISECONDS, SECONDS));
    assertEquals(7000L, conf.getTimeDuration(""test.time.a"", 30, MILLISECONDS));
    assertEquals(7000000L,
        conf.getTimeDuration(""test.time.a"", 30, MICROSECONDS));
    assertEquals(7000000000L,
        conf.getTimeDuration(""test.time.a"", 30, NANOSECONDS));
    conf.setTimeDuration(""test.time.b"", 1, DAYS);
    assertEquals(""1d"", conf.get(""test.time.b""));
    assertEquals(1, conf.getTimeDuration(""test.time.b"", 1, DAYS));
    assertEquals(24, conf.getTimeDuration(""test.time.b"", 1, HOURS));
    assertEquals(MINUTES.convert(1, DAYS),
        conf.getTimeDuration(""test.time.b"", 1, MINUTES));

    // check default
    assertEquals(30L, conf.getTimeDuration(""test.time.X"", 30, SECONDS));
    conf.set(""test.time.X"", ""30"");
    assertEquals(30L, conf.getTimeDuration(""test.time.X"", 40, SECONDS));
    assertEquals(30000L,
        conf.getTimeDuration(""test.time.X"", 40, SECONDS, MILLISECONDS));
    assertEquals(10L, conf.getTimeDuration(""test.time.c"", ""10"", SECONDS));
    assertEquals(30L, conf.getTimeDuration(""test.time.c"", ""30s"", SECONDS));
    assertEquals(120L, conf.getTimeDuration(""test.time.c"", ""2m"", SECONDS));
    conf.set(""test.time.c"", ""30"");
    assertEquals(30L, conf.getTimeDuration(""test.time.c"", ""40s"", SECONDS));

    // check suffix insensitive
    conf.set(""test.time.d"", ""30S"");
    assertEquals(30L, conf.getTimeDuration(""test.time.d"", 40, SECONDS));

    for (Configuration.ParsedTimeDuration ptd :
        Configuration.ParsedTimeDuration.values()) {
      conf.setTimeDuration(""test.time.unit"", 1, ptd.unit());
      assertEquals(1 + ptd.suffix(), conf.get(""test.time.unit""));
      assertEquals(1, conf.getTimeDuration(""test.time.unit"", 2, ptd.unit()));
    }",Eager Test
"@Test
  public void testVariableSubstitution() throws IOException {
    // stubbing only environment dependent functions
    Configuration mock = Mockito.spy(conf);
    Mockito.when(mock.getProperty(""user.name"")).thenReturn(""hadoop_user"");
    Mockito.when(mock.getenv(""FILE_NAME"")).thenReturn(""hello"");

    out=new BufferedWriter(new FileWriter(CONFIG));
    startConfig();
    declareProperty(""my.int"", ""${intvar}",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testGetProperty() throws Exception {
    Configuration configurations = getMultiPropertiesConf();
    // list various of property names
    String[] testKeys = new String[] {
        ""test.key1"",
        ""test.unknown.key"",
        """",
        ""test.key2"",
        null
    }",Eager Test
"@Test
  public void testWriteXml() throws Exception {
    StringWriter sw = new StringWriter();
    ConfServlet.writeResponse(getTestConf(), sw, ""xml"");
    String xml = sw.toString();

    DocumentBuilderFactory docBuilderFactory = XMLUtils.newSecureDocumentBuilderFactory();
    DocumentBuilder builder = docBuilderFactory.newDocumentBuilder();
    Document doc = builder.parse(new InputSource(new StringReader(xml)));
    NodeList nameNodes = doc.getElementsByTagName(""name"");
    boolean foundSetting = false;
    for (int i = 0; i < nameNodes.getLength(); i++) {
      Node nameNode = nameNodes.item(i);
      String key = nameNode.getTextContent();
      if (TEST_KEY.equals(key)) {
        foundSetting = true;
        Element propertyElem = (Element)nameNode.getParentNode();
        String val = propertyElem.getElementsByTagName(""value"").item(0).getTextContent();
        assertEquals(TEST_VAL, val);
      }",Eager Test
"@Test
  public void testOpsWhenACLAttributeExists() throws Exception {
    final Configuration conf = new Configuration();
    KeyProvider kp = 
        new UserProvider.Factory().createProvider(new URI(""user:///""), conf);
    KeyACLs mock = mock(KeyACLs.class);
    when(mock.isACLPresent(""testKey"", KeyOpType.MANAGEMENT)).thenReturn(true);
    when(mock.isACLPresent(""testKey"", KeyOpType.GENERATE_EEK)).thenReturn(true);
    when(mock.isACLPresent(""testKey"", KeyOpType.DECRYPT_EEK)).thenReturn(true);
    when(mock.isACLPresent(""testKey"", KeyOpType.ALL)).thenReturn(true);
    UserGroupInformation u1 = UserGroupInformation.createRemoteUser(""u1"");
    UserGroupInformation u2 = UserGroupInformation.createRemoteUser(""u2"");
    UserGroupInformation u3 = UserGroupInformation.createRemoteUser(""u3"");
    UserGroupInformation sudo = UserGroupInformation.createRemoteUser(""sudo"");
    when(mock.hasAccessToKey(""testKey"", u1, KeyOpType.MANAGEMENT)).thenReturn(true);
    when(mock.hasAccessToKey(""testKey"", u2, KeyOpType.GENERATE_EEK)).thenReturn(true);
    when(mock.hasAccessToKey(""testKey"", u3, KeyOpType.DECRYPT_EEK)).thenReturn(true);
    when(mock.hasAccessToKey(""testKey"", sudo, KeyOpType.ALL)).thenReturn(true);
    final KeyProviderCryptoExtension kpExt =
        new KeyAuthorizationKeyProvider(
            KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp),
            mock);

    final KeyVersion barKv = u1.doAs(
        new PrivilegedExceptionAction<KeyVersion>() {
          @Override
          public KeyVersion run() throws Exception {
            Options opt = newOptions(conf);
            Map<String, String> m = new HashMap<String, String>();
            m.put(""key.acl.name"", ""testKey"");
            opt.setAttributes(m);
            try {
              KeyVersion kv = 
                  kpExt.createKey(""foo"", SecureRandom.getSeed(16), opt);
              kpExt.rollNewVersion(kv.getName());
              kpExt.rollNewVersion(kv.getName(), SecureRandom.getSeed(16));
              kpExt.deleteKey(kv.getName());
            }",Eager Test
"@Test
  public void testDelegationTokensOpsHttpKerberized() throws Exception {
    testDelegationTokensOps(false, true);
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testDelegationTokensOpsHttpPseudo() throws Exception {
    testDelegationTokensOps(false, false);
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testKMSJMX() throws Exception {
    Configuration conf = new Configuration();
    final File confDir = getTestDir();
    conf = createBaseKMSConf(confDir, conf);
    final String processName = ""testkmsjmx"";
    conf.set(KMSConfiguration.METRICS_PROCESS_NAME_KEY, processName);
    writeConf(confDir, conf);

    runServer(null, null, confDir, new KMSCallable<Void>() {
      @Override
      public Void call() throws Exception {
        final URL jmxUrl = new URL(
            getKMSUrl() + ""/jmx?user.name=whatever&qry=Hadoop:service=""
                + processName + "",name=JvmMetrics"");
        LOG.info(""Requesting jmx from "" + jmxUrl);
        final StringBuilder sb = new StringBuilder();
        final InputStream in = jmxUrl.openConnection().getInputStream();
        final byte[] buffer = new byte[64 * 1024];
        int len;
        while ((len = in.read(buffer)) > 0) {
          sb.append(new String(buffer, 0, len));
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testKMSTimeout() throws Exception {
    File confDir = getTestDir();
    Configuration conf = createBaseKMSConf(confDir);
    conf.setInt(CommonConfigurationKeysPublic.KMS_CLIENT_TIMEOUT_SECONDS, 1);
    writeConf(confDir, conf);

    ServerSocket sock;
    int port;
    try {
      sock = new ServerSocket(0, 50, InetAddress.getByName(""localhost""));
      port = sock.getLocalPort();
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testKMSWithZKDTSM() throws Exception {
    doKMSWithZK(false, true);
  }",Eager Test + Mystery Guest
"@Test
  public void testStartStopHttpKerberos() throws Exception {
    testStartStop(false, true);
  }",Eager Test
"@Test
  public void testStartStopHttpsPseudo() throws Exception {
    testStartStop(true, false);
  }",Eager Test
"@Test
  public void testCustom() {
    final Configuration conf = new Configuration(false);
    for (KMSACLs.Type type : KMSACLs.Type.values()) {
      conf.set(type.getAclConfigKey(), type.toString() + "" "");
    }",Eager Test
"@Test
  public void testKeyAclConfigurationLoad() {
    final Configuration conf = new Configuration(false);
    conf.set(KEY_ACL + ""test_key_1.MANAGEMENT"", ""CREATE"");
    conf.set(KEY_ACL + ""test_key_2.ALL"", ""CREATE"");
    conf.set(KEY_ACL + ""test_key_3.NONEXISTOPERATION"", ""CREATE"");
    conf.set(DEFAULT_KEY_ACL_PREFIX + ""MANAGEMENT"", ""ROLLOVER"");
    conf.set(WHITELIST_KEY_ACL_PREFIX + ""MANAGEMENT"", ""DECRYPT_EEK"");
    conf.set(DEFAULT_KEY_ACL_PREFIX + ""ALL"", ""invalid"");
    conf.set(WHITELIST_KEY_ACL_PREFIX + ""ALL"", ""invalid"");
    final KMSACLs acls = new KMSACLs(conf);
    Assert.assertTrue(""expected key ACL size is 2 but got ""
        + acls.keyAcls.size(), acls.keyAcls.size() == 2);
    Assert.assertTrue(""expected whitelist ACL size is 1 but got ""
        + acls.whitelistKeyAcls.size(), acls.whitelistKeyAcls.size() == 1);
    Assert.assertFalse(""ALL should not be allowed for whitelist ACLs."",
        acls.whitelistKeyAcls.containsKey(KeyOpType.ALL));
    Assert.assertTrue(""expected default ACL size is 1 but got ""
        + acls.defaultKeyAcls.size(), acls.defaultKeyAcls.size() == 1);
    Assert.assertTrue(""ALL should not be allowed for default ACLs."",
        acls.defaultKeyAcls.size() == 1);
  }",No Smells
"@Test
  public void testAggregationUnauth() throws Exception {
    kmsAudit.unauthorized(luser, KMSOp.GENERATE_EEK, ""k2"");
    kmsAudit.evictCacheForTesting();
    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, ""k3"", ""testmsg"");
    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, ""k3"", ""testmsg"");
    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, ""k3"", ""testmsg"");
    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, ""k3"", ""testmsg"");
    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, ""k3"", ""testmsg"");
    kmsAudit.unauthorized(luser, KMSOp.GENERATE_EEK, ""k3"");
    // wait a bit so the UNAUTHORIZED-triggered cache invalidation happens.
    Thread.sleep(1000);
    kmsAudit.ok(luser, KMSOp.GENERATE_EEK, ""k3"", ""testmsg"");
    kmsAudit.evictCacheForTesting();
    String out = getAndResetLogOutput();
    System.out.println(out);

    // The UNAUTHORIZED will trigger cache invalidation, which then triggers
    // the aggregated OK (accessCount=5). But the order of the UNAUTHORIZED and
    // the aggregated OK is arbitrary - no correctness concerns, but flaky here.
    boolean doesMatch = out.matches(
        ""UNAUTHORIZED\\[op=GENERATE_EEK, key=k2, user=luser@REALM\\] ""
            + ""OK\\[op=GENERATE_EEK, key=k3, user=luser@REALM, accessCount=1,""
            + "" interval=[^m]{1,4}",No Smells
"@Test
  public void testInitAuditLoggers() throws Exception {
    // Default should be the simple logger
    List<KMSAuditLogger> loggers = (List<KMSAuditLogger>) FieldUtils.
        getField(KMSAudit.class, ""auditLoggers"", true).get(kmsAudit);

    Assert.assertEquals(1, loggers.size());
    Assert.assertEquals(SimpleKMSAuditLogger.class, loggers.get(0).getClass());

    // Explicitly configure the simple logger. Duplicates are ignored.
    final Configuration conf = new Configuration();
    conf.set(KMSConfiguration.KMS_AUDIT_LOGGER_KEY,
        SimpleKMSAuditLogger.class.getName() + "", ""
            + SimpleKMSAuditLogger.class.getName());
    final KMSAudit audit = new KMSAudit(conf);
    loggers = (List<KMSAuditLogger>) FieldUtils.
        getField(KMSAudit.class, ""auditLoggers"", true).get(kmsAudit);
    Assert.assertEquals(1, loggers.size());
    Assert.assertEquals(SimpleKMSAuditLogger.class, loggers.get(0).getClass());

    // If any loggers unable to load, init should fail.
    conf.set(KMSConfiguration.KMS_AUDIT_LOGGER_KEY,
        SimpleKMSAuditLogger.class.getName() + "",unknown"");
    try {
      new KMSAudit(conf);
      Assert.fail(""loggers configured but invalid, init should fail."");
    }",No Smells
"@Test
  public void testClientRetriesWithRuntimeException() throws Exception {
    Configuration conf = new Configuration();
    conf.setInt(
        CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, 3);
    KMSClientProvider p1 = mock(KMSClientProvider.class);
    when(p1.createKey(Mockito.anyString(), Mockito.any(Options.class)))
        .thenThrow(new RuntimeException(""p1""));
    KMSClientProvider p2 = mock(KMSClientProvider.class);
    when(p2.createKey(Mockito.anyString(), Mockito.any(Options.class)))
        .thenThrow(new IOException(""p2""));

    when(p1.getKMSUrl()).thenReturn(""p1"");
    when(p2.getKMSUrl()).thenReturn(""p2"");

    LoadBalancingKMSClientProvider kp = new LoadBalancingKMSClientProvider(
        new KMSClientProvider[] {p1, p2}",No Smells
"@Test
  public void testClientRetriesWithTimeoutsException() throws Exception {
    Configuration conf = new Configuration();
    conf.setInt(
        CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, 4);
    KMSClientProvider p1 = mock(KMSClientProvider.class);
    when(p1.createKey(Mockito.anyString(), Mockito.any(Options.class)))
        .thenThrow(new ConnectTimeoutException(""p1""));
    KMSClientProvider p2 = mock(KMSClientProvider.class);
    when(p2.createKey(Mockito.anyString(), Mockito.any(Options.class)))
        .thenThrow(new UnknownHostException(""p2""));
    KMSClientProvider p3 = mock(KMSClientProvider.class);
    when(p3.createKey(Mockito.anyString(), Mockito.any(Options.class)))
        .thenThrow(new NoRouteToHostException(""p3""));
    KMSClientProvider p4 = mock(KMSClientProvider.class);
    when(p4.createKey(Mockito.anyString(), Mockito.any(Options.class)))
        .thenReturn(
            new KMSClientProvider.KMSKeyVersion(""test3"", ""v1"", new byte[0]));
    when(p1.getKMSUrl()).thenReturn(""p1"");
    when(p2.getKMSUrl()).thenReturn(""p2"");
    when(p3.getKMSUrl()).thenReturn(""p3"");
    when(p4.getKMSUrl()).thenReturn(""p4"");
    LoadBalancingKMSClientProvider kp = new LoadBalancingKMSClientProvider(
        new KMSClientProvider[] {p1, p2, p3, p4}",No Smells
"@Test
  public void testWarmUpEncryptedKeysWhenOneProviderSucceeds()
      throws Exception {
    Configuration conf = new Configuration();
    KMSClientProvider p1 = mock(KMSClientProvider.class);
    String keyName = ""key1"";
    Mockito.doThrow(new IOException(new AuthorizationException(""p1""))).when(p1)
        .warmUpEncryptedKeys(Mockito.anyString());
    KMSClientProvider p2 = mock(KMSClientProvider.class);
    Mockito.doNothing().when(p2)
        .warmUpEncryptedKeys(Mockito.anyString());

    when(p1.getKMSUrl()).thenReturn(""p1"");
    when(p2.getKMSUrl()).thenReturn(""p2"");

    LoadBalancingKMSClientProvider kp = new LoadBalancingKMSClientProvider(
        new KMSClientProvider[] {p1, p2}",No Smells
"@Test
  public void testMetadata() throws Exception {
    KeyProvider.Metadata mockMeta = Mockito.mock(KeyProvider.Metadata.class);
    KeyProvider mockProv = Mockito.mock(KeyProvider.class);
    Mockito.when(mockProv.getMetadata(Mockito.eq(""k1""))).thenReturn(mockMeta);
    Mockito.when(mockProv.getMetadata(Mockito.eq(""k2""))).thenReturn(null);
    Mockito.when(mockProv.getConf()).thenReturn(new Configuration());
    KeyProvider cache = new CachingKeyProvider(mockProv, 100, 100);

    // asserting caching
    Assert.assertEquals(mockMeta, cache.getMetadata(""k1""));
    Mockito.verify(mockProv, Mockito.times(1)).getMetadata(Mockito.eq(""k1""));
    Assert.assertEquals(mockMeta, cache.getMetadata(""k1""));
    Mockito.verify(mockProv, Mockito.times(1)).getMetadata(Mockito.eq(""k1""));
    Thread.sleep(200);
    Assert.assertEquals(mockMeta, cache.getMetadata(""k1""));
    Mockito.verify(mockProv, Mockito.times(2)).getMetadata(Mockito.eq(""k1""));

    // asserting no caching when key is not known
    cache = new CachingKeyProvider(mockProv, 100, 100);
    Assert.assertEquals(null, cache.getMetadata(""k2""));
    Mockito.verify(mockProv, Mockito.times(1)).getMetadata(Mockito.eq(""k2""));
    Assert.assertEquals(null, cache.getMetadata(""k2""));
    Mockito.verify(mockProv, Mockito.times(2)).getMetadata(Mockito.eq(""k2""));
  }",No Smells
"@Test
  public void testRollNewVersion() throws Exception {
    KeyProvider.KeyVersion mockKey = Mockito.mock(KeyProvider.KeyVersion.class);
    KeyProvider mockProv = Mockito.mock(KeyProvider.class);
    Mockito.when(mockProv.getCurrentKey(Mockito.eq(""k1""))).thenReturn(mockKey);
    Mockito.when(mockProv.getConf()).thenReturn(new Configuration());
    KeyProvider cache = new CachingKeyProvider(mockProv, 100, 100);
    Assert.assertEquals(mockKey, cache.getCurrentKey(""k1""));
    Mockito.verify(mockProv, Mockito.times(1)).getCurrentKey(Mockito.eq(""k1""));
    cache.rollNewVersion(""k1"");

    // asserting the cache is purged
    Assert.assertEquals(mockKey, cache.getCurrentKey(""k1""));
    Mockito.verify(mockProv, Mockito.times(2)).getCurrentKey(Mockito.eq(""k1""));
    cache.rollNewVersion(""k1"", new byte[0]);
    Assert.assertEquals(mockKey, cache.getCurrentKey(""k1""));
    Mockito.verify(mockProv, Mockito.times(3)).getCurrentKey(Mockito.eq(""k1""));
  }",No Smells
"@Test
  public void testMaterialGeneration() throws Exception {
    MyKeyProvider kp = new MyKeyProvider(new Configuration());
    KeyProvider.Options options = new KeyProvider.Options(new Configuration());
    options.setCipher(CIPHER);
    options.setBitLength(128);
    kp.createKey(""hello"", options);
    Assert.assertEquals(128, kp.size);
    Assert.assertEquals(CIPHER, kp.algorithm);
    Assert.assertNotNull(kp.material);

    kp = new MyKeyProvider(new Configuration());
    kp.rollNewVersion(""hello"");
    Assert.assertEquals(128, kp.size);
    Assert.assertEquals(CIPHER, kp.algorithm);
    Assert.assertNotNull(kp.material);
  }",No Smells
"@Test
  public void testCreateExtension() throws Exception {
    Configuration conf = new Configuration();
    Credentials credentials = new Credentials();    
    KeyProvider kp = 
        new UserProvider.Factory().createProvider(new URI(""user:///""), conf);
    KeyProviderDelegationTokenExtension kpDTE1 = 
        KeyProviderDelegationTokenExtension
        .createKeyProviderDelegationTokenExtension(kp);
    Assert.assertNotNull(kpDTE1);
    Token<?>[] tokens = kpDTE1.addDelegationTokens(""user"", credentials);
    // Default implementation should return no tokens.
    Assert.assertNotNull(tokens);
    Assert.assertEquals(0, tokens.length);
    
    MockKeyProvider mock = mock(MockKeyProvider.class);
    Mockito.when(mock.getConf()).thenReturn(new Configuration());
    when(mock.getCanonicalServiceName()).thenReturn(""cservice"");
    when(mock.getDelegationToken(""renewer"")).thenReturn(
        new Token(null, null, new Text(""kind""), new Text(
            ""tservice""))
    );
    KeyProviderDelegationTokenExtension kpDTE2 =
        KeyProviderDelegationTokenExtension
        .createKeyProviderDelegationTokenExtension(mock);
    tokens = kpDTE2.addDelegationTokens(""renewer"", credentials);
    Assert.assertNotNull(tokens);
    Assert.assertEquals(1, tokens.length);
    Assert.assertEquals(""kind"", tokens[0].getKind().toString());
    Assert.assertEquals(""tservice"", tokens[0].getService().toString());
    Assert.assertNotNull(credentials.getToken(new Text(""cservice"")));
  }",No Smells
"@Test
  public void testJksProvider() throws Exception {
    Configuration conf = new Configuration();
    final Path jksPath = new Path(testRootDir.toString(), ""test.jks"");
    final String ourUrl =
        JavaKeyStoreProvider.SCHEME_NAME + ""://file"" + jksPath.toUri();

    File file = new File(testRootDir, ""test.jks"");
    file.delete();
    conf.set(KeyProviderFactory.KEY_PROVIDER_PATH, ourUrl);
    checkSpecificProvider(conf, ourUrl);

    // START : Test flush error by failure injection
    conf.set(KeyProviderFactory.KEY_PROVIDER_PATH, ourUrl.replace(
        JavaKeyStoreProvider.SCHEME_NAME,
        FailureInjectingJavaKeyStoreProvider.SCHEME_NAME));
    // get a new instance of the provider to ensure it was saved correctly
    KeyProvider provider = KeyProviderFactory.getProviders(conf).get(0);
    // inject failure during keystore write
    FailureInjectingJavaKeyStoreProvider fProvider =
        (FailureInjectingJavaKeyStoreProvider) provider;
    fProvider.setWriteFail(true);
    provider.createKey(""key5"", new byte[]{1}",Eager Test
"@Test
  public void testKeySuccessfulKeyLifecycle() throws Exception {
    int rc = 0;
    String keyName = ""key1"";

    KeyShell ks = new KeyShell();
    ks.setConf(new Configuration());

    outContent.reset();
    final String[] args1 = {""create"", keyName, ""-provider"", jceksProvider}",No Smells
"@Test
  public void testMultiPartUploadConcurrent() throws IOException {
    FileSystem.clearStatistics();
    long size = 50 * 1024 * 1024 - 1;
    ContractTestUtils.createAndVerifyFile(fs, getTestPath(), size);
    FileSystem.Statistics statistics =
        FileSystem.getStatistics(""oss"", AliyunOSSFileSystem.class);
    assertEquals(105, statistics.getReadOps());
    assertEquals(size, statistics.getBytesRead());
    assertEquals(52, statistics.getWriteOps());
    assertEquals(size, statistics.getBytesWritten());
    bufferShouldReleased();
  }",Mystery Guest
"@Test
  public void testZeroByteUpload() throws IOException {
    ContractTestUtils.createAndVerifyFile(fs, getTestPath(), 0);
    bufferShouldReleased(true);
  }",Mystery Guest
"@Test
  public void testOSSFileReaderTask() throws Exception {
    Path smallSeekFile = setPath(""/test/smallSeekFileOSSFileReader.txt"");
    long size = 5 * 1024 * 1024;

    ContractTestUtils.generateTestFile(this.fs, smallSeekFile, size, 256, 255);
    LOG.info(""5MB file created: smallSeekFileOSSFileReader.txt"");
    ReadBuffer readBuffer = new ReadBuffer(12, 24);
    AliyunOSSFileReaderTask task = new AliyunOSSFileReaderTask(""1"",
        ((AliyunOSSFileSystem)this.fs).getStore(), readBuffer);
    //NullPointerException, fail
    task.run();
    assertEquals(readBuffer.getStatus(), ReadBuffer.STATUS.ERROR);
    //OK
    task = new AliyunOSSFileReaderTask(
        ""test/test/smallSeekFileOSSFileReader.txt"",
        ((AliyunOSSFileSystem)this.fs).getStore(), readBuffer);
    task.run();
    assertEquals(readBuffer.getStatus(), ReadBuffer.STATUS.SUCCESS);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testSeekFile() throws Exception {
    Path smallSeekFile = setPath(""/test/smallSeekFile.txt"");
    long size = 5 * 1024 * 1024;

    ContractTestUtils.generateTestFile(this.fs, smallSeekFile, size, 256, 255);
    LOG.info(""5MB file created: smallSeekFile.txt"");

    FSDataInputStream instream = this.fs.open(smallSeekFile);
    int seekTimes = 5;
    LOG.info(""multiple fold position seeking test...:"");
    for (int i = 0; i < seekTimes; i++) {
      long pos = size / (seekTimes - i) - 1;
      LOG.info(""begin seeking for pos: "" + pos);
      instream.seek(pos);
      assertTrue(""expected position at:"" + pos + "", but got:""
          + instream.getPos(), instream.getPos() == pos);
      LOG.info(""completed seeking at pos: "" + instream.getPos());
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testSingleThreaded() throws Exception {
    AzureFileSystemInstrumentation instrumentation =
        new AzureFileSystemInstrumentation(new Configuration());
    BandwidthGaugeUpdater updater =
        new BandwidthGaugeUpdater(instrumentation, 1000, true);
    updater.triggerUpdate(true);
    assertEquals(0, AzureMetricsTestUtil.getCurrentBytesWritten(instrumentation));
    updater.blockUploaded(new Date(), new Date(), 150);
    updater.triggerUpdate(true);
    assertEquals(150, AzureMetricsTestUtil.getCurrentBytesWritten(instrumentation));
    updater.blockUploaded(new Date(new Date().getTime() - 10000),
        new Date(), 200);
    updater.triggerUpdate(true);
    long currentBytes = AzureMetricsTestUtil.getCurrentBytesWritten(instrumentation);
    assertTrue(
        ""We expect around (200/10 = 20) bytes written as the gauge value."" +
        ""Got "" + currentBytes,
        currentBytes > 18 && currentBytes < 22);
    updater.close();
  }",No Smells
"@Test
  public void testAppendBlockOperations() throws Exception {
    CloudBlobContainer container = getTestAccount().getRealContainer();

    OperationContext context = new OperationContext();
    context.getResponseReceivedEventHandler().addListener(
        new ResponseReceivedEventHandler());
    context.getSendingRequestEventHandler().addListener(
        new SendingRequestEventHandler());

    CloudAppendBlob appendBlob = container.getAppendBlobReference(
        ""testAppendBlockOperations"");
    assertNull(lastOperationTypeSent);
    assertNull(lastOperationTypeReceived);
    assertEquals(0, lastContentLengthReceived);

    try (
        BlobOutputStream output
            = appendBlob.openWriteNew(null, null, context);
    ) {
      assertEquals(BlobOperationDescriptor.OperationType.CreateBlob,
          lastOperationTypeReceived);
      assertEquals(0, lastContentLengthReceived);

      String message = ""this is a test"";
      output.write(message.getBytes(StandardCharsets.UTF_8));
      output.flush();
      assertEquals(BlobOperationDescriptor.OperationType.AppendBlock,
          lastOperationTypeSent);
      assertEquals(BlobOperationDescriptor.OperationType.AppendBlock,
          lastOperationTypeReceived);
      assertEquals(message.length(), lastContentLengthReceived);
    }",No Smells
"@Test
  public void testNoMetricUpdatesThenNoWaiting() {
    ClientThrottlingAnalyzer analyzer = new ClientThrottlingAnalyzer(
        ""test"",
        ANALYSIS_PERIOD);
    validate(0, analyzer.getSleepDuration());
    sleep(ANALYSIS_PERIOD_PLUS_10_PERCENT);
    validate(0, analyzer.getSleepDuration());
  }",No Smells
"@Test
  public void testDelete() throws Exception {
    Path danglingFile = new Path(""/crashedInTheMiddle"");

    // Create a file and leave it dangling and try to delete it.
    FSDataOutputStream stream = fs.create(danglingFile);
    stream.write(new byte[] { 1, 2, 3 }",Mystery Guest
"@Test
  public void testManySuccessAndErrorsAndWaiting() {
    AbfsClientThrottlingAnalyzer analyzer = new AbfsClientThrottlingAnalyzer(
        ""test"", abfsConfiguration);
    validate(0, analyzer.getSleepDuration());
    final int numberOfRequests = 20;
    for (int i = 0; i < numberOfRequests; i++) {
      analyzer.addBytesTransferred(8 * MEGABYTE, false);
      analyzer.addBytesTransferred(2 * MEGABYTE, true);
    }",Eager Test
"@Test
  public void testOnlySuccessThenNoWaiting() {
    AbfsClientThrottlingAnalyzer analyzer = new AbfsClientThrottlingAnalyzer(
        ""test"", abfsConfiguration);
    analyzer.addBytesTransferred(8 * MEGABYTE, false);
    validate(0, analyzer.getSleepDuration());
    sleep(ANALYSIS_PERIOD_PLUS_10_PERCENT);
    validate(0, analyzer.getSleepDuration());
  }",No Smells
"@Test
  public void testIfUriContainsAbfs() throws Exception {
    Assert.assertTrue(UriUtils.containsAbfsUrl(""abfs.dfs.core.windows.net""));
    Assert.assertTrue(UriUtils.containsAbfsUrl(""abfs.dfs.preprod.core.windows.net""));
    Assert.assertFalse(UriUtils.containsAbfsUrl(""abfs.dfs.cores.windows.net""));
    Assert.assertFalse(UriUtils.containsAbfsUrl(""""));
    Assert.assertFalse(UriUtils.containsAbfsUrl(null));
    Assert.assertFalse(UriUtils.containsAbfsUrl(""abfs.dfs.cores.windows.net""));
    Assert.assertFalse(UriUtils.containsAbfsUrl(""xhdfs.blob.core.windows.net""));
  }",No Smells
"@Test
  public void testCreatePermission() throws IOException {
    assumeNotWindows();
    String filename = ""foo"";
    Path f = fileContextTestHelper.getTestRootPath(fc, filename);
    fileContextTestHelper.createFile(fc, filename);
    doFilePermissionCheck(FileContext.FILE_DEFAULT_PERM.applyUMask(fc.getUMask()),
                        fc.getFileStatus(f).getPermission());
  }",Mystery Guest
"@Test
  public void testCreateFileWithNullName() throws IOException {
    String fileName = null;

    try {

      Path testPath = qualifiedPath(fileName, fc2);
      // Ensure file does not exist
      Assert.assertFalse(exists(fc2, testPath));

      // Create a file on fc2's file system using fc1
      createFile(fc1, testPath);
      Assert.fail(""Create file with null name should throw IllegalArgumentException."");
    }",Mystery Guest
"@Test
  public void testListStatusThrowsExceptionForNonExistentFile()
      throws Exception {
    String testFile = ""test/hadoop/file"";
    Path testPath = qualifiedPath(testFile, fc2);
    try {
      fc1.listStatus(testPath);
      Assert.fail(""Should throw FileNotFoundException"");
    }",Mystery Guest + Resource Optimism
"@Test
  public void testFTPDefaultPort() throws Exception {
    FTPFileSystem ftp = new FTPFileSystem();
    assertEquals(FTP.DEFAULT_PORT, ftp.getDefaultPort());
  }",No Smells
"@Test
  public void testGetFsAction(){
    FTPFileSystem ftp = new FTPFileSystem();
    int[] accesses = new int[] {FTPFile.USER_ACCESS, FTPFile.GROUP_ACCESS,
        FTPFile.WORLD_ACCESS}",Eager Test
"@Test
  public void testDoubleStop() throws Exception {
    webServer = createWebServer(createConfigurationWithRandomSecret());
    webServer.start();
    webServer.stop();
    webServer.stop();
  }",No Smells
"@Test
  public void testStructureGenerator() throws Exception {
    StructureGenerator sg = new StructureGenerator();
    String[] args = new String[]{""-maxDepth"", ""2"", ""-minWidth"", ""1"",
        ""-maxWidth"", ""2"", ""-numOfFiles"", ""2"",
        ""-avgFileSize"", ""1"", ""-outDir"", OUT_DIR.getAbsolutePath(), ""-seed"", ""1""}",Mystery Guest + Resource Optimism
"@Test
  public void testUMaskParser() throws IOException {
    Configuration conf = new Configuration();
    
    // Ensure that we get the right octal values back for all legal values
    for(FsAction u : FsAction.values()) {
      for(FsAction g : FsAction.values()) {
        for(FsAction o : FsAction.values()) {
          FsPermission f = new FsPermission(u, g, o);
          String asOctal = String.format(""%1$03o"", f.toShort());
          conf.set(FsPermission.UMASK_LABEL, asOctal);
          FsPermission fromConf = FsPermission.getUMask(conf);
          assertEquals(f, fromConf);
        }",Eager Test
"@Test
  public void testAbortJobNotTask() throws Exception {
    executeWork(""abort task no work"",
        (job, jContext, tContext, committer) -> {
          // write output
          writeTextOutput(tContext);
          committer.abortJob(jContext, JobStatus.State.RUNNING);
          assertTaskAttemptPathDoesNotExist(
              committer, tContext);
          assertJobAttemptPathDoesNotExist(
              committer, jContext);
          assertNoMultipartUploadsPending(outDir);
        }",No Smells
"@Test
  public void testCommitJobButNotTask() throws Exception {
    executeWork(""commit a job while a task's work is pending, "" +
            ""expect task writes to be cancelled."",
        (job, jContext, tContext, committer) -> {
          // step 1: write the text
          writeTextOutput(tContext);
          // step 2: commit the job
          createCommitter(tContext).commitJob(tContext);
          // verify that no output can be observed
          assertPart0000DoesNotExist(outDir);
          // that includes, no pending MPUs; commitJob is expected to
          // cancel any.
          assertNoMultipartUploadsPending(outDir);
        }",No Smells
"@Test
  public void testCommitterWithFailure() throws Exception {
    describe(""Fail the first job commit then retry"");
    JobData jobData = startJob(new FailingCommitterFactory(), true);
    JobContext jContext = jobData.jContext;
    TaskAttemptContext tContext = jobData.tContext;
    AbstractS3ACommitter committer = jobData.committer;

    // do commit
    committer.commitTask(tContext);

    // now fail job
    expectSimulatedFailureOnJobCommit(jContext, committer);

    commitJob(committer, jContext);

    // but the data got there, due to the order of operations.
    validateContent(outDir, shouldExpectSuccessMarker(),
        committer.getUUID());
    expectJobCommitToFail(jContext, committer);
  }",No Smells
"@Test
  public void testFailAbort() throws Exception {
    describe(""Abort the task, then job (failed), abort the job again"");
    JobData jobData = startJob(true);
    JobContext jContext = jobData.jContext;
    TaskAttemptContext tContext = jobData.tContext;
    AbstractS3ACommitter committer = jobData.committer;

    // do abort
    committer.abortTask(tContext);

    committer.getJobAttemptPath(jContext);
    committer.getTaskAttemptPath(tContext);
    assertPart0000DoesNotExist(outDir);
    assertSuccessMarkerDoesNotExist(outDir);
    describe(""Aborting job into %s"", outDir);

    committer.abortJob(jContext, JobStatus.State.FAILED);

    assertTaskAttemptPathDoesNotExist(committer, tContext);
    assertJobAttemptPathDoesNotExist(committer, jContext);

    // try again; expect abort to be idempotent.
    committer.abortJob(jContext, JobStatus.State.FAILED);
    assertNoMultipartUploadsPending(outDir);

  }",No Smells
"@Test
  public void testGetPartition() {
    assertEquals(""year=2017/month=10"",
        getPartition(""year=2017/month=10/part-0000.avro""));
  }",No Smells
"@Test
  public void testRelativizeParent() {
    // goes up to the parent if one is above the other
    assertEquals(""/"", getRelativePath(BASE, BASE.getParent()));
  }",No Smells
"@Test
  public void testUUIDDottedPath() {
    assertUUIDAdded(""/parent.dir/part-0000"", ""/parent.dir/part-0000-UUID"");
  }",No Smells
"@Test
  public void testAttemptPathConstructionWrongSchema() throws Exception {
    Configuration config = newConfig();
    final String jobUUID = addUUID(config);
    config.set(BUFFER_DIR,
        ""hdfs://nn:8020/tmp/mr-local-0,hdfs://nn:8020/tmp/mr-local-1"");
    intercept(IllegalArgumentException.class, ""Wrong FS"",
        () -> getLocalTaskAttemptTempDir(config, jobUUID,
                tac.getTaskAttemptID()));
  }",Mystery Guest
"@Test
  public void testCommitPathConstruction() throws Exception {
    Path committedTaskPath = committer.getCommittedTaskPath(tac);
    assertEquals(""Path should be in HDFS: "" + committedTaskPath,
        ""hdfs"", committedTaskPath.toUri().getScheme());
    String ending = STAGING_UPLOADS + ""/_temporary/0/task_job_0001_r_000002"";
    assertTrue(""Did not end with \"""" + ending +""\"" :"" + committedTaskPath,
        committedTaskPath.toString().endsWith(ending));
  }",No Smells
"@Test
  public void testJobCommitFailure() throws Exception {
    Path jobAttemptPath = jobCommitter.getJobAttemptPath(job);
    FileSystem fs = jobAttemptPath.getFileSystem(conf);

    Set<String> uploads = runTasks(job, 4, 3);

    assertPathExists(fs, ""No job attempt path"", jobAttemptPath);

    errors.failOnCommit(5);
    setMockLogLevel(MockS3AFileSystem.LOG_NAME);

    intercept(IOException.class,
        ""Fail on commit 5"",
        ""Should propagate the commit failure"",
        () -> {
          jobCommitter.commitJob(job);
          return jobCommitter.toString();
        }",Mystery Guest
"@Test
  public void testTaskInitializeFailure() throws Exception {
    committer.setupTask(tac);

    errors.failOnInit(1);

    Path attemptPath = committer.getTaskAttemptPath(tac);
    FileSystem fs = attemptPath.getFileSystem(conf);

    writeOutputFile(tac.getTaskAttemptID(), attemptPath,
        UUID.randomUUID().toString(), 10);
    writeOutputFile(tac.getTaskAttemptID(), attemptPath,
        UUID.randomUUID().toString(), 10);

    intercept(IOException.class,
        ""Fail on init 1"",
        ""Should fail during init"",
        () -> committer.commitTask(tac));

    assertEquals(""Should have initialized one file upload"",
        1, results.getUploads().size());
    assertEquals(""Should abort the upload"",
        new HashSet<>(results.getUploads()),
        getAbortedIds(results.getAborts()));
    assertPathDoesNotExist(fs,
        ""Should remove the attempt path"",
        attemptPath);
  }",No Smells
"@Test
  public void testFinalDestinationBaseDirectChild() {
    finalDestination(l(MAGIC_PATH_PREFIX, BASE, ""3.txt""));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testFinalDestinationMagic1() {
    assertEquals(l(""first"", ""2""),
        finalDestination(l(""first"", MAGIC_PATH_PREFIX, ""2"")));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testLastElementSingle() {
    assertEquals(""first"", lastElement(l(""first"")));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testParentDeepMagic() {
    assertParents(a(""parent1"", ""parent2""), DEEP_MAGIC);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testSplitRootPath() {
    assertPathSplits(""/"", EMPTY);
  }",No Smells
"@Test
  public void testConnectionRetryPolicyIdempotent() throws Throwable {
    assertRetryAction(""Expected retry on connection timeout"",
        RETRY_POLICY, RetryPolicy.RetryAction.RETRY,
        HADOOP_CONNECTION_TIMEOUT_EX, 1, true);
    assertRetryAction(""Expected connection timeout failure"",
        RETRY_POLICY, RetryPolicy.RetryAction.FAIL,
        HADOOP_CONNECTION_TIMEOUT_EX, RETRIES_TOO_MANY, true);
  }",No Smells
"@Test
  public void testConnectionRetryPolicyNonIdempotent() throws Throwable {
    assertRetryAction(""Expected retry on connection timeout"",
        RETRY_POLICY, RetryPolicy.RetryAction.RETRY,
        HADOOP_CONNECTION_TIMEOUT_EX, 1, false);
  }",No Smells
"@Test
  public void testNPEsNotRetried() throws Throwable {
    assertRetryAction(""Expected NPE trigger failure"",
        RETRY_POLICY, RetryPolicy.RetryAction.FAIL,
        new NullPointerException(""oops""), 1, true);
    // catch notification didn't see it
    assertEquals(""retry count "", 0, retryCount);
  }",No Smells
"@Test
  public void testQuietlyEvalReturnValueFail() {
    // use a variable so IDEs don't warn of numeric overflows
    int d = 0;
    assertOptionalUnset(""quietly"",
        quietlyEval("""", """", () -> 3 / d));
  }",No Smells
"@Test
  public void testQuietlyVoid() {
    quietlyEval("""", """",
        () -> {
        throw HADOOP_CONNECTION_TIMEOUT_EX;
      }",No Smells
"@Test
  public void testS3500isStatus500Exception() throws Exception {
    verifyTranslated(SC_500_INTERNAL_SERVER_ERROR, AWSStatus500Exception.class);
  }",No Smells
"@Test
  public void testShadedConnectionTimeoutExceptionMatching() throws Throwable {
    // connection timeout exceptions are special, but as AWS shades
    // theirs, we need to string match them
    verifyTranslated(ConnectTimeoutException.class,
        SdkException.builder()
            .cause(LOCAL_CONNECTION_TIMEOUT_EX)
            .build());
  }",No Smells
"@Test
  public void testFsUriNoUserNoPass() throws Throwable {
    assertMatchesEndpoint(NO_USER_NO_PASS);
  }",No Smells
"@Test
  public void testFsUriWithPlusInPass() throws Throwable {
    assertInvalid(WITH_PLUS_IN_PASS);
  }",No Smells
"@Test
  public void testFsUriWithSlashInPass() throws Throwable {
    assertInvalid(WITH_SLASH_IN_PASS);
  }",No Smells
"@Test
  public void testLoginNoUserNoPassTwoColon() throws Throwable {
    assertMatchesLogin("""", """", NO_USER_NO_PASS_TWO_COLON);
  }",No Smells
"@Test
  public void testSimpleFSURI() throws Throwable {
    assertMatchesEndpoint(ENDPOINT);
  }",No Smells
"@Test
  public void testCreateFile() throws Exception {
    Path file = touch(sftpFs, name.getMethodName().toLowerCase());
    assertTrue(localFs.exists(file));
    assertTrue(sftpFs.delete(file, false));
    assertFalse(localFs.exists(file));
    assertThat(
        ((SFTPFileSystem) sftpFs).getConnectionPool().getLiveConnCount())
        .isEqualTo(1);
  }",Mystery Guest
"@Test
  public void testReadFile() throws Exception {
    byte[] data = ""yaks"".getBytes();
    Path file = touch(localFs, name.getMethodName().toLowerCase(), data);
    FSDataInputStream is = null;
    try {
      is = sftpFs.open(file);
      byte[] b = new byte[data.length];
      is.read(b);
      assertArrayEquals(data, b);
    }",Mystery Guest
"@Test
  public void testRenameFile() throws Exception {
    byte[] data = ""dingos"".getBytes();
    Path file1 = touch(localFs, name.getMethodName().toLowerCase() + ""1"");
    Path file2 = new Path(localDir, name.getMethodName().toLowerCase() + ""2"");

    assertTrue(sftpFs.rename(file1, file2));

    assertTrue(sftpFs.exists(file2));
    assertFalse(sftpFs.exists(file1));

    assertTrue(localFs.exists(file2));
    assertFalse(localFs.exists(file1));

    assertTrue(sftpFs.delete(file2, false));
    assertThat(
        ((SFTPFileSystem) sftpFs).getConnectionPool().getLiveConnCount())
        .isEqualTo(1);
  }",Mystery Guest
"@Test
  public void testStatFile() throws Exception {
    byte[] data = ""yaks"".getBytes();
    Path file = touch(localFs, name.getMethodName().toLowerCase(), data);

    FileStatus lstat = localFs.getFileStatus(file);
    FileStatus sstat = sftpFs.getFileStatus(file);
    assertNotNull(sstat);

    assertEquals(lstat.getPath().toUri().getPath(),
                 sstat.getPath().toUri().getPath());
    assertEquals(data.length, sstat.getLen());
    assertEquals(lstat.getLen(), sstat.getLen());
    assertTrue(sftpFs.delete(file, false));
    assertThat(
        ((SFTPFileSystem) sftpFs).getConnectionPool().getLiveConnCount())
        .isEqualTo(1);
  }",Mystery Guest
"@Test
  public void testSetOptions() throws IOException {
    And and = new And();
    Expression first = mock(Expression.class);
    Expression second = mock(Expression.class);

    Deque<Expression> children = new LinkedList<Expression>();
    children.add(second);
    children.add(first);
    and.addChildren(children);

    FindOptions options = mock(FindOptions.class);
    and.setOptions(options);
    verify(first).setOptions(options);
    verify(second).setOptions(options);
    verifyNoMoreInteractions(first);
    verifyNoMoreInteractions(second);
  }",No Smells
"@Test
  public void testLsAclsUnsupported() throws Exception {
    Configuration conf = new Configuration();
    conf.set(CommonConfigurationKeys.FS_DEFAULT_NAME_KEY, ""stubfs:///"");
    conf.setClass(""fs.stubfs.impl"", StubFileSystem.class, FileSystem.class);
    assertEquals(""ls must succeed even if FileSystem does not implement ACLs."",
      0, ToolRunner.run(conf, new FsShell(), new String[] { ""-ls"", ""/"" }",No Smells
"@Test
  public void testGetInstances() {
    factory.registerCommands(TestRegistrar.class);

    Command instance;
    instance = factory.getInstance(""blarg"");
    assertNull(instance);
    
    instance = factory.getInstance(""tc1"");
    assertNotNull(instance);
    assertEquals(TestCommand1.class, instance.getClass());
    assertEquals(""tc1"", instance.getCommandName());
    
    instance = factory.getInstance(""tc2"");
    assertNotNull(instance);
    assertEquals(TestCommand2.class, instance.getClass());
    assertEquals(""tc2"", instance.getCommandName());

    instance = factory.getInstance(""tc2.1"");
    assertNotNull(instance);
    assertEquals(TestCommand2.class, instance.getClass());    
    assertEquals(""tc2.1"", instance.getCommandName());
    
    factory.addClass(TestCommand4.class, ""tc4"");
    instance = factory.getInstance(""tc4"");
    assertNotNull(instance);
    assertEquals(TestCommand4.class, instance.getClass());    
    assertEquals(""tc4"", instance.getCommandName());
    String usage = instance.getUsage();
    assertEquals(""-tc4 tc4_usage"", usage);
    assertEquals(""tc4_description"", instance.getDescription());
  }",No Smells
"@Test
  public void testPrintableCharacters() throws Exception {
    // ASCII
    expect(""Should keep ASCII letter"", ""abcdef237"", ""abcdef237"");
    expect(""Should keep ASCII symbol"", "" !\""|}",No Smells
"@Test
  public void testGetfattrValidations() throws Exception {
    errContent.reset();
    assertFalse(""getfattr should fail without path"",
        0 == runCommand(new String[] { ""-getfattr"", ""-d""}",No Smells
"@Test
  public void testDifferentTagsDontMatch() {
    assertNotEquals(valid1, tag(""other valid one""));
  }",No Smells
"@Test
  public void testEmptyTagsEqual() {
    assertEquals(empty1, empty2);
  }",No Smells
"@Test
  public void testValidAndEmptyTagsDontMatch() {
    assertNotEquals(valid1, empty1);
    assertNotEquals(valid1, tag(""other valid one""));
  }",No Smells
"@Test
  public void testValidTagsEqual() {
    assertEquals(valid1, valid2);
  }",No Smells
"@Test
  public void testRenameFileIntoDir() throws Exception {
    Path srcPath = new Path(TEST_ROOT_DIR, ""testRenameSrc"");
    Path dstPath = new Path(TEST_ROOT_DIR, ""testRenameDir"");
    localFs.mkdirs(dstPath);
    verifyRename(srcPath, dstPath, true);
  }",Mystery Guest
"@Test
  public void testRenameFileToFile() throws Exception {
    Path srcPath = new Path(TEST_ROOT_DIR, ""testRenameSrc"");
    Path dstPath = new Path(TEST_ROOT_DIR, ""testRenameDst"");
    verifyRename(srcPath, dstPath, false);
  }",Mystery Guest
"@Test
  public void testSetPermissionCrc() throws Exception {
    FileSystem rawFs = localFs.getRawFileSystem();
    Path p = new Path(TEST_ROOT_DIR, ""testCrcPermissions"");
    localFs.createNewFile(p);
    Path crc = localFs.getChecksumFile(p);
    assert(rawFs.exists(crc));

    for (short mode : Arrays.asList((short)0666, (short)0660, (short)0600)) {
      FsPermission perm = new FsPermission(mode);
      localFs.setPermission(p, perm);
      assertEquals(perm, localFs.getFileStatus(p).getPermission());
      assertEquals(perm, rawFs.getFileStatus(crc).getPermission());
    }",Mystery Guest
"@Test
  public void testNoArgs() {
    checkArgLimits(null, 0, 0);
    checkArgLimits(null, 0, 1);    
    checkArgLimits(NotEnoughArgumentsException.class, 1, 1);
    checkArgLimits(NotEnoughArgumentsException.class, 1, 2);
  }",No Smells
"@Test
  public void testOneOpt() {
    args = listOf(""-a"");
    expectedOpts = setOf(""a"");
    
    checkArgLimits(UnknownOptionException.class, 0, 0);
    checkArgLimits(null, 0, 0, ""a"", ""b"");
    checkArgLimits(NotEnoughArgumentsException.class, 1, 1, ""a"", ""b"");
  }",No Smells
"@Test
  public void testGetHeaderWithQuota() {
    String header = ""       QUOTA       REM_QUOTA     SPACE_QUOTA ""
        + ""REM_SPACE_QUOTA    DIR_COUNT   FILE_COUNT       CONTENT_SIZE "";
    assertEquals(header, ContentSummary.getHeader(true));
  }",No Smells
"@Test
  public void testReadFields() throws IOException {
    long length = 11111;
    long fileCount = 22222;
    long directoryCount = 33333;
    long quota = 44444;
    long spaceConsumed = 55555;
    long spaceQuota = 66666;

    ContentSummary contentSummary = new ContentSummary.Builder().build();

    DataInput in = mock(DataInput.class);
    when(in.readLong()).thenReturn(length).thenReturn(fileCount)
        .thenReturn(directoryCount).thenReturn(quota).thenReturn(spaceConsumed)
        .thenReturn(spaceQuota);

    contentSummary.readFields(in);
    assertEquals(""getLength"", length, contentSummary.getLength());
    assertEquals(""getFileCount"", fileCount, contentSummary.getFileCount());
    assertEquals(""getDirectoryCount"", directoryCount,
        contentSummary.getDirectoryCount());
    assertEquals(""getQuota"", quota, contentSummary.getQuota());
    assertEquals(""getSpaceConsumed"", spaceConsumed,
        contentSummary.getSpaceConsumed());
    assertEquals(""getSpaceQuota"", spaceQuota, contentSummary.getSpaceQuota());
  }",No Smells
"@Test
  public void testToStringHumanWithQuota() {
    long length = Long.MAX_VALUE;
    long fileCount = 222222222;
    long directoryCount = 33333;
    long quota = 222256578;
    long spaceConsumed = 1073741825;
    long spaceQuota = 1;

    ContentSummary contentSummary = new ContentSummary.Builder().length(length).
        fileCount(fileCount).directoryCount(directoryCount).quota(quota).
        spaceConsumed(spaceConsumed).spaceQuota(spaceQuota).build();
    String expected = ""     212.0 M            1023               1 ""
        + ""           -1 G       32.6 K      211.9 M              8.0 E "";
    assertEquals(expected, contentSummary.toString(true, true));
  }",No Smells
"@Test
  public void testToStringNoQuota() {
    long length = 11111;
    long fileCount = 22222;
    long directoryCount = 33333;

    ContentSummary contentSummary = new ContentSummary.Builder().length(length).
        fileCount(fileCount).directoryCount(directoryCount).build();
    String expected = ""        none             inf            none""
        + ""             inf        33333        22222              11111 "";
    assertEquals(expected, contentSummary.toString(true));
  }",No Smells
"@Test
  public void testToStringNoShowQuota() {
    long length = 11111;
    long fileCount = 22222;
    long directoryCount = 33333;
    long quota = 44444;
    long spaceConsumed = 55555;
    long spaceQuota = 66665;

    ContentSummary contentSummary = new ContentSummary.Builder().length(length).
        fileCount(fileCount).directoryCount(directoryCount).quota(quota).
        spaceConsumed(spaceConsumed).spaceQuota(spaceQuota).build();
    String expected = ""       33333        22222              11111 "";
    assertEquals(expected, contentSummary.toString(false));
  }",No Smells
"@Test
  public void testToStringWithQuota() {
    long length = 11111;
    long fileCount = 22222;
    long directoryCount = 33333;
    long quota = 44444;
    long spaceConsumed = 55555;
    long spaceQuota = 66665;

    ContentSummary contentSummary = new ContentSummary.Builder().length(length).
        fileCount(fileCount).directoryCount(directoryCount).quota(quota).
        spaceConsumed(spaceConsumed).spaceQuota(spaceQuota).build();
    String expected = ""       44444          -11111           66665           11110""
        + ""        33333        22222              11111 "";
    assertEquals(expected, contentSummary.toString(true));
  }",No Smells
"@Test
  public void testDefaultURIWithoutScheme() throws Exception {
    final Configuration conf = new Configuration();
    conf.set(FileSystem.FS_DEFAULT_NAME_KEY, ""/"");
    try {
      FileContext.getFileContext(conf);
      fail(UnsupportedFileSystemException.class + "" not thrown!"");
    }",No Smells
"@Test
  public void testFsClose() throws Exception {
    {
      Configuration conf = new Configuration();
      new Path(""file:///"").getFileSystem(conf);
      FileSystem.closeAll();
    }",Mystery Guest
"@Test
  public void testCompareFsNull() throws Exception {
    setupCompareFs();
    assertFalse(FileUtil.compareFs(null, fs1));
    assertFalse(FileUtil.compareFs(fs1, null));
  }",No Smells
"@Test
  public void testReadSymlinkWithNullInput() {
    String result = FileUtil.readLink(null);
    Assert.assertEquals("""", result);
  }",Mystery Guest
"@Test
  public void testReadSymlinkWithAFileAsInput() throws IOException {
    File file = new File(del, FILE);

    String result = FileUtil.readLink(file);
    Assert.assertEquals("""", result);

    Verify.delete(file);
  }",Mystery Guest
"@Test
  public void testSymlink2DifferentFile() throws IOException {
    File file = new File(del, FILE);
    File fileSecond = new File(del, FILE + ""_1"");
    File link = new File(del, ""_link"");

    // Create a symbolic link
    // The operation should succeed
    int result =
        FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath());

    Assert.assertEquals(0, result);

    // The operation should fail and returns 1
    result =
        FileUtil.symLink(fileSecond.getAbsolutePath(), link.getAbsolutePath());

    Assert.assertEquals(1, result);
  }",Mystery Guest
"@Test
  public void testFilterEmbedInit() throws Exception {
    FileSystem mockFs = createMockFs(false); // no conf = need init
    checkInit(new FilterFileSystem(mockFs), true);
  }",No Smells
"@Test
  public void testFilterEmbedNoInit() throws Exception {
    FileSystem mockFs = createMockFs(true); // has conf = skip init
    checkInit(new FilterFileSystem(mockFs), false);
  }",No Smells
"@Test
  public void testFilterFileSystem() throws Exception {
    int errors = 0;
    for (Method m : FileSystem.class.getDeclaredMethods()) {
      if (Modifier.isStatic(m.getModifiers()) ||
          Modifier.isPrivate(m.getModifiers()) ||
          Modifier.isFinal(m.getModifiers())) {
        continue;
      }",Eager Test
"@Test
  public void testLocalEmbedNoInit() throws Exception {
    FileSystem mockFs = createMockFs(true); // has conf = skip init
    checkInit(new LocalFileSystem(mockFs), false);
  }",No Smells
"@Test
  public void testVerifyChecksumPassthru() {
    FileSystem mockFs = mock(FileSystem.class);
    FileSystem fs = new FilterFileSystem(mockFs);

    fs.setVerifyChecksum(false);
    verify(mockFs).setVerifyChecksum(eq(false));
    reset(mockFs);
    fs.setVerifyChecksum(true);
    verify(mockFs).setVerifyChecksum(eq(true));
  }",No Smells
"@Test
  public void testFilterFileSystem() throws Exception {
    for (Method m : AbstractFileSystem.class.getDeclaredMethods()) {
      if (Modifier.isStatic(m.getModifiers()))
        continue;
      if (Modifier.isPrivate(m.getModifiers()))
        continue;
      if (Modifier.isFinal(m.getModifiers()))
        continue;
      
      try {
        DontCheck.class.getMethod(m.getName(), m.getParameterTypes());
        LOG.info(""Skipping "" + m);
      }",Eager Test
"@Test
  public void testFilteringWithNonrequiredAuthority() throws Exception {
    Configuration conf = new Configuration();
    ConfigUtil.addLink(conf, ""custom"", ""/mnt"", URI.create(""file:///""));
    FileContext fc =
        FileContext.getFileContext(URI.create(""viewfs://custom/""), conf);
    new FilterFs(fc.getDefaultFileSystem()) {}",No Smells
"@Test
  public void testBuilderConf() throws Exception {
    File file = new File(DIR, ""testBuilderConf"");
    assertTrue(file.createNewFile());
    Configuration conf = new Configuration();
    conf.set(""fs.getspaceused.classname"", DummyDU.class.getName());
    CachingGetSpaceUsed instance =
        (CachingGetSpaceUsed) new CachingGetSpaceUsed.Builder()
            .setPath(file)
            .setInterval(0)
            .setConf(conf)
            .build();
    assertNotNull(instance);
    assertTrue(instance instanceof DummyDU);
    assertFalse(instance.running());
    instance.close();
  }",No Smells
"@Test
  public void testExpansionIsIdentical() throws IOException {
    checkExpansionIsIdentical("""");
    checkExpansionIsIdentical(""/}",No Smells
"@Test
  public void testCreateHardLinkMult() throws IOException {
    //hardlink a whole list of three files at once
    String[] fileNames = src.list();
    createHardLinkMult(src, fileNames, tgt_mult);
    
    //validate by link count - each file has been linked once,
    //so each count is ""2""
    assertEquals(2, getLinkCount(x1));
    assertEquals(2, getLinkCount(x2));
    assertEquals(2, getLinkCount(x3));
    assertEquals(2, getLinkCount(x1_mult));
    assertEquals(2, getLinkCount(x2_mult));
    assertEquals(2, getLinkCount(x3_mult));

    //validate by contents
    validateTgtMult();
    
    //validate that change of content is reflected in the other linked files
    appendToFile(x1_mult, str3);
    assertTrue(fetchFileContents(x1_mult).equals(str1 + str3));
    assertTrue(fetchFileContents(x1).equals(str1 + str3));
  }",No Smells
"@Test
  public void testCreateHardLinkMultEmptyList() throws IOException {
    String[] emptyList = {}",No Smells
"@Test
  public void testHarUri() {
    final Configuration conf = new Configuration();
    checkInvalidPath(""har://hdfs-/foo.har"", conf);
    checkInvalidPath(""har://hdfs/foo.har"", conf);
    checkInvalidPath(""har://-hdfs/foo.har"", conf);
    checkInvalidPath(""har://-/foo.har"", conf);
    checkInvalidPath(""har://127.0.0.1-/foo.har"", conf);
    checkInvalidPath(""har://127.0.0.1/foo.har"", conf);
  }",No Smells
"@Test
  public void testCreateFileAndMkdirs() throws IOException {
    Path test_dir = new Path(TEST_ROOT_DIR, ""test_dir"");
    Path test_file = new Path(test_dir, ""file1"");
    assertTrue(fileSys.mkdirs(test_dir));
   
    final int fileSize = new Random().nextInt(1 << 20) + 1;
    writeFile(fileSys, test_file, fileSize);

    {
      //check FileStatus and ContentSummary 
      final FileStatus status = fileSys.getFileStatus(test_file);
      Assert.assertEquals(fileSize, status.getLen());
      final ContentSummary summary = fileSys.getContentSummary(test_dir);
      Assert.assertEquals(fileSize, summary.getLength());
    }",No Smells
"@Test
  public void testPathEscapes() throws IOException {
    Path path = new Path(TEST_ROOT_DIR, ""foo%bar"");
    writeFile(fileSys, path, 1);
    FileStatus status = fileSys.getFileStatus(path);
    assertEquals(fileSys.makeQualified(path), status.getPath());
    cleanupFile(fileSys, path);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testStatistics() throws Exception {
    int fileSchemeCount = 0;
    for (Statistics stats : FileSystem.getAllStatistics()) {
      if (stats.getScheme().equals(""file"")) {
        fileSchemeCount++;
      }",Eager Test
"@Test
  public void testSyncable() throws IOException {
    FileSystem fs = fileSys.getRawFileSystem();
    Path file = new Path(TEST_ROOT_DIR, ""syncable"");
    FSDataOutputStream out = fs.create(file);
    final int bytesWritten = 1;
    byte[] expectedBuf = new byte[] {'0', '1', '2', '3'}",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testToStringNoQuota() {
    QuotaUsage quotaUsage = new QuotaUsage.Builder().
        fileAndDirectoryCount(1234).build();
    String expected = ""        none             inf            none""
        + ""             inf "";
    assertEquals(expected, quotaUsage.toString());
  }",No Smells
"@Test
  public void testExistingFileTrash() throws IOException {
    Configuration conf = new Configuration();
    conf.setClass(""fs.file.impl"", TestLFS.class, FileSystem.class);
    FileSystem fs = FileSystem.getLocal(conf);
    conf.set(""fs.defaultFS"", fs.getUri().toString());
    conf.setLong(FS_TRASH_INTERVAL_KEY, 0); // disabled
    assertFalse(new Trash(conf).isEnabled());

    conf.setLong(FS_TRASH_INTERVAL_KEY, -1); // disabled
    assertFalse(new Trash(conf).isEnabled());

    conf.setLong(FS_TRASH_INTERVAL_KEY, 10); // 10 minute
    assertTrue(new Trash(conf).isEnabled());

    FsShell shell = new FsShell();
    shell.setConf(conf);

    // First create a new directory with mkdirs
    Path myPath = new Path(TEST_DIR, ""test/mkdirs"");
    mkdir(fs, myPath);

    // Second, create a file in that directory.
    Path myFile = new Path(TEST_DIR, ""test/mkdirs/myExistingFile"");
    writeFile(fs, myFile, 10);
    // First rm a file
    mkdir(fs, myPath);
    writeFile(fs, myFile, 10);

    String[] args1 = new String[2];
    args1[0] = ""-rm"";
    args1[1] = myFile.toString();
    int val1 = -1;
    try {
      val1 = shell.run(args1);
    }",No Smells
"@Test
  public void testPluggableTrash() throws IOException {
    Configuration conf = new Configuration();

    // Test plugged TrashPolicy
    conf.setClass(""fs.trash.classname"", TestTrashPolicy.class, TrashPolicy.class);
    Trash trash = new Trash(conf);
    assertTrue(trash.getTrashPolicy().getClass().equals(TestTrashPolicy.class));
  }",No Smells
"@Test
  public void testTrashRestarts() throws Exception {
    Configuration conf = new Configuration();
    conf.setClass(""fs.trash.classname"",
        AuditableTrashPolicy.class,
        TrashPolicy.class);
    conf.setClass(""fs.file.impl"", TestLFS.class, FileSystem.class);
    conf.set(FS_TRASH_INTERVAL_KEY, ""50""); // in milliseconds for test
    Trash trash = new Trash(conf);
    // create 5 checkpoints
    for(int i=0; i<5; i++) {
      trash.checkpoint();
    }",Eager Test
"@Test
  public void testXAttrEquals() {
    assertNotSame(XATTR1, XATTR2);
    assertNotSame(XATTR2, XATTR3);
    assertNotSame(XATTR3, XATTR4);
    assertNotSame(XATTR4, XATTR5);
    assertEquals(XATTR, XATTR1);
    assertEquals(XATTR1, XATTR1);
    assertEquals(XATTR2, XATTR2);
    assertEquals(XATTR3, XATTR3);
    assertEquals(XATTR4, XATTR4);
    assertEquals(XATTR5, XATTR5);
    assertNotEquals(XATTR1, XATTR2);
    assertNotEquals(XATTR2, XATTR3);
    assertNotEquals(XATTR3, XATTR4);
    assertNotEquals(XATTR4, XATTR5);
  }",No Smells
"@Test
  public void testXAttrHashCode() {
    assertEquals(XATTR.hashCode(), XATTR1.hashCode());
    assertNotEquals(XATTR1.hashCode(), XATTR2.hashCode());
    assertNotEquals(XATTR2.hashCode(), XATTR3.hashCode());
    assertNotEquals(XATTR3.hashCode(), XATTR4.hashCode());
    assertNotEquals(XATTR4.hashCode(), XATTR5.hashCode());
  }",No Smells
"@Test
  public void testBasicPaths() {
    URI uri = fSys.getUri();
    Assert.assertEquals(chrootedTo.toUri(), uri);
    Assert.assertEquals(fSys.makeQualified(
        new Path(System.getProperty(""user.home""))),
        fSys.getWorkingDirectory());
    Assert.assertEquals(fSys.makeQualified(
        new Path(System.getProperty(""user.home""))),
        fSys.getHomeDirectory());
    /*
     * ChRootedFs as its uri like file:///chrootRoot.
     * This is questionable since path.makequalified(uri, path) ignores
     * the pathPart of a uri. So our notion of chrooted URI is questionable.
     * But if we were to fix Path#makeQualified() then  the next test should
     *  have been:

    Assert.assertEquals(
        new Path(chrootedTo + ""/foo/bar"").makeQualified(
            FsConstants.LOCAL_FS_URI, null),
        fSys.makeQualified(new Path( ""/foo/bar"")));
    */
    
    Assert.assertEquals(
        new Path(""/foo/bar"").makeQualified(FsConstants.LOCAL_FS_URI, null),
        fSys.makeQualified(new Path(""/foo/bar"")));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testCreateDelete() throws IOException {
    

    // Create file 
    fileSystemTestHelper.createFile(fSys, ""/foo"");
    Assert.assertTrue(fSys.isFile(new Path(""/foo"")));
    Assert.assertTrue(fSysTarget.isFile(new Path(chrootedTo, ""foo"")));
    
    // Create file with recursive dir
    fileSystemTestHelper.createFile(fSys, ""/newDir/foo"");
    Assert.assertTrue(fSys.isFile(new Path(""/newDir/foo"")));
    Assert.assertTrue(fSysTarget.isFile(new Path(chrootedTo,""newDir/foo"")));
    
    // Delete the created file
    Assert.assertTrue(fSys.delete(new Path(""/newDir/foo""), false));
    Assert.assertFalse(fSys.exists(new Path(""/newDir/foo"")));
    Assert.assertFalse(fSysTarget.exists(new Path(chrootedTo, ""newDir/foo"")));
    
    // Create file with a 2 component dirs recursively
    fileSystemTestHelper.createFile(fSys, ""/newDir/newDir2/foo"");
    Assert.assertTrue(fSys.isFile(new Path(""/newDir/newDir2/foo"")));
    Assert.assertTrue(fSysTarget.isFile(new Path(chrootedTo,""newDir/newDir2/foo"")));
    
    // Delete the created file
    Assert.assertTrue(fSys.delete(new Path(""/newDir/newDir2/foo""), false));
    Assert.assertFalse(fSys.exists(new Path(""/newDir/newDir2/foo"")));
    Assert.assertFalse(fSysTarget.exists(new Path(chrootedTo,""newDir/newDir2/foo"")));
  }",Mystery Guest
"@Test
  public void testListLocatedFileStatus() throws Exception {
    final Path mockMount = new Path(""mockfs://foo/user"");
    final Path mockPath = new Path(""/usermock"");
    final Configuration conf = new Configuration();
    conf.setClass(""fs.mockfs.impl"", MockFileSystem.class, FileSystem.class);
    ConfigUtil.addLink(conf, mockPath.toString(), mockMount.toUri());
    FileSystem vfs = FileSystem.get(URI.create(""viewfs:///""), conf);
    vfs.listLocatedStatus(mockPath);
    final FileSystem mockFs =
        ((MockFileSystem) getChildFileSystem((ViewFileSystem) vfs,
            new URI(""mockfs://foo/""))).getRawFileSystem();
    verify(mockFs).listLocatedStatus(new Path(mockMount.toUri().getPath()));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testResolvePath() throws IOException {
    Assert.assertEquals(chrootedTo, fSys.resolvePath(new Path(""/""))); 
    fileSystemTestHelper.createFile(fSys, ""/foo"");
    Assert.assertEquals(new Path(chrootedTo, ""foo""),
        fSys.resolvePath(new Path(""/foo""))); 
  }",Mystery Guest
"@Test
  public void testURI() {
    URI uri = fSys.getUri();
    Assert.assertEquals(chrootedTo.toUri(), uri);
  }",No Smells
"@Test
  public void testCreateDelete() throws IOException {
    

    // Create file 
    fileContextTestHelper.createFileNonRecursive(fc, ""/foo"");
    Assert.assertTrue(isFile(fc, new Path(""/foo"")));
    Assert.assertTrue(isFile(fcTarget, new Path(chrootedTo, ""foo"")));
    
    // Create file with recursive dir
    fileContextTestHelper.createFile(fc, ""/newDir/foo"");
    Assert.assertTrue(isFile(fc, new Path(""/newDir/foo"")));
    Assert.assertTrue(isFile(fcTarget, new Path(chrootedTo,""newDir/foo"")));
    
    // Delete the created file
    Assert.assertTrue(fc.delete(new Path(""/newDir/foo""), false));
    Assert.assertFalse(exists(fc, new Path(""/newDir/foo"")));
    Assert.assertFalse(exists(fcTarget, new Path(chrootedTo,""newDir/foo"")));
    
    // Create file with a 2 component dirs recursively
    fileContextTestHelper.createFile(fc, ""/newDir/newDir2/foo"");
    Assert.assertTrue(isFile(fc, new Path(""/newDir/newDir2/foo"")));
    Assert.assertTrue(isFile(fcTarget, new Path(chrootedTo,""newDir/newDir2/foo"")));
    
    // Delete the created file
    Assert.assertTrue(fc.delete(new Path(""/newDir/newDir2/foo""), false));
    Assert.assertFalse(exists(fc, new Path(""/newDir/newDir2/foo"")));
    Assert.assertFalse(exists(fcTarget, new Path(chrootedTo,""newDir/newDir2/foo"")));
  }",Mystery Guest
"@Test
  public void testResolvePath() throws IOException {
    Assert.assertEquals(chrootedTo, fc.getDefaultFileSystem().resolvePath(new Path(""/""))); 
    fileContextTestHelper.createFile(fc, ""/foo"");
    Assert.assertEquals(new Path(chrootedTo, ""foo""),
        fc.getDefaultFileSystem().resolvePath(new Path(""/foo""))); 
  }",Mystery Guest
"@Test
  public void testWorkingDirectory() throws Exception {

    // First we cd to our test root
    fc.mkdir(new Path(""/testWd""), FileContext.DEFAULT_PERM, false);
    Path workDir = new Path(""/testWd"");
    Path fqWd = fc.makeQualified(workDir);
    fc.setWorkingDirectory(workDir);
    Assert.assertEquals(fqWd, fc.getWorkingDirectory());

    fc.setWorkingDirectory(new Path("".""));
    Assert.assertEquals(fqWd, fc.getWorkingDirectory());

    fc.setWorkingDirectory(new Path(""..""));
    Assert.assertEquals(fqWd.getParent(), fc.getWorkingDirectory());
    
    // cd using a relative path

    // Go back to our test root
    workDir = new Path(""/testWd"");
    fqWd = fc.makeQualified(workDir);
    fc.setWorkingDirectory(workDir);
    Assert.assertEquals(fqWd, fc.getWorkingDirectory());
    
    Path relativeDir = new Path(""existingDir1"");
    Path absoluteDir = new Path(workDir,""existingDir1"");
    fc.mkdir(absoluteDir, FileContext.DEFAULT_PERM, true);
    Path fqAbsoluteDir = fc.makeQualified(absoluteDir);
    fc.setWorkingDirectory(relativeDir);
    Assert.assertEquals(fqAbsoluteDir, fc.getWorkingDirectory());
    // cd using a absolute path
    absoluteDir = new Path(""/test/existingDir2"");
    fqAbsoluteDir = fc.makeQualified(absoluteDir);
    fc.mkdir(absoluteDir, FileContext.DEFAULT_PERM, true);
    fc.setWorkingDirectory(absoluteDir);
    Assert.assertEquals(fqAbsoluteDir, fc.getWorkingDirectory());
    
    // Now open a file relative to the wd we just set above.
    Path absolutePath = new Path(absoluteDir, ""foo"");
    fc.create(absolutePath, EnumSet.of(CreateFlag.CREATE)).close();
    fc.open(new Path(""foo"")).close();
    
    // Now mkdir relative to the dir we cd'ed to
    fc.mkdir(new Path(""newDir""), FileContext.DEFAULT_PERM, true);
    Assert.assertTrue(isDir(fc, new Path(absoluteDir, ""newDir"")));

    absoluteDir = fileContextTestHelper.getTestRootPath(fc, ""nonexistingPath"");
    try {
      fc.setWorkingDirectory(absoluteDir);
      Assert.fail(""cd to non existing dir should have failed"");
    }",Mystery Guest
"@Test
  public void testCreateNodeResultRetryBecomeActive() throws Exception {
    mockNoPriorActive();
    
    elector.joinElection(data);

    elector.processResult(Code.CONNECTIONLOSS.intValue(), ZK_LOCK_NAME, mockZK,
        ZK_LOCK_NAME);
    elector.processResult(Code.CONNECTIONLOSS.intValue(), ZK_LOCK_NAME, mockZK,
        ZK_LOCK_NAME);
    elector.processResult(Code.CONNECTIONLOSS.intValue(), ZK_LOCK_NAME, mockZK,
        ZK_LOCK_NAME);
    elector.processResult(Code.CONNECTIONLOSS.intValue(), ZK_LOCK_NAME, mockZK,
        ZK_LOCK_NAME);
    // 4 errors results in fatalError
    Mockito
        .verify(mockApp, Mockito.times(1))
        .notifyFatalError(
            ""Received create error from Zookeeper. code:CONNECTIONLOSS "" +
            ""for path "" + ZK_LOCK_NAME + "". "" +
            ""Not retrying further znode create connection errors."");

    elector.joinElection(data);
    // recreate connection via getNewZooKeeper
    Assert.assertEquals(2, count);
    elector.processResult(Code.CONNECTIONLOSS.intValue(), ZK_LOCK_NAME, mockZK,
        ZK_LOCK_NAME);
    elector.processResult(Code.NODEEXISTS.intValue(), ZK_LOCK_NAME, mockZK,
        ZK_LOCK_NAME);
    verifyExistCall(1);

    Stat stat = new Stat();
    stat.setEphemeralOwner(1L);
    Mockito.when(mockZK.getSessionId()).thenReturn(1L);
    elector.processResult(Code.OK.intValue(), ZK_LOCK_NAME, mockZK, stat);
    Mockito.verify(mockApp, Mockito.times(1)).becomeActive();
    verifyExistCall(1);
    Mockito.verify(mockZK, Mockito.times(6)).create(ZK_LOCK_NAME, data,
        Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, elector, mockZK);
  }",No Smells
"@Test
  public void testFailToBecomeActive() throws Exception {
    mockNoPriorActive();
    elector.joinElection(data);
    Assert.assertEquals(0, elector.sleptFor);
    
    Mockito.doThrow(new ServiceFailedException(""failed to become active""))
        .when(mockApp).becomeActive();
    elector.processResult(Code.OK.intValue(), ZK_LOCK_NAME, mockZK,
        ZK_LOCK_NAME);
    // Should have tried to become active
    Mockito.verify(mockApp).becomeActive();
    
    // should re-join
    Mockito.verify(mockZK, Mockito.times(2)).create(ZK_LOCK_NAME, data,
        Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, elector, mockZK);
    Assert.assertEquals(2, count);
    Assert.assertTrue(elector.sleptFor > 0);
  }",No Smells
"@Test
  public void testQuitElectionRemovesBreadcrumbNode() throws Exception {
    mockNoPriorActive();
    elector.joinElection(data);
    elector.processResult(Code.OK.intValue(), ZK_LOCK_NAME, mockZK,
        ZK_LOCK_NAME);
    // Writes its own active info
    Mockito.verify(mockZK, Mockito.times(1)).create(
        Mockito.eq(ZK_BREADCRUMB_NAME), Mockito.eq(data),
        Mockito.eq(Ids.OPEN_ACL_UNSAFE),
        Mockito.eq(CreateMode.PERSISTENT));
    mockPriorActive(data);
    
    elector.quitElection(false);
    
    // Deletes its own active data
    Mockito.verify(mockZK, Mockito.times(1)).delete(
        Mockito.eq(ZK_BREADCRUMB_NAME), Mockito.eq(0));
  }",No Smells
"@Test
  public void testStatNodeError() {
    elector.joinElection(data);
    elector.processResult(Code.RUNTIMEINCONSISTENCY.intValue(), ZK_LOCK_NAME,
        mockZK, (Stat) null);
    Mockito.verify(mockApp, Mockito.times(0)).enterNeutralMode();
    Mockito.verify(mockApp, Mockito.times(1)).notifyFatalError(
        ""Received stat error from Zookeeper. code:RUNTIMEINCONSISTENCY"");
  }",No Smells
"@Test
  public void testSuccessiveStandbyCalls() {
    elector.joinElection(data);

    // make the object go into the monitoring standby state
    elector.processResult(Code.NODEEXISTS.intValue(), ZK_LOCK_NAME, mockZK,
        ZK_LOCK_NAME);
    Mockito.verify(mockApp, Mockito.times(1)).becomeStandby();
    verifyExistCall(1);
    Assert.assertTrue(elector.isMonitorLockNodePending());

    Stat stat = new Stat();
    stat.setEphemeralOwner(0L);
    Mockito.when(mockZK.getSessionId()).thenReturn(1L);
    elector.processResult(Code.OK.intValue(), ZK_LOCK_NAME, mockZK, stat);
    Assert.assertFalse(elector.isMonitorLockNodePending());

    WatchedEvent mockEvent = Mockito.mock(WatchedEvent.class);
    Mockito.when(mockEvent.getPath()).thenReturn(ZK_LOCK_NAME);

    // notify node deletion
    // monitoring should be setup again after event is received
    Mockito.when(mockEvent.getType()).thenReturn(Event.EventType.NodeDeleted);
    elector.processWatchEvent(mockZK, mockEvent);
    // is standby. no need to notify anything now
    Mockito.verify(mockApp, Mockito.times(0)).enterNeutralMode();
    // another joinElection called.
    Mockito.verify(mockZK, Mockito.times(2)).create(ZK_LOCK_NAME, data,
        Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, elector, mockZK);
    // lost election
    elector.processResult(Code.NODEEXISTS.intValue(), ZK_LOCK_NAME, mockZK,
        ZK_LOCK_NAME);
    // still standby. so no need to notify again
    Mockito.verify(mockApp, Mockito.times(1)).becomeStandby();
    // monitor is set again
    verifyExistCall(2);
  }",No Smells
"@Test
  public void testFailoverToFaultyServiceFailsbackOK() throws Exception {
    DummyHAService svc1 = spy(new DummyHAService(HAServiceState.ACTIVE, svc1Addr));
    DummyHAService svc2 = new DummyHAService(HAServiceState.STANDBY, svc2Addr);
    Mockito.doThrow(new ServiceFailedException(""Failed!""))
        .when(svc2.proxy).transitionToActive(anyReqInfo());
    svc1.fencer = svc2.fencer = setupFencer(AlwaysSucceedFencer.class.getName());

    try {
      doFailover(svc1, svc2, false, false);
      fail(""Failover to already active service"");
    }",No Smells
"@Test
  public void testFailoverToNonExistantServiceFails() throws Exception {
    DummyHAService svc1 = new DummyHAService(HAServiceState.ACTIVE, svc1Addr);
    DummyHAService svc2 = spy(new DummyHAService(null, svc2Addr));
    Mockito.doThrow(new IOException(""Failed to connect""))
      .when(svc2).getProxy(Mockito.<Configuration>any(),
          Mockito.anyInt());
    svc1.fencer = svc2.fencer = setupFencer(AlwaysSucceedFencer.class.getName());

    try {
      doFailover(svc1, svc2, false, false);
      fail(""Failed over to a non-existant standby"");
    }",No Smells
"@Test
  public void testFailoverToUnreadyService() throws Exception {
    DummyHAService svc1 = new DummyHAService(HAServiceState.ACTIVE, svc1Addr);
    DummyHAService svc2 = new DummyHAService(HAServiceState.STANDBY, svc2Addr);
    Mockito.doReturn(STATE_NOT_READY).when(svc2.proxy)
        .getServiceStatus();
    svc1.fencer = svc2.fencer = setupFencer(AlwaysSucceedFencer.class.getName());

    try {
      doFailover(svc1, svc2, false, false);
      fail(""Can't failover to a service that's not ready"");
    }",No Smells
"@Test
  public void testFailureToFenceOnFailbackFailsTheFailback() throws Exception {
    DummyHAService svc1 = new DummyHAService(HAServiceState.ACTIVE, svc1Addr);
    DummyHAService svc2 = new DummyHAService(HAServiceState.STANDBY, svc2Addr);
    Mockito.doThrow(new IOException(""Failed!""))
        .when(svc2.proxy).transitionToActive(anyReqInfo());
    svc1.fencer = svc2.fencer = setupFencer(AlwaysFailFencer.class.getName());
    AlwaysFailFencer.fenceCalled = 0;

    try {
      doFailover(svc1, svc2, false, false);
      fail(""Failed over to service that won't transition to active"");
    }",No Smells
"@Test
  public void testWeDontFailbackIfActiveWasFenced() throws Exception {
    DummyHAService svc1 = new DummyHAService(HAServiceState.ACTIVE, svc1Addr);
    DummyHAService svc2 = new DummyHAService(HAServiceState.STANDBY, svc2Addr);
    Mockito.doThrow(new ServiceFailedException(""Failed!""))
        .when(svc2.proxy).transitionToActive(anyReqInfo());
    svc1.fencer = svc2.fencer = setupFencer(AlwaysSucceedFencer.class.getName());

    try {
      doFailover(svc1, svc2, true, false);
      fail(""Failed over to service that won't transition to active"");
    }",No Smells
"@Test
  public void testWeFenceOnFailbackIfTransitionToActiveFails() throws Exception {
    DummyHAService svc1 = new DummyHAService(HAServiceState.ACTIVE, svc1Addr);
    DummyHAService svc2 = new DummyHAService(HAServiceState.STANDBY, svc2Addr);
    Mockito.doThrow(new ServiceFailedException(""Failed!""))
        .when(svc2.proxy).transitionToActive(anyReqInfo());
    svc1.fencer = svc2.fencer = setupFencer(AlwaysSucceedFencer.class.getName());
    AlwaysSucceedFencer.fenceCalled = 0;

    try {
      doFailover(svc1, svc2, false, false);
      fail(""Failed over to service that won't transition to active"");
    }",No Smells
"@Test
  public void testAdminUsage() throws Exception {
    assertEquals(-1, runTool());
    assertOutputContains(""Usage:"");
    assertOutputContains(""-transitionToActive"");
    
    assertEquals(-1, runTool(""badCommand""));
    assertOutputContains(""Bad command 'badCommand'"");
    
    assertEquals(-1, runTool(""-badCommand""));
    assertOutputContains(""badCommand: Unknown"");    

    // valid command but not enough arguments
    assertEquals(-1, runTool(""-transitionToActive""));
    assertOutputContains(""transitionToActive: incorrect number of arguments"");
    assertEquals(-1, runTool(""-transitionToActive"", ""x"", ""y""));
    assertOutputContains(""transitionToActive: incorrect number of arguments"");
  }",No Smells
"@Test
  public void testShortNameSsh() throws BadFencingConfigurationException {
    NodeFencer fencer = setupFencer(""sshfence"");
    assertFalse(fencer.fence(MOCK_TARGET));
  }",No Smells
"@Test
  public void testShortNameSshWithUser() throws BadFencingConfigurationException {
    NodeFencer fencer = setupFencer(""sshfence(user)"");
    assertFalse(fencer.fence(MOCK_TARGET));
  }",No Smells
"@Test
  public void testShortNameSshWithUserPort() throws BadFencingConfigurationException {
    NodeFencer fencer = setupFencer(""sshfence(user:123)"");
    assertFalse(fencer.fence(MOCK_TARGET));
  }",No Smells
"@Test
  public void testBasicSuccessFailure() {
    assertTrue(fencer.tryFence(TEST_TARGET, ""echo""));
    assertFalse(fencer.tryFence(TEST_TARGET, ""exit 1""));
    // bad path should also fail
    assertFalse(fencer.tryFence(TEST_TARGET, ""xxxxxxxxxxxx""));
  }",No Smells
"@Test
  public void testCheckParensNoArgs() {
    try {
      Configuration conf = new Configuration();
      new NodeFencer(conf, ""shell()"");
      fail(""Didn't throw when passing no args to shell"");
    }",No Smells
"@Test
  public void testDontFailoverToUnhealthyNode() throws Exception {
    cluster.start();

    // Make svc1 unhealthy, and wait for its FC to notice the bad health.
    cluster.setHealthy(1, false);
    cluster.waitForHealthState(1, HealthMonitor.State.SERVICE_UNHEALTHY);

    // Expire svc0
    cluster.getElector(0).preventSessionReestablishmentForTests();
    try {
      cluster.expireActiveLockHolder(0);

      LOG.info(""Expired svc0's ZK session. Waiting a second to give svc1"" +
          "" a chance to take the lock, if it is ever going to."");
      Thread.sleep(1000);

      // Ensure that no one holds the lock.
      cluster.waitForActiveLockHolder(null);

    }",No Smells
"@Test
  public void testGracefulFailoverFailBecomingActive() throws Exception {
    cluster.start();

    cluster.waitForActiveLockHolder(0);
    cluster.setFailToBecomeActive(1, true);

    // Ask for failover, it should fail and report back to user.
    try {
      cluster.getService(1).getZKFCProxy(conf, 5000).gracefulFailover();
      fail(""Did not fail to graceful failover when target failed "" +
          ""to become active!"");
    }",No Smells
"@Test
  public void testGracefulFailoverToUnhealthy() throws Exception {
    cluster.start();

    cluster.waitForActiveLockHolder(0);

    // Mark it unhealthy, wait for it to exit election
    cluster.setHealthy(1, false);
    cluster.waitForElectorState(1, ActiveStandbyElector.State.INIT);

    // Ask for failover, it should fail, because it's unhealthy
    try {
      cluster.getService(1).getZKFCProxy(conf, 5000).gracefulFailover();
      fail(""Did not fail to graceful failover to unhealthy service!"");
    }",No Smells
"@Test
  public void testOneOfEverything() throws Exception {
    cluster.start();

    // Failover by session expiration
    LOG.info(""====== Failing over by session expiration"");
    cluster.expireAndVerifyFailover(0, 1);
    cluster.expireAndVerifyFailover(1, 0);

    // Restart ZK
    LOG.info(""====== Restarting server"");
    stopServer();
    waitForServerDown(hostPort, CONNECTION_TIMEOUT);
    startServer();
    waitForServerUp(hostPort, CONNECTION_TIMEOUT);

    // Failover by bad health
    cluster.setHealthy(0, false);
    cluster.waitForHAState(0, HAServiceState.INITIALIZING);
    cluster.waitForHAState(1, HAServiceState.ACTIVE);
    cluster.setHealthy(1, true);
    cluster.setHealthy(0, false);
    cluster.waitForHAState(1, HAServiceState.ACTIVE);
    cluster.waitForHAState(0, HAServiceState.INITIALIZING);
    cluster.setHealthy(0, true);

    cluster.waitForHealthState(0, State.SERVICE_HEALTHY);

    // Graceful failovers
    cluster.getZkfc(1).gracefulFailoverToYou();
    cluster.getZkfc(0).gracefulFailoverToYou();
  }",No Smells
"@Test
  public void testZooKeeperFailure() throws Exception {
    cluster.start();

    // Record initial ZK sessions
    long session0 = cluster.getElector(0).getZKSessionIdForTests();
    long session1 = cluster.getElector(1).getZKSessionIdForTests();

    LOG.info(""====== Stopping ZK server"");
    stopServer();
    waitForServerDown(hostPort, CONNECTION_TIMEOUT);

    LOG.info(""====== Waiting for services to enter NEUTRAL mode"");
    cluster.waitForElectorState(0,
        ActiveStandbyElector.State.NEUTRAL);
    cluster.waitForElectorState(1,
        ActiveStandbyElector.State.NEUTRAL);

    LOG.info(""====== Checking that the services didn't change HA state"");
    assertEquals(HAServiceState.ACTIVE, cluster.getService(0).state);
    assertEquals(HAServiceState.STANDBY, cluster.getService(1).state);

    LOG.info(""====== Restarting server"");
    startServer();
    waitForServerUp(hostPort, CONNECTION_TIMEOUT);

    // Nodes should go back to their original states, since they re-obtain
    // the same sessions.
    cluster.waitForElectorState(0, ActiveStandbyElector.State.ACTIVE);
    cluster.waitForElectorState(1, ActiveStandbyElector.State.STANDBY);
    // Check HA states didn't change.
    cluster.waitForHAState(0, HAServiceState.ACTIVE);
    cluster.waitForHAState(1, HAServiceState.STANDBY);

    // Check they re-used the same sessions and didn't spuriously reconnect
    assertEquals(session0,
        cluster.getElector(0).getZKSessionIdForTests());
    assertEquals(session1,
        cluster.getElector(1).getZKSessionIdForTests());
  }",No Smells
"@Test
  public void testShortCircuitCacheUnbufferDefault() throws Exception {
    testShortCircuitCacheUnbufferWithDisableInterval(
        DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_DEFAULT, true);
  }",No Smells
"@Test
  public void testShortCircuitReadFromServerWithoutShm() throws Exception {
    TemporarySocketDirectory sockDir = new TemporarySocketDirectory();
    Configuration clientConf = createShortCircuitConf(
        ""testShortCircuitReadFromServerWithoutShm"", sockDir);
    Configuration serverConf = new Configuration(clientConf);
    serverConf.setInt(
        DFS_SHORT_CIRCUIT_SHARED_MEMORY_WATCHER_INTERRUPT_CHECK_MS, 0);
    DFSInputStream.tcpReadsDisabledForTesting = true;
    final MiniDFSCluster cluster =
        new MiniDFSCluster.Builder(serverConf).numDataNodes(1).build();
    cluster.waitActive();
    clientConf.set(DFS_CLIENT_CONTEXT,
        ""testShortCircuitReadFromServerWithoutShm_clientContext"");
    final DistributedFileSystem fs =
        (DistributedFileSystem)FileSystem.get(cluster.getURI(0), clientConf);
    final String TEST_FILE = ""/test_file"";
    final int TEST_FILE_LEN = 4000;
    final int SEED = 0xFADEC;
    DFSTestUtil.createFile(fs, new Path(TEST_FILE), TEST_FILE_LEN,
        (short)1, SEED);
    byte contents[] = DFSTestUtil.readFileBuffer(fs, new Path(TEST_FILE));
    byte expected[] = DFSTestUtil.
        calculateFileContentsFromSeed(SEED, TEST_FILE_LEN);
    Assert.assertTrue(Arrays.equals(contents, expected));
    final ShortCircuitCache cache =
        fs.getClient().getClientContext().getShortCircuitCache(0);
    final DatanodeInfo datanode = new DatanodeInfoBuilder()
        .setNodeID(cluster.getDataNodes().get(0).getDatanodeId())
        .build();
    cache.getDfsClientShmManager().visit(new Visitor() {
      @Override
      public void visit(HashMap<DatanodeInfo, PerDatanodeVisitorInfo> info)
          throws IOException {
        Assert.assertEquals(1,  info.size());
        PerDatanodeVisitorInfo vinfo = info.get(datanode);
        Assert.assertTrue(vinfo.disabled);
        Assert.assertEquals(0, vinfo.full.size());
        Assert.assertEquals(0, vinfo.notFull.size());
      }",No Smells
"@Test
  public void testBlockReaderLocalByteBufferFastLaneReadsNoChecksum()
      throws IOException {
    runBlockReaderLocalTest(
        new TestBlockReaderLocalByteBufferFastLaneReads(),
        false, 2 * BlockReaderLocalTest.BYTES_PER_CHECKSUM);
  }",No Smells
"@Test
  public void testBlockReaderLocalByteBufferFastLaneReadsNoChecksumNoReadahead()
      throws IOException {
    runBlockReaderLocalTest(new TestBlockReaderLocalByteBufferFastLaneReads(),
        false, 0);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testBlockReaderLocalByteBufferReadsNoChecksum()
      throws IOException {
    runBlockReaderLocalTest(
        new TestBlockReaderLocalByteBufferReads(),
        false, HdfsClientConfigKeys.DFS_DATANODE_READAHEAD_BYTES_DEFAULT);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testBlockReaderLocalOnFileWithoutChecksumNoReadahead()
      throws IOException {
    runBlockReaderLocalTest(new TestBlockReaderLocalOnFileWithoutChecksum(),
        true, 0);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testBlockReaderLocalReadCorruptNoReadahead()
      throws IOException {
    runBlockReaderLocalTest(new TestBlockReaderLocalReadCorrupt(), true, 0);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testBlockReaderLocalReadZeroBytesNoChecksum()
      throws IOException {
    runBlockReaderLocalTest(new TestBlockReaderLocalReadZeroBytes(),
        false, HdfsClientConfigKeys.DFS_DATANODE_READAHEAD_BYTES_DEFAULT);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testManyDfsClientsWhereSomeNotOpen() throws Exception {
    // First DFSClient has no files open so doesn't renew leases.
    final DFSClient mockClient1 = createMockClient();
    Mockito.doReturn(false).when(mockClient1).renewLease();
    assertSame(renewer, LeaseRenewer.getInstance(
        FAKE_AUTHORITY, FAKE_UGI_A, mockClient1));
    long fileId = 456L;
    renewer.put(mockClient1);

    // Second DFSClient does renew lease
    final DFSClient mockClient2 = createMockClient();
    Mockito.doReturn(true).when(mockClient2).renewLease();
    assertSame(renewer, LeaseRenewer.getInstance(
        FAKE_AUTHORITY, FAKE_UGI_A, mockClient2));

    renewer.put(mockClient2);


    // Wait for lease to get renewed
    GenericTestUtils.waitFor(new Supplier<Boolean>() {
      @Override
      public Boolean get() {
        try {
          Mockito.verify(mockClient1, Mockito.atLeastOnce()).renewLease();
          Mockito.verify(mockClient2, Mockito.atLeastOnce()).renewLease();
          return true;
        }",No Smells
"@Test
  public void testChooseRandomWithStorageTypeTwoTrial() throws Exception {
    Node n;
    DatanodeDescriptor dd;
    n = CLUSTER.chooseRandomWithStorageType(""/l2/d3/r4"", null, null,
        StorageType.ARCHIVE);
    HashSet<Node> excluded = new HashSet<>();
    // exclude the host on r4 (since there is only one host, no randomness here)
    excluded.add(n);

    // search with given scope being desired scope
    for (int i = 0; i < 10; i++) {
      n = CLUSTER.chooseRandomWithStorageTypeTwoTrial(
          ""/l2/d3"", null, StorageType.ARCHIVE);
      assertTrue(n instanceof DatanodeDescriptor);
      dd = (DatanodeDescriptor) n;
      assertTrue(dd.getHostName().equals(""host13"") ||
          dd.getHostName().equals(""host14""));
    }",Eager Test
"@Test
  public void testChooseRandomWithStorageTypeWrapper() throws Exception {
    Node n;
    DatanodeDescriptor dd;
    n = CLUSTER.chooseRandomWithStorageType(""/l2/d3/r4"", null, null,
        StorageType.ARCHIVE);
    HashSet<Node> excluded = new HashSet<>();
    // exclude the host on r4 (since there is only one host, no randomness here)
    excluded.add(n);

    // search with given scope being desired scope
    for (int i = 0; i < 10; i++) {
      n = CLUSTER.chooseRandomWithStorageType(
          ""/l2/d3"", null, StorageType.ARCHIVE);
      assertTrue(n instanceof DatanodeDescriptor);
      dd = (DatanodeDescriptor) n;
      assertTrue(dd.getHostName().equals(""host13"") ||
          dd.getHostName().equals(""host14""));
    }",Eager Test
"@Test
  public void testStart() throws IOException {
    // Start minicluster
    NfsConfiguration config = new NfsConfiguration();
    MiniDFSCluster cluster = new MiniDFSCluster.Builder(config).numDataNodes(1)
        .build();
    cluster.waitActive();
    
    // Use emphral port in case tests are running in parallel
    config.setInt(""nfs3.mountd.port"", 0);
    config.setInt(""nfs3.server.port"", 0);
    
    int newTimeoutMillis = 1000; // 1s
    // Set the new portmap rpc timeout values and check
    config.setInt(NfsConfigKeys.NFS_UDP_CLIENT_PORTMAP_TIMEOUT_MILLIS_KEY,
                  newTimeoutMillis);
    assertTrue(config.getInt(
                      NfsConfigKeys.NFS_UDP_CLIENT_PORTMAP_TIMEOUT_MILLIS_KEY,
          0) == newTimeoutMillis);

    // Start nfs
    Nfs3 nfs3 = new Nfs3(config);
    nfs3.startServiceInternal(false);

    RpcProgramMountd mountd = (RpcProgramMountd) nfs3.getMountd()
        .getRpcProgram();
    mountd.nullOp(new XDR(), 1234, InetAddress.getByName(""localhost""));
    assertTrue(mountd.getPortmapUdpTimeoutMillis() == newTimeoutMillis);
    RpcProgramNfs3 nfsd = (RpcProgramNfs3) nfs3.getRpcProgram();
    nfsd.nullProcedure();
    assertTrue(nfsd.getPortmapUdpTimeoutMillis() == newTimeoutMillis);
    
    cluster.shutdown();
  }",No Smells
"@Test
  public void testBlackListIpClient() throws IOException {
    Configuration conf = new Configuration();
    FileUtils.write(blacklistFile,
        InetAddress.getLocalHost().getHostAddress(), true);
    conf.set(BlackListBasedTrustedChannelResolver
            .DFS_DATATRANSFER_CLIENT_FIXED_BLACK_LIST_FILE,
        blacklistFile.getAbsolutePath());

    resolver.setConf(conf);
    assertFalse(resolver.isTrusted());

  }",Mystery Guest + Resource Optimism
"@Test
  public void testEmptyReport() {
    BlockListAsLongs blocks = checkReport();
    assertArrayEquals(
        new long[] {
            0, 0,
            -1, -1, -1 }",No Smells
"@Test
  public void testFuzz() throws InterruptedException {
    Replica[] replicas = new Replica[100000];
    Random rand = new Random(0);
    for (int i=0; i<replicas.length; i++) {
      Block b = new Block(rand.nextLong(), i, i<<4);
      switch (rand.nextInt(2)) {
        case 0:
          replicas[i] = new FinalizedReplica(b, null, null);
          break;
        case 1:
          replicas[i] = new ReplicaBeingWritten(b, null, null, null);
          break;
        case 2:
          replicas[i] = new ReplicaWaitingToBeRecovered(b, null, null);
          break;
      }",Eager Test
"@Test
  public void testInvalid() {
    try {
      new ErasureCodingPolicy(null, SCHEMA_1, 123, (byte) -1);
      fail(""Instantiated invalid ErasureCodingPolicy"");
    }",No Smells
"@Test
  public void testRelease204() {
    assertTrue(NameNodeLayoutVersion.supports(LayoutVersion.Feature.DELEGATION_TOKEN, 
        Feature.RESERVED_REL20_204.getInfo().getLayoutVersion()));
  }",No Smells
"@Test
  public void testAclEntryProto() {
    // All fields populated.
    AclEntry e1 = new AclEntry.Builder().setName(""test"")
        .setPermission(FsAction.READ_EXECUTE).setScope(AclEntryScope.DEFAULT)
        .setType(AclEntryType.OTHER).build();
    // No name.
    AclEntry e2 = new AclEntry.Builder().setScope(AclEntryScope.ACCESS)
        .setType(AclEntryType.USER).setPermission(FsAction.ALL).build();
    // No permission, which will default to the 0'th enum element.
    AclEntry e3 = new AclEntry.Builder().setScope(AclEntryScope.ACCESS)
        .setType(AclEntryType.USER).setName(""test"").build();
    AclEntry[] expected = new AclEntry[] { e1, e2,
        new AclEntry.Builder()
            .setScope(e3.getScope())
            .setType(e3.getType())
            .setName(e3.getName())
            .setPermission(FsAction.NONE)
            .build() }",No Smells
"@Test
  public void testBlockChecksumTypeProto() {
    assertEquals(BlockChecksumType.MD5CRC,
        PBHelperClient.convert(HdfsProtos.BlockChecksumTypeProto.MD5CRC));
    assertEquals(BlockChecksumType.COMPOSITE_CRC,
        PBHelperClient.convert(
            HdfsProtos.BlockChecksumTypeProto.COMPOSITE_CRC));
    assertEquals(PBHelperClient.convert(BlockChecksumType.MD5CRC),
        HdfsProtos.BlockChecksumTypeProto.MD5CRC);
    assertEquals(PBHelperClient.convert(BlockChecksumType.COMPOSITE_CRC),
        HdfsProtos.BlockChecksumTypeProto.COMPOSITE_CRC);
  }",No Smells
"@Test
  public void testConvertAddingECPolicyResponse() throws Exception {
    // Check conversion of the built-in policies.
    for (ErasureCodingPolicy policy :
        SystemErasureCodingPolicies.getPolicies()) {
      AddErasureCodingPolicyResponse response =
          new AddErasureCodingPolicyResponse(policy);
      HdfsProtos.AddErasureCodingPolicyResponseProto proto = PBHelperClient
          .convertAddErasureCodingPolicyResponse(response);
      // Optional fields should not be set.
      assertFalse(""Unnecessary field is set."", proto.hasErrorMsg());
      // Convert proto back to an object and check for equality.
      AddErasureCodingPolicyResponse convertedResponse = PBHelperClient
          .convertAddErasureCodingPolicyResponse(proto);
      assertEquals(""Converted policy not equal"", response.getPolicy(),
          convertedResponse.getPolicy());
      assertEquals(""Converted policy not equal"", response.isSucceed(),
          convertedResponse.isSucceed());
    }",Eager Test
"@Test
  public void testConvertBlock() {
    Block b = new Block(1, 100, 3);
    BlockProto bProto = PBHelperClient.convert(b);
    Block b2 = PBHelperClient.convert(bProto);
    assertEquals(b, b2);
  }",No Smells
"@Test
  public void testConvertErasureCodingPolicy() throws Exception {
    // Check conversion of the built-in policies.
    for (ErasureCodingPolicy policy :
        SystemErasureCodingPolicies.getPolicies()) {
      HdfsProtos.ErasureCodingPolicyProto proto = PBHelperClient
          .convertErasureCodingPolicy(policy);
      // Optional fields should not be set.
      assertFalse(""Unnecessary field is set."", proto.hasName());
      assertFalse(""Unnecessary field is set."", proto.hasSchema());
      assertFalse(""Unnecessary field is set."", proto.hasCellSize());
      // Convert proto back to an object and check for equality.
      ErasureCodingPolicy convertedPolicy = PBHelperClient
          .convertErasureCodingPolicy(proto);
      assertEquals(""Converted policy not equal"", policy, convertedPolicy);
    }",Eager Test
"@Test
  public void testConvertExportedBlockKeys() {
    BlockKey[] keys = new BlockKey[] { getBlockKey(2), getBlockKey(3) }",No Smells
"@Test
  public void testConvertRecoveringBlock() {
    DatanodeInfo di1 = DFSTestUtil.getLocalDatanodeInfo();
    DatanodeInfo di2 = DFSTestUtil.getLocalDatanodeInfo();
    DatanodeInfo[] dnInfo = new DatanodeInfo[] { di1, di2 }",No Smells
"@Test
  public void testDataNodeInfoPBHelper() {
    DatanodeID id = DFSTestUtil.getLocalDatanodeID();
    DatanodeInfo dnInfos0 = new DatanodeInfoBuilder().setNodeID(id)
        .build();
    dnInfos0.setCapacity(3500L);
    dnInfos0.setDfsUsed(1000L);
    dnInfos0.setNonDfsUsed(2000L);
    dnInfos0.setRemaining(500L);
    HdfsProtos.DatanodeInfoProto dnproto = PBHelperClient.convert(dnInfos0);
    DatanodeInfo dnInfos1 = PBHelperClient.convert(dnproto);
    compare(dnInfos0, dnInfos1);
    assertEquals(dnInfos0.getNonDfsUsed(), dnInfos1.getNonDfsUsed());

    //Testing without nonDfs field
    HdfsProtos.DatanodeInfoProto.Builder b =
        HdfsProtos.DatanodeInfoProto.newBuilder();
    b.setId(PBHelperClient.convert(id)).setCapacity(3500L).setDfsUsed(1000L)
        .setRemaining(500L);
    DatanodeInfo dnInfos3 = PBHelperClient.convert(b.build());
    assertEquals(dnInfos0.getNonDfsUsed(), dnInfos3.getNonDfsUsed());
  }",No Smells
"@Test
  public void testFSServerDefaultsHelper() {
    HdfsProtos.FsServerDefaultsProto.Builder b =
        HdfsProtos.FsServerDefaultsProto
        .newBuilder();
    b.setBlockSize(DFSConfigKeys.DFS_BLOCK_SIZE_DEFAULT);
    b.setBytesPerChecksum(DFSConfigKeys.DFS_BYTES_PER_CHECKSUM_DEFAULT);
    b.setWritePacketSize(
        HdfsClientConfigKeys.DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT);
    b.setReplication(DFSConfigKeys.DFS_REPLICATION_DEFAULT);
    b.setFileBufferSize(DFSConfigKeys.IO_FILE_BUFFER_SIZE_DEFAULT);
    b.setEncryptDataTransfer(DFSConfigKeys.DFS_ENCRYPT_DATA_TRANSFER_DEFAULT);
    b.setTrashInterval(DFSConfigKeys.FS_TRASH_INTERVAL_DEFAULT);
    b.setChecksumType(HdfsProtos.ChecksumTypeProto.forNumber(
        DataChecksum.Type.valueOf(DFSConfigKeys.DFS_CHECKSUM_TYPE_DEFAULT).id));
    HdfsProtos.FsServerDefaultsProto proto = b.build();

    assertFalse(""KeyProvider uri is not supported"",
        proto.hasKeyProviderUri());
    FsServerDefaults fsServerDefaults = PBHelperClient.convert(proto);
    Assert.assertNotNull(""FsServerDefaults is null"", fsServerDefaults);
    Assert.assertNull(""KeyProviderUri should be null"",
        fsServerDefaults.getKeyProviderUri());
  }",No Smells
"@Test
  public void testChangeWritersLogsInSync() throws Exception {
    writeSegment(cluster, qjm, 1, 3, false);
    QJMTestUtil.assertExistsInQuorum(cluster,
        NNStorage.getInProgressEditsFileName(1));

    // Make a new QJM
    qjm = closeLater(new QuorumJournalManager(
        conf, cluster.getQuorumJournalURI(JID), FAKE_NSINFO));
    qjm.recoverUnfinalizedSegments();
    checkRecovery(cluster, 1, 3);
  }",No Smells
"@Test
  public void testChangeWritersLogsOutOfSync3() throws Exception {
    // Journal states:  [3, 4, 5]
    // During recovery: [3, 4, x]
    // Should recovery to txn 4
    doOutOfSyncTest(2, 4L);
  }",No Smells
"@Test
  public void testNewerVersionOfSegmentWins() throws Exception {
    setupEdgeCaseOneJnHasSegmentWithAcceptedRecovery();
    
    // Now start writing again without JN0 present:
    cluster.getJournalNode(0).stopAndJoin(0);
    
    qjm = createSpyingQJM();
    try {
      assertEquals(100, QJMTestUtil.recoverAndReturnLastTxn(qjm));
      
      // Write segment but do not finalize
      writeSegment(cluster, qjm, 101, 50, false);
    }",No Smells
"@Test
  public void testOutOfSyncAtBeginningOfSegment0() throws Exception {
    doTestOutOfSyncAtBeginningOfSegment(0);
  }",No Smells
"@Test
  public void testOutOfSyncAtBeginningOfSegment1() throws Exception {
    doTestOutOfSyncAtBeginningOfSegment(1);
  }",No Smells
"@Test
  public void testPurgeLogs() throws Exception {
    for (int txid = 1; txid <= 5; txid++) {
      writeSegment(cluster, qjm, txid, 1, true);
    }",Eager Test
"@Test
  public void testToString() throws Exception {
    GenericTestUtils.assertMatches(
        qjm.toString(),
        ""QJM to \\[127.0.0.1:\\d+, 127.0.0.1:\\d+, 127.0.0.1:\\d+\\]"");
  }",No Smells
"@Test
  public void testFormatNonEmptyStorageDirectories() throws Exception {
    try {
      // Format again here and to format the non-empty directories in
      // journal node.
      journal.format(FAKE_NSINFO, false);
      fail(""Did not fail to format non-empty directories in journal node."");
    }",No Smells
"@Test
  public void testJournalNodeSyncerNotStartWhenSyncDisabled()
      throws IOException {
    //JournalSyncer will not be started, as journalsync is not enabled
    conf.setBoolean(DFSConfigKeys.DFS_JOURNALNODE_ENABLE_SYNC_KEY, false);
    jn.getOrCreateJournal(journalId);
    Assert.assertEquals(false,
        jn.getJournalSyncerStatus(journalId));
    Assert.assertEquals(false,
        jn.getJournal(journalId).getTriedJournalSyncerStartedwithnsId());

    //Trying by passing nameserviceId still journalnodesyncer should not start
    // IstriedJournalSyncerStartWithnsId should also be false
    jn.getOrCreateJournal(journalId, ""mycluster"");
    Assert.assertEquals(false,
        jn.getJournalSyncerStatus(journalId));
    Assert.assertEquals(false,
        jn.getJournal(journalId).getTriedJournalSyncerStartedwithnsId());

  }",No Smells
"@Test
  public void
      testJournalNodeSyncwithFederationTypeIncorrectConfigWithNamenodeId()
      throws IOException {
    //JournalSyncer will not be started, as nameserviceId passed is null,
    // but configured shared edits dir is appended with nameserviceId +
    // namenodeId
    setupStaticHostResolution(2, ""journalnode"");
    jn.getOrCreateJournal(journalId);
    Assert.assertEquals(false,
        jn.getJournalSyncerStatus(journalId));
    Assert.assertEquals(false,
        jn.getJournal(journalId).getTriedJournalSyncerStartedwithnsId());

    //Trying by passing nameserviceId and resolve hostnames
    // now IstriedJournalSyncerStartWithnsId should  be set
    // and  journalnode syncer will not  be started
    // as for each nnId, different shared Edits dir value is configured

    jn.getOrCreateJournal(journalId, ""ns1"");
    Assert.assertEquals(false,
        jn.getJournalSyncerStatus(journalId));
    Assert.assertEquals(true,
        jn.getJournal(journalId).getTriedJournalSyncerStartedwithnsId());
  }",No Smells
"@Test
  public void testStartStop() throws IOException {
    Configuration conf = new Configuration();
    MiniJournalCluster c = new MiniJournalCluster.Builder(conf)
      .build();
    c.waitActive();
    try {
      URI uri = c.getQuorumJournalURI(""myjournal"");
      String[] addrs = uri.getAuthority().split("";"");
      assertEquals(3, addrs.length);
      
      JournalNode node = c.getJournalNode(0);
      String dir = node.getConf().get(DFSConfigKeys.DFS_JOURNALNODE_EDITS_DIR_KEY);
      assertEquals(
          new File(MiniDFSCluster.getBaseDirectory() + ""journalnode-0"")
            .getAbsolutePath(),
          dir);
    }",Mystery Guest + Resource Optimism
"@Test
  public void testDelegationTokenUgi() throws Exception {
    final DistributedFileSystem dfs = cluster.getFileSystem();
    Token<?>[] tokens = dfs.addDelegationTokens(""renewer"", null);
    Assert.assertEquals(1, tokens.length);
    Token<?> token1 = tokens[0];
    DelegationTokenIdentifier ident =
        (DelegationTokenIdentifier) token1.decodeIdentifier();
    UserGroupInformation expectedUgi = ident.getUser();

    // get 2 new instances (clones) of the identifier, query their ugi
    // twice each, all ugi instances should be equivalent
    for (int i=0; i<2; i++) {
      DelegationTokenIdentifier identClone =
          (DelegationTokenIdentifier)token1.decodeIdentifier();
      Assert.assertEquals(ident, identClone);
      Assert.assertNotSame(ident, identClone);
      Assert.assertSame(expectedUgi, identClone.getUser());
      Assert.assertSame(expectedUgi, identClone.getUser());
    }",Eager Test
"@Test
  public void testDelegationTokenWithDoAs() throws Exception {
    final DistributedFileSystem dfs = cluster.getFileSystem();
    final Credentials creds = new Credentials();
    final Token<?> tokens[] = dfs.addDelegationTokens(""JobTracker"", creds);
    Assert.assertEquals(1, tokens.length);
    @SuppressWarnings(""unchecked"")
    final Token<DelegationTokenIdentifier> token =
        (Token<DelegationTokenIdentifier>) tokens[0];
    final UserGroupInformation longUgi = UserGroupInformation
        .createRemoteUser(""JobTracker/foo.com@FOO.COM"");
    final UserGroupInformation shortUgi = UserGroupInformation
        .createRemoteUser(""JobTracker"");
    longUgi.doAs(new PrivilegedExceptionAction<Object>() {
      @Override
      public Object run() throws IOException {
        try {
          token.renew(config);
        }",No Smells
"@Test
  public void testChooseDataNode() {
    Collection<Node> allNodes = new ArrayList<>(dataNodes.length);
    Collections.addAll(allNodes, dataNodes);
    if (placementPolicy instanceof AvailableSpaceBlockPlacementPolicy) {
      // exclude all datanodes when chooseDataNode, no NPE should be thrown
      ((AvailableSpaceBlockPlacementPolicy) placementPolicy)
          .chooseDataNode(""~"", allNodes);
    }",No Smells
"@Test
  public void testIsDeleted() {
    BlockInfo blockInfo = new BlockInfoContiguous((short) 3);
    BlockCollection bc = Mockito.mock(BlockCollection.class);
    blockInfo.setBlockCollectionId(1000);
    Assert.assertFalse(blockInfo.isDeleted());
    blockInfo.setBlockCollectionId(INVALID_INODE_ID);
    Assert.assertTrue(blockInfo.isDeleted());
  }",No Smells
"@Test
  public void testAddStorage() {
    // first add NUM_DATA_BLOCKS + NUM_PARITY_BLOCKS storages, i.e., a complete
    // group of blocks/storages
    DatanodeStorageInfo[] storageInfos = DFSTestUtil.createDatanodeStorageInfos(
        totalBlocks);
    Block[] blocks = createReportedBlocks(totalBlocks);
    int i = 0;
    for (; i < storageInfos.length; i += 2) {
      info.addStorage(storageInfos[i], blocks[i]);
      Assert.assertEquals(i/2 + 1, info.numNodes());
    }",No Smells
"@Test
  public void testAllNodesHoldingReplicasDecommissioned() throws Exception {
    addNodes(nodes);
    for (int i = 0; i < NUM_TEST_ITERS; i++) {
      doTestAllNodesHoldingReplicasDecommissioned(i);
    }",Eager Test
"@Test
  public void testBlockReportQueueing() throws Exception {
    Configuration conf = new HdfsConfiguration();
    final MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).build();
    try {
      cluster.waitActive();
      final FSNamesystem fsn = cluster.getNamesystem();
      final BlockManager bm = fsn.getBlockManager();
      final ExecutorService executor = Executors.newCachedThreadPool();

      final CyclicBarrier startBarrier = new CyclicBarrier(2);
      final CountDownLatch endLatch = new CountDownLatch(3);
      final CountDownLatch doneLatch = new CountDownLatch(1);

      // create a task intended to block while processing, thus causing
      // the queue to backup.  simulates how a full BR is processed.
      FutureTask<?> blockingOp = new FutureTask<Void>(
          new Callable<Void>(){
            @Override
            public Void call() throws IOException {
              bm.runBlockOp(new Callable<Void>() {
                @Override
                public Void call()
                    throws InterruptedException, BrokenBarrierException {
                  // use a barrier to control the blocking.
                  startBarrier.await();
                  endLatch.countDown();
                  return null;
                }",No Smells
"@Test
  public void testFavorDecomUntilHardLimit() throws Exception {
    bm.setMaxReplicationStreams(0, false);
    bm.setReplicationStreamsHardLimit(1);

    long blockId = 42;         // arbitrary
    Block aBlock = new Block(blockId, 0, 0);
    List<DatanodeDescriptor> origNodes = getNodes(0, 1);
    // Add the block to the first node.
    addBlockOnNodes(blockId,origNodes.subList(0,1));
    origNodes.get(0).startDecommission();

    List<DatanodeDescriptor> cntNodes = new LinkedList<DatanodeDescriptor>();
    List<DatanodeStorageInfo> liveNodes = new LinkedList<DatanodeStorageInfo>();

    assertNotNull(""Chooses decommissioning source node for a normal replication""
        + "" if all available source nodes have reached their replication""
        + "" limits below the hard limit."",
        bm.chooseSourceDatanodes(
            bm.getStoredBlock(aBlock),
            cntNodes,
            liveNodes,
            new NumberReplicas(),
            new LinkedList<Byte>(),
            new ArrayList<Byte>(),
            new ArrayList<Byte>(),
            LowRedundancyBlocks.QUEUE_LOW_REDUNDANCY)[0]);


    // Increase the replication count to test replication count > hard limit
    DatanodeStorageInfo targets[] = { origNodes.get(1).getStorageInfos()[0] }",No Smells
"@Test
  public void testMetaSaveInMaintenanceReplicas() throws Exception {
    List<DatanodeStorageInfo> origStorages = getStorages(0, 1);
    List<DatanodeDescriptor> origNodes = getNodes(origStorages);
    BlockInfo block = makeBlockReplicasMaintenance(0, origNodes);
    File file = new File(""test.log"");
    PrintWriter out = new PrintWriter(file);
    bm.metaSave(out);
    out.flush();
    FileInputStream fstream = new FileInputStream(file);
    DataInputStream in = new DataInputStream(fstream);
    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
    StringBuilder buffer = new StringBuilder();
    String line;
    try {
      while ((line = reader.readLine()) != null) {
        buffer.append(line);
        System.out.println(line);
      }",Eager Test
"@Test
  public void testMetaSaveMissingReplicas() throws Exception {
    List<DatanodeStorageInfo> origStorages = getStorages(0, 1);
    List<DatanodeDescriptor> origNodes = getNodes(origStorages);
    BlockInfo block = makeBlockReplicasMissing(0, origNodes);
    File file = new File(""test.log"");
    PrintWriter out = new PrintWriter(file);
    bm.metaSave(out);
    out.flush();
    FileInputStream fstream = new FileInputStream(file);
    DataInputStream in = new DataInputStream(fstream);
    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
    StringBuilder buffer = new StringBuilder();
    String line;
    try {
      while ((line = reader.readLine()) != null) {
        buffer.append(line);
      }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testStorageWithRemainingCapacity() throws Exception {
    final Configuration conf = new HdfsConfiguration();
    final MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).build();
    FileSystem fs = FileSystem.get(conf);
    Path file1 = null;
    try {
      cluster.waitActive();
      final FSNamesystem namesystem = cluster.getNamesystem();
      final String poolId = namesystem.getBlockPoolId();
      final DatanodeRegistration nodeReg =
        InternalDataNodeTestUtils.getDNRegistrationForBP(cluster.getDataNodes().
        		get(0), poolId);
      final DatanodeDescriptor dd = NameNodeAdapter.getDatanode(namesystem,
    		  nodeReg);
      // By default, MiniDFSCluster will create 1 datanode with 2 storages.
      // Assigning 64k for remaining storage capacity and will 
      //create a file with 100k.
      for(DatanodeStorageInfo storage:  dd.getStorageInfos()) { 
    	  storage.setUtilizationForTesting(65536, 0, 65536, 0);
      }",Eager Test + Mystery Guest
"@Test
  public void testSufficientlyReplBlocksUsesNewRack() throws Exception {
    addNodes(nodes);
    for (int i = 0; i < NUM_TEST_ITERS; i++) {
      doTestSufficientlyReplBlocksUsesNewRack(i);
    }",No Smells
"@Test
  public void testUCBlockNotConsideredMissing() throws Exception {
    DatanodeDescriptor node = nodes.get(0);
    DatanodeStorageInfo ds = node.getStorageInfos()[0];
    node.setAlive(true);
    DatanodeRegistration nodeReg =
        new DatanodeRegistration(node, null, null, """");

    // register new node
    bm.getDatanodeManager().registerDatanode(nodeReg);
    bm.getDatanodeManager().addDatanode(node);

    // Build an incremental report
    List<ReceivedDeletedBlockInfo> rdbiList = new ArrayList<>();

    // blk_42 is under construction, finalizes on one node and is
    // immediately deleted on same node
    long blockId = 42;  // arbitrary
    BlockInfo receivedBlock = addUcBlockToBM(blockId);

    rdbiList.add(new ReceivedDeletedBlockInfo(new Block(receivedBlock),
        ReceivedDeletedBlockInfo.BlockStatus.RECEIVED_BLOCK, null));
    rdbiList.add(new ReceivedDeletedBlockInfo(
        new Block(blockId),
        ReceivedDeletedBlockInfo.BlockStatus.DELETED_BLOCK, null));

    // process IBR
    StorageReceivedDeletedBlocks srdb =
        new StorageReceivedDeletedBlocks(new DatanodeStorage(ds.getStorageID()),
            rdbiList.toArray(new ReceivedDeletedBlockInfo[rdbiList.size()]));
    bm.setInitializedReplQueues(true);
    bm.processIncrementalBlockReport(node, srdb);
    // Needed replications should still be 0.
    assertEquals(""UC block was incorrectly added to needed Replications"",
        0, bm.neededReconstruction.size());
    bm.setInitializedReplQueues(false);
  }",No Smells
"@Test
  public void testGetSafeModeTipsWithoutNumLiveDatanode() throws IOException {
    Configuration conf = new HdfsConfiguration();
    conf.setDouble(DFSConfigKeys.DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY,
        THRESHOLD);
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_SAFEMODE_EXTENSION_KEY,
        EXTENSION);
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY, 0);

    NameNode.initMetrics(conf, NamenodeRole.NAMENODE);

    BlockManager blockManager = spy(new BlockManager(fsn, false, conf));

    BlockManagerSafeMode safeMode = new BlockManagerSafeMode(blockManager,
        fsn, false, conf);
    safeMode.activate(BLOCK_TOTAL);
    String tip = safeMode.getSafeModeTip();

    assertTrue(tip.contains(""The minimum number of live datanodes is not ""
        + ""required.""));
  }",No Smells
"@Test
  public void testIsPolicySatisfiedParentFalse() {
    when(bpsd.isPlacementPolicySatisfied()).thenReturn(false);
    when(bpsd.getAdditionalReplicasRequired()).thenReturn(1);
    BlockPlacementStatusWithUpgradeDomain bps =
        new BlockPlacementStatusWithUpgradeDomain(bpsd, upgradeDomains, 3, 3);

    // Parent policy is not satisfied but upgrade domain policy is
    assertFalse(bps.isPlacementPolicySatisfied());
    assertEquals(1, bps.getAdditionalReplicasRequired());
  }",No Smells
"@Test
  public void testBlocksCounter() throws Exception {
    DatanodeDescriptor dd = BlockManagerTestUtil.getLocalDatanodeDescriptor(true);
    assertEquals(0, dd.numBlocks());
    BlockInfo blk = new BlockInfoContiguous(new Block(1L), (short) 1);
    BlockInfo blk1 = new BlockInfoContiguous(new Block(2L), (short) 2);
    DatanodeStorageInfo[] storages = dd.getStorageInfos();
    assertTrue(storages.length > 0);
    // add first block
    assertEquals(AddBlockResult.ADDED, storages[0].addBlock(blk));
    assertEquals(1, dd.numBlocks());
    // remove a non-existent block
    assertFalse(BlocksMap.removeBlock(dd, blk1));
    assertEquals(1, dd.numBlocks());
    // add an existent block
    assertNotEquals(AddBlockResult.ADDED, storages[0].addBlock(blk));
    assertEquals(1, dd.numBlocks());
    // add second block
    assertEquals(AddBlockResult.ADDED, storages[0].addBlock(blk1));
    assertEquals(2, dd.numBlocks());
    // remove first block
    assertTrue(BlocksMap.removeBlock(dd, blk));
    assertEquals(1, dd.numBlocks());
    // remove second block
    assertTrue(BlocksMap.removeBlock(dd, blk1));
    assertEquals(0, dd.numBlocks());    
  }",Mystery Guest + Resource Optimism
"@Test
  public void testNumVersionsReportedCorrect() throws IOException {
    //Create the DatanodeManager which will be tested
    FSNamesystem fsn = Mockito.mock(FSNamesystem.class);
    Mockito.when(fsn.hasWriteLock()).thenReturn(true);
    DatanodeManager dm = mockDatanodeManager(fsn, new Configuration());

    //Seed the RNG with a known value so test failures are easier to reproduce
    Random rng = new Random();
    int seed = rng.nextInt();
    rng = new Random(seed);
    LOG.info(""Using seed "" + seed + "" for testing"");

    //A map of the Storage IDs to the DN registration it was registered with
    HashMap <String, DatanodeRegistration> sIdToDnReg =
      new HashMap<String, DatanodeRegistration>();

    for(int i=0; i<NUM_ITERATIONS; ++i) {

      //If true, remove a node for every 3rd time (if there's one)
      if(rng.nextBoolean() && i%3 == 0 && sIdToDnReg.size()!=0) {
        //Pick a random node.
        int randomIndex = rng.nextInt() % sIdToDnReg.size();
        //Iterate to that random position 
        Iterator<Map.Entry<String, DatanodeRegistration>> it =
          sIdToDnReg.entrySet().iterator();
        for(int j=0; j<randomIndex-1; ++j) {
          it.next();
        }",Eager Test
"@Test
  public void testRemoveIncludedNode() throws IOException {
    FSNamesystem fsn = Mockito.mock(FSNamesystem.class);

    // Set the write lock so that the DatanodeManager can start
    Mockito.when(fsn.hasWriteLock()).thenReturn(true);

    DatanodeManager dm = mockDatanodeManager(fsn, new Configuration());
    HostFileManager hm = new HostFileManager();
    HostSet noNodes = new HostSet();
    HostSet oneNode = new HostSet();
    HostSet twoNodes = new HostSet();
    DatanodeRegistration dr1 = new DatanodeRegistration(
      new DatanodeID(""127.0.0.1"", ""127.0.0.1"", ""someStorageID-123"",
          12345, 12345, 12345, 12345),
      new StorageInfo(HdfsServerConstants.NodeType.DATA_NODE),
      new ExportedBlockKeys(), ""test"");
    DatanodeRegistration dr2 = new DatanodeRegistration(
      new DatanodeID(""127.0.0.1"", ""127.0.0.1"", ""someStorageID-234"",
          23456, 23456, 23456, 23456),
      new StorageInfo(HdfsServerConstants.NodeType.DATA_NODE),
      new ExportedBlockKeys(), ""test"");

    twoNodes.add(entry(""127.0.0.1:12345""));
    twoNodes.add(entry(""127.0.0.1:23456""));
    oneNode.add(entry(""127.0.0.1:23456""));

    hm.refresh(twoNodes, noNodes);
    Whitebox.setInternalState(dm, ""hostConfigManager"", hm);

    // Register two data nodes to simulate them coming up.
    // We need to add two nodes, because if we have only one node, removing it
    // will cause the includes list to be empty, which means all hosts will be
    // allowed.
    dm.registerDatanode(dr1);
    dm.registerDatanode(dr2);

    // Make sure that both nodes are reported
    List<DatanodeDescriptor> both =
        dm.getDatanodeListForReport(HdfsConstants.DatanodeReportType.ALL);

    // Sort the list so that we know which one is which
    Collections.sort(both);

    Assert.assertEquals(""Incorrect number of hosts reported"",
        2, both.size());
    Assert.assertEquals(""Unexpected host or host in unexpected position"",
        ""127.0.0.1:12345"", both.get(0).getInfoAddr());
    Assert.assertEquals(""Unexpected host or host in unexpected position"",
        ""127.0.0.1:23456"", both.get(1).getInfoAddr());

    // Remove one node from includes, but do not add it to excludes.
    hm.refresh(oneNode, noNodes);

    // Make sure that only one node is still reported
    List<DatanodeDescriptor> onlyOne =
        dm.getDatanodeListForReport(HdfsConstants.DatanodeReportType.ALL);

    Assert.assertEquals(""Incorrect number of hosts reported"",
        1, onlyOne.size());
    Assert.assertEquals(""Unexpected host reported"",
        ""127.0.0.1:23456"", onlyOne.get(0).getInfoAddr());

    // Remove all nodes from includes
    hm.refresh(noNodes, noNodes);

    // Check that both nodes are reported again
    List<DatanodeDescriptor> bothAgain =
        dm.getDatanodeListForReport(HdfsConstants.DatanodeReportType.ALL);

    // Sort the list so that we know which one is which
    Collections.sort(bothAgain);

    Assert.assertEquals(""Incorrect number of hosts reported"",
        2, bothAgain.size());
    Assert.assertEquals(""Unexpected host or host in unexpected position"",
        ""127.0.0.1:12345"", bothAgain.get(0).getInfoAddr());
    Assert.assertEquals(""Unexpected host or host in unexpected position"",
        ""127.0.0.1:23456"", bothAgain.get(1).getInfoAddr());
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testGetDatanodeByHost() throws Exception {
    assertEquals(map.getDatanodeByHost(""1.1.1.1""), dataNodes[0]);
    assertEquals(map.getDatanodeByHost(""2.2.2.2""), dataNodes[1]);
    DatanodeDescriptor node = map.getDatanodeByHost(""3.3.3.3"");
    assertTrue(node == dataNodes[2] || node == dataNodes[3]);
    assertNull(map.getDatanodeByHost(""4.4.4.4""));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testAddAndRemoveBlocks() {
    // Add blocks
    assertTrue(pendingRecoveryBlocks.add(blk1));
    assertTrue(pendingRecoveryBlocks.add(blk2));

    // Remove blk1
    pendingRecoveryBlocks.remove(blk1);

    // Adding back blk1 should succeed
    assertTrue(pendingRecoveryBlocks.add(blk1));
  }",No Smells
"@Test
  public void testEmptyReports() {
    tracker.updateSlowDiskReportAsync(timer.monotonicNow());
    assertTrue(getSlowDisksReportForTesting(tracker).isEmpty());
  }",No Smells
"@Test
  public void testGetJson() throws Exception {
    addSlowDiskForTesting(""dn1"", ""disk1"",
        ImmutableMap.of(DiskOp.METADATA, 1.1, DiskOp.READ, 1.8));
    addSlowDiskForTesting(""dn1"", ""disk2"",
        ImmutableMap.of(DiskOp.READ, 1.3));
    addSlowDiskForTesting(""dn2"", ""disk2"",
        ImmutableMap.of(DiskOp.WRITE, 1.1));
    addSlowDiskForTesting(""dn3"", ""disk1"",
        ImmutableMap.of(DiskOp.WRITE, 1.1));

    tracker.updateSlowDiskReportAsync(timer.monotonicNow());

    GenericTestUtils.waitFor(new Supplier<Boolean>() {
      @Override
      public Boolean get() {
        return tracker.getSlowDiskReportAsJsonString() != null;
      }",No Smells
"@Test
  public void testReplacement() throws Exception {
    addSlowDiskForTesting(""dn1"", ""disk1"",
        ImmutableMap.of(DiskOp.METADATA, 1.1, DiskOp.READ, 1.8));
    timer.advance(reportValidityMs);
    addSlowDiskForTesting(""dn1"", ""disk1"",
        ImmutableMap.of(DiskOp.READ, 1.4));

    tracker.updateSlowDiskReportAsync(timer.monotonicNow());

    GenericTestUtils.waitFor(new Supplier<Boolean>() {
      @Override
      public Boolean get() {
        return !tracker.getSlowDisksReport().isEmpty();
      }",No Smells
"@Test
  public void testEmptyReports() {
    assertTrue(tracker.getReportsForAllDataNodes().isEmpty());
    assertTrue(tracker.getReportsForNode(""noSuchNode"").isEmpty());
  }",No Smells
"@Test
  public void testGetJson() throws IOException {
    OutlierMetrics outlierMetrics1 = new OutlierMetrics(0.0, 0.0, 0.0, 1.1);
    tracker.addReport(""node1"", ""node2"", outlierMetrics1);
    OutlierMetrics outlierMetrics2 = new OutlierMetrics(0.0, 0.0, 0.0, 1.23);
    tracker.addReport(""node2"", ""node3"", outlierMetrics2);
    OutlierMetrics outlierMetrics3 = new OutlierMetrics(0.0, 0.0, 0.0, 2.13);
    tracker.addReport(""node2"", ""node1"", outlierMetrics3);
    OutlierMetrics outlierMetrics4 = new OutlierMetrics(0.0, 0.0, 0.0, 1.244);
    tracker.addReport(""node4"", ""node1"", outlierMetrics4);

    final Set<SlowPeerJsonReport> reports = getAndDeserializeJson();

    // And ensure its contents are what we expect.
    assertThat(reports.size(), is(3));
    assertTrue(isNodeInReports(reports, ""node1""));
    assertTrue(isNodeInReports(reports, ""node2""));
    assertTrue(isNodeInReports(reports, ""node4""));

    assertFalse(isNodeInReports(reports, ""node3""));
  }",No Smells
"@Test
  public void testReportsAreRetrieved() {
    tracker.addReport(""node2"", ""node1"", new OutlierMetrics(0.0, 0.0, 0.0, 1.2));
    tracker.addReport(""node3"", ""node1"", new OutlierMetrics(0.0, 0.0, 0.0, 2.1));
    tracker.addReport(""node3"", ""node2"", new OutlierMetrics(0.0, 0.0, 0.0, 1.22));

    assertThat(tracker.getReportsForAllDataNodes().size(), is(2));
    assertThat(tracker.getReportsForNode(""node2"").size(), is(1));
    assertThat(tracker.getReportsForNode(""node3"").size(), is(2));
    assertThat(tracker.getReportsForNode(""node1"").size(), is(0));
  }",No Smells
"@Test
  public void testNonExistentBlock() throws Exception {
    inMemoryLevelDBAliasMapClient.setConf(conf);
    levelDBAliasMapServer.setConf(conf);
    levelDBAliasMapServer.start();
    Block block1 = new Block(100, 43, 44);
    ProvidedStorageLocation providedStorageLocation1 = null;
    BlockAliasMap.Writer<FileRegion> writer1 =
        inMemoryLevelDBAliasMapClient.getWriter(null, BPID);
    try {
      writer1.store(new FileRegion(block1, providedStorageLocation1));
      fail(""Should fail on writing a region with null ProvidedLocation"");
    }",No Smells
"@Test
  public void testServerBindHost() throws Exception {
    conf.set(DFS_NAMENODE_SERVICE_RPC_BIND_HOST_KEY, ""0.0.0.0"");
    writeRead();
  }",No Smells
"@Test
  public void testReadBack() throws Exception {
    File dbFile = Files.createTempDirectory(""fileregionformat"")
        .toFile();
    try {
      LevelDBFileRegionAliasMap frf = new LevelDBFileRegionAliasMap();
      LevelDBFileRegionAliasMap.LevelDBOptions opts =
          new LevelDBFileRegionAliasMap.LevelDBOptions()
              .filename(dbFile.getAbsolutePath());
      BlockAliasMap.Writer<FileRegion> writer = frf.getWriter(opts, BPID);

      FileRegion fr = new FileRegion(1, new Path(""/file""), 1, 1, 1);
      writer.store(fr);
      writer.close();

      BlockAliasMap.Reader<FileRegion> reader = frf.getReader(opts, BPID);
      FileRegion fr2 = reader.resolve(new Block(1, 1, 1)).get();
      assertEquals(fr, fr2);
      reader.close();
    }",No Smells
"@Test
  public void testRemoteAddrWithTrustedProxy() {
    assertEquals(clientAddr, getRemoteAddr(clientAddr, proxyAddr, true));
    assertEquals(clientAddr, getRemoteAddr(chainedClientAddr, proxyAddr, true));
  }",No Smells
"@Test
  public void testRemoteAddrWithTrustedProxyAndEmptyClient() {
    assertEquals(proxyAddr, getRemoteAddr(null, proxyAddr, true));
    assertEquals(proxyAddr, getRemoteAddr("""", proxyAddr, true));
  }",No Smells
"@Test
  public void testDuplicateReplicaResolution() throws IOException {
    FsVolumeImpl fsv1 = Mockito.mock(FsVolumeImpl.class);
    FsVolumeImpl fsv2 = Mockito.mock(FsVolumeImpl.class);

    File f1 = new File(""d1/block"");
    File f2 = new File(""d2/block"");

    ReplicaInfo replicaOlder = new FinalizedReplica(1,1,1,fsv1,f1);
    ReplicaInfo replica = new FinalizedReplica(1,2,2,fsv1,f1);
    ReplicaInfo replicaSame = new FinalizedReplica(1,2,2,fsv1,f1);
    ReplicaInfo replicaNewer = new FinalizedReplica(1,3,3,fsv1,f1);

    ReplicaInfo replicaOtherOlder = new FinalizedReplica(1,1,1,fsv2,f2);
    ReplicaInfo replicaOtherSame = new FinalizedReplica(1,2,2,fsv2,f2);
    ReplicaInfo replicaOtherNewer = new FinalizedReplica(1,3,3,fsv2,f2);

    // equivalent path so don't remove either
    assertNull(BlockPoolSlice.selectReplicaToDelete(replicaSame, replica));
    assertNull(BlockPoolSlice.selectReplicaToDelete(replicaOlder, replica));
    assertNull(BlockPoolSlice.selectReplicaToDelete(replicaNewer, replica));

    // keep latest found replica
    assertSame(replica,
        BlockPoolSlice.selectReplicaToDelete(replicaOtherSame, replica));
    assertSame(replicaOtherOlder,
        BlockPoolSlice.selectReplicaToDelete(replicaOtherOlder, replica));
    assertSame(replica,
        BlockPoolSlice.selectReplicaToDelete(replicaOtherNewer, replica));
  }",No Smells
"@Test
  public void testDfsReservedPercentageForDifferentStorageTypes()
      throws IOException {
    conf.setClass(DFSConfigKeys.DFS_DATANODE_DU_RESERVED_CALCULATOR_KEY,
        ReservedSpaceCalculator.ReservedSpaceCalculatorPercentage.class,
        ReservedSpaceCalculator.class);
    conf.setLong(DFS_DATANODE_DU_RESERVED_PERCENTAGE_KEY, 15);

    File volDir = new File(baseDir, ""volume-0"");
    volDir.mkdirs();

    DF usage = mock(DF.class);
    when(usage.getCapacity()).thenReturn(4000L);
    when(usage.getAvailable()).thenReturn(1000L);

    // when storage type reserved is not configured, should consider
    // dfs.datanode.du.reserved.pct
    FsVolumeImpl volume = new FsVolumeImplBuilder()
        .setConf(conf)
        .setDataset(dataset)
        .setStorageID(""storage-id"")
        .setStorageDirectory(
            new StorageDirectory(StorageLocation.parse(
                ""[RAM_DISK]"" + volDir.getPath())))
        .setUsage(usage)
        .build();

    assertEquals(600, volume.getReserved());
    assertEquals(3400, volume.getCapacity());
    assertEquals(400, volume.getAvailable());

    // when storage type reserved is configured.
    conf.setLong(
        DFS_DATANODE_DU_RESERVED_PERCENTAGE_KEY + "".""
            + StringUtils.toLowerCase(StorageType.RAM_DISK.toString()), 10);
    conf.setLong(
        DFS_DATANODE_DU_RESERVED_PERCENTAGE_KEY + "".""
            + StringUtils.toLowerCase(StorageType.SSD.toString()), 50);
    conf.setLong(
        DFS_DATANODE_DU_RESERVED_PERCENTAGE_KEY + "".""
            + StringUtils.toLowerCase(StorageType.NVDIMM.toString()), 20);
    FsVolumeImpl volume1 = new FsVolumeImplBuilder()
        .setConf(conf)
        .setDataset(dataset)
        .setStorageID(""storage-id"")
        .setStorageDirectory(
            new StorageDirectory(StorageLocation.parse(
                ""[RAM_DISK]"" + volDir.getPath())))
        .setUsage(usage)
        .build();
    assertEquals(400, volume1.getReserved());
    assertEquals(3600, volume1.getCapacity());
    assertEquals(600, volume1.getAvailable());
    FsVolumeImpl volume2 = new FsVolumeImplBuilder()
        .setConf(conf)
        .setDataset(dataset)
        .setStorageID(""storage-id"")
        .setStorageDirectory(
            new StorageDirectory(StorageLocation.parse(
                ""[SSD]"" + volDir.getPath())))
        .setUsage(usage)
        .build();
    assertEquals(2000, volume2.getReserved());
    assertEquals(2000, volume2.getCapacity());
    assertEquals(0, volume2.getAvailable());
    FsVolumeImpl volume3 = new FsVolumeImplBuilder()
        .setConf(conf)
        .setDataset(dataset)
        .setStorageID(""storage-id"")
        .setStorageDirectory(
            new StorageDirectory(StorageLocation.parse(
                ""[DISK]"" + volDir.getPath())))
        .setUsage(usage)
        .build();
    assertEquals(600, volume3.getReserved());
    FsVolumeImpl volume4 = new FsVolumeImplBuilder()
        .setConf(conf)
        .setDataset(dataset)
        .setStorageID(""storage-id"")
        .setStorageDirectory(
            new StorageDirectory(StorageLocation.parse(volDir.getPath())))
        .setUsage(usage)
        .build();
    assertEquals(600, volume4.getReserved());
    FsVolumeImpl volume5 = new FsVolumeImplBuilder()
        .setConf(conf)
        .setDataset(dataset)
        .setStorageID(""storage-id"")
        .setStorageDirectory(
            new StorageDirectory(StorageLocation.parse(
                ""[NVDIMM]"" + volDir.getPath())))
        .setUsage(usage)
        .build();
    assertEquals(800, volume5.getReserved());
    assertEquals(3200, volume5.getCapacity());
    assertEquals(200, volume5.getAvailable());
  }",Eager Test
"@Test
  public void testGet() {
    // Test 1: null argument throws invalid argument exception
    try {
      map.get(bpid, null);
      fail(""Expected exception not thrown"");
    }",No Smells
"@Test
  public void testReservedSpaceConservativePerStorageType() {
    // This policy should take the maximum of the two
    conf.setClass(DFS_DATANODE_DU_RESERVED_CALCULATOR_KEY,
        ReservedSpaceCalculatorConservative.class,
        ReservedSpaceCalculator.class);

    // Test DISK + taking the reserved bytes over percentage,
    // as that gives more reserved space
    conf.setLong(DFS_DATANODE_DU_RESERVED_KEY + "".disk"", 800);
    conf.setLong(DFS_DATANODE_DU_RESERVED_PERCENTAGE_KEY + "".disk"", 20);
    checkReserved(StorageType.DISK, 1600, 800);

    // Test ARCHIVE + taking reserved space based on the percentage,
    // as that gives more reserved space
    conf.setLong(DFS_DATANODE_DU_RESERVED_KEY + "".archive"", 1300);
    conf.setLong(DFS_DATANODE_DU_RESERVED_PERCENTAGE_KEY + "".archive"", 50);
    checkReserved(StorageType.ARCHIVE, 6200, 3100);

    // Test NVDIMM + taking reserved space based on the percentage,
    // as that gives more reserved space
    conf.setLong(DFS_DATANODE_DU_RESERVED_KEY + "".nvdimm"", 500);
    conf.setLong(DFS_DATANODE_DU_RESERVED_PERCENTAGE_KEY + "".nvdimm"", 20);
    checkReserved(StorageType.NVDIMM, 3000, 600);
  }",No Smells
"@Test
  public void testReservedSpacePercentagePerStorageType() {
    conf.setClass(DFS_DATANODE_DU_RESERVED_CALCULATOR_KEY,
        ReservedSpaceCalculatorPercentage.class,
        ReservedSpaceCalculator.class);

    // Test DISK
    conf.setLong(DFS_DATANODE_DU_RESERVED_PERCENTAGE_KEY + "".disk"", 20);
    checkReserved(StorageType.DISK, 1600, 320);

    // Test SSD
    conf.setLong(DFS_DATANODE_DU_RESERVED_PERCENTAGE_KEY + "".ssd"", 50);
    checkReserved(StorageType.SSD, 8001, 4000);

    // Test NVDIMM
    conf.setLong(DFS_DATANODE_DU_RESERVED_PERCENTAGE_KEY + "".nvdimm"", 30);
    checkReserved(StorageType.NVDIMM, 1000, 300);
  }",No Smells
"@Test
  public void testRR() throws Exception {
    @SuppressWarnings(""unchecked"")
    final RoundRobinVolumeChoosingPolicy<FsVolumeSpi> policy = 
        ReflectionUtils.newInstance(RoundRobinVolumeChoosingPolicy.class, null);
    testRR(policy);
  }",No Smells
"@Test
  public void testRRPolicyExceptionMessage() throws Exception {
    final RoundRobinVolumeChoosingPolicy<FsVolumeSpi> policy
        = new RoundRobinVolumeChoosingPolicy<FsVolumeSpi>();
    testRRPolicyExceptionMessage(policy);
  }",No Smells
"@Test
  public void testInternalNameService() throws Exception {
    Configuration conf = new Configuration();
    conf.set(DFSConfigKeys.DFS_NAMESERVICES, ""ns1,ns2,ns3"");
    addNN(conf, ""ns1"", ""mock1:8020"");
    addNN(conf, ""ns2"", ""mock1:8020"");
    addNN(conf, ""ns3"", ""mock1:8020"");
    conf.set(DFSConfigKeys.DFS_INTERNAL_NAMESERVICES_KEY, ""ns1"");
    bpm.refreshNamenodes(conf);
    assertEquals(""create #1\n"", log.toString());
    Map<String, BPOfferService> map = bpm.getBpByNameserviceId();
    Assert.assertFalse(map.containsKey(""ns2""));
    Assert.assertFalse(map.containsKey(""ns3""));
    Assert.assertTrue(map.containsKey(""ns1""));
    log.setLength(0);
  }",No Smells
"@Test
  public void testIBRClearanceForStandbyOnReRegister() throws Exception {
    final BPOfferService bpos = setupBPOSForNNs(mockNN1, mockNN2);
    bpos.start();
    try {
      waitForInitialization(bpos);
      // Should start with neither NN as active.
      assertNull(bpos.getActiveNN());
      // Have NN1 claim active at txid 1
      mockHaStatuses[0] = new NNHAStatusHeartbeat(HAServiceState.ACTIVE, 1);
      bpos.triggerHeartbeatForTests();
      // Now mockNN1 is acting like active namenode and mockNN2 as Standby
      assertSame(mockNN1, bpos.getActiveNN());
      // Return nothing when active Active Namenode gets IBRs
      Mockito.doNothing().when(mockNN1).blockReceivedAndDeleted(
          Mockito.any(DatanodeRegistration.class), Mockito.anyString(), Mockito
              .any(StorageReceivedDeletedBlocks[].class));

      final IOException re = new IOException(
          ""Standby NN is currently not able to process IBR"");

      final AtomicBoolean ibrReported = new AtomicBoolean(false);
      // throw exception for standby when first IBR is receieved
      Mockito.doAnswer(new Answer<Void>() {
        @Override
        public Void answer(InvocationOnMock invocation) throws Throwable {
          ibrReported.set(true);
          throw re;
        }",Eager Test
"@Test
  public void testIgnoreDeletionsFromNonActive() throws Exception {
    BPOfferService bpos = setupBPOSForNNs(mockNN1, mockNN2);

    // Ask to invalidate FAKE_BLOCK when block report hits the
    // standby
    Mockito.doReturn(new BlockCommand(DatanodeProtocol.DNA_INVALIDATE,
        FAKE_BPID, new Block[] { FAKE_BLOCK.getLocalBlock() }",No Smells
"@Test
  public void testLocklessBlockPoolId() throws Exception {
    BPOfferService bpos = Mockito.spy(setupBPOSForNNs(mockNN1));

    // bpNSInfo is not set, should take lock to check nsInfo.
    assertNull(bpos.getBlockPoolId());
    Mockito.verify(bpos).readLock();

    // setting the bpNSInfo should cache the bp id, thus no locking.
    Mockito.reset(bpos);
    NamespaceInfo nsInfo = new NamespaceInfo(1, FAKE_CLUSTERID, FAKE_BPID, 0);
    assertNull(bpos.setNamespaceInfo(nsInfo));
    assertEquals(FAKE_BPID, bpos.getBlockPoolId());
    Mockito.verify(bpos, Mockito.never()).readLock();

    // clearing the bpNSInfo should clear the cached bp id, thus requiring
    // locking to check the bpNSInfo.
    Mockito.reset(bpos);
    assertEquals(nsInfo, bpos.setNamespaceInfo(null));
    assertNull(bpos.getBlockPoolId());
    Mockito.verify(bpos).readLock();

    // test setting it again.
    Mockito.reset(bpos);
    assertNull(bpos.setNamespaceInfo(nsInfo));
    assertEquals(FAKE_BPID, bpos.getBlockPoolId());
    Mockito.verify(bpos, Mockito.never()).readLock();
  }",No Smells
"@Test
  public void testNNHAStateUpdateFromVersionRequest() throws Exception {
    final BPOfferService bpos = setupBPOSForNNs(mockNN1, mockNN2);
    Mockito.doReturn(true).when(mockDn).areHeartbeatsDisabledForTests();
    BPServiceActor actor = bpos.getBPServiceActors().get(0);
    bpos.start();
    waitForInitialization(bpos);
    // Should start with neither NN as active.
    assertNull(bpos.getActiveNN());

    // getNamespaceInfo() will not include HAServiceState
    NamespaceInfo nsInfo = mockNN1.versionRequest();
    bpos.verifyAndSetNamespaceInfo(actor, nsInfo);

    assertNull(bpos.getActiveNN());

    // Change mock so getNamespaceInfo() will include HAServiceState
    Mockito.doReturn(new NamespaceInfo(1, FAKE_CLUSTERID, FAKE_BPID, 0,
        HAServiceState.ACTIVE)).when(mockNN1).versionRequest();

    // Update the bpos NamespaceInfo
    nsInfo = mockNN1.versionRequest();
    bpos.verifyAndSetNamespaceInfo(actor, nsInfo);

    assertNotNull(bpos.getActiveNN());

  }",No Smells
"@Test
  public void testReportBadBlockWhenStandbyNNTimesOut() throws Exception {
    BPOfferService bpos = setupBPOSForNNs(mockNN1, mockNN2);
    bpos.start();
    try {
      waitForInitialization(bpos);
      // Should start with neither NN as active.
      assertNull(bpos.getActiveNN());
      // Have NN1 claim active at txid 1
      mockHaStatuses[0] = new NNHAStatusHeartbeat(HAServiceState.ACTIVE, 1);
      bpos.triggerHeartbeatForTests();
      // Now mockNN1 is acting like active namenode and mockNN2 as Standby
      assertSame(mockNN1, bpos.getActiveNN());
      Mockito.doAnswer(new BPOfferServiceSynchronousCallAnswer(0))
         .when(mockNN1).reportBadBlocks(Mockito.any());
      Mockito.doAnswer(new BPOfferServiceSynchronousCallAnswer(1))
         .when(mockNN2).reportBadBlocks(Mockito.any());
      bpos.reportBadBlocks(FAKE_BLOCK, mockFSDataset.getVolume(FAKE_BLOCK)
          .getStorageID(), mockFSDataset.getVolume(FAKE_BLOCK)
          .getStorageType());
      bpos.reportBadBlocks(FAKE_BLOCK, mockFSDataset.getVolume(FAKE_BLOCK)
          .getStorageID(), mockFSDataset.getVolume(FAKE_BLOCK)
          .getStorageType());
      Thread.sleep(10000);
      long difference = secondCallTime - firstCallTime;
      assertTrue(""Active namenode reportBadBlock processing should be ""
          + ""independent of standby namenode reportBadBlock processing "",
          difference < 5000);
    }",No Smells
"@Test
  public void testDatanodeBlocksReplicatedMetric() throws Exception {
    Configuration conf = new HdfsConfiguration();
    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).build();
    try {
      FileSystem fs = cluster.getFileSystem();
      List<DataNode> datanodes = cluster.getDataNodes();
      assertEquals(datanodes.size(), 1);
      DataNode datanode = datanodes.get(0);

      MetricsRecordBuilder rb = getMetrics(datanode.getMetrics().name());
      long blocksReplicated = getLongCounter(""BlocksReplicated"", rb);
      assertEquals(""No blocks replicated yet"", 0, blocksReplicated);

      Path path = new Path(""/counter.txt"");
      DFSTestUtil.createFile(fs, path, 1024, (short) 2, Time.monotonicNow());
      cluster.startDataNodes(conf, 1, true, StartupOption.REGULAR, null);
      ExtendedBlock firstBlock = DFSTestUtil.getFirstBlock(fs, path);
      DFSTestUtil.waitForReplication(cluster, firstBlock, 1, 2, 0);

      MetricsRecordBuilder rbNew = getMetrics(datanode.getMetrics().name());
      blocksReplicated = getLongCounter(""BlocksReplicated"", rbNew);
      assertEquals(""blocks replicated counter incremented"", 1, blocksReplicated);
    }",Mystery Guest
"@Test
  public void testDataNodeMXBean() throws Exception {
    Configuration conf = new Configuration();
    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).build();

    try {
      List<DataNode> datanodes = cluster.getDataNodes();
      Assert.assertEquals(datanodes.size(), 1);
      DataNode datanode = datanodes.get(0);

      MBeanServer mbs = ManagementFactory.getPlatformMBeanServer(); 
      ObjectName mxbeanName = new ObjectName(
          ""Hadoop:service=DataNode,name=DataNodeInfo"");
      // get attribute ""ClusterId""
      String clusterId = (String) mbs.getAttribute(mxbeanName, ""ClusterId"");
      Assert.assertEquals(datanode.getClusterId(), clusterId);
      // get attribute ""Version""
      String version = (String)mbs.getAttribute(mxbeanName, ""Version"");
      Assert.assertEquals(datanode.getVersion(),version);
      // get attribute ""DNStartedTimeInMillis""
      long startTime = (long) mbs.getAttribute(mxbeanName, ""DNStartedTimeInMillis"");
      Assert.assertTrue(""Datanode start time should not be 0"", startTime > 0);
      Assert.assertEquals(datanode.getDNStartedTimeInMillis(), startTime);
      // get attribute ""SotfwareVersion""
      String softwareVersion =
          (String)mbs.getAttribute(mxbeanName, ""SoftwareVersion"");
      Assert.assertEquals(datanode.getSoftwareVersion(),softwareVersion);
      Assert.assertEquals(version, softwareVersion
          + "", r"" + datanode.getRevision());
      // get attribute ""RpcPort""
      String rpcPort = (String)mbs.getAttribute(mxbeanName, ""RpcPort"");
      Assert.assertEquals(datanode.getRpcPort(),rpcPort);
      // get attribute ""HttpPort""
      String httpPort = (String)mbs.getAttribute(mxbeanName, ""HttpPort"");
      Assert.assertNotNull(httpPort);
      Assert.assertEquals(datanode.getHttpPort(),httpPort);
      // get attribute ""NamenodeAddresses""
      String namenodeAddresses = (String)mbs.getAttribute(mxbeanName, 
          ""NamenodeAddresses"");
      Assert.assertEquals(datanode.getNamenodeAddresses(),namenodeAddresses);
      // get attribute ""getDatanodeHostname""
      String datanodeHostname = (String)mbs.getAttribute(mxbeanName,
          ""DatanodeHostname"");
      Assert.assertEquals(datanode.getDatanodeHostname(),datanodeHostname);
      // get attribute ""getVolumeInfo""
      String volumeInfo = (String)mbs.getAttribute(mxbeanName, ""VolumeInfo"");
      Assert.assertEquals(replaceDigits(datanode.getVolumeInfo()),
          replaceDigits(volumeInfo));
      // Ensure mxbean's XceiverCount is same as the DataNode's
      // live value.
      int xceiverCount = (Integer)mbs.getAttribute(mxbeanName,
          ""XceiverCount"");
      Assert.assertEquals(datanode.getXceiverCount(), xceiverCount);
      // Ensure mxbean's XmitsInProgress is same as the DataNode's
      // live value.
      int xmitsInProgress =
          (Integer) mbs.getAttribute(mxbeanName, ""XmitsInProgress"");
      Assert.assertEquals(datanode.getXmitsInProgress(), xmitsInProgress);
      String bpActorInfo = (String)mbs.getAttribute(mxbeanName,
          ""BPServiceActorInfo"");
      Assert.assertEquals(datanode.getBPServiceActorInfo(), bpActorInfo);
      String slowDisks = (String)mbs.getAttribute(mxbeanName, ""SlowDisks"");
      Assert.assertEquals(datanode.getSlowDisks(), slowDisks);
    }",No Smells
"@Test
  public void testDataNodeMXBeanSecurityEnabled() throws Exception {
    Configuration simpleConf = new Configuration();
    Configuration secureConf = createSecureConfig(""authentication"");

    // get attribute ""SecurityEnabled"" with simple configuration
    try (MiniDFSCluster cluster =
                 new MiniDFSCluster.Builder(simpleConf).build()) {
      List<DataNode> datanodes = cluster.getDataNodes();
      Assert.assertEquals(datanodes.size(), 1);
      DataNode datanode = datanodes.get(0);

      MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
      ObjectName mxbeanName = new ObjectName(
              ""Hadoop:service=DataNode,name=DataNodeInfo"");

      boolean securityEnabled = (boolean) mbs.getAttribute(mxbeanName,
              ""SecurityEnabled"");
      Assert.assertFalse(securityEnabled);
      Assert.assertEquals(datanode.isSecurityEnabled(), securityEnabled);
    }",No Smells
"@Test
  public void testDataNodeMXBeanSlowDisksEnabled() throws Exception {
    Configuration conf = new Configuration();
    conf.setInt(DFSConfigKeys
        .DFS_DATANODE_FILEIO_PROFILING_SAMPLING_PERCENTAGE_KEY, 100);
    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).build();

    try {
      List<DataNode> datanodes = cluster.getDataNodes();
      Assert.assertEquals(datanodes.size(), 1);
      DataNode datanode = datanodes.get(0);
      String slowDiskPath = ""test/data1/slowVolume"";
      datanode.getDiskMetrics().addSlowDiskForTesting(slowDiskPath, null);

      MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
      ObjectName mxbeanName = new ObjectName(
          ""Hadoop:service=DataNode,name=DataNodeInfo"");

      String slowDisks = (String)mbs.getAttribute(mxbeanName, ""SlowDisks"");
      Assert.assertEquals(datanode.getSlowDisks(), slowDisks);
      Assert.assertTrue(slowDisks.contains(slowDiskPath));
    }",No Smells
"@Test
  public void testFSDatasetFactory() {
    final Configuration conf = new Configuration();
    FsDatasetSpi.Factory<?> f = FsDatasetSpi.Factory.getFactory(conf);
    assertEquals(FsDatasetFactory.class, f.getClass());
    assertFalse(f.isSimulated());

    SimulatedFSDataset.setFactory(conf);
    FsDatasetSpi.Factory<?> s = FsDatasetSpi.Factory.getFactory(conf);
    assertEquals(SimulatedFSDataset.Factory.class, s.getClass());
    assertTrue(s.isSimulated());
  }",No Smells
"@Test
  public void testInjectionEmpty() throws IOException {
    SimulatedFSDataset fsdataset = getSimulatedFSDataset(); 
    assertBlockReportCountAndSize(fsdataset, 0);
    int bytesAdded = addSomeBlocks(fsdataset);
    assertBlockReportCountAndSize(fsdataset, NUMBLOCKS);
    assertBlockLengthInBlockReports(fsdataset);
    
    // Inject blocks into an empty fsdataset
    //  - injecting the blocks we got above.
    SimulatedFSDataset sfsdataset = getSimulatedFSDataset();
    injectBlocksFromBlockReport(fsdataset, sfsdataset);
    assertBlockReportCountAndSize(fsdataset, NUMBLOCKS);
    assertBlockLengthInBlockReports(fsdataset, sfsdataset);

    assertEquals(bytesAdded, sfsdataset.getDfsUsed());
    assertEquals(sfsdataset.getCapacity()-bytesAdded, sfsdataset.getRemaining());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testInvalidate() throws IOException {
    final SimulatedFSDataset fsdataset = getSimulatedFSDataset();
    int bytesAdded = addSomeBlocks(fsdataset);
    Block[] deleteBlocks = new Block[2];
    deleteBlocks[0] = new Block(1, 0, 0);
    deleteBlocks[1] = new Block(2, 0, 0);
    fsdataset.invalidate(bpid, deleteBlocks);
    checkInvalidBlock(new ExtendedBlock(bpid, deleteBlocks[0]));
    checkInvalidBlock(new ExtendedBlock(bpid, deleteBlocks[1]));
    long sizeDeleted = blockIdToLen(1) + blockIdToLen(2);
    assertEquals(bytesAdded-sizeDeleted, fsdataset.getDfsUsed());
    assertEquals(fsdataset.getCapacity()-bytesAdded+sizeDeleted,  fsdataset.getRemaining());
    
    // Now make sure the rest of the blocks are valid
    for (int i=3; i <= NUMBLOCKS; ++i) {
      Block b = new Block(i, 0, 0);
      assertTrue(fsdataset.isValidBlock(new ExtendedBlock(bpid, b)));
    }",Eager Test
"@Test
  public void testStorageReportHasStorageTypeAndState() throws IOException {

    // Make sure we are not testing with the default type, that would not
    // be a very good test.
    assertNotSame(storageType, StorageType.DEFAULT);
    NameNode nn = cluster.getNameNode();
    DataNode dn = cluster.getDataNodes().get(0);

    // Insert a spy object for the NN RPC.
    DatanodeProtocolClientSideTranslatorPB nnSpy =
        InternalDataNodeTestUtils.spyOnBposToNN(dn, nn);

    // Trigger a heartbeat so there is an interaction with the spy
    // object.
    DataNodeTestUtils.triggerHeartbeat(dn);

    // Verify that the callback passed in the expected parameters.
    ArgumentCaptor<StorageReport[]> captor =
        ArgumentCaptor.forClass(StorageReport[].class);

    Mockito.verify(nnSpy).sendHeartbeat(
        any(DatanodeRegistration.class),
        captor.capture(),
        anyLong(), anyLong(), anyInt(), anyInt(), anyInt(),
        any(), Mockito.anyBoolean(),
        Mockito.any(SlowPeerReports.class),
        Mockito.any(SlowDiskReports.class));

    StorageReport[] reports = captor.getValue();

    for (StorageReport report: reports) {
      assertThat(report.getStorage().getStorageType(), is(storageType));
      assertThat(report.getStorage().getState(), is(DatanodeStorage.State.NORMAL));
    }",Eager Test
"@Test
  public void testUGICacheInSecure() throws Exception {
    String uri1 = WebHdfsFileSystem.PATH_PREFIX
        + PATH
        + ""?op=OPEN""
        + Param.toSortedString(""&"", new OffsetParam((long) OFFSET),
            new LengthParam((long) LENGTH), new UserParam(""root""));

    String uri2 = WebHdfsFileSystem.PATH_PREFIX
        + PATH
        + ""?op=OPEN""
        + Param.toSortedString(""&"", new OffsetParam((long) OFFSET),
            new LengthParam((long) LENGTH), new UserParam(""hdfs""));

    DataNodeUGIProvider ugiProvider1 = new DataNodeUGIProvider(
        new ParameterParser(new QueryStringDecoder(URI.create(uri1)), conf));
    UserGroupInformation ugi11 = ugiProvider1.ugi();
    UserGroupInformation ugi12 = ugiProvider1.ugi();

    Assert.assertEquals(
        ""With UGI cache, two UGIs for the same user should be same"", ugi11,
        ugi12);

    DataNodeUGIProvider ugiProvider2 = new DataNodeUGIProvider(
        new ParameterParser(new QueryStringDecoder(URI.create(uri2)), conf));
    UserGroupInformation url21 = ugiProvider2.ugi();
    UserGroupInformation url22 = ugiProvider2.ugi();

    Assert.assertEquals(
        ""With UGI cache, two UGIs for the same user should be same"", url21,
        url22);

    Assert.assertNotEquals(
        ""With UGI cache, two UGIs for the different user should not be same"",
        ugi11, url22);

    awaitCacheEmptyDueToExpiration();
    ugi12 = ugiProvider1.ugi();
    url22 = ugiProvider2.ugi();

    String msg = ""With cache eviction, two UGIs returned by"" +
    "" the same user should not be same"";
    Assert.assertNotEquals(msg, ugi11, ugi12);
    Assert.assertNotEquals(msg, url21, url22);

    Assert.assertNotEquals(
        ""With UGI cache, two UGIs for the different user should not be same"",
        ugi11, url22);
  }",No Smells
"@Test
  public void testOffset() throws IOException {
    final long X = 42;

    long offset = new OffsetParam(Long.toString(X)).getOffset();
    Assert.assertEquals(""OffsetParam: "", X, offset);

    offset = new OffsetParam((String) null).getOffset();
    Assert.assertEquals(""OffsetParam with null should have defaulted to 0"", 0, offset);

    try {
      offset = new OffsetParam(""abc"").getValue();
      Assert.fail(""OffsetParam with nondigit value should have thrown IllegalArgumentException"");
    }",No Smells
"@Test
  public void testGreedyPlannerBalanceVolumeSet() throws Exception {
    URI clusterJson = getClass()
        .getResource(""/diskBalancer/data-cluster-3node-3disk.json"").toURI();
    ClusterConnector jsonConnector = ConnectorFactory.getCluster(clusterJson,
        null);
    DiskBalancerCluster cluster = new DiskBalancerCluster(jsonConnector);
    cluster.readClusterInfo();
    Assert.assertEquals(3, cluster.getNodes().size());
    cluster.setNodesToProcess(cluster.getNodes());
    DiskBalancerDataNode node = cluster.getNodes().get(0);
    GreedyPlanner planner = new GreedyPlanner(10.0f, node);
    NodePlan plan = new NodePlan(node.getDataNodeName(),
        node.getDataNodePort());
    planner.balanceVolumeSet(node, node.getVolumeSets().get(""SSD""), plan);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testGreedyPlannerComputePlan() throws Exception {
    URI clusterJson = getClass()
        .getResource(""/diskBalancer/data-cluster-3node-3disk.json"").toURI();
    ClusterConnector jsonConnector = ConnectorFactory.getCluster(clusterJson,
        null);
    DiskBalancerCluster cluster = new DiskBalancerCluster(jsonConnector);
    cluster.readClusterInfo();
    Assert.assertEquals(3, cluster.getNodes().size());
    cluster.setNodesToProcess(cluster.getNodes());
    List<NodePlan> plan = cluster.computePlan(10.0f);
    Assert.assertNotNull(plan);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testGreedyPlannerEqualDisksNoMoves() throws Exception {
    NullConnector nullConnector = new NullConnector();
    DiskBalancerCluster cluster = new DiskBalancerCluster(nullConnector);

    DiskBalancerDataNode node =
        new DiskBalancerDataNode(UUID.randomUUID().toString());

    // All disks have same capacity of data
    DiskBalancerVolume volume1 = createVolume(""volume1"", 100, 30);
    DiskBalancerVolume volume2 = createVolume(""volume2"", 100, 30);
    DiskBalancerVolume volume3 = createVolume(""volume3"", 100, 30);

    node.addVolume(volume1);
    node.addVolume(volume2);
    node.addVolume(volume3);

    nullConnector.addNode(node);
    cluster.readClusterInfo();
    Assert.assertEquals(1, cluster.getNodes().size());

    GreedyPlanner planner = new GreedyPlanner(10.0f, node);
    NodePlan plan = new NodePlan(node.getDataNodeName(),
        node.getDataNodePort());
    planner.balanceVolumeSet(node, node.getVolumeSets().get(""SSD""), plan);

    // since we have same size of data in all disks , we should have
    // no moves planned.
    assertEquals(0, plan.getVolumeSetPlans().size());
  }",No Smells
"@Test
  public void testGreedyPlannerTwoVolume() throws Exception {
    NullConnector nullConnector = new NullConnector();
    DiskBalancerCluster cluster = new DiskBalancerCluster(nullConnector);

    DiskBalancerDataNode node =
        new DiskBalancerDataNode(UUID.randomUUID().toString());

    DiskBalancerVolume volume30 = createVolume(""volume30"", 100, 30);
    DiskBalancerVolume volume10 = createVolume(""volume10"", 100, 10);

    node.addVolume(volume10);
    node.addVolume(volume30);

    nullConnector.addNode(node);
    cluster.readClusterInfo();
    Assert.assertEquals(1, cluster.getNodes().size());

    GreedyPlanner planner = new GreedyPlanner(5.0f, node);
    NodePlan plan = new NodePlan(node.getDataNodeUUID(),
        node.getDataNodePort());
    planner.balanceVolumeSet(node, node.getVolumeSets().get(""SSD""), plan);

    // We should have only one planned move from
    // volume30 to volume10 of 10 GB Size.

    assertEquals(1, plan.getVolumeSetPlans().size());
    Step step = plan.getVolumeSetPlans().get(0);
    assertEquals(""volume30"", step.getSourceVolume().getPath());
    assertEquals(""volume10"", step.getDestinationVolume().getPath());
    assertEquals(""10 G"", step.getSizeString(step.getBytesToMove()));
  }",No Smells
"@Test
  public void testLoadsCorrectClusterConnector() throws Exception {
    ClusterConnector connector = ConnectorFactory.getCluster(getClass()
            .getResource(""/diskBalancer/data-cluster-3node-3disk.json"").toURI()
        , null);
    assertEquals(connector.getClass().toString(),
        ""class org.apache.hadoop.hdfs.server.diskbalancer.connectors."" +
            ""JsonNodeConnector"");

  }",Mystery Guest + Resource Optimism
"@Test
  public void testPlannerScale() throws Exception {
    final int diskCount = 256; // it is rare to see more than 48 disks
    DiskBalancerTestUtil util = new DiskBalancerTestUtil();
    DiskBalancerVolumeSet vSet =
        util.createRandomVolumeSet(StorageType.SSD, diskCount);
    NullConnector nullConnector = new NullConnector();
    DiskBalancerCluster cluster = new DiskBalancerCluster(nullConnector);

    DiskBalancerDataNode node =
        new DiskBalancerDataNode(UUID.randomUUID().toString());
    int diskNum = 0;
    for (DiskBalancerVolume vol : vSet.getVolumes()) {
      vol.setPath(""volume"" + diskNum++);
      node.addVolume(vol);
    }",Eager Test
"@Test
  public void testResolverWithNoPreference() throws IOException {
    MultipleDestinationMountTableResolver mountTableResolver =
        mockAvailableSpaceResolver(1.0f);
    // Since we don't have any preference, it will
    // always chose the maximum-available-space subcluster.
    PathLocation loc = mountTableResolver.getDestinationForPath(""/space"");
    assertEquals(""subcluster9"",
        loc.getDestinations().get(0).getNameserviceId());

    loc = mountTableResolver.getDestinationForPath(""/space/subdir"");
    assertEquals(""subcluster9"",
        loc.getDestinations().get(0).getNameserviceId());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testDefaultNameServiceEnable() throws IOException {
    assertTrue(mountTable.isDefaultNSEnable());
    mountTable.setDefaultNameService(""3"");
    mountTable.removeEntry(""/"");

    assertEquals(""3->/unknown"",
        mountTable.getDestinationForPath(""/unknown"").toString());

    Map<String, String> map = getMountTableEntry(""4"", ""/unknown"");
    mountTable.addEntry(MountTable.newInstance(""/unknown"", map));
    mountTable.setDefaultNSEnable(false);
    assertFalse(mountTable.isDefaultNSEnable());

    assertEquals(""4->/unknown"",
        mountTable.getDestinationForPath(""/unknown"").toString());
    try {
      mountTable.getDestinationForPath(""/"");
      fail(""The getDestinationForPath call should fail."");
    }",Mystery Guest + Resource Optimism
"@Test
  public void testGetMountPoints() throws IOException {
    // Check mount points beneath the path without trailing slash.
    getMountPoints(false);
  }",No Smells
"@Test
  public void testGetConnectionWithConcurrency() throws Exception {
    Map<ConnectionPoolId, ConnectionPool> poolMap = connManager.getPools();
    Configuration copyConf = new Configuration(conf);
    copyConf.setInt(RBFConfigKeys.DFS_ROUTER_MAX_CONCURRENCY_PER_CONNECTION_KEY, 20);

    ConnectionPool pool = new ConnectionPool(
        copyConf, TEST_NN_ADDRESS, TEST_USER1, 1, 10, 0.5f,
        ClientProtocol.class, null);
    poolMap.put(
        new ConnectionPoolId(TEST_USER1, TEST_NN_ADDRESS, ClientProtocol.class),
        pool);
    assertEquals(1, pool.getNumConnections());
    // one connection can process the maximum number of requests concurrently.
    for (int i = 0; i < 20; i++) {
      ConnectionContext cc = pool.getConnection();
      assertTrue(cc.isUsable());
      cc.getClient();
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testValidClientIndex() throws Exception {
    ConnectionPool pool = new ConnectionPool(conf, TEST_NN_ADDRESS, TEST_USER1,
        2, 2, 0.5f, ClientProtocol.class, null);
    for(int i = -3; i <= 3; i++) {
      pool.getClientIndex().set(i);
      ConnectionContext conn = pool.getConnection();
      assertNotNull(conn);
      assertTrue(conn.isUsable());
    }",Eager Test
"@Test
  public void testRouterIDInRouterRpcClient() throws Exception {

    Router router = new Router();
    router.init(new RouterConfigBuilder(conf).rpc().build());
    router.setRouterId(""Router-0"");
    RemoteMethod remoteMethod = mock(RemoteMethod.class);

    intercept(IOException.class, ""Router-0"",
        () -> router.getRpcServer().getRPCClient()
            .invokeSingle(""ns0"", remoteMethod));

    router.stop();
    router.close();
  }",No Smells
"@Test
  public void testAddOrderMountTable() throws IOException {
    testAddOrderMountTable(DestinationOrder.HASH);
    testAddOrderMountTable(DestinationOrder.LOCAL);
    testAddOrderMountTable(DestinationOrder.RANDOM);
    testAddOrderMountTable(DestinationOrder.HASH_ALL);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testGetChildrenPaths() {
    RouterQuotaUsage quotaUsage = new RouterQuotaUsage.Builder().build();
    manager.put(""/path1"", quotaUsage);
    manager.put(""/path2"", quotaUsage);
    manager.put(""/path1/subdir"", quotaUsage);
    manager.put(""/path1/subdir/subdir"", quotaUsage);

    Set<String> childrenPaths = manager.getPaths(""/path1"");
    assertEquals(3, childrenPaths.size());
    assertTrue(childrenPaths.contains(""/path1/subdir"")
        && childrenPaths.contains(""/path1/subdir/subdir"")
        && childrenPaths.contains(""/path1""));

    // test for corner case
    manager.put(""/path3"", quotaUsage);
    manager.put(""/path3/subdir"", quotaUsage);
    manager.put(""/path3-subdir"", quotaUsage);

    childrenPaths = manager.getPaths(""/path3"");
    assertEquals(2, childrenPaths.size());
    // path /path3-subdir should not be returned
    assertTrue(childrenPaths.contains(""/path3"")
        && childrenPaths.contains(""/path3/subdir"")
        && !childrenPaths.contains(""/path3-subdir""));
  }",No Smells
"@Test
  public void testQuota() throws IOException {
    MountTable record = MountTable.newInstance(SRC, DST_MAP);
    record.setQuota(QUOTA);

    validateDestinations(record);
    assertEquals(SRC, record.getSourcePath());
    assertEquals(DST, record.getDestinations());
    assertTrue(DATE_CREATED > 0);
    assertTrue(DATE_MOD > 0);

    RouterQuotaUsage quotaGet = record.getQuota();
    assertEquals(NS_COUNT, quotaGet.getFileAndDirectoryCount());
    assertEquals(NS_QUOTA, quotaGet.getQuota());
    assertEquals(SS_COUNT, quotaGet.getSpaceConsumed());
    assertEquals(SS_QUOTA, quotaGet.getSpaceQuota());
  }",No Smells
"@Test
  public void testSerialization() throws IOException {

    RouterState record = generateRecord();

    StateStoreSerializer serializer = StateStoreSerializer.getSerializer();
    String serializedString = serializer.serializeString(record);
    RouterState newRecord =
        serializer.deserialize(serializedString, RouterState.class);

    validateRecord(newRecord);
  }",No Smells
"@Test
  public void testMoverCli() throws Exception {
    final Configuration clusterConf = new HdfsConfiguration();
    clusterConf.set(DFSConfigKeys.DFS_STORAGE_POLICY_SATISFIER_MODE_KEY,
        StoragePolicySatisfierMode.NONE.toString());
    final MiniDFSCluster cluster = new MiniDFSCluster
        .Builder(clusterConf).numDataNodes(0).build();
    try {
      final Configuration conf = cluster.getConfiguration(0);
      try {
        Mover.Cli.getNameNodePathsToMove(conf, ""-p"", ""/foo"", ""bar"");
        Assert.fail(""Expected exception for illegal path bar"");
      }",No Smells
"@Test
  public void testMoverCliWithHAConf() throws Exception {
    final Configuration conf = new HdfsConfiguration();
    conf.set(DFSConfigKeys.DFS_STORAGE_POLICY_SATISFIER_MODE_KEY,
        StoragePolicySatisfierMode.NONE.toString());
    final MiniDFSCluster cluster = new MiniDFSCluster
        .Builder(conf)
        .nnTopology(MiniDFSNNTopology.simpleHATopology())
        .numDataNodes(0).build();
    HATestUtil.setFailoverConfigurations(cluster, conf, ""MyCluster"");
    try {
      Map<URI, List<Path>> movePaths = Mover.Cli.getNameNodePathsToMove(conf,
          ""-p"", ""/foo"", ""/bar"");
      Collection<URI> namenodes = DFSUtil.getInternalNsRpcUris(conf);
      Assert.assertEquals(1, namenodes.size());
      Assert.assertEquals(1, movePaths.size());
      URI nn = namenodes.iterator().next();
      Assert.assertEquals(new URI(""hdfs://MyCluster""), nn);
      Assert.assertTrue(movePaths.containsKey(nn));
      checkMovePaths(movePaths.get(nn), new Path(""/foo""), new Path(""/bar""));
    }",No Smells
"@Test
  public void testSharedEditsMissingLogs() throws Exception {
    removeStandbyNameDirs();

    CheckpointSignature sig = nn0.getRpcServer().rollEditLog();
    assertEquals(3, sig.getCurSegmentTxId());

    // Should have created edits_1-2 in shared edits dir
    URI editsUri = cluster.getSharedEditsDir(0, maxNNCount - 1);
    File editsDir = new File(editsUri);
    File currentDir = new File(editsDir, ""current"");
    File editsSegment = new File(currentDir,
        NNStorage.getFinalizedEditsFileName(1, 2));
    GenericTestUtils.assertExists(editsSegment);
    GenericTestUtils.assertExists(currentDir);

    // Delete the segment.
    assertTrue(editsSegment.delete());

    // Trying to bootstrap standby should now fail since the edit
    // logs aren't available in the shared dir.
    LogCapturer logs = GenericTestUtils.LogCapturer.captureLogs(
        LoggerFactory.getLogger(BootstrapStandby.class));
    try {
      assertEquals(BootstrapStandby.ERR_CODE_LOGS_UNAVAILABLE, forceBootstrap(1));
    }",Mystery Guest + Resource Optimism
"@Test
  public void testStandbyDirsAlreadyExist() throws Exception {
    // Should not pass since standby dirs exist, force not given
    int rc = BootstrapStandby.run(
        new String[]{""-nonInteractive""}",No Smells
"@Test
  public void testSuccessfulBaseCase() throws Exception {
    removeStandbyNameDirs();

    // skip the first NN, its up
    for (int index = 1; index < maxNNCount; index++) {
      try {
        cluster.restartNameNode(index);
        fail(""Did not throw"");
      }",Eager Test
"@Test
  public void testNonRandomGetProxy() throws Exception {
    final AtomicInteger nn1Count = new AtomicInteger(0);
    final AtomicInteger nn2Count = new AtomicInteger(0);

    Map<InetSocketAddress, ClientProtocol> proxyMap = new HashMap<>();

    final ClientProtocol nn1Mock = mock(ClientProtocol.class);
    when(nn1Mock.getStats()).thenAnswer(createAnswer(nn1Count, 1));
    proxyMap.put(ns1nn1, nn1Mock);

    final ClientProtocol nn2Mock = mock(ClientProtocol.class);
    when(nn2Mock.getStats()).thenAnswer(createAnswer(nn2Count, 2));
    proxyMap.put(ns1nn2, nn2Mock);

    ConfiguredFailoverProxyProvider<ClientProtocol> provider1 =
        new ConfiguredFailoverProxyProvider<>(conf, ns1Uri,
            ClientProtocol.class, createFactory(proxyMap));
    ClientProtocol proxy1 = provider1.getProxy().proxy;
    proxy1.getStats();
    assertEquals(1, nn1Count.get());
    assertEquals(0, nn2Count.get());
    proxy1.getStats();
    assertEquals(2, nn1Count.get());
    assertEquals(0, nn2Count.get());
    nn1Count.set(0);
    nn2Count.set(0);

    for (int i = 0; i < NUM_ITERATIONS; i++) {
      ConfiguredFailoverProxyProvider<ClientProtocol> provider2 =
          new ConfiguredFailoverProxyProvider<>(conf, ns1Uri,
              ClientProtocol.class, createFactory(proxyMap));
      ClientProtocol proxy2 = provider2.getProxy().proxy;
      proxy2.getStats();
    }",Eager Test
"@Test
  public void testRandomGetProxy() throws Exception {
    final AtomicInteger nn1Count = new AtomicInteger(0);
    final AtomicInteger nn2Count = new AtomicInteger(0);
    final AtomicInteger nn3Count = new AtomicInteger(0);

    Map<InetSocketAddress, ClientProtocol> proxyMap = new HashMap<>();

    final ClientProtocol nn1Mock = mock(ClientProtocol.class);
    when(nn1Mock.getStats()).thenAnswer(createAnswer(nn1Count, 1));
    proxyMap.put(ns2nn1, nn1Mock);

    final ClientProtocol nn2Mock = mock(ClientProtocol.class);
    when(nn2Mock.getStats()).thenAnswer(createAnswer(nn2Count, 2));
    proxyMap.put(ns2nn2, nn2Mock);

    final ClientProtocol nn3Mock = mock(ClientProtocol.class);
    when(nn3Mock.getStats()).thenAnswer(createAnswer(nn3Count, 3));
    proxyMap.put(ns2nn3, nn3Mock);


    for (int i = 0; i < NUM_ITERATIONS; i++) {
      ConfiguredFailoverProxyProvider<ClientProtocol> provider =
          new ConfiguredFailoverProxyProvider<>(conf, ns2Uri,
              ClientProtocol.class, createFactory(proxyMap));
      ClientProtocol proxy = provider.getProxy().proxy;
      proxy.getStats();
    }",Eager Test
"@Test
  public void testNN0TriggersLogRolls() throws Exception {
    testStandbyTriggersLogRolls(0);
  }",Eager Test
"@Test
  public void testStartNNWithTrashEmptier() throws Exception {
    MiniDFSCluster cluster = null;
    Configuration conf = new HdfsConfiguration();
    
    // enable both trash emptier and dropping response
    conf.setLong(""fs.trash.interval"", 360);
    conf.setInt(HdfsClientConfigKeys.DFS_CLIENT_TEST_DROP_NAMENODE_RESPONSE_NUM_KEY, 2);

    try {
      cluster = new MiniDFSCluster.Builder(conf)
          .nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(0)
          .build();
      cluster.waitActive();
      cluster.transitionToActive(0);
    }",No Smells
"@Test
  public void testFileNotFoundExceptionWithSingleProxy() throws Exception {
    ClientProtocol active = Mockito.mock(ClientProtocol.class);
    Mockito
        .when(active.getBlockLocations(anyString(), anyLong(), anyLong()))
        .thenThrow(new RemoteException(""java.io.FileNotFoundException"",
            ""File does not exist!""));

    ClientProtocol standby = Mockito.mock(ClientProtocol.class);
    Mockito
        .when(standby.getBlockLocations(anyString(), anyLong(), anyLong()))
        .thenThrow(
            new RemoteException(""org.apache.hadoop.ipc.StandbyException"",
                ""Standby NameNode""));

    RequestHedgingProxyProvider<ClientProtocol> provider =
        new RequestHedgingProxyProvider<>(conf, nnUri,
            ClientProtocol.class, createFactory(standby, active));
    try {
      provider.getProxy().proxy.getBlockLocations(""/tmp/test.file"", 0L, 20L);
      Assert.fail(""Should fail since the active namenode throws""
          + "" FileNotFoundException!"");
    }",Eager Test
"@Test
  public void testHedgingWhenConnectException() throws Exception {
    ClientProtocol active = Mockito.mock(ClientProtocol.class);
    Mockito.when(active.getStats()).thenThrow(new ConnectException());

    ClientProtocol standby = Mockito.mock(ClientProtocol.class);
    Mockito.when(standby.getStats())
        .thenThrow(
            new RemoteException(""org.apache.hadoop.ipc.StandbyException"",
            ""Standby NameNode""));

    RequestHedgingProxyProvider<ClientProtocol> provider =
        new RequestHedgingProxyProvider<>(conf, nnUri,
          ClientProtocol.class, createFactory(active, standby));
    try {
      provider.getProxy().proxy.getStats();
      Assert.fail(""Should fail since the active namenode throws""
          + "" ConnectException!"");
    }",Eager Test
"@Test
  public void testHedgingWhenOneIsSlow() throws Exception {
    final ClientProtocol goodMock = Mockito.mock(ClientProtocol.class);
    Mockito.when(goodMock.getStats()).thenAnswer(new Answer<long[]>() {
      @Override
      public long[] answer(InvocationOnMock invocation) throws Throwable {
        Thread.sleep(1000);
        return new long[]{1}",No Smells
"@Test
  public void testSingleProxyFailover() throws Exception {
    String singleNS = ""mycluster-"" + Time.monotonicNow();
    URI singleNNUri = new URI(""hdfs://"" + singleNS);
    Configuration singleConf = new Configuration();
    singleConf.set(HdfsClientConfigKeys.DFS_NAMESERVICES, singleNS);
    singleConf.set(HdfsClientConfigKeys.
        DFS_HA_NAMENODES_KEY_PREFIX + ""."" + singleNS, ""nn1"");

    singleConf.set(HdfsClientConfigKeys.
            DFS_NAMENODE_RPC_ADDRESS_KEY + ""."" + singleNS + "".nn1"",
        RandomStringUtils.randomAlphabetic(8) + "".foo.bar:9820"");
    ClientProtocol active = Mockito.mock(ClientProtocol.class);
    Mockito
        .when(active.getBlockLocations(anyString(), anyLong(), anyLong()))
        .thenThrow(new RemoteException(""java.io.FileNotFoundException"",
            ""File does not exist!""));

    RequestHedgingProxyProvider<ClientProtocol> provider =
        new RequestHedgingProxyProvider<>(singleConf, singleNNUri,
            ClientProtocol.class, createFactory(active));
    try {
      provider.getProxy().proxy.getBlockLocations(""/tmp/test.file"", 0L, 20L);
      Assert.fail(""Should fail since the active namenode throws""
          + "" FileNotFoundException!"");
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testCorruptBlock() throws Exception {
    // Create a file with single block with two replicas
    final Path file = getTestPath(""testCorruptBlock"");
    final short replicaCount = 2;
    createFile(file, 100, replicaCount);
    DFSTestUtil.waitForReplication(fs, file, replicaCount, 15000);

    // Disable the heartbeats, so that no corrupted replica
    // can be fixed
    for (DataNode dn : cluster.getDataNodes()) {
      DataNodeTestUtils.setHeartbeatsDisabledForTests(dn, true);
    }",Eager Test + Mystery Guest
"@Test
  public void testEditLogTailing() throws Exception {
    HdfsConfiguration conf = new HdfsConfiguration();
    conf.setInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY, 1);
    conf.setInt(DFSConfigKeys.DFS_METRICS_PERCENTILES_INTERVALS_KEY, 60);
    MiniDFSCluster dfsCluster = null;
    try {
      dfsCluster = new MiniDFSCluster.Builder(conf)
          .numDataNodes(0)
          .nnTopology(MiniDFSNNTopology.simpleHATopology())
          .build();
      DistributedFileSystem dfs = dfsCluster.getFileSystem(0);
      dfsCluster.transitionToActive(0);
      dfsCluster.waitActive();

      Path testDir = new Path(""/testdir"");
      dfs.mkdir(testDir, FsPermission.getDefault());

      dfsCluster.getNameNodeRpc(0).rollEditLog();
      Thread.sleep(2 * 1000);

      // We need to get the metrics for the SBN (excluding the NN from dfs
      // cluster created in setUp() and the ANN).
      MetricsRecordBuilder rb = getMetrics(NN_METRICS+""-2"");
      assertQuantileGauges(""EditLogTailTime60s"", rb);
      assertQuantileGauges(""EditLogFetchTime60s"", rb);
      assertQuantileGauges(""NumEditLogLoaded60s"", rb, ""Count"");
      assertQuantileGauges(""EditLogTailInterval60s"", rb);
      assertCounterGt(""EditLogTailTimeNumOps"", 0L, rb);
      assertCounterGt(""EditLogFetchTimeNumOps"", 0L, rb);
      assertCounterGt(""NumEditLogLoadedNumOps"", 0L, rb);
      assertCounterGt(""EditLogTailIntervalNumOps"", 0L, rb);
    }",Mystery Guest
"@Test
  public void testMissingBlock() throws Exception {
    // Create a file with single block with two replicas
    Path file = getTestPath(""testMissingBlocks"");
    createFile(file, 100, (short)1);
    
    // Corrupt the only replica of the block to result in a missing block
    LocatedBlock block = NameNodeAdapter.getBlockLocations(
        cluster.getNameNode(), file.toString(), 0, 1).get(0);
    cluster.getNamesystem().writeLock();
    try {
      bm.findAndMarkBlockAsCorrupt(block.getBlock(), block.getLocations()[0],
          ""STORAGE_ID"", ""TEST"");
    }",Mystery Guest + Resource Optimism
"@Test
  public void testReadWriteOps() throws Exception {
    MetricsRecordBuilder rb = getMetrics(NN_METRICS);
    long startWriteCounter = MetricsAsserts.getLongCounter(""TransactionsNumOps"",
        rb);
    Path file1_Path = new Path(TEST_ROOT_DIR_PATH, ""ReadData.dat"");

    //Perform create file operation
    createFile(file1_Path, 1024, (short) 2);

    // Perform read file operation on earlier created file
    readFile(fs, file1_Path);
    MetricsRecordBuilder rbNew = getMetrics(NN_METRICS);
    assertTrue(MetricsAsserts.getLongCounter(""TransactionsNumOps"", rbNew) >
        startWriteCounter);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testSyncAndBlockReportMetric() throws Exception {
    MetricsRecordBuilder rb = getMetrics(NN_METRICS);
    // We have one sync when the cluster starts up, just opening the journal
    assertCounter(""SyncsNumOps"", 4L, rb);
    // Each datanode reports in when the cluster comes up
    assertCounter(""StorageBlockReportNumOps"",
                  (long) DATANODE_COUNT * cluster.getStoragesPerDatanode(), rb);
    
    // Sleep for an interval+slop to let the percentiles rollover
    Thread.sleep((PERCENTILES_INTERVAL+1)*1000);
    
    // Check that the percentiles were updated
    assertQuantileGauges(""Syncs1s"", rb);
    assertQuantileGauges(""StorageBlockReport1s"", rb);
  }",No Smells
"@Test
  public void testRemoveRandom() throws Exception {
    final int n = NUM_SNAPSHOTS;
    testRemove(""Random"", n, i -> ThreadLocalRandom.current().nextInt(n - i));
  }",Eager Test + Mystery Guest
"@Test
  public void testDiffReportWithRenameAndAppend() throws Exception {
    final Path root = new Path(""/"");
    final Path foo = new Path(root, ""foo"");
    DFSTestUtil.createFile(hdfs, foo, BLOCKSIZE, REPLICATION, SEED);

    SnapshotTestHelper.createSnapshot(hdfs, root, ""s0"");
    final Path bar = new Path(root, ""bar"");
    hdfs.rename(foo, bar);
    DFSTestUtil.appendFile(hdfs, bar, 10); // append 10 bytes
    SnapshotTestHelper.createSnapshot(hdfs, root, ""s1"");

    // we always put modification on the file before rename
    verifyDiffReport(root, ""s0"", ""s1"",
        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes("""")),
        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(""foo"")),
        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(""foo""),
            DFSUtil.string2Bytes(""bar"")));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testDiffReportWithRenameAndSnapshotDeletion() throws Exception {
    final Path root = new Path(""/"");
    final Path foo = new Path(root, ""foo"");
    final Path bar = new Path(foo, ""bar"");
    DFSTestUtil.createFile(hdfs, bar, BLOCKSIZE, REPLICATION, SEED);

    SnapshotTestHelper.createSnapshot(hdfs, root, ""s0"");
    // rename /foo to /foo2
    final Path foo2 = new Path(root, ""foo2"");
    hdfs.rename(foo, foo2);
    // now /foo/bar becomes /foo2/bar
    final Path bar2 = new Path(foo2, ""bar"");

    // delete snapshot s0 so that the withNameList inside of the WithCount node
    // of foo becomes empty
    hdfs.deleteSnapshot(root, ""s0"");

    // create snapshot s1 and rename bar again
    SnapshotTestHelper.createSnapshot(hdfs, root, ""s1"");
    final Path bar3 = new Path(foo2, ""bar-new"");
    hdfs.rename(bar2, bar3);

    // we always put modification on the file before rename
    verifyDiffReport(root, ""s1"", """",
        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(""foo2"")),
        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(""foo2/bar""),
            DFSUtil.string2Bytes(""foo2/bar-new"")));
  }",No Smells
"@Test
  public void testDiffReportWithRpcLimit() throws Exception {
    final Path root = new Path(""/"");
    hdfs.mkdirs(root);
    for (int i = 1; i < 4; i++) {
      final Path path = new Path(root, ""dir"" + i);
      hdfs.mkdirs(path);
    }",Eager Test
"@Test
  public void testDiffReportWithRpcLimit2() throws Exception {
    final Path root = new Path(""/"");
    hdfs.mkdirs(root);
    for (int i = 1; i <=3; i++) {
      final Path path = new Path(root, ""dir"" + i);
      hdfs.mkdirs(path);
    }",Eager Test
"@Test
  public void testSnapshotDiffInfo() throws Exception {
    Path snapshotRootDirPath = dir;
    Path snapshotDirDescendantPath = new Path(snapshotRootDirPath, ""desc"");
    Path snapshotDirNonDescendantPath = new Path(""/dummy/non/snap/desc"");
    hdfs.mkdirs(snapshotDirDescendantPath);
    hdfs.mkdirs(snapshotDirNonDescendantPath);

    hdfs.allowSnapshot(snapshotRootDirPath);
    hdfs.createSnapshot(snapshotRootDirPath, ""s0"");
    hdfs.createSnapshot(snapshotRootDirPath, ""s1"");

    INodeDirectory snapshotRootDir = cluster.getNameNode()
        .getNamesystem().getFSDirectory().getINode(
            snapshotRootDirPath.toUri().getPath())
        .asDirectory();
    INodeDirectory snapshotRootDescendantDir = cluster.getNameNode()
        .getNamesystem().getFSDirectory().getINode(
            snapshotDirDescendantPath.toUri().getPath())
        .asDirectory();
    INodeDirectory snapshotRootNonDescendantDir = cluster.getNameNode()
        .getNamesystem().getFSDirectory().getINode(
            snapshotDirNonDescendantPath.toUri().getPath())
        .asDirectory();
    try {
      SnapshotDiffInfo sdi = new SnapshotDiffInfo(
          snapshotRootDir,
          snapshotRootDescendantDir,
          new Snapshot(0, ""s0"", snapshotRootDescendantDir),
          new Snapshot(0, ""s1"", snapshotRootDescendantDir));
      LOG.info(""SnapshotDiffInfo: "" + sdi.getFrom() + "" - "" + sdi.getTo());
    }",No Smells
"@Test
  public void testSnapshotDiffReportRemoteIterator2() throws Exception {
    final Path root = new Path(""/"");
    hdfs.mkdirs(root);
    SnapshotTestHelper.createSnapshot(hdfs, root, ""s0"");
    try {
      hdfs.snapshotDiffReportListingRemoteIterator(root, ""s0"", """");
    }",No Smells
"@Test
  public void testFinalState() {
    setStartupProgressForFinalState(startupProgress);

    MetricsRecordBuilder builder = getMetrics(metrics, true);
    assertTrue(getLongCounter(""ElapsedTime"", builder) >= 0L);
    assertGauge(""PercentComplete"", 1.0f, builder);
    assertCounter(""LoadingFsImageCount"", 100L, builder);
    assertTrue(getLongCounter(""LoadingFsImageElapsedTime"", builder) >= 0L);
    assertCounter(""LoadingFsImageTotal"", 100L, builder);
    assertGauge(""LoadingFsImagePercentComplete"", 1.0f, builder);
    assertCounter(""LoadingEditsCount"", 200L, builder);
    assertTrue(getLongCounter(""LoadingEditsElapsedTime"", builder) >= 0L);
    assertCounter(""LoadingEditsTotal"", 200L, builder);
    assertGauge(""LoadingEditsPercentComplete"", 1.0f, builder);
    assertCounter(""SavingCheckpointCount"", 300L, builder);
    assertTrue(getLongCounter(""SavingCheckpointElapsedTime"", builder) >= 0L);
    assertCounter(""SavingCheckpointTotal"", 300L, builder);
    assertGauge(""SavingCheckpointPercentComplete"", 1.0f, builder);
    assertCounter(""SafeModeCount"", 400L, builder);
    assertTrue(getLongCounter(""SafeModeElapsedTime"", builder) >= 0L);
    assertCounter(""SafeModeTotal"", 400L, builder);
    assertGauge(""SafeModePercentComplete"", 1.0f, builder);
  }",No Smells
"@Test
  public void testFilterAclEntriesByAclSpecAutomaticDefaultOther()
      throws AclException {
    List<AclEntry> existing = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, OTHER, READ))
      .add(aclEntry(DEFAULT, USER, READ_WRITE))
      .add(aclEntry(DEFAULT, GROUP, READ_WRITE))
      .add(aclEntry(DEFAULT, OTHER, NONE))
      .build();
    List<AclEntry> aclSpec = Lists.newArrayList(
      aclEntry(DEFAULT, OTHER));
    List<AclEntry> expected = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, OTHER, READ))
      .add(aclEntry(DEFAULT, USER, READ_WRITE))
      .add(aclEntry(DEFAULT, GROUP, READ_WRITE))
      .add(aclEntry(DEFAULT, OTHER, READ))
      .build();
    assertEquals(expected, filterAclEntriesByAclSpec(existing, aclSpec));
  }",No Smells
"@Test
  public void testFilterAclEntriesByAclSpecDefaultMaskPreserved()
      throws AclException {
    List<AclEntry> existing = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, USER, ""bruce"", READ))
      .add(aclEntry(ACCESS, USER, ""diana"", READ_WRITE))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, MASK, READ_WRITE))
      .add(aclEntry(ACCESS, OTHER, READ))
      .add(aclEntry(DEFAULT, USER, ALL))
      .add(aclEntry(DEFAULT, USER, ""diana"", ALL))
      .add(aclEntry(DEFAULT, GROUP, READ))
      .add(aclEntry(DEFAULT, MASK, READ))
      .add(aclEntry(DEFAULT, OTHER, NONE))
      .build();
    List<AclEntry> aclSpec = Lists.newArrayList(
      aclEntry(ACCESS, USER, ""diana""));
    List<AclEntry> expected = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, USER, ""bruce"", READ))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, MASK, READ))
      .add(aclEntry(ACCESS, OTHER, READ))
      .add(aclEntry(DEFAULT, USER, ALL))
      .add(aclEntry(DEFAULT, USER, ""diana"", ALL))
      .add(aclEntry(DEFAULT, GROUP, READ))
      .add(aclEntry(DEFAULT, MASK, READ))
      .add(aclEntry(DEFAULT, OTHER, NONE))
      .build();
    assertEquals(expected, filterAclEntriesByAclSpec(existing, aclSpec));
  }",No Smells
"@Test
  public void testMergeAclEntriesAutomaticDefaultUser() throws AclException {
    List<AclEntry> existing = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, OTHER, READ))
      .build();
    List<AclEntry> aclSpec = Lists.newArrayList(
      aclEntry(DEFAULT, GROUP, READ_EXECUTE),
      aclEntry(DEFAULT, OTHER, READ));
    List<AclEntry> expected = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, OTHER, READ))
      .add(aclEntry(DEFAULT, USER, ALL))
      .add(aclEntry(DEFAULT, GROUP, READ_EXECUTE))
      .add(aclEntry(DEFAULT, OTHER, READ))
      .build();
    assertEquals(expected, mergeAclEntries(existing, aclSpec));
  }",No Smells
"@Test
  public void testReplaceAclEntriesAccessMaskPreserved() throws AclException {
    List<AclEntry> existing = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, USER, ""bruce"", READ))
      .add(aclEntry(ACCESS, USER, ""diana"", READ_WRITE))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, MASK, READ))
      .add(aclEntry(ACCESS, OTHER, READ))
      .add(aclEntry(DEFAULT, USER, ALL))
      .add(aclEntry(DEFAULT, USER, ""bruce"", READ))
      .add(aclEntry(DEFAULT, USER, ""diana"", READ_WRITE))
      .add(aclEntry(DEFAULT, GROUP, READ))
      .add(aclEntry(DEFAULT, MASK, READ_WRITE))
      .add(aclEntry(DEFAULT, OTHER, NONE))
      .build();
    List<AclEntry> aclSpec = Lists.newArrayList(
      aclEntry(DEFAULT, USER, ALL),
      aclEntry(DEFAULT, USER, ""bruce"", READ),
      aclEntry(DEFAULT, GROUP, READ),
      aclEntry(DEFAULT, OTHER, NONE));
    List<AclEntry> expected = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, USER, ""bruce"", READ))
      .add(aclEntry(ACCESS, USER, ""diana"", READ_WRITE))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, MASK, READ))
      .add(aclEntry(ACCESS, OTHER, READ))
      .add(aclEntry(DEFAULT, USER, ALL))
      .add(aclEntry(DEFAULT, USER, ""bruce"", READ))
      .add(aclEntry(DEFAULT, GROUP, READ))
      .add(aclEntry(DEFAULT, MASK, READ))
      .add(aclEntry(DEFAULT, OTHER, NONE))
      .build();
    assertEquals(expected, replaceAclEntries(existing, aclSpec));
  }",No Smells
"@Test
  public void testReplaceAclEntriesAutomaticDefaultUser() throws AclException {
    List<AclEntry> existing = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, OTHER, NONE))
      .build();
    List<AclEntry> aclSpec = Lists.newArrayList(
      aclEntry(ACCESS, USER, ALL),
      aclEntry(ACCESS, GROUP, READ),
      aclEntry(ACCESS, OTHER, NONE),
      aclEntry(DEFAULT, USER, ""bruce"", READ),
      aclEntry(DEFAULT, GROUP, READ_WRITE),
      aclEntry(DEFAULT, MASK, READ_WRITE),
      aclEntry(DEFAULT, OTHER, READ));
    List<AclEntry> expected = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, OTHER, NONE))
      .add(aclEntry(DEFAULT, USER, ALL))
      .add(aclEntry(DEFAULT, USER, ""bruce"", READ))
      .add(aclEntry(DEFAULT, GROUP, READ_WRITE))
      .add(aclEntry(DEFAULT, MASK, READ_WRITE))
      .add(aclEntry(DEFAULT, OTHER, READ))
      .build();
    assertEquals(expected, replaceAclEntries(existing, aclSpec));
  }",No Smells
"@Test
  public void testReplaceAclEntriesDefaultMaskCalculated() throws AclException {
    List<AclEntry> existing = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, OTHER, READ))
      .build();
    List<AclEntry> aclSpec = Lists.newArrayList(
      aclEntry(ACCESS, USER, ALL),
      aclEntry(ACCESS, GROUP, READ),
      aclEntry(ACCESS, OTHER, READ),
      aclEntry(DEFAULT, USER, ALL),
      aclEntry(DEFAULT, USER, ""bruce"", READ),
      aclEntry(DEFAULT, USER, ""diana"", READ_WRITE),
      aclEntry(DEFAULT, GROUP, ALL),
      aclEntry(DEFAULT, OTHER, READ));
    List<AclEntry> expected = new ImmutableList.Builder<AclEntry>()
      .add(aclEntry(ACCESS, USER, ALL))
      .add(aclEntry(ACCESS, GROUP, READ))
      .add(aclEntry(ACCESS, OTHER, READ))
      .add(aclEntry(DEFAULT, USER, ALL))
      .add(aclEntry(DEFAULT, USER, ""bruce"", READ))
      .add(aclEntry(DEFAULT, USER, ""diana"", READ_WRITE))
      .add(aclEntry(DEFAULT, GROUP, ALL))
      .add(aclEntry(DEFAULT, MASK, ALL))
      .add(aclEntry(DEFAULT, OTHER, READ))
      .build();
    assertEquals(expected, replaceAclEntries(existing, aclSpec));
  }",No Smells
"@Test
  public void testBackupNodeTailsEdits() throws Exception {
    Configuration conf = new HdfsConfiguration();
    HAUtil.setAllowStandbyReads(conf, true);
    MiniDFSCluster cluster = null;
    FileSystem fileSys = null;
    BackupNode backup = null;

    try {
      cluster = new MiniDFSCluster.Builder(conf)
                                  .numDataNodes(0).build();
      fileSys = cluster.getFileSystem();
      backup = startBackupNode(conf, StartupOption.BACKUP, 1);
      
      BackupImage bnImage = (BackupImage) backup.getFSImage();
      testBNInSync(cluster, backup, 1);
      
      // Force a roll -- BN should roll with NN.
      NameNode nn = cluster.getNameNode();
      NamenodeProtocols nnRpc = nn.getRpcServer();
      nnRpc.rollEditLog();
      assertEquals(bnImage.getEditLog().getCurSegmentTxId(),
          nn.getFSImage().getEditLog().getCurSegmentTxId());
      
      // BN should stay in sync after roll
      testBNInSync(cluster, backup, 2);
      
      long nnImageBefore =
        nn.getFSImage().getStorage().getMostRecentCheckpointTxId();
      // BN checkpoint
      backup.doCheckpoint();
      
      // NN should have received a new image
      long nnImageAfter =
        nn.getFSImage().getStorage().getMostRecentCheckpointTxId();
      
      assertTrue(""nn should have received new checkpoint. before: "" +
          nnImageBefore + "" after: "" + nnImageAfter,
          nnImageAfter > nnImageBefore);

      // BN should stay in sync after checkpoint
      testBNInSync(cluster, backup, 3);

      // Stop BN
      StorageDirectory sd = bnImage.getStorage().getStorageDir(0);
      backup.stop();
      backup = null;
      
      // When shutting down the BN, it shouldn't finalize logs that are
      // still open on the NN
      EditLogFile editsLog = FSImageTestUtil.findLatestEditsLog(sd);
      assertEquals(editsLog.getFirstTxId(),
          nn.getFSImage().getEditLog().getCurSegmentTxId());
      assertTrue(""Should not have finalized "" + editsLog,
          editsLog.isInProgress());
      
      // do some edits
      assertTrue(fileSys.mkdirs(new Path(""/edit-while-bn-down"")));
  
      // start a new backup node
      backup = startBackupNode(conf, StartupOption.BACKUP, 1);

      testBNInSync(cluster, backup, 4);
      assertNotNull(backup.getNamesystem()
          .getFileInfo(""/edit-while-bn-down"", false, false, false));
      
      // Trigger an unclean shutdown of the backup node. Backup node will not
      // unregister from the active when this is done simulating a node crash.
      backup.stop(false);
           
      // do some edits on the active. This should go through without failing.
      // This will verify that active is still up and can add entries to
      // master editlog.
      assertTrue(fileSys.mkdirs(new Path(""/edit-while-bn-down-2"")));
      
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testBackupNodeTailsEdits() throws Exception {
    Configuration conf = new HdfsConfiguration();
    HAUtil.setAllowStandbyReads(conf, true);
    MiniDFSCluster cluster = null;
    FileSystem fileSys = null;
    BackupNode backup = null;

    try {
      cluster = new MiniDFSCluster.Builder(conf)
                                  .numDataNodes(0).build();
      fileSys = cluster.getFileSystem();
      backup = startBackupNode(conf, StartupOption.BACKUP, 1);
      
      BackupImage bnImage = (BackupImage) backup.getFSImage();
      testBNInSync(cluster, backup, 1);
      
      // Force a roll -- BN should roll with NN.
      NameNode nn = cluster.getNameNode();
      NamenodeProtocols nnRpc = nn.getRpcServer();
      nnRpc.rollEditLog();
      assertEquals(bnImage.getEditLog().getCurSegmentTxId(),
          nn.getFSImage().getEditLog().getCurSegmentTxId());
      
      // BN should stay in sync after roll
      testBNInSync(cluster, backup, 2);
      
      long nnImageBefore =
        nn.getFSImage().getStorage().getMostRecentCheckpointTxId();
      // BN checkpoint
      backup.doCheckpoint();
      
      // NN should have received a new image
      long nnImageAfter =
        nn.getFSImage().getStorage().getMostRecentCheckpointTxId();
      
      assertTrue(""nn should have received new checkpoint. before: "" +
          nnImageBefore + "" after: "" + nnImageAfter,
          nnImageAfter > nnImageBefore);

      // BN should stay in sync after checkpoint
      testBNInSync(cluster, backup, 3);

      // Stop BN
      StorageDirectory sd = bnImage.getStorage().getStorageDir(0);
      backup.stop();
      backup = null;
      
      // When shutting down the BN, it shouldn't finalize logs that are
      // still open on the NN
      EditLogFile editsLog = FSImageTestUtil.findLatestEditsLog(sd);
      assertEquals(editsLog.getFirstTxId(),
          nn.getFSImage().getEditLog().getCurSegmentTxId());
      assertTrue(""Should not have finalized "" + editsLog,
          editsLog.isInProgress());
      
      // do some edits
      assertTrue(fileSys.mkdirs(new Path(""/edit-while-bn-down"")));
  
      // start a new backup node
      backup = startBackupNode(conf, StartupOption.BACKUP, 1);

      testBNInSync(cluster, backup, 4);
      assertNotNull(backup.getNamesystem()
          .getFileInfo(""/edit-while-bn-down"", false, false, false));
      
      // Trigger an unclean shutdown of the backup node. Backup node will not
      // unregister from the active when this is done simulating a node crash.
      backup.stop(false);
           
      // do some edits on the active. This should go through without failing.
      // This will verify that active is still up and can add entries to
      // master editlog.
      assertTrue(fileSys.mkdirs(new Path(""/edit-while-bn-down-2"")));
      
    }",Eager Test
"@Test
  public void testChooseTarget() throws Exception {
    doTestChooseTargetNormalCase();
    doTestChooseTargetSpecialCase();
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testRawWrites() throws IOException {
    EditLogFileOutputStream elos = new EditLogFileOutputStream(conf,
        TEST_EDITS, 0);
    try {
      byte[] small = new byte[] { 1, 2, 3, 4, 5, 8, 7 }",Eager Test
"@Test
  public void testAskForTransactionsMidfile() throws IOException {
    File f = new File(TestEditLog.TEST_DIR + ""/askfortransactionsmidfile"");
    NNStorage storage = setupEdits(Collections.<URI>singletonList(f.toURI()), 
                                   10);
    StorageDirectory sd = storage.dirIterator(NameNodeDirType.EDITS).next();
    
    FileJournalManager jm = new FileJournalManager(conf, sd, storage);
    
    // 10 rolls, so 11 rolled files, 110 txids total.
    final int TOTAL_TXIDS = 10 * 11;
    for (int txid = 1; txid <= TOTAL_TXIDS; txid++) {
      assertEquals((TOTAL_TXIDS - txid) + 1, getNumberOfTransactions(jm, txid,
          true, false));
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testInprogressRecoveryMixed() throws IOException {
    File f1 = new File(TestEditLog.TEST_DIR + ""/mixtest0"");
    File f2 = new File(TestEditLog.TEST_DIR + ""/mixtest1"");
    File f3 = new File(TestEditLog.TEST_DIR + ""/mixtest2"");
    
    List<URI> editUris = ImmutableList.of(f1.toURI(), f2.toURI(), f3.toURI());

    // abort after the 5th roll 
    NNStorage storage = setupEdits(editUris,
                                   5, new AbortSpec(5, 1));
    Iterator<StorageDirectory> dirs = storage.dirIterator(NameNodeDirType.EDITS);
    StorageDirectory sd = dirs.next();
    FileJournalManager jm = new FileJournalManager(conf, sd, storage);
    assertEquals(6*TXNS_PER_ROLL, getNumberOfTransactions(jm, 1, true, false));
    
    sd = dirs.next();
    jm = new FileJournalManager(conf, sd, storage);
    assertEquals(5*TXNS_PER_ROLL + TXNS_PER_FAIL, getNumberOfTransactions(jm, 1,
        true, false));

    sd = dirs.next();
    jm = new FileJournalManager(conf, sd, storage);
    assertEquals(6*TXNS_PER_ROLL, getNumberOfTransactions(jm, 1, true, false));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testINodeXAttrsLimit() throws Exception {
    List<XAttr> existingXAttrs = Lists.newArrayListWithCapacity(2);
    XAttr xAttr1 = (new XAttr.Builder()).setNameSpace(XAttr.NameSpace.USER).
        setName(""a1"").setValue(new byte[]{0x31, 0x32, 0x33}",No Smells
"@Test
  public void testDisplayRecentEditLogOpCodes() throws IOException {
    // start a cluster
    Configuration conf = getConf();
    MiniDFSCluster cluster = null;
    FileSystem fileSys = null;
    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES)
        .enableManagedDfsDirsRedundancy(false).build();
    cluster.waitActive();
    fileSys = cluster.getFileSystem();
    final FSNamesystem namesystem = cluster.getNamesystem();

    FSImage fsimage = namesystem.getFSImage();
    for (int i = 0; i < 20; i++) {
      fileSys.mkdirs(new Path(""/tmp/tmp"" + i));
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testFSEditLogOpCodes() throws IOException {
    //try all codes
    for(FSEditLogOpCodes c : FSEditLogOpCodes.values()) {
      final byte code = c.getOpCode();
      assertEquals(""c="" + c + "", code="" + code,
          c, FSEditLogOpCodes.fromByte(code));
    }",Eager Test
"@Test
  public void testValidateEditLogWithCorruptBody() throws IOException {
    File testDir = new File(TEST_DIR, ""testValidateEditLogWithCorruptBody"");
    SortedMap<Long, Long> offsetToTxId = Maps.newTreeMap();
    final int NUM_TXNS = 20;
    File logFile = prepareUnfinalizedTestEditLog(testDir, NUM_TXNS,
        offsetToTxId);
    // Back up the uncorrupted log
    File logFileBak = new File(testDir, logFile.getName() + "".bak"");
    Files.copy(logFile, logFileBak);
    EditLogValidation validation =
        EditLogFileInputStream.scanEditLog(logFile, Long.MAX_VALUE, true);
    assertTrue(!validation.hasCorruptHeader());
    // We expect that there will be an OP_START_LOG_SEGMENT, followed by
    // NUM_TXNS opcodes, followed by an OP_END_LOG_SEGMENT.
    assertEquals(NUM_TXNS + 1, validation.getEndTxId());
    // Corrupt each edit and verify that validation continues to work
    for (Map.Entry<Long, Long> entry : offsetToTxId.entrySet()) {
      long txOffset = entry.getKey();
      long txId = entry.getValue();

      // Restore backup, corrupt the txn opcode
      Files.copy(logFileBak, logFile);
      corruptByteInFile(logFile, txOffset);
      validation = EditLogFileInputStream.scanEditLog(logFile,
          Long.MAX_VALUE, true);
      long expectedEndTxId = (txId == (NUM_TXNS + 1)) ?
          NUM_TXNS : (NUM_TXNS + 1);
      assertEquals(""Failed when corrupting txn opcode at "" + txOffset,
          expectedEndTxId, validation.getEndTxId());
      assertTrue(!validation.hasCorruptHeader());
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testValidateEmptyEditLog() throws IOException {
    File testDir = new File(TEST_DIR, ""testValidateEmptyEditLog"");
    SortedMap<Long, Long> offsetToTxId = Maps.newTreeMap();
    File logFile = prepareUnfinalizedTestEditLog(testDir, 0, offsetToTxId);
    // Truncate the file so that there is nothing except the header and
    // layout flags section.
    truncateFile(logFile, 8);
    EditLogValidation validation =
        EditLogFileInputStream.scanEditLog(logFile, Long.MAX_VALUE, true);
    assertTrue(!validation.hasCorruptHeader());
    assertEquals(HdfsServerConstants.INVALID_TXID, validation.getEndTxId());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testBlockTypeProtoDefaultsToContiguous() throws Exception {
    INodeSection.INodeFile.Builder builder = INodeSection.INodeFile
        .newBuilder();
    INodeSection.INodeFile inodeFile = builder.build();
    BlockType defaultBlockType = PBHelperClient.convert(inodeFile
        .getBlockType());
    assertEquals(defaultBlockType, BlockType.CONTIGUOUS);
  }",No Smells
"@Test
  public void testDigest() throws IOException {
    Configuration conf = new Configuration();
    MiniDFSCluster cluster = null;
    try {
      cluster = new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
      DistributedFileSystem fs = cluster.getFileSystem();
      fs.setSafeMode(SafeModeAction.ENTER);
      fs.saveNamespace();
      fs.setSafeMode(SafeModeAction.LEAVE);
      File currentDir = FSImageTestUtil.getNameNodeCurrentDirs(cluster, 0).get(
          0);
      File fsimage = FSImageTestUtil.findNewestImageFile(currentDir
          .getAbsolutePath());
      assertEquals(MD5FileUtils.readStoredMd5ForFile(fsimage),
          MD5FileUtils.computeMd5ForFile(fsimage));
    }",Mystery Guest + Resource Optimism
"@Test
  public void testHasNonEcBlockUsingStripedIDForLoadSnapshot()
      throws IOException{
    // start a cluster
    Configuration conf = new HdfsConfiguration();
    MiniDFSCluster cluster = null;
    try {
      cluster = new MiniDFSCluster.Builder(conf).numDataNodes(9)
          .build();
      cluster.waitActive();
      DistributedFileSystem fs = cluster.getFileSystem();
      FSNamesystem fns = cluster.getNamesystem();

      String testDir = ""/test_block_manager"";
      String testFile = ""testfile_loadSnapshot"";
      String testFilePath = testDir + ""/"" + testFile;
      String clientName = ""testUser_loadSnapshot"";
      String clientMachine = ""testMachine_loadSnapshot"";
      long blkId = -1;
      long blkNumBytes = 1024;
      long timestamp = 1426222918;

      Path d = new Path(testDir);
      fs.mkdir(d, new FsPermission(""755""));
      fs.allowSnapshot(d);

      Path p = new Path(testFilePath);
      DFSTestUtil.createFile(fs, p, 0, (short) 1, 1);
      BlockInfoContiguous cBlk = new BlockInfoContiguous(
          new Block(blkId, blkNumBytes, timestamp), (short)3);
      INodeFile file = (INodeFile)fns.getFSDirectory().getINode(testFilePath);
      file.toUnderConstruction(clientName, clientMachine);
      file.addBlock(cBlk);
      TestINodeFile.toCompleteFile(file);

      fs.createSnapshot(d,""testHasNonEcBlockUsingStripeID"");
      fs.truncate(p,0);
      fns.enterSafeMode(false);
      fns.saveNamespace(0, 0);
      cluster.restartNameNodes();
      cluster.waitActive();
      fns = cluster.getNamesystem();
      assertTrue(fns.getBlockManager().hasNonEcBlockUsingStripedID());

      cluster.shutdown();
      cluster = null;
    }",Mystery Guest + Resource Optimism
"@Test
  public void testPersist() throws IOException {
    Configuration conf = new Configuration();
    testPersistHelper(conf);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testSaveAndLoadErasureCodingPolicies() throws IOException{
    Configuration conf = new Configuration();
    final int blockSize = 16 * 1024 * 1024;
    conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY, blockSize);
    try (MiniDFSCluster cluster =
             new MiniDFSCluster.Builder(conf).numDataNodes(10).build()) {
      cluster.waitActive();
      DistributedFileSystem fs = cluster.getFileSystem();
      DFSTestUtil.enableAllECPolicies(fs);

      // Save namespace and restart NameNode
      fs.setSafeMode(SafeModeAction.ENTER);
      fs.saveNamespace();
      fs.setSafeMode(SafeModeAction.LEAVE);

      cluster.restartNameNodes();
      cluster.waitActive();

      assertEquals(""Erasure coding policy number should match"",
          SystemErasureCodingPolicies.getPolicies().size(),
          ErasureCodingPolicyManager.getInstance().getPolicies().length);

      // Add new erasure coding policy
      ECSchema newSchema = new ECSchema(""rs"", 5, 4);
      ErasureCodingPolicy newPolicy =
          new ErasureCodingPolicy(newSchema, 2 * 1024, (byte) 254);
      ErasureCodingPolicy[] policies = new ErasureCodingPolicy[]{newPolicy}",Mystery Guest + Resource Optimism
"@Test
  public void testSaveAndLoadFileUnderReplicationPolicyDir()
      throws IOException {
    Configuration conf = new Configuration();
    MiniDFSCluster cluster = null;
    try {
      cluster = new MiniDFSCluster.Builder(conf).build();
      cluster.waitActive();
      FSNamesystem fsn = cluster.getNamesystem();
      DistributedFileSystem fs = cluster.getFileSystem();
      DFSTestUtil.enableAllECPolicies(fs);
      ErasureCodingPolicy replicaPolicy =
          SystemErasureCodingPolicies.getReplicationPolicy();
      ErasureCodingPolicy defaultEcPolicy =
          StripedFileTestUtil.getDefaultECPolicy();

      final Path ecDir = new Path(""/ec"");
      final Path replicaDir = new Path(ecDir, ""replica"");
      final Path replicaFile1 = new Path(replicaDir, ""f1"");
      final Path replicaFile2 = new Path(replicaDir, ""f2"");

      // create root directory
      fs.mkdir(ecDir, null);
      fs.setErasureCodingPolicy(ecDir, defaultEcPolicy.getName());

      // create directory, and set replication Policy
      fs.mkdir(replicaDir, null);
      fs.setErasureCodingPolicy(replicaDir, replicaPolicy.getName());

      // create an empty file f1
      fs.create(replicaFile1).close();

      // create an under-construction file f2
      FSDataOutputStream out = fs.create(replicaFile2, (short) 2);
      out.writeBytes(""hello"");
      ((DFSOutputStream) out.getWrappedStream()).hsync(EnumSet
          .of(SyncFlag.UPDATE_LENGTH));

      // checkpoint
      fs.setSafeMode(SafeModeAction.ENTER);
      fs.saveNamespace();
      fs.setSafeMode(SafeModeAction.LEAVE);

      cluster.restartNameNode();
      cluster.waitActive();
      fs = cluster.getFileSystem();

      assertTrue(fs.getFileStatus(ecDir).isDirectory());
      assertTrue(fs.getFileStatus(replicaDir).isDirectory());
      assertTrue(fs.exists(replicaFile1));
      assertTrue(fs.exists(replicaFile2));

      // check directories
      assertEquals(""Directory should have default EC policy."",
          defaultEcPolicy, fs.getErasureCodingPolicy(ecDir));
      assertEquals(""Directory should hide replication EC policy."",
          null, fs.getErasureCodingPolicy(replicaDir));

      // check file1
      assertEquals(""File should not have EC policy."", null,
          fs.getErasureCodingPolicy(replicaFile1));
      // check internals of file2
      INodeFile file2Node =
          fsn.dir.getINode4Write(replicaFile2.toString()).asFile();
      assertEquals(""hello"".length(), file2Node.computeFileSize());
      assertTrue(file2Node.isUnderConstruction());
      BlockInfo[] blks = file2Node.getBlocks();
      assertEquals(1, blks.length);
      assertEquals(BlockUCState.UNDER_CONSTRUCTION, blks[0].getBlockUCState());
      assertEquals(""File should return expected replication factor."",
          2, blks[0].getReplication());
      assertEquals(""File should not have EC policy."", null,
          fs.getErasureCodingPolicy(replicaFile2));
      // check lease manager
      Lease lease = fsn.leaseManager.getLease(file2Node);
      Assert.assertNotNull(lease);
    }",Mystery Guest + Resource Optimism
"@Test
  public void test() throws Exception {
    Configuration conf = new Configuration();
    MiniDFSCluster cluster = null;

    try {
      cluster = new MiniDFSCluster.Builder(conf).build();
      cluster.waitActive();

      FSNamesystem fsn = cluster.getNameNode().namesystem;

      MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
      ObjectName mxbeanName = new ObjectName(
          ""Hadoop:service=NameNode,name=FSNamesystemState"");

      String snapshotStats = (String) (mbs.getAttribute(mxbeanName,
          ""SnapshotStats""));

      @SuppressWarnings(""unchecked"")
      Map<String, Object> stat = (Map<String, Object>) JSON
          .parse(snapshotStats);

      assertTrue(stat.containsKey(""SnapshottableDirectories"")
          && (Long) stat.get(""SnapshottableDirectories"") == fsn
              .getNumSnapshottableDirs());
      assertTrue(stat.containsKey(""Snapshots"")
          && (Long) stat.get(""Snapshots"") == fsn.getNumSnapshots());

      Object pendingDeletionBlocks = mbs.getAttribute(mxbeanName,
        ""PendingDeletionBlocks"");
      assertNotNull(pendingDeletionBlocks);
      assertTrue(pendingDeletionBlocks instanceof Long);

      Object encryptionZones = mbs.getAttribute(mxbeanName,
          ""NumEncryptionZones"");
      assertNotNull(encryptionZones);
      assertTrue(encryptionZones instanceof Integer);
    }",No Smells
"@Test
  public void testWithFSEditLogLock() throws Exception {
    Configuration conf = new Configuration();
    int jmxCachePeriod = 1;
    new ConfigBuilder().add(""namenode.period"", jmxCachePeriod)
        .save(TestMetricsConfig.getTestFilename(""hadoop-metrics2-namenode""));
    MiniDFSCluster cluster = null;
    try {
      cluster = new MiniDFSCluster.Builder(conf).build();
      cluster.waitActive();
      synchronized (cluster.getNameNode().getFSImage().getEditLog()) {
        Thread.sleep(jmxCachePeriod * 1000);
        MBeanClient client = new MBeanClient();
        client.start();
        client.join(20000);
        assertTrue(""JMX calls are blocked when FSEditLog"" +
            "" is synchronized by another thread"", client.succeeded);
        client.interrupt();
      }",Eager Test
"@Test
  public void testAclGroupDeny() throws IOException {
    INodeFile inodeFile = createINodeFile(inodeRoot, ""file1"", ""bruce"", ""sales"",
      (short)0604);
    addAcl(inodeFile,
      aclEntry(ACCESS, USER, READ_WRITE),
      aclEntry(ACCESS, GROUP, NONE),
      aclEntry(ACCESS, MASK, NONE),
      aclEntry(ACCESS, OTHER, READ));
    assertPermissionGranted(BRUCE, ""/file1"", READ_WRITE);
    assertPermissionGranted(CLARK, ""/file1"", READ);
    assertPermissionDenied(DIANA, ""/file1"", READ);
    assertPermissionDenied(DIANA, ""/file1"", WRITE);
    assertPermissionDenied(DIANA, ""/file1"", EXECUTE);
    assertPermissionDenied(DIANA, ""/file1"", READ_WRITE);
    assertPermissionDenied(DIANA, ""/file1"", READ_EXECUTE);
    assertPermissionDenied(DIANA, ""/file1"", WRITE_EXECUTE);
    assertPermissionDenied(DIANA, ""/file1"", ALL);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testAclGroupMask() throws IOException {
    INodeFile inodeFile = createINodeFile(inodeRoot, ""file1"", ""bruce"", ""execs"",
      (short)0644);
    addAcl(inodeFile,
      aclEntry(ACCESS, USER, READ_WRITE),
      aclEntry(ACCESS, GROUP, READ_WRITE),
      aclEntry(ACCESS, MASK, READ),
      aclEntry(ACCESS, OTHER, READ));
    assertPermissionGranted(BRUCE, ""/file1"", READ_WRITE);
    assertPermissionGranted(CLARK, ""/file1"", READ);
    assertPermissionDenied(CLARK, ""/file1"", WRITE);
    assertPermissionDenied(CLARK, ""/file1"", EXECUTE);
    assertPermissionDenied(CLARK, ""/file1"", READ_WRITE);
    assertPermissionDenied(CLARK, ""/file1"", READ_EXECUTE);
    assertPermissionDenied(CLARK, ""/file1"", WRITE_EXECUTE);
    assertPermissionDenied(CLARK, ""/file1"", ALL);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testAclNamedGroup() throws IOException {
    INodeFile inodeFile = createINodeFile(inodeRoot, ""file1"", ""bruce"", ""execs"",
      (short)0640);
    addAcl(inodeFile,
      aclEntry(ACCESS, USER, READ_WRITE),
      aclEntry(ACCESS, GROUP, READ),
      aclEntry(ACCESS, GROUP, ""sales"", READ),
      aclEntry(ACCESS, MASK, READ),
      aclEntry(ACCESS, OTHER, NONE));
    assertPermissionGranted(BRUCE, ""/file1"", READ_WRITE);
    assertPermissionGranted(CLARK, ""/file1"", READ);
    assertPermissionGranted(DIANA, ""/file1"", READ);
    assertPermissionDenied(DIANA, ""/file1"", WRITE);
    assertPermissionDenied(DIANA, ""/file1"", EXECUTE);
    assertPermissionDenied(DIANA, ""/file1"", READ_WRITE);
    assertPermissionDenied(DIANA, ""/file1"", READ_EXECUTE);
    assertPermissionDenied(DIANA, ""/file1"", ALL);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testAclNamedGroupDeny() throws IOException {
    INodeFile inodeFile = createINodeFile(inodeRoot, ""file1"", ""bruce"", ""sales"",
      (short)0644);
    addAcl(inodeFile,
      aclEntry(ACCESS, USER, READ_WRITE),
      aclEntry(ACCESS, GROUP, READ),
      aclEntry(ACCESS, GROUP, ""execs"", NONE),
      aclEntry(ACCESS, MASK, READ),
      aclEntry(ACCESS, OTHER, READ));
    assertPermissionGranted(BRUCE, ""/file1"", READ_WRITE);
    assertPermissionGranted(DIANA, ""/file1"", READ);
    assertPermissionDenied(CLARK, ""/file1"", READ);
    assertPermissionDenied(CLARK, ""/file1"", WRITE);
    assertPermissionDenied(CLARK, ""/file1"", EXECUTE);
    assertPermissionDenied(CLARK, ""/file1"", READ_WRITE);
    assertPermissionDenied(CLARK, ""/file1"", READ_EXECUTE);
    assertPermissionDenied(CLARK, ""/file1"", WRITE_EXECUTE);
    assertPermissionDenied(CLARK, ""/file1"", ALL);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testAclNamedGroupTraverseDeny() throws IOException {
    INodeDirectory inodeDir = createINodeDirectory(inodeRoot, ""dir1"", ""bruce"",
      ""execs"", (short)0755);
    INodeFile inodeFile = createINodeFile(inodeDir, ""file1"", ""bruce"", ""execs"",
      (short)0644);
    addAcl(inodeDir,
      aclEntry(ACCESS, USER, ALL),
      aclEntry(ACCESS, GROUP, READ_EXECUTE),
      aclEntry(ACCESS, GROUP, ""sales"", NONE),
      aclEntry(ACCESS, MASK, READ_EXECUTE),
      aclEntry(ACCESS, OTHER, READ_EXECUTE));
    assertPermissionGranted(BRUCE, ""/dir1/file1"", READ_WRITE);
    assertPermissionGranted(CLARK, ""/dir1/file1"", READ);
    assertPermissionDenied(DIANA, ""/dir1/file1"", READ);
    assertPermissionDenied(DIANA, ""/dir1/file1"", WRITE);
    assertPermissionDenied(DIANA, ""/dir1/file1"", EXECUTE);
    assertPermissionDenied(DIANA, ""/dir1/file1"", READ_WRITE);
    assertPermissionDenied(DIANA, ""/dir1/file1"", READ_EXECUTE);
    assertPermissionDenied(DIANA, ""/dir1/file1"", WRITE_EXECUTE);
    assertPermissionDenied(DIANA, ""/dir1/file1"", ALL);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testAclOther() throws IOException {
    INodeFile inodeFile = createINodeFile(inodeRoot, ""file1"", ""bruce"", ""sales"",
      (short)0774);
    addAcl(inodeFile,
      aclEntry(ACCESS, USER, ALL),
      aclEntry(ACCESS, USER, ""diana"", ALL),
      aclEntry(ACCESS, GROUP, READ_WRITE),
      aclEntry(ACCESS, MASK, ALL),
      aclEntry(ACCESS, OTHER, READ));
    assertPermissionGranted(BRUCE, ""/file1"", ALL);
    assertPermissionGranted(DIANA, ""/file1"", ALL);
    assertPermissionGranted(CLARK, ""/file1"", READ);
    assertPermissionDenied(CLARK, ""/file1"", WRITE);
    assertPermissionDenied(CLARK, ""/file1"", EXECUTE);
    assertPermissionDenied(CLARK, ""/file1"", READ_WRITE);
    assertPermissionDenied(CLARK, ""/file1"", READ_EXECUTE);
    assertPermissionDenied(CLARK, ""/file1"", WRITE_EXECUTE);
    assertPermissionDenied(CLARK, ""/file1"", ALL);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testConcatRelativeTargetPath() throws IOException {
    Path dir = new Path(""/dir"");
    Path trg = new Path(""trg"");
    Path src = new Path(dir, ""src"");
    dfs.setWorkingDirectory(dir);
    DFSTestUtil.createFile(dfs, trg, blockSize, REPL_FACTOR, 1);
    DFSTestUtil.createFile(dfs, src, blockSize, REPL_FACTOR, 1);
    dfs.concat(trg, new Path[]{src}",Mystery Guest
"@Test
  public void testIllegalArg() throws IOException {
    long fileLen = blockSize*3;
    
    Path parentDir  = new Path (""/parentTrg"");
    assertTrue(dfs.mkdirs(parentDir));
    Path trg = new Path(parentDir, ""trg"");
    DFSTestUtil.createFile(dfs, trg, fileLen, REPL_FACTOR, 1);

    // must be in the same dir
    {
      // create first file
      Path dir1 = new Path (""/dir1"");
      assertTrue(dfs.mkdirs(dir1));
      Path src = new Path(dir1, ""src"");
      DFSTestUtil.createFile(dfs, src, fileLen, REPL_FACTOR, 1);
      
      try {
        dfs.concat(trg, new Path [] {src}",Mystery Guest
"@Test
  public void testAuthzDelegationToProvider() throws Exception {
    LOG.info(""Test not bypassing provider"");
    String[] users = {""u1""}",Mystery Guest
"@Test
  public void testCustomProvider() throws Exception {
    final UserGroupInformation[] users = new UserGroupInformation[]{
        UserGroupInformation.createUserForTesting(
            System.getProperty(""user.name""), new String[]{""supergroup""}",Eager Test
"@Test
  public void testDelegationToProvider() throws Exception {
    Assert.assertTrue(CALLED.contains(""start""));
    FileSystem fs = FileSystem.get(miniDFS.getConfiguration(0));
    final Path tmpPath = new Path(""/tmp"");
    final Path fooPath = new Path(""/tmp/foo"");

    fs.mkdirs(tmpPath);
    fs.setPermission(tmpPath, new FsPermission(HDFS_PERMISSION));
    UserGroupInformation ugi = UserGroupInformation.createUserForTesting(""u1"",
        new String[]{""g1""}",Mystery Guest
"@Test
  public void testDotdotInodePath() throws Exception {
    final Configuration conf = new Configuration();
    MiniDFSCluster cluster = null;
    DFSClient client = null;
    try {
      cluster = new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
      cluster.waitActive();
      final DistributedFileSystem hdfs = cluster.getFileSystem();
      final FSDirectory fsdir = cluster.getNamesystem().getFSDirectory();

      final Path dir = new Path(""/dir"");
      hdfs.mkdirs(dir);
      long dirId = fsdir.getINode(dir.toString()).getId();
      long parentId = fsdir.getINode(""/"").getId();
      String testPath = ""/.reserved/.inodes/"" + dirId + ""/.."";

      client = new DFSClient(DFSUtilClient.getNNAddress(conf), conf);
      HdfsFileStatus status = client.getFileInfo(testPath);
      assertTrue(parentId == status.getFileId());
      
      // Test root's parent is still root
      testPath = ""/.reserved/.inodes/"" + parentId + ""/.."";
      status = client.getFileInfo(testPath);
      assertTrue(parentId == status.getFileId());
      
    }",Mystery Guest
"@Test
  public void testGetFullPathName() {
    replication = 3;
    preferredBlockSize = 128*1024*1024;
    INodeFile inf = createINodeFile(replication, preferredBlockSize);
    inf.setLocalName(DFSUtil.string2Bytes(""f""));

    INodeDirectory root = new INodeDirectory(HdfsConstants.GRANDFATHER_INODE_ID,
        INodeDirectory.ROOT_NAME, perm, 0L);
    INodeDirectory dir = new INodeDirectory(HdfsConstants.GRANDFATHER_INODE_ID,
        DFSUtil.string2Bytes(""d""), perm, 0L);

    assertEquals(""f"", inf.getFullPathName());

    dir.addChild(inf);
    assertEquals(""d""+Path.SEPARATOR+""f"", inf.getFullPathName());

    root.addChild(dir);
    assertEquals(Path.SEPARATOR+""d""+Path.SEPARATOR+""f"", inf.getFullPathName());
    assertEquals(Path.SEPARATOR+""d"", dir.getFullPathName());

    assertEquals(Path.SEPARATOR, root.getFullPathName());
  }",No Smells
"@Test
  public void testGetPathFromInode() throws QuotaExceededException {
    String path = ""/a/b/c"";
    INode inode = createTreeOfInodes(path);
    byte[][] expected = INode.getPathComponents(path);
    byte[][] actual = FSDirectory.getPathComponents(inode);
    DFSTestUtil.checkComponentsEquals(expected, actual);
  }",No Smells
"@Test
  public void testInodePath() throws IOException {
    // For a non .inodes path the regular components are returned
    String path = ""/a/b/c"";
    INode inode = createTreeOfInodes(path);
    // For an any inode look up return inode corresponding to ""c"" from /a/b/c
    FSDirectory fsd = Mockito.mock(FSDirectory.class);
    Mockito.doReturn(inode).when(fsd).getInode(Mockito.anyLong());

    // Tests for FSDirectory#resolvePath()
    // Non inode regular path
    String resolvedPath = FSDirectory.resolvePath(path, fsd);
    assertEquals(path, resolvedPath);

    // Inode path with no trailing separator
    String testPath = ""/.reserved/.inodes/1"";
    resolvedPath = FSDirectory.resolvePath(testPath, fsd);
    assertEquals(path, resolvedPath);

    // Inode path with trailing separator
    testPath = ""/.reserved/.inodes/1/"";
    resolvedPath = FSDirectory.resolvePath(testPath, fsd);
    assertEquals(path, resolvedPath);

    // Inode relative path
    testPath = ""/.reserved/.inodes/1/d/e/f"";
    resolvedPath = FSDirectory.resolvePath(testPath, fsd);
    assertEquals(""/a/b/c/d/e/f"", resolvedPath);

    // A path with just .inodes  returns the path as is
    testPath = ""/.reserved/.inodes"";
    resolvedPath = FSDirectory.resolvePath(testPath, fsd);
    assertEquals(testPath, resolvedPath);

    // Root inode path
    testPath = ""/.reserved/.inodes/"" + INodeId.ROOT_INODE_ID;
    resolvedPath = FSDirectory.resolvePath(testPath, fsd);
    assertEquals(""/"", resolvedPath);

    // An invalid inode path should remain unresolved
    testPath = ""/.invalid/.inodes/1"";
    resolvedPath = FSDirectory.resolvePath(testPath, fsd);
    assertEquals(testPath, resolvedPath);

    // Test path with nonexistent(deleted or wrong id) inode
    Mockito.doReturn(null).when(fsd).getInode(Mockito.anyLong());
    testPath = ""/.reserved/.inodes/1234"";
    try {
      String realPath = FSDirectory.resolvePath(testPath, fsd);
      fail(""Path should not be resolved:"" + realPath);
    }",Mystery Guest + Resource Optimism
"@Test
  public void testLocationLimitInListingOps() throws Exception {
    final Configuration conf = new Configuration();
    conf.setInt(DFSConfigKeys.DFS_LIST_LIMIT, 9); // 3 blocks * 3 replicas
    MiniDFSCluster cluster = null;
    try {
      cluster = new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
      cluster.waitActive();
      final DistributedFileSystem hdfs = cluster.getFileSystem();
      ArrayList<String> source = new ArrayList<String>();

      // tmp1 holds files with 3 blocks, 3 replicas
      // tmp2 holds files with 3 blocks, 1 replica
      hdfs.mkdirs(new Path(""/tmp1""));
      hdfs.mkdirs(new Path(""/tmp2""));

      source.add(""f1"");
      source.add(""f2"");

      int numEntries = source.size();
      for (int j=0;j<numEntries;j++) {
          DFSTestUtil.createFile(hdfs, new Path(""/tmp1/""+source.get(j)), 4096,
          3*1024-100, 1024, (short) 3, 0);
      }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testReplication () {
    replication = 3;
    preferredBlockSize = 128*1024*1024;
    INodeFile inf = createINodeFile(replication, preferredBlockSize);
    assertEquals(""True has to be returned in this case"", replication,
                 inf.getFileReplication());
  }",Resource Optimism
"@Test
  public void testRemoveLeases() throws Exception {
    FSNamesystem fsn = mock(FSNamesystem.class);
    LeaseManager lm = new LeaseManager(fsn);
    ArrayList<Long> ids = Lists.newArrayList(INodeId.ROOT_INODE_ID + 1,
            INodeId.ROOT_INODE_ID + 2, INodeId.ROOT_INODE_ID + 3,
            INodeId.ROOT_INODE_ID + 4);
    for (long id : ids) {
      lm.addLease(""foo"", id);
    }",Eager Test
"@Test
  public void testLastContactTime() throws Exception {
    Configuration conf = new Configuration();
    conf.setInt(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY, 1);
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY, 1);
    MiniDFSCluster cluster = null;
    HostsFileWriter hostsFileWriter = new HostsFileWriter();
    hostsFileWriter.initialize(conf, ""temp/TestNameNodeMXBean"");

    try {
      cluster = new MiniDFSCluster.Builder(conf, baseDir.getRoot()).numDataNodes(3).build();
      cluster.waitActive();

      FSNamesystem fsn = cluster.getNameNode().namesystem;

      MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
      ObjectName mxbeanName = new ObjectName(
        ""Hadoop:service=NameNode,name=NameNodeInfo"");

      List<String> hosts = new ArrayList<>();
      for(DataNode dn : cluster.getDataNodes()) {
        hosts.add(dn.getDisplayName());
      }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testCheckAvailability()
      throws IOException {
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_DU_RESERVED_KEY, 0);
    NameNodeResourceChecker nb = new NameNodeResourceChecker(conf);
    assertTrue(
        ""isResourceAvailable must return true if "" +
            ""disk usage is lower than threshold"",
        nb.hasAvailableDiskSpace());
  }",No Smells
"@Test
  public void testCheckAvailabilityNeg() throws IOException {
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_DU_RESERVED_KEY, Long.MAX_VALUE);
    NameNodeResourceChecker nb = new NameNodeResourceChecker(conf);
    assertFalse(
        ""isResourceAvailable must return false if "" +
            ""disk usage is higher than threshold"",
        nb.hasAvailableDiskSpace());
  }",No Smells
"@Test
  public void testOldInProgress() throws IOException {
    TestCaseDescription tc = new TestCaseDescription();
    tc.addRoot(""/foo1"", NameNodeDirType.IMAGE_AND_EDITS);
    tc.addImage(""/foo1/current/"" + getImageFileName(100), true);
    tc.addImage(""/foo1/current/"" + getImageFileName(200), true);
    tc.addImage(""/foo1/current/"" + getImageFileName(300), false);
    tc.addImage(""/foo1/current/"" + getImageFileName(400), false);
    tc.addLog(""/foo1/current/"" + getInProgressEditsFileName(101), true);
    runTest(tc);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testNNThroughput() throws Exception {
    Configuration conf = new HdfsConfiguration();
    conf.setInt(DFSConfigKeys.DFS_BLOCK_SIZE_KEY, 16);
    File nameDir = new File(MiniDFSCluster.getBaseDirectory(), ""name"");
    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,
        nameDir.getAbsolutePath());
    DFSTestUtil.formatNameNode(conf);
    NNThroughputBenchmark.runBenchmark(conf, new String[] {""-op"", ""all""}",Mystery Guest + Resource Optimism
"@Test
  public void testDifferentSpecifiedPolicies() {
    BlockStoragePolicySuite bsps = BlockStoragePolicySuite.createDefaultSuite();
    StoragePolicySummary sts = new StoragePolicySummary(bsps.getAllPolicies());
    BlockStoragePolicy hot = bsps.getPolicy(""HOT"");
    BlockStoragePolicy warm = bsps.getPolicy(""WARM"");
    BlockStoragePolicy cold = bsps.getPolicy(""COLD"");
    //DISK:3
    sts.add(new StorageType[]{StorageType.DISK,StorageType.DISK,StorageType.DISK}",No Smells
"@Test
  public void testMultipleWarmsInDifferentOrder() {
    BlockStoragePolicySuite bsps = BlockStoragePolicySuite.createDefaultSuite();
    StoragePolicySummary sts = new StoragePolicySummary(bsps.getAllPolicies());
    BlockStoragePolicy warm = bsps.getPolicy(""WARM"");
    //DISK:1,ARCHIVE:1
    sts.add(new StorageType[]{StorageType.DISK,StorageType.ARCHIVE}",No Smells
"@Test
  public void testClientSideExceptionOnJustOneDir() throws IOException {
    Configuration conf = new HdfsConfiguration();
    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf)
      .numDataNodes(0).build();
    NNStorage mockStorage = Mockito.mock(NNStorage.class);
    List<File> localPaths = ImmutableList.of(
        new File(""/xxxxx-does-not-exist/blah""),
        new File(TEST_DIR, ""testfile"")    
        );
       
    try {
      URL fsName = DFSUtil.getInfoServer(
          cluster.getNameNode().getServiceRpcAddress(), conf,
          DFSUtil.getHttpClientScheme(conf)).toURL();

      String id = ""getimage=1&txid=0"";

      TransferFsImage.getFileClient(fsName, id, localPaths, mockStorage, false);      
      Mockito.verify(mockStorage).reportErrorOnFile(localPaths.get(0));
      assertTrue(""The valid local file should get saved properly"",
          localPaths.get(1).length() > 0);
    }",Mystery Guest + Resource Optimism
"@Test
  public void testFetchOrCreateRetries() throws Exception {
    try(ShortCircuitCache cache = Mockito
        .spy(new ShortCircuitCache(10, 10000000, 10, 10000000, 1, 10000, 0))) {
      final TestFileDescriptorPair pair = new TestFileDescriptorPair();
      ExtendedBlockId extendedBlockId = new ExtendedBlockId(123, ""test_bp1"");
      SimpleReplicaCreator sRC = new SimpleReplicaCreator(123, cache, pair);

      // Arrange that fetch will throw RetriableException for any call
      Mockito.doThrow(new RetriableException(""Retry"")).when(cache)
        .fetch(Mockito.eq(extendedBlockId), Mockito.any());

      // Act: calling fetchOrCreate two times
      //  first call: it will create and put entry to replicaInfoMap
      //  second call: it will call fetch to get info for entry, and should
      //               retry 3 times because RetriableException thrown
      cache.fetchOrCreate(extendedBlockId, sRC);
      cache.fetchOrCreate(extendedBlockId, sRC);

      // Assert that fetchOrCreate retried to fetch at least 3 times
      Mockito.verify(cache, Mockito.atLeast(3))
        .fetch(Mockito.eq(extendedBlockId), Mockito.any());
    }",No Smells
"@Test
  public void testChooseExcess() {
    final BlockStoragePolicy hot = POLICY_SUITE.getPolicy(HOT);
    final BlockStoragePolicy warm = POLICY_SUITE.getPolicy(WARM);
    final BlockStoragePolicy cold = POLICY_SUITE.getPolicy(COLD);

    final short replication = 3;
    for(int n = 0; n <= 6; n++) {
      for(int d = 0; d <= n; d++) {
        final int a = n - d;
        final List<StorageType> chosen = asList(d, a);
        {
          final int nDisk = Math.max(0, d - replication); 
          final int nArchive = a;
          final StorageType[] expected = newStorageTypes(nDisk, nArchive);
          checkChooseExcess(hot, replication, chosen, expected);
        }",Eager Test
"@Test
  public void testChooseStorageTypesWithArchiveUnavailable() {
    runWithArchiveUnavailable(CheckChooseStorageTypes.ArchivalUnavailableAndNewBlock);
    runWithArchiveUnavailable(CheckChooseStorageTypes.ArchivalUnavailableAndNonNewBlock);
  }",No Smells
"@Test
  public void testChooseStorageTypesWithDiskUnavailableAndNonNewBlock() {
    final BlockStoragePolicy hot = POLICY_SUITE.getPolicy(HOT);
    final BlockStoragePolicy warm = POLICY_SUITE.getPolicy(WARM);
    final BlockStoragePolicy cold = POLICY_SUITE.getPolicy(COLD);

    final short replication = 3;
    final EnumSet<StorageType> unavailables = disk;
    final boolean isNewBlock = false;
    {
      final List<StorageType> chosen = Lists.newArrayList();
      checkChooseStorageTypes(hot, replication, chosen, unavailables, isNewBlock,
          StorageType.ARCHIVE, StorageType.ARCHIVE, StorageType.ARCHIVE);
      checkChooseStorageTypes(warm, replication, chosen, unavailables, isNewBlock,
          StorageType.ARCHIVE, StorageType.ARCHIVE, StorageType.ARCHIVE);
      checkChooseStorageTypes(cold, replication, chosen, unavailables, isNewBlock,
          StorageType.ARCHIVE, StorageType.ARCHIVE, StorageType.ARCHIVE);
    }",No Smells
"@Test
  public void testChooseTargetWithTopology() throws Exception {
    BlockStoragePolicy policy1 = new BlockStoragePolicy((byte) 9, ""TEST1"",
        new StorageType[]{StorageType.SSD, StorageType.DISK,
            StorageType.ARCHIVE}",Mystery Guest + Resource Optimism
"@Test
  public void testDefaultPolicies() {
    final Map<Byte, String> expectedPolicyStrings = new HashMap<Byte, String>();
    expectedPolicyStrings.put(COLD,
        ""BlockStoragePolicy{COLD:"" + COLD + "", storageTypes=[ARCHIVE], "" +
            ""creationFallbacks=[], replicationFallbacks=[]}",Eager Test
"@Test
  public void testGetAllStoragePoliciesFromFs() throws IOException {
    final MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf)
        .numDataNodes(REPLICATION)
        .storageTypes(
            new StorageType[] {StorageType.DISK, StorageType.ARCHIVE}",Eager Test
"@Test
  public void testGetStoragePolicy() throws Exception {
    final MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf)
        .numDataNodes(REPLICATION).build();
    cluster.waitActive();
    final DistributedFileSystem fs = cluster.getFileSystem();
    try {
      final Path dir = new Path(""/testGetStoragePolicy"");
      final Path fooFile = new Path(dir, ""foo"");
      DFSTestUtil.createFile(fs, fooFile, FILE_LEN, REPLICATION, 0L);
      DFSClient client = new DFSClient(cluster.getNameNode(0)
          .getNameNodeAddress(), conf);
      client.setStoragePolicy(""/testGetStoragePolicy/foo"",
          HdfsConstants.COLD_STORAGE_POLICY_NAME);
      String policyName = client.getStoragePolicy(""/testGetStoragePolicy/foo"")
          .getName();
      Assert.assertEquals(""File storage policy should be COLD"",
          HdfsConstants.COLD_STORAGE_POLICY_NAME, policyName);
    }",No Smells
"@Test
  public void testStorageType() {
    final EnumMap<StorageType, Integer> map = new EnumMap<>(StorageType.class);

    //put storage type is reversed order
    map.put(StorageType.NVDIMM, 1);
    map.put(StorageType.ARCHIVE, 1);
    map.put(StorageType.DISK, 1);
    map.put(StorageType.SSD, 1);
    map.put(StorageType.RAM_DISK, 1);

    {
      final Iterator<StorageType> i = map.keySet().iterator();
      Assert.assertEquals(StorageType.RAM_DISK, i.next());
      Assert.assertEquals(StorageType.SSD, i.next());
      Assert.assertEquals(StorageType.DISK, i.next());
      Assert.assertEquals(StorageType.ARCHIVE, i.next());
      Assert.assertEquals(StorageType.NVDIMM, i.next());
    }",No Smells
"@Test
  public void testStorageTypeCheckAccess(){
    testStorageTypeCheckAccessResult(new StorageType[]{StorageType.DEFAULT}",No Smells
"@Test
  public void testDNSLookups() throws Exception {
    MonitorDNS sm = new MonitorDNS();
    System.setSecurityManager(sm);
    
    MiniDFSCluster cluster = null;
    try {
      HdfsConfiguration conf = new HdfsConfiguration();
      cluster = new MiniDFSCluster.Builder(conf).numDataNodes(8).build();
      cluster.waitActive();
      
      int initialLookups = sm.lookups;
      assertTrue(""dns security manager is active"", initialLookups != 0);
      
      DatanodeManager dm =
          cluster.getNamesystem().getBlockManager().getDatanodeManager();
      
      // make sure no lookups occur
      dm.refreshNodes(conf);
      assertEquals(initialLookups, sm.lookups);

      dm.refreshNodes(conf);
      assertEquals(initialLookups, sm.lookups);
      
      // ensure none of the reports trigger lookups
      dm.getDatanodeListForReport(DatanodeReportType.ALL);
      assertEquals(initialLookups, sm.lookups);
      
      dm.getDatanodeListForReport(DatanodeReportType.LIVE);
      assertEquals(initialLookups, sm.lookups);
      
      dm.getDatanodeListForReport(DatanodeReportType.DEAD);
      assertEquals(initialLookups, sm.lookups);
    }",No Smells
"@Test
  public void testForcedRegistration() throws Exception {
    final Configuration conf = new HdfsConfiguration();
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_HANDLER_COUNT_KEY, 4);
    conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY, Integer.MAX_VALUE);

    MiniDFSCluster cluster = null;
    try {
      cluster = new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
      cluster.waitActive();
      cluster.getHttpUri(0);
      FSNamesystem fsn = cluster.getNamesystem();
      String bpId = fsn.getBlockPoolId();

      DataNode dn = cluster.getDataNodes().get(0);
      DatanodeDescriptor dnd =
          NameNodeAdapter.getDatanode(fsn, dn.getDatanodeId());
      DataNodeTestUtils.setHeartbeatsDisabledForTests(dn, true);
      DatanodeStorageInfo storage = dnd.getStorageInfos()[0];

      // registration should not change after heartbeat.
      assertTrue(dnd.isRegistered());
      DatanodeRegistration lastReg = dn.getDNRegistrationForBP(bpId);
      waitForHeartbeat(dn, dnd);
      assertSame(lastReg, dn.getDNRegistrationForBP(bpId));

      // force a re-registration on next heartbeat.
      dnd.setForceRegistration(true);
      assertFalse(dnd.isRegistered());
      waitForHeartbeat(dn, dnd);
      assertTrue(dnd.isRegistered());
      DatanodeRegistration newReg = dn.getDNRegistrationForBP(bpId);
      assertNotSame(lastReg, newReg);
      lastReg = newReg;

      // registration should not change on subsequent heartbeats.
      waitForHeartbeat(dn, dnd);
      assertTrue(dnd.isRegistered());
      assertSame(lastReg, dn.getDNRegistrationForBP(bpId));
      assertTrue(""block report is not processed for DN "" + dnd,
          waitForBlockReport(dn, dnd));
      assertTrue(dnd.isRegistered());
      assertSame(lastReg, dn.getDNRegistrationForBP(bpId));

      // check that block report is not processed and registration didn't
      // change.
      dnd.setForceRegistration(true);
      assertFalse(""block report is processed for DN "" + dnd,
          waitForBlockReport(dn, dnd));
      assertFalse(dnd.isRegistered());
      assertSame(lastReg, dn.getDNRegistrationForBP(bpId));

      // heartbeat should trigger re-registration, and next block report
      // should not change registration.
      waitForHeartbeat(dn, dnd);
      assertTrue(dnd.isRegistered());
      newReg = dn.getDNRegistrationForBP(bpId);
      assertNotSame(lastReg, newReg);
      lastReg = newReg;
      assertTrue(""block report is not processed for DN "" + dnd,
          waitForBlockReport(dn, dnd));
      assertTrue(dnd.isRegistered());
      assertSame(lastReg, dn.getDNRegistrationForBP(bpId));

      // registration doesn't change.
      ExtendedBlock eb = new ExtendedBlock(bpId, 1234);
      dn.notifyNamenodeDeletedBlock(eb, storage.getStorageID());
      DataNodeTestUtils.triggerDeletionReport(dn);
      assertTrue(dnd.isRegistered());
      assertSame(lastReg, dn.getDNRegistrationForBP(bpId));

      // a failed IBR will effectively unregister the node.
      boolean failed = false;
      try {
        // pass null to cause a failure since there aren't any easy failure
        // modes since it shouldn't happen.
        fsn.processIncrementalBlockReport(lastReg, null);
      }",No Smells
"@Test
  public void testRegistrationWithDifferentSoftwareVersions() throws Exception {
    Configuration conf = new HdfsConfiguration();
    conf.set(DFSConfigKeys.DFS_DATANODE_MIN_SUPPORTED_NAMENODE_VERSION_KEY, ""3.0.0"");
    conf.set(DFSConfigKeys.DFS_NAMENODE_MIN_SUPPORTED_DATANODE_VERSION_KEY, ""3.0.0"");
    MiniDFSCluster cluster = null;
    try {
      cluster = new MiniDFSCluster.Builder(conf)
          .numDataNodes(0)
          .build();
      
      NamenodeProtocols rpcServer = cluster.getNameNodeRpc();
      
      long nnCTime = cluster.getNamesystem().getFSImage().getStorage().getCTime();
      StorageInfo mockStorageInfo = mock(StorageInfo.class);
      doReturn(nnCTime).when(mockStorageInfo).getCTime();
      
      DatanodeRegistration mockDnReg = mock(DatanodeRegistration.class);
      doReturn(DataNodeLayoutVersion.getCurrentLayoutVersion())
          .when(mockDnReg).getVersion();
      doReturn(""127.0.0.1"").when(mockDnReg).getIpAddr();
      doReturn(123).when(mockDnReg).getXferPort();
      doReturn(""fake-storage-id"").when(mockDnReg).getDatanodeUuid();
      doReturn(mockStorageInfo).when(mockDnReg).getStorageInfo();
      
      // Should succeed when software versions are the same.
      doReturn(""3.0.0"").when(mockDnReg).getSoftwareVersion();
      rpcServer.registerDatanode(mockDnReg);
      
      // Should succeed when software version of DN is above minimum required by NN.
      doReturn(""4.0.0"").when(mockDnReg).getSoftwareVersion();
      rpcServer.registerDatanode(mockDnReg);
      
      // Should fail when software version of DN is below minimum required by NN.
      doReturn(""2.0.0"").when(mockDnReg).getSoftwareVersion();
      try {
        rpcServer.registerDatanode(mockDnReg);
        fail(""Should not have been able to register DN with too-low version."");
      }",No Smells
"@Test  
  public void testDataTransferProtocol() throws IOException {
    Random random = new Random();
    int oneMil = 1024*1024;
    Path file = new Path(""dataprotocol.dat"");
    int numDataNodes = 1;
    
    Configuration conf = new HdfsConfiguration();
    conf.setInt(DFSConfigKeys.DFS_REPLICATION_KEY, numDataNodes); 
    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).numDataNodes(numDataNodes).build();
    try {
    cluster.waitActive();
    datanode = cluster.getFileSystem().getDataNodeStats(DatanodeReportType.LIVE)[0];
    dnAddr = NetUtils.createSocketAddr(datanode.getXferAddr());
    FileSystem fileSys = cluster.getFileSystem();
    
    int fileLen = Math.min(conf.getInt(DFSConfigKeys.DFS_BLOCK_SIZE_KEY, 4096), 4096);
    
      DFSTestUtil.createFile(fileSys, file, fileLen, fileLen,
          fileSys.getDefaultBlockSize(file),
          fileSys.getDefaultReplication(file), 0L);

    // get the first blockid for the file
    final ExtendedBlock firstBlock = DFSTestUtil.getFirstBlock(fileSys, file);
    final String poolId = firstBlock.getBlockPoolId();
    long newBlockId = firstBlock.getBlockId() + 1;

    recvBuf.reset();
    sendBuf.reset();
    
    // bad version
    recvOut.writeShort((short)(DataTransferProtocol.DATA_TRANSFER_VERSION-1));
    sendOut.writeShort((short)(DataTransferProtocol.DATA_TRANSFER_VERSION-1));
    sendRecvData(""Wrong Version"", true);

    // bad ops
    sendBuf.reset();
    sendOut.writeShort((short)DataTransferProtocol.DATA_TRANSFER_VERSION);
    sendOut.writeByte(Op.WRITE_BLOCK.code - 1);
    sendRecvData(""Wrong Op Code"", true);
    
    /* Test OP_WRITE_BLOCK */
    sendBuf.reset();
    
    DataChecksum badChecksum = Mockito.spy(DEFAULT_CHECKSUM);
    Mockito.doReturn(-1).when(badChecksum).getBytesPerChecksum();

    writeBlock(poolId, newBlockId, badChecksum);
    recvBuf.reset();
    sendResponse(Status.ERROR, null, null, recvOut);
    sendRecvData(""wrong bytesPerChecksum while writing"", true);

    sendBuf.reset();
    recvBuf.reset();
    writeBlock(poolId, ++newBlockId, DEFAULT_CHECKSUM);

    PacketHeader hdr = new PacketHeader(
      4,     // size of packet
      0,     // offset in block,
      100,   // seqno
      false, // last packet
      -1 - random.nextInt(oneMil), // bad datalen
      false);
    hdr.write(sendOut);

    sendResponse(Status.SUCCESS, """", null, recvOut);
    new PipelineAck(100, new int[] {PipelineAck.combineHeader
      (PipelineAck.ECN.DISABLED, Status.ERROR)}",Eager Test + Mystery Guest
"@Test
  public void TestPipeLineAckCompatibility() throws IOException {
    DataTransferProtos.PipelineAckProto proto = DataTransferProtos
        .PipelineAckProto.newBuilder()
        .setSeqno(0)
        .addReply(Status.CHECKSUM_OK)
        .build();

    DataTransferProtos.PipelineAckProto newProto = DataTransferProtos
        .PipelineAckProto.newBuilder().mergeFrom(proto)
        .addFlag(PipelineAck.combineHeader(PipelineAck.ECN.SUPPORTED,
                                           Status.CHECKSUM_OK))
        .build();

    ByteArrayOutputStream oldAckBytes = new ByteArrayOutputStream();
    proto.writeDelimitedTo(oldAckBytes);
    PipelineAck oldAck = new PipelineAck();
    oldAck.readFields(new ByteArrayInputStream(oldAckBytes.toByteArray()));
    assertEquals(PipelineAck.combineHeader(PipelineAck.ECN.DISABLED, Status
        .CHECKSUM_OK), oldAck.getHeaderFlag(0));

    PipelineAck newAck = new PipelineAck();
    ByteArrayOutputStream newAckBytes = new ByteArrayOutputStream();
    newProto.writeDelimitedTo(newAckBytes);
    newAck.readFields(new ByteArrayInputStream(newAckBytes.toByteArray()));
    assertEquals(PipelineAck.combineHeader(PipelineAck.ECN.SUPPORTED, Status
        .CHECKSUM_OK), newAck.getHeaderFlag(0));
  }",No Smells
"@Test
  public void testGetLongStatistics() {
    short iterations = 0; // number of the iter.hasNext()
    final Iterator<LongStatistic> iter = statistics.getLongStatistics();

    while (iter.hasNext()) {
      final LongStatistic longStat = iter.next();
      assertNotNull(longStat);
      final OpType opType = OpType.fromSymbol(longStat.getName());
      assertNotNull(opType);
      assertTrue(expectedOpsCountMap.containsKey(opType));
      assertEquals(expectedOpsCountMap.get(opType).longValue(),
          longStat.getValue());
      iterations++;
    }",Eager Test
"@Test
  public void testIsTracked() {
    assertFalse(statistics.isTracked(null));
    assertFalse(statistics.isTracked(NO_SUCH_OP));

    final Iterator<LongStatistic> iter = statistics.getLongStatistics();
    while (iter.hasNext()) {
      final LongStatistic longStatistic = iter.next();
      assertTrue(statistics.isTracked(longStatistic.getName()));
    }",Eager Test
"@Test
  public void testReset() {
    statistics.reset();
    for (OpType opType : OpType.values()) {
      expectedOpsCountMap.get(opType).set(0);
    }",Eager Test
"@Test
  public void testIdempotentClose() throws Exception {
    final int numBlocks = 2;
    DFSTestUtil.createStripedFile(cluster, filePath, null, numBlocks,
        stripesPerBlock, false, ecPolicy);

    try (DFSInputStream in = fs.getClient().open(filePath.toString())) {
      assertTrue(in instanceof DFSStripedInputStream);
      // Close twice
      in.close();
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testRefreshBlock() throws Exception {
    final int numBlocks = 4;
    DFSTestUtil.createStripedFile(cluster, filePath, null, numBlocks,
        stripesPerBlock, false, ecPolicy);
    LocatedBlocks lbs = fs.getClient().namenode.getBlockLocations(
        filePath.toString(), 0, blockGroupSize * numBlocks);
    final DFSStripedInputStream in = new DFSStripedInputStream(fs.getClient(),
        filePath.toString(), false, ecPolicy, null);

    List<LocatedBlock> lbList = lbs.getLocatedBlocks();
    for (LocatedBlock aLbList : lbList) {
      LocatedStripedBlock lsb = (LocatedStripedBlock) aLbList;
      LocatedBlock[] blks = StripedBlockUtil.parseStripedBlockGroup(lsb,
          cellSize, dataBlocks, parityBlocks);
      for (int j = 0; j < dataBlocks; j++) {
        LocatedBlock refreshed = in.refreshLocatedBlock(blks[j]);
        assertEquals(blks[j].getBlock(), refreshed.getBlock());
        assertEquals(blks[j].getStartOffset(), refreshed.getStartOffset());
        assertArrayEquals(blks[j].getLocations(), refreshed.getLocations());
      }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testFileMoreThanABlockGroup3() throws Exception {
    testOneFile(""/MoreThanABlockGroup3"",
        blockSize * dataBlocks * 3 + cellSize * dataBlocks
        + cellSize + 123);
  }",Mystery Guest + Resource Optimism + Redundent Print
"@Test
  public void testFileMoreThanOneStripe1() throws Exception {
    testOneFile(""/MoreThanOneStripe1"", cellSize * dataBlocks + 123);
  }",Mystery Guest + Resource Optimism + Redundent Print
"@Test
  public void testFileSmallerThanOneCell1() throws Exception {
    testOneFile(""/SmallerThanOneCell"", 1);
  }",Mystery Guest + Resource Optimism + Redundent Print
"@Test
  public void testFileSmallerThanOneCell2() throws Exception {
    testOneFile(""/SmallerThanOneCell"", cellSize - 1);
  }",Mystery Guest + Resource Optimism + Redundent Print
"@Test
  public void testFileSmallerThanOneStripe2() throws Exception {
    testOneFile(""/SmallerThanOneStripe"", cellSize + 123);
  }",Mystery Guest + Resource Optimism + Redundent Print
"@Test
  public void testStreamFlush() throws Exception {
    final byte[] bytes = StripedFileTestUtil.generateBytes(blockSize *
        dataBlocks * 3 + cellSize * dataBlocks + cellSize + 123);
    try (FSDataOutputStream os = fs.create(new Path(""/ec-file-1""))) {
      assertFalse(
          ""DFSStripedOutputStream should not have hflush() capability yet!"",
          os.hasCapability(StreamCapability.HFLUSH.getValue()));
      assertFalse(
          ""DFSStripedOutputStream should not have hsync() capability yet!"",
          os.hasCapability(StreamCapability.HSYNC.getValue()));
      try (InputStream is = new ByteArrayInputStream(bytes)) {
        IOUtils.copyBytes(is, os, bytes.length);
        os.hflush();
        IOUtils.copyBytes(is, os, bytes.length);
        os.hsync();
        IOUtils.copyBytes(is, os, bytes.length);
      }",Mystery Guest + Resource Optimism + Redundent Print
"@Test
  public void testEncryptionProbe() throws Throwable {
    Configuration conf = new Configuration(false);
    conf.unset(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH);
    assertFalse(""encryption enabled on no provider key"",
        DFSUtilClient.isHDFSEncryptionEnabled(conf));
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,
        """");
    assertFalse(""encryption enabled on empty provider key"",
        DFSUtilClient.isHDFSEncryptionEnabled(conf));
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,
        ""\n\t\n"");
    assertFalse(""encryption enabled on whitespace provider key"",
        DFSUtilClient.isHDFSEncryptionEnabled(conf));
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,
        ""http://hadoop.apache.org"");
    assertTrue(""encryption disabled on valid provider key"",
        DFSUtilClient.isHDFSEncryptionEnabled(conf));

  }",No Smells
"@Test
  public void testGetNNServiceRpcAddressesForNsIds() throws IOException {
    Configuration conf = new HdfsConfiguration();
    conf.set(DFS_NAMESERVICES, ""nn1,nn2"");
    conf.set(DFS_INTERNAL_NAMESERVICES_KEY, ""nn1"");
    // Test - configured list of namenodes are returned
    final String NN1_ADDRESS = ""localhost:9000"";
    final String NN2_ADDRESS = ""localhost:9001"";
    conf.set(DFSUtil.addKeySuffixes(DFS_NAMENODE_RPC_ADDRESS_KEY, ""nn1""),
            NN1_ADDRESS);
    conf.set(DFSUtil.addKeySuffixes(DFS_NAMENODE_RPC_ADDRESS_KEY, ""nn2""),
            NN2_ADDRESS);

    {
      Collection<String> internal = DFSUtil.getInternalNameServices(conf);
      assertEquals(new HashSet<>(Arrays.asList(""nn1"")), internal);

      Collection<String> all = DFSUtilClient.getNameServiceIds(conf);
      assertEquals(new HashSet<>(Arrays.asList(""nn1"", ""nn2"")), all);
    }",No Smells
"@Test
  public void testGetNNUris() throws Exception {
    HdfsConfiguration conf = new HdfsConfiguration();

    final String NS2_NN_ADDR    = ""ns2-nn.example.com:8020"";
    final String NN1_ADDR       = ""nn.example.com:8020"";
    final String NN1_SRVC_ADDR  = ""nn.example.com:9821"";
    final String NN2_ADDR       = ""nn2.example.com:8020"";

    conf.set(DFS_NAMESERVICES, ""ns1"");
    conf.set(DFSUtil.addKeySuffixes(
        DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY, ""ns1""), NS1_NN1_ADDR);
    conf.set(DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY, ""hdfs://"" + NN2_ADDR);
    conf.set(CommonConfigurationKeys.FS_DEFAULT_NAME_KEY, ""hdfs://"" + NN1_ADDR);

    Collection<URI> uris = DFSUtil.getInternalNsRpcUris(conf);
    assertEquals(""Incorrect number of URIs returned"", 2, uris.size());
    assertTrue(""Missing URI for name service ns1"",
        uris.contains(new URI(""hdfs://"" + NS1_NN1_ADDR)));
    assertTrue(""Missing URI for service address"",
        uris.contains(new URI(""hdfs://"" + NN2_ADDR)));

    conf = new HdfsConfiguration();
    conf.set(DFS_NAMESERVICES, ""ns1,ns2"");
    conf.set(DFSUtil.addKeySuffixes(DFS_HA_NAMENODES_KEY_PREFIX, ""ns1""),
        ""nn1,nn2"");
    conf.set(DFSUtil.addKeySuffixes(
        DFS_NAMENODE_RPC_ADDRESS_KEY, ""ns1"", ""nn1""), NS1_NN1_ADDR);
    conf.set(DFSUtil.addKeySuffixes(
        DFS_NAMENODE_RPC_ADDRESS_KEY, ""ns1"", ""nn2""), NS1_NN2_ADDR);
    conf.set(DFSUtil.addKeySuffixes(
        DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY, ""ns1""), NS1_NN_ADDR);
    conf.set(DFSUtil.addKeySuffixes(
        DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY, ""ns2""), NS2_NN_ADDR);
    conf.set(DFS_NAMENODE_RPC_ADDRESS_KEY, ""hdfs://"" + NN1_ADDR);
    conf.set(CommonConfigurationKeys.FS_DEFAULT_NAME_KEY, ""hdfs://"" + NN2_ADDR);

    /**
     * {@link DFSUtil#getInternalNsRpcUris}",No Smells
"@Test
  public void testLocatedBlocks2Locations() {
    DatanodeInfo d = DFSTestUtil.getLocalDatanodeInfo();
    DatanodeInfo[] ds = new DatanodeInfo[1];
    ds[0] = d;

    // ok
    ExtendedBlock b1 = new ExtendedBlock(""bpid"", 1, 1, 1);
    LocatedBlock l1 = new LocatedBlock(b1, ds);
    l1.setStartOffset(0);
    l1.setCorrupt(false);

    // corrupt
    ExtendedBlock b2 = new ExtendedBlock(""bpid"", 2, 1, 1);
    LocatedBlock l2 = new LocatedBlock(b2, ds);
    l2.setStartOffset(0);
    l2.setCorrupt(true);

    List<LocatedBlock> ls = Arrays.asList(l1, l2);
    LocatedBlocks lbs = new LocatedBlocks(10, false, ls, l2, true, null, null);

    BlockLocation[] bs = DFSUtilClient.locatedBlocks2Locations(lbs);

    assertTrue(""expected 2 blocks but got "" + bs.length,
               bs.length == 2);

    int corruptCount = 0;
    for (BlockLocation b: bs) {
      if (b.isCorrupt()) {
        corruptCount++;
      }",Eager Test
"@Test
  public void testSubstituteForWildcardAddress() throws IOException {
    assertEquals(""foo:12345"",
        DFSUtil.substituteForWildcardAddress(""0.0.0.0:12345"", ""foo""));
    assertEquals(""127.0.0.1:12345"",
        DFSUtil.substituteForWildcardAddress(""127.0.0.1:12345"", ""foo""));
  }",No Smells
"@Test
  public void testDFSClient() throws Exception {
    Configuration conf = getTestConfiguration();
    final long grace = 1000L;
    MiniDFSCluster cluster = null;
    LeaseRenewer.setLeaseRenewerGraceDefault(grace);

    try {
      cluster = new MiniDFSCluster.Builder(conf).numDataNodes(2).build();
      final String filepathstring = ""/test/LeaseChecker/foo"";
      final Path[] filepaths = new Path[4];
      for(int i = 0; i < filepaths.length; i++) {
        filepaths[i] = new Path(filepathstring + i);
      }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testDFSCloseOrdering() throws Exception {
    DistributedFileSystem fs = new MyDistributedFileSystem();
    Path path = new Path(""/a"");
    fs.deleteOnExit(path);
    fs.close();

    InOrder inOrder = inOrder(fs.dfs);
    inOrder.verify(fs.dfs).closeOutputStreams(eq(false));
    inOrder.verify(fs.dfs).delete(eq(path.toString()), eq(true));
    inOrder.verify(fs.dfs).close();
  }",No Smells
"@Test
  public void testEnableAndDisableErasureCodingPolicy() throws Exception {
    Configuration conf = getTestConfiguration();
    MiniDFSCluster cluster = null;

    try {
      cluster = new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
      DistributedFileSystem fs = cluster.getFileSystem();
      ECSchema toAddSchema = new ECSchema(""rs"", 3, 2);
      ErasureCodingPolicy toAddPolicy =
          new ErasureCodingPolicy(toAddSchema, 128 * 1024, (byte) 254);
      String policyName = toAddPolicy.getName();
      ErasureCodingPolicy[] policies =
          new ErasureCodingPolicy[]{toAddPolicy}",Eager Test
"@Test
  public void testFileSystemCloseAll() throws Exception {
    Configuration conf = getTestConfiguration();
    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).numDataNodes(0).
        build();
    URI address = FileSystem.getDefaultUri(conf);

    try {
      FileSystem.closeAll();

      conf = getTestConfiguration();
      FileSystem.setDefaultUri(conf, address);
      FileSystem.get(conf);
      FileSystem.get(conf);
      FileSystem.closeAll();
    }",No Smells
"@Test
  public void testHdfsDataOutputStreamBuilderSetParameters()
      throws IOException {
    Configuration conf = getTestConfiguration();
    try (MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf)
        .numDataNodes(1).build()) {
      cluster.waitActive();
      DistributedFileSystem fs = cluster.getFileSystem();

      testBuilderSetters(fs);
    }",No Smells
"@Test
  public void testInvalidScriptMappingFileReadStatistics() throws Exception {
    // Even though network location of the client machine is unknown,
    // MiniDFSCluster's datanode is on the local host and thus the network
    // distance is 0.
    testReadFileSystemStatistics(0, true, true);
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testListStatusOfSnapshotDirs() throws IOException {
    MiniDFSCluster cluster = new MiniDFSCluster.Builder(getTestConfiguration())
        .build();
    try {
      DistributedFileSystem dfs = cluster.getFileSystem();
      dfs.create(new Path(""/parent/test1/dfsclose/file-0""));
      Path snapShotDir = new Path(""/parent/test1/"");
      dfs.allowSnapshot(snapShotDir);

      FileStatus status = dfs.getFileStatus(new Path(""/parent/test1""));
      assertTrue(status.isSnapshotEnabled());
      status = dfs.getFileStatus(new Path(""/parent/""));
      assertFalse(status.isSnapshotEnabled());
    }",Mystery Guest + Resource Optimism
"@Test
  public void testRemoveErasureCodingPolicy() throws Exception {
    Configuration conf = getTestConfiguration();
    MiniDFSCluster cluster = null;

    try {
      cluster = new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
      DistributedFileSystem fs = cluster.getFileSystem();
      ECSchema toAddSchema = new ECSchema(""rs"", 3, 2);
      ErasureCodingPolicy toAddPolicy =
          new ErasureCodingPolicy(toAddSchema, 128 * 1024, (byte) 254);
      String policyName = toAddPolicy.getName();
      ErasureCodingPolicy[] policies = new ErasureCodingPolicy[]{toAddPolicy}",No Smells
"@Test
  public void testStatistics() throws IOException {
    FileSystem.getStatistics(HdfsConstants.HDFS_URI_SCHEME,
        DistributedFileSystem.class).reset();
    @SuppressWarnings(""unchecked"")
    ThreadLocal<StatisticsData> data = (ThreadLocal<StatisticsData>)
        Whitebox.getInternalState(
        FileSystem.getStatistics(HdfsConstants.HDFS_URI_SCHEME,
        DistributedFileSystem.class), ""threadData"");
    data.set(null);

    int lsLimit = 2;
    final Configuration conf = getTestConfiguration();
    conf.setInt(DFSConfigKeys.DFS_LIST_LIMIT, lsLimit);
    final MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).build();
    try {
      cluster.waitActive();
      final FileSystem fs = cluster.getFileSystem();
      Path dir = new Path(""/test"");
      Path file = new Path(dir, ""file"");

      int readOps = 0;
      int writeOps = 0;
      int largeReadOps = 0;

      long opCount = getOpStatistics(OpType.MKDIRS);
      fs.mkdirs(dir);
      checkStatistics(fs, readOps, ++writeOps, largeReadOps);
      checkOpStatistics(OpType.MKDIRS, opCount + 1);
      
      opCount = getOpStatistics(OpType.CREATE);
      FSDataOutputStream out = fs.create(file, (short)1);
      out.close();
      checkStatistics(fs, readOps, ++writeOps, largeReadOps);
      checkOpStatistics(OpType.CREATE, opCount + 1);

      opCount = getOpStatistics(OpType.GET_FILE_STATUS);
      FileStatus status = fs.getFileStatus(file);
      checkStatistics(fs, ++readOps, writeOps, largeReadOps);
      checkOpStatistics(OpType.GET_FILE_STATUS, opCount + 1);
      
      opCount = getOpStatistics(OpType.GET_FILE_BLOCK_LOCATIONS);
      fs.getFileBlockLocations(file, 0, 0);
      checkStatistics(fs, ++readOps, writeOps, largeReadOps);
      checkOpStatistics(OpType.GET_FILE_BLOCK_LOCATIONS, opCount + 1);
      fs.getFileBlockLocations(status, 0, 0);
      checkStatistics(fs, ++readOps, writeOps, largeReadOps);
      checkOpStatistics(OpType.GET_FILE_BLOCK_LOCATIONS, opCount + 2);
      
      opCount = getOpStatistics(OpType.OPEN);
      FSDataInputStream in = fs.open(file);
      in.close();
      checkStatistics(fs, ++readOps, writeOps, largeReadOps);
      checkOpStatistics(OpType.OPEN, opCount + 1);
      
      opCount = getOpStatistics(OpType.SET_REPLICATION);
      fs.setReplication(file, (short)2);
      checkStatistics(fs, readOps, ++writeOps, largeReadOps);
      checkOpStatistics(OpType.SET_REPLICATION, opCount + 1);
      
      opCount = getOpStatistics(OpType.RENAME);
      Path file1 = new Path(dir, ""file1"");
      fs.rename(file, file1);
      checkStatistics(fs, readOps, ++writeOps, largeReadOps);
      checkOpStatistics(OpType.RENAME, opCount + 1);
      
      opCount = getOpStatistics(OpType.GET_CONTENT_SUMMARY);
      fs.getContentSummary(file1);
      checkStatistics(fs, ++readOps, writeOps, largeReadOps);
      checkOpStatistics(OpType.GET_CONTENT_SUMMARY, opCount + 1);
      
      
      // Iterative ls test
      long mkdirOp = getOpStatistics(OpType.MKDIRS);
      long listStatusOp = getOpStatistics(OpType.LIST_STATUS);
      long locatedListStatusOP = getOpStatistics(OpType.LIST_LOCATED_STATUS);
      for (int i = 0; i < 10; i++) {
        Path p = new Path(dir, Integer.toString(i));
        fs.mkdirs(p);
        mkdirOp++;
        FileStatus[] list = fs.listStatus(dir);
        if (list.length > lsLimit) {
          // if large directory, then count readOps and largeReadOps by 
          // number times listStatus iterates
          int iterations = (int)Math.ceil((double)list.length/lsLimit);
          largeReadOps += iterations;
          readOps += iterations;
          listStatusOp += iterations;
        }",Eager Test + Mystery Guest
"@Test
  public void testGetFileStatusOnFile() throws Exception {
    checkFile(fs, file1, 1);
    // test getFileStatus on a file
    FileStatus status = fs.getFileStatus(file1);
    assertFalse(file1 + "" should be a file"", status.isDirectory());
    assertEquals(blockSize, status.getBlockSize());
    assertEquals(1, status.getReplication());
    assertEquals(fileSize, status.getLen());
    ContractTestUtils.assertNotErasureCoded(fs, file1);
    assertEquals(file1.makeQualified(fs.getUri(),
        fs.getWorkingDirectory()).toString(), 
        status.getPath().toString());
    assertTrue(file1 + "" should have erasure coding unset in "" +
            ""FileStatus#toString(): "" + status,
        status.toString().contains(""isErasureCoded=false""));
  }",Eager Test + Mystery Guest
"@Test
  public void testListStatusOnFile() throws IOException {
    FileStatus[] stats = fs.listStatus(file1);
    assertEquals(1, stats.length);
    FileStatus status = stats[0];
    assertFalse(file1 + "" should be a file"", status.isDirectory());
    assertEquals(blockSize, status.getBlockSize());
    assertEquals(1, status.getReplication());
    assertEquals(fileSize, status.getLen());
    ContractTestUtils.assertNotErasureCoded(fs, file1);
    assertEquals(file1.makeQualified(fs.getUri(),
        fs.getWorkingDirectory()).toString(), 
        status.getPath().toString());

    RemoteIterator<FileStatus> itor = fc.listStatus(file1);
    status = itor.next();
    assertEquals(stats[0], status);
    assertFalse(file1 + "" should be a file"", status.isDirectory());
  }",Eager Test + Mystery Guest
"@Test
  public void TestDFSCheckSumType() throws Exception{
    Configuration conf = new HdfsConfiguration();
    conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY, BLOCK_SIZE);
    conf.setInt(DFSConfigKeys.DFS_BYTES_PER_CHECKSUM_KEY, BYTES_PER_CHECKSUM);
    conf.set(DFSConfigKeys.DFS_CHECKSUM_TYPE_KEY, ""NULL"");
    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf)
                                               .numDataNodes(NUM_OF_DATANODES)
                                               .build();
    fileSys = cluster.getFileSystem();
    try {
      Path file = new Path(""try.dat"");
      Random rand = new Random(seed);
      rand.nextBytes(expected);
      writeFile1(file);
    }",No Smells
"@Test
  public void testGetKeyProvider() throws IOException {
    HdfsAdmin hdfsAdmin = new HdfsAdmin(FileSystem.getDefaultUri(conf), conf);
    Assert.assertNull(""should return null for an non-encrypted cluster"",
        hdfsAdmin.getKeyProvider());

    shutDownCluster();

    Configuration conf = new Configuration();
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,
        getKeyProviderURI());

    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(2).build();
    cluster.waitActive();
    hdfsAdmin = new HdfsAdmin(FileSystem.getDefaultUri(conf), conf);

    Assert.assertNotNull(""should not return null for an encrypted cluster"",
        hdfsAdmin.getKeyProvider());
  }",No Smells
"@Test
  public void testHdfsAdminStoragePolicies() throws Exception {
    HdfsAdmin hdfsAdmin = new HdfsAdmin(FileSystem.getDefaultUri(conf), conf);
    FileSystem fs = FileSystem.get(conf);
    final Path foo = new Path(""/foo"");
    final Path bar = new Path(foo, ""bar"");
    final Path wow = new Path(bar, ""wow"");
    DFSTestUtil.createFile(fs, wow, SIZE, REPL, 0);

    final BlockStoragePolicySuite suite = BlockStoragePolicySuite
        .createDefaultSuite();
    final BlockStoragePolicy warm = suite.getPolicy(""WARM"");
    final BlockStoragePolicy cold = suite.getPolicy(""COLD"");
    final BlockStoragePolicy hot = suite.getPolicy(""HOT"");

    /*
     * test: set storage policy
     */
    hdfsAdmin.setStoragePolicy(foo, warm.getName());
    hdfsAdmin.setStoragePolicy(bar, cold.getName());
    hdfsAdmin.setStoragePolicy(wow, hot.getName());

    /*
     * test: get storage policy after set
     */
    assertEquals(hdfsAdmin.getStoragePolicy(foo), warm);
    assertEquals(hdfsAdmin.getStoragePolicy(bar), cold);
    assertEquals(hdfsAdmin.getStoragePolicy(wow), hot);

    /*
     * test: unset storage policy
     */
    hdfsAdmin.unsetStoragePolicy(foo);
    hdfsAdmin.unsetStoragePolicy(bar);
    hdfsAdmin.unsetStoragePolicy(wow);

    /*
     * test: get storage policy after unset. HOT by default.
     */
    assertEquals(hdfsAdmin.getStoragePolicy(foo), hot);
    assertEquals(hdfsAdmin.getStoragePolicy(bar), hot);
    assertEquals(hdfsAdmin.getStoragePolicy(wow), hot);

    /*
     * test: get all storage policies
     */
    // Get policies via HdfsAdmin
    Set<String> policyNamesSet1 = new HashSet<>();
    for (BlockStoragePolicySpi policy : hdfsAdmin.getAllStoragePolicies()) {
      policyNamesSet1.add(policy.getName());
    }",Eager Test
"@Test
  public void testBlockAllocationAdjustsUsageConservatively() 
      throws Exception {
    final Path parent = new Path(
        PathUtils.getTestDir(getClass()).getPath(),
        GenericTestUtils.getMethodName());
    assertTrue(dfs.mkdirs(parent));

    DFSAdmin admin = new DFSAdmin(conf);
    Path dir = new Path(parent, ""test"");
    Path file1 = new Path(parent, ""test/test1"");
    Path file2 = new Path(parent, ""test/test2"");
    boolean exceededQuota = false;
    final int QUOTA_SIZE = 3 * DEFAULT_BLOCK_SIZE; // total space usage including
                                           // repl.
    final int FILE_SIZE = DEFAULT_BLOCK_SIZE / 2;
    ContentSummary c;

    // Create the directory and set the quota
    assertTrue(dfs.mkdirs(dir));
    runCommand(admin, false, ""-setSpaceQuota"", Integer.toString(QUOTA_SIZE),
         dir.toString());

    // Creating a file should use half the quota
    DFSTestUtil.createFile(dfs, file1, FILE_SIZE, (short) 3, 1L);
    DFSTestUtil.waitReplication(dfs, file1, (short) 3);
    c = dfs.getContentSummary(dir);
    compareQuotaUsage(c, dfs, dir);
    checkContentSummary(c, webhdfs.getContentSummary(dir));
    assertEquals(""Quota is half consumed"", QUOTA_SIZE / 2,
                 c.getSpaceConsumed());

    // We can not create the 2nd file because even though the total spaced
    // used by two files (2 * 3 * 512/2) would fit within the quota (3 * 512)
    // when a block for a file is created the space used is adjusted
    // conservatively (3 * block size, ie assumes a full block is written)
    // which will violate the quota (3 * block size) since we've already
    // used half the quota for the first file.
    try {
      DFSTestUtil.createFile(dfs, file2, FILE_SIZE, (short) 3, 1L);
    }",Mystery Guest
"@Test
  public void testHugeFileCount() throws IOException {
    final Path parent = new Path(
        PathUtils.getTestDir(getClass()).getPath(),
        GenericTestUtils.getMethodName());
    assertTrue(dfs.mkdirs(parent));

    for (int i = 1; i <= 5; i++) {
      FSDataOutputStream out =
          dfs.create(new Path(parent, ""Folder1/"" + ""file"" + i),(short)1);
      out.close();
    }",Eager Test + Mystery Guest
"@Test
  public void testMaxSpaceQuotas() throws Exception {
    final Path parent = new Path(
        PathUtils.getTestDir(getClass()).getPath(),
        GenericTestUtils.getMethodName());
    assertTrue(dfs.mkdirs(parent));

    final FileSystem fs = cluster.getFileSystem();
    assertTrue(""Not a HDFS: ""+fs.getUri(),
                fs instanceof DistributedFileSystem);
    final DistributedFileSystem dfs = (DistributedFileSystem)fs;

    // create test directory
    final Path testFolder = new Path(parent, ""testFolder"");
    assertTrue(dfs.mkdirs(testFolder));

    // setting namespace quota to Long.MAX_VALUE - 1 should work
    dfs.setQuota(testFolder, Long.MAX_VALUE - 1, 10);
    ContentSummary c = dfs.getContentSummary(testFolder);
    compareQuotaUsage(c, dfs, testFolder);
    assertTrue(""Quota not set properly"", c.getQuota() == Long.MAX_VALUE - 1);

    // setting diskspace quota to Long.MAX_VALUE - 1 should work
    dfs.setQuota(testFolder, 10, Long.MAX_VALUE - 1);
    c = dfs.getContentSummary(testFolder);
    compareQuotaUsage(c, dfs, testFolder);
    assertTrue(""Quota not set properly"", c.getSpaceQuota() == Long.MAX_VALUE - 1);

    // setting namespace quota to Long.MAX_VALUE should not work + no error
    dfs.setQuota(testFolder, Long.MAX_VALUE, 10);
    c = dfs.getContentSummary(testFolder);
    compareQuotaUsage(c, dfs, testFolder);
    assertTrue(""Quota should not have changed"", c.getQuota() == 10);

    // setting diskspace quota to Long.MAX_VALUE should not work + no error
    dfs.setQuota(testFolder, 10, Long.MAX_VALUE);
    c = dfs.getContentSummary(testFolder);
    compareQuotaUsage(c, dfs, testFolder);
    assertTrue(""Quota should not have changed"", c.getSpaceQuota() == 10);

    // setting namespace quota to Long.MAX_VALUE + 1 should not work + error
    try {
      dfs.setQuota(testFolder, Long.MAX_VALUE + 1, 10);
      fail(""Exception not thrown"");
    }",Mystery Guest
"@Test
  public void testSetSpaceQuotaWhenStorageTypeIsWrong() throws Exception {
    Configuration conf = new HdfsConfiguration();
    conf.set(FS_DEFAULT_NAME_KEY, ""hdfs://127.0.0.1:8020"");
    DFSAdmin admin = new DFSAdmin(conf);
    ByteArrayOutputStream err = new ByteArrayOutputStream();
    PrintStream oldErr = System.err;
    try {
      System.setErr(new PrintStream(err));
      String[] args =
          { ""-setSpaceQuota"", ""100"", ""-storageType"", ""COLD"", ""/testDir"" }",No Smells
"@Test
  public void testSpaceQuotaExceptionOnClose() throws Exception {
    GenericTestUtils.setLogLevel(DFSOutputStream.LOG, Level.TRACE);
    GenericTestUtils.setLogLevel(DataStreamer.LOG, Level.TRACE);
    final DFSAdmin dfsAdmin = new DFSAdmin(conf);
    final Path dir = new Path(
        PathUtils.getTestDir(getClass()).getPath(),
        GenericTestUtils.getMethodName());
    assertTrue(dfs.mkdirs(dir));
    final String[] args = new String[] {""-setSpaceQuota"", ""1"", dir.toString()}",Mystery Guest
"@Test
  public void testSpaceQuotaExceptionOnFlush() throws Exception {
    GenericTestUtils.setLogLevel(DFSOutputStream.LOG, Level.TRACE);
    GenericTestUtils.setLogLevel(DataStreamer.LOG, Level.TRACE);
    GenericTestUtils.setLogLevel(DFSClient.LOG, Level.TRACE);
    final DFSAdmin dfsAdmin = new DFSAdmin(conf);
    final Path dir = new Path(
        PathUtils.getTestDir(getClass()).getPath(),
        GenericTestUtils.getMethodName());
    assertTrue(dfs.mkdirs(dir));
    final String[] args = new String[] {""-setSpaceQuota"", ""1"", dir.toString()}",Mystery Guest
"@Test
  public void testDefaultPolicy() throws Exception {
    final Configuration conf = new HdfsConfiguration();
    final ReplaceDatanodeOnFailure p = ReplaceDatanodeOnFailure.get(conf);

    final DatanodeInfo[] infos = new DatanodeInfo[5];
    final DatanodeInfo[][] datanodes = new DatanodeInfo[infos.length + 1][];
    datanodes[0] = DatanodeInfo.EMPTY_ARRAY;
    for(int i = 0; i < infos.length; ) {
      infos[i] = DFSTestUtil.getLocalDatanodeInfo(9867 + i);
      i++;
      datanodes[i] = new DatanodeInfo[i];
      System.arraycopy(infos, 0, datanodes[i], 0, datanodes[i].length);
    }",Eager Test
"@Test
  public void testAllowSnapshot() throws Exception {
    // Idempotent test
    DFSTestUtil.DFSAdminRun(""-allowSnapshot /sub1"", 0,
        ""Allowing snapshot "" + ""on /sub1 succeeded"", conf);
    // allow normal dir success
    DFSTestUtil.FsShellRun(""-mkdir /sub2"", conf);
    DFSTestUtil.DFSAdminRun(""-allowSnapshot /sub2"", 0,
        ""Allowing snapshot "" + ""on /sub2 succeeded"", conf);
    // allow non-exists dir failed
    DFSTestUtil.DFSAdminRun(""-allowSnapshot /sub3"", -1, null, conf);
  }",No Smells
"@Test
  public void testDisallowSnapshot() throws Exception {
    DFSTestUtil.FsShellRun(""-createSnapshot /sub1 sn1"", conf);
    // cannot delete snapshotable dir
    DFSTestUtil.FsShellRun(""-rmr /sub1"", 1, ""The directory /sub1 cannot be deleted since /sub1 is snapshottable and already has snapshots"", conf);
    DFSTestUtil.DFSAdminRun(""-disallowSnapshot /sub1"", -1,
        ""disallowSnapshot: The directory /sub1 has snapshot(s). Please redo the operation after removing all the snapshots."", conf);
    DFSTestUtil.FsShellRun(""-deleteSnapshot /sub1 sn1"", conf);
    DFSTestUtil.DFSAdminRun(""-disallowSnapshot /sub1"", 0,
        ""Disallowing snapshot on /sub1 succeeded"", conf);
    // Idempotent test
    DFSTestUtil.DFSAdminRun(""-disallowSnapshot /sub1"", 0,
        ""Disallowing snapshot on /sub1 succeeded"", conf);
    // now it can be deleted
    DFSTestUtil.FsShellRun(""-rmr /sub1"", conf);
  }",No Smells
"@Test
  public void testGenerated() throws IOException {
    // edits generated by nnHelper (MiniDFSCluster), should have all op codes
    // binary, XML, reparsed binary
    String edits = nnHelper.generateEdits();
    LOG.info(""Generated edits="" + edits);
    String editsParsedXml = folder.newFile(""editsParsed.xml"").getAbsolutePath();
    String editsReparsed = folder.newFile(""editsParsed"").getAbsolutePath();
    // capital case extension
    String editsParsedXML_caseInSensitive =
        folder.newFile(""editsRecoveredParsed.XML"").getAbsolutePath();

    // parse to XML then back to binary
    assertEquals(0, runOev(edits, editsParsedXml, ""xml"", false));
    assertEquals(0, runOev(edits, editsParsedXML_caseInSensitive, ""xml"", false));
    assertEquals(0, runOev(editsParsedXml, editsReparsed, ""binary"", false));
    assertEquals(0,
        runOev(editsParsedXML_caseInSensitive, editsReparsed, ""binary"", false));


    // judgment time
    assertTrue(""Edits "" + edits + "" should have all op codes"",
        hasAllOpCodes(edits));
    LOG.info(""Comparing generated file "" + editsReparsed
        + "" with reference file "" + edits);
    assertTrue(
        ""Generated edits and reparsed (bin to XML to bin) should be same"",
        filesEqualIgnoreTrailingZeros(edits, editsReparsed));
  }",Mystery Guest
"@Test
  public void testStored() throws IOException {
    // reference edits stored with source code (see build.xml)
    final String cacheDir = System.getProperty(""test.cache.data"",
        ""target/test-classes"");
    // binary, XML, reparsed binary
    String editsStored = cacheDir + ""/editsStored"";
    String editsStoredParsedXml = cacheDir + ""/editsStoredParsed.xml"";
    String editsStoredReparsed = cacheDir + ""/editsStoredReparsed"";
    // reference XML version of editsStored (see build.xml)
    String editsStoredXml = cacheDir + ""/editsStored.xml"";

    // parse to XML then back to binary
    assertEquals(0, runOev(editsStored, editsStoredParsedXml, ""xml"", false));
    assertEquals(0,
        runOev(editsStoredParsedXml, editsStoredReparsed, ""binary"", false));

    // judgement time
    assertTrue(""Edits "" + editsStored + "" should have all op codes"",
        hasAllOpCodes(editsStored));
    assertTrue(""Reference XML edits and parsed to XML should be same"",
        FileUtils.contentEqualsIgnoreEOL(new File(editsStoredXml),
            new File(editsStoredParsedXml), ""UTF-8""));
    assertTrue(
        ""Reference edits and reparsed (bin to XML to bin) should be same"",
        filesEqualIgnoreTrailingZeros(editsStored, editsStoredReparsed));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testFileDistributionCalculatorForException() throws Exception {
    File fsimageFile = null;
    Configuration conf = new Configuration();
    // Avoid using the same cluster dir to cause the global originalFsimage
    // file to be cleared.
    conf.set(HDFS_MINIDFS_BASEDIR, GenericTestUtils.getRandomizedTempPath());
    HashMap<String, FileStatus> files = Maps.newHashMap();

    // Create a initial fsimage file
    try (MiniDFSCluster cluster =
        new MiniDFSCluster.Builder(conf).numDataNodes(1).build()) {
      cluster.waitActive();
      DistributedFileSystem hdfs = cluster.getFileSystem();

      // Create a reasonable namespace
      Path dir = new Path(""/dir"");
      hdfs.mkdirs(dir);
      files.put(dir.toString(), pathToFileEntry(hdfs, dir.toString()));
      // Create files with byte size that can't be divided by step size,
      // the byte size for here are 3, 9, 15, 21.
      for (int i = 0; i < FILES_PER_DIR; i++) {
        Path file = new Path(dir, ""file"" + i);
        DFSTestUtil.createFile(hdfs, file, 6 * i + 3, (short) 1, 0);

        files.put(file.toString(),
            pathToFileEntry(hdfs, file.toString()));
      }",Eager Test + Mystery Guest
"@Test
  public void testFileDistributionCalculatorWithOptions() throws Exception {
    int status = OfflineImageViewerPB.run(new String[] {""-i"",
        originalFsimage.getAbsolutePath(), ""-o"", ""-"", ""-p"", ""FileDistribution"",
        ""-maxSize"", ""512"", ""-step"", ""8""}",No Smells
"@Test
  public void testWebImageViewer() throws Exception {
    WebImageViewer viewer = new WebImageViewer(
        NetUtils.createSocketAddr(""localhost:0""));
    try {
      viewer.initServer(originalFsimage.getAbsolutePath());
      int port = viewer.getPort();

      // create a WebHdfsFileSystem instance
      URI uri = new URI(""webhdfs://localhost:"" + String.valueOf(port));
      Configuration conf = new Configuration();
      WebHdfsFileSystem webhdfs = (WebHdfsFileSystem)FileSystem.get(uri, conf);

      // verify the number of directories
      FileStatus[] statuses = webhdfs.listStatus(new Path(""/""));
      assertEquals(dirCount, statuses.length);

      // verify the number of files in the directory
      statuses = webhdfs.listStatus(new Path(""/dir0""));
      assertEquals(FILES_PER_DIR, statuses.length);

      // compare a file
      FileStatus status = webhdfs.listStatus(new Path(""/dir0/file0""))[0];
      FileStatus expected = writtenFiles.get(""/dir0/file0"");
      compareFile(expected, status);

      // LISTSTATUS operation to an empty directory
      statuses = webhdfs.listStatus(new Path(""/emptydir""));
      assertEquals(0, statuses.length);

      // LISTSTATUS operation to a invalid path
      URL url = new URL(""http://localhost:"" + port +
                    ""/webhdfs/v1/invalid/?op=LISTSTATUS"");
      verifyHttpResponseCode(HttpURLConnection.HTTP_NOT_FOUND, url);

      // LISTSTATUS operation to a invalid prefix
      url = new URL(""http://localhost:"" + port + ""/foo"");
      verifyHttpResponseCode(HttpURLConnection.HTTP_NOT_FOUND, url);

      // Verify the Erasure Coded empty file status
      Path emptyECFilePath = new Path(""/ec/EmptyECFile.txt"");
      FileStatus actualEmptyECFileStatus =
          webhdfs.getFileStatus(new Path(emptyECFilePath.toString()));
      FileStatus expectedEmptyECFileStatus = writtenFiles.get(
          emptyECFilePath.toString());
      System.out.println(webhdfs.getFileStatus(new Path(emptyECFilePath
              .toString())));
      compareFile(expectedEmptyECFileStatus, actualEmptyECFileStatus);

      // Verify the Erasure Coded small file status
      Path smallECFilePath = new Path(""/ec/SmallECFile.txt"");
      FileStatus actualSmallECFileStatus =
          webhdfs.getFileStatus(new Path(smallECFilePath.toString()));
      FileStatus expectedSmallECFileStatus = writtenFiles.get(
          smallECFilePath.toString());
      compareFile(expectedSmallECFileStatus, actualSmallECFileStatus);

      // GETFILESTATUS operation
      status = webhdfs.getFileStatus(new Path(""/dir0/file0""));
      compareFile(expected, status);

      // GETFILESTATUS operation to a invalid path
      url = new URL(""http://localhost:"" + port +
                    ""/webhdfs/v1/invalid/?op=GETFILESTATUS"");
      verifyHttpResponseCode(HttpURLConnection.HTTP_NOT_FOUND, url);

      // invalid operation
      url = new URL(""http://localhost:"" + port + ""/webhdfs/v1/?op=INVALID"");
      verifyHttpResponseCode(HttpURLConnection.HTTP_BAD_REQUEST, url);

      // invalid method
      url = new URL(""http://localhost:"" + port + ""/webhdfs/v1/?op=LISTSTATUS"");
      HttpURLConnection connection = (HttpURLConnection) url.openConnection();
      connection.setRequestMethod(""POST"");
      connection.connect();
      assertEquals(HttpURLConnection.HTTP_BAD_METHOD,
          connection.getResponseCode());
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testReturnedTokenIsNull() throws Exception {
    WebHdfsFileSystem fs = mock(WebHdfsFileSystem.class);
    doReturn(null).when(fs).getDelegationToken(anyString());
    Path p = new Path(f.getRoot().getAbsolutePath(), tokenFile);
    DelegationTokenFetcher.saveDelegationToken(conf, fs, null, p);
    // When Token returned is null, TokenFile should not exist
    Assert.assertFalse(p.getFileSystem(conf).exists(p));

  }",Mystery Guest
"@Test
  public void testCheckHealth() throws Exception {
    assertEquals(0, runTool(""-checkHealth"", ""nn1""));
    Mockito.verify(mockProtocol).monitorHealth();
    
    Mockito.doThrow(new HealthCheckFailedException(""fake health check failure""))
      .when(mockProtocol).monitorHealth();
    assertEquals(-1, runTool(""-checkHealth"", ""nn1""));
    assertOutputContains(""Health check failed: fake health check failure"");
  }",No Smells
"@Test
  public void testFailoverWithAutoHa() throws Exception {
    Mockito.doReturn(STANDBY_READY_RESULT).when(mockProtocol).getServiceStatus();
    // Turn on auto-HA in the config
    HdfsConfiguration conf = getHAConf();
    conf.setBoolean(DFSConfigKeys.DFS_HA_AUTO_FAILOVER_ENABLED_KEY, true);
    conf.set(DFSConfigKeys.DFS_HA_FENCE_METHODS_KEY, getFencerTrueCommand());
    tool.setConf(conf);

    assertEquals(0, runTool(""-failover"", ""nn1"", ""nn2""));
    Mockito.verify(mockZkfcProtocol).gracefulFailover();
  }",No Smells
"@Test
  public void testFailoverWithFenceButNoFencer() throws Exception {
    Mockito.doReturn(STANDBY_READY_RESULT).when(mockProtocol).getServiceStatus();
    assertEquals(-1, runTool(""-failover"", ""nn1"", ""nn2"", ""--forcefence""));
  }",No Smells
"@Test
  public void testMutativeOperationsWithAutoHaEnabled() throws Exception {
    Mockito.doReturn(STANDBY_READY_RESULT).when(mockProtocol).getServiceStatus();
    
    // Turn on auto-HA in the config
    HdfsConfiguration conf = getHAConf();
    conf.setBoolean(DFSConfigKeys.DFS_HA_AUTO_FAILOVER_ENABLED_KEY, true);
    conf.set(DFSConfigKeys.DFS_HA_FENCE_METHODS_KEY, getFencerTrueCommand());
    tool.setConf(conf);

    // Should fail without the forcemanual flag
    assertEquals(-1, runTool(""-transitionToActive"", ""nn1""));
    assertTrue(errOutput.contains(""Refusing to manually manage""));
    assertEquals(-1, runTool(""-transitionToStandby"", ""nn1""));
    assertTrue(errOutput.contains(""Refusing to manually manage""));
    assertEquals(-1, runTool(""-transitionToObserver"", ""nn1""));
    assertTrue(errOutput.contains(""Refusing to manually manage""));

    Mockito.verify(mockProtocol, Mockito.never())
      .transitionToActive(anyReqInfo());
    Mockito.verify(mockProtocol, Mockito.never())
        .transitionToStandby(anyReqInfo());
    Mockito.verify(mockProtocol, Mockito.never())
        .transitionToObserver(anyReqInfo());


    // Force flag should bypass the check and change the request source
    // for the RPC
    setupConfirmationOnSystemIn();
    assertEquals(0, runTool(""-transitionToActive"", ""-forcemanual"", ""nn1""));
    setupConfirmationOnSystemIn();
    assertEquals(0, runTool(""-transitionToStandby"", ""-forcemanual"", ""nn1""));
    setupConfirmationOnSystemIn();
    assertEquals(0, runTool(""-transitionToObserver"", ""-forcemanual"", ""nn1""));

    Mockito.verify(mockProtocol, Mockito.times(1)).transitionToActive(
        reqInfoCaptor.capture());
    Mockito.verify(mockProtocol, Mockito.times(1)).transitionToStandby(
        reqInfoCaptor.capture());
    Mockito.verify(mockProtocol, Mockito.times(1)).transitionToObserver(
        reqInfoCaptor.capture());

    // All of the RPCs should have had the ""force"" source
    for (StateChangeRequestInfo ri : reqInfoCaptor.getAllValues()) {
      assertEquals(RequestSource.REQUEST_BY_USER_FORCED, ri.getSource());
    }",Eager Test
"@Test
  public void testOverwriteFile() throws IOException {
    assertTrue(""Creating empty dst file"", DST_FILE.createNewFile());
    
    OutputStream fos = new AtomicFileOutputStream(DST_FILE);
    
    assertTrue(""Empty file still exists"", DST_FILE.exists());
    fos.write(TEST_STRING.getBytes());
    fos.flush();
    
    // Original contents still in place
    assertEquals("""", DFSTestUtil.readFile(DST_FILE));

    fos.close();

    // New contents replace original file
    String readBackData = DFSTestUtil.readFile(DST_FILE);
    assertEquals(TEST_STRING, readBackData);
  }",Mystery Guest
"@Test
  public void testAllocateRecycle() throws Exception {
    final int countThreshold = 4;
    final int countLimit = 8;
    final long countResetTimePeriodMs = 200L;
    final ByteArrayManager.Impl bam = new ByteArrayManager.Impl(
        new ByteArrayManager.Conf(
            countThreshold, countLimit, countResetTimePeriodMs));
    
    final CounterMap counters = bam.getCounters();
    final ManagerMap managers = bam.getManagers();
    
    final int[] uncommonArrays = {0, 1, 2, 4, 8, 16, 32, 64}",Eager Test
"@Test
  public void testCyclicIteration() throws Exception {
    for(int n = 0; n < 5; n++) {
      checkCyclicIteration(n);
    }",Eager Test
"@Test
  public void testRepeatECSchema() throws Exception {
    PrintWriter out = new PrintWriter(new FileWriter(POLICY_FILE));
    out.println(""<?xml version=\""1.0\""?>"");
    out.println(""<configuration>"");
    out.println(""<layoutversion>1</layoutversion>"");
    out.println(""<schemas>"");
    out.println(""  <schema id=\""RSk12m4\"">"");
    out.println(""    <codec>RS-legacy</codec>"");
    out.println(""    <k>12</k>"");
    out.println(""    <m>4</m>"");
    out.println(""  </schema>"");
    out.println(""  <schema id=\""RS-legacyk12m4\"">"");
    out.println(""    <codec>RS-legacy</codec>"");
    out.println(""    <k>12</k>"");
    out.println(""    <m>4</m>"");
    out.println(""  </schema>"");
    out.println(""</schemas>"");
    out.println(""<policies>"");
    out.println(""  <policy>"");
    out.println(""    <schema>RS-legacyk12m4</schema>"");
    out.println(""    <cellsize>1024</cellsize>"");
    out.println(""  </policy>"");
    out.println(""  <policy>"");
    out.println(""    <schema>RSk12m4</schema>"");
    out.println(""    <cellsize>20480</cellsize>"");
    out.println(""  </policy>"");
    out.println(""</policies>"");
    out.println(""</configuration>"");
    out.close();

    ECPolicyLoader ecPolicyLoader = new ECPolicyLoader();

    try {
      ecPolicyLoader.loadPolicy(POLICY_FILE);
      fail(""RuntimeException should be thrown for repetitive elements"");
    }",No Smells
"@Test
  public void testEmptyBasic() {
    LOG.info(""Test empty basic"");
    Iterator<Integer> iter = set.iterator();
    // iterator should not have next
    assertFalse(iter.hasNext());
    assertEquals(0, set.size());
    assertTrue(set.isEmpty());
    LOG.info(""Test empty - DONE"");
  }",No Smells
"@Test
  public void testOneElementBasic() {
    LOG.info(""Test one element basic"");
    set.add(list.get(0));
    // set should be non-empty
    assertEquals(1, set.size());
    assertFalse(set.isEmpty());

    // iterator should have next
    Iterator<Integer> iter = set.iterator();
    assertTrue(iter.hasNext());

    // iterator should not have next
    assertEquals(list.get(0), iter.next());
    assertFalse(iter.hasNext());
    LOG.info(""Test one element basic - DONE"");
  }",No Smells
"@Test
  public void testPollNMultiArray() {
    LOG.info(""Test pollN multi array"");

    // use addAll
    set.addAll(list);

    // poll existing elements (less than size)
    Integer[] poll = new Integer[10];
    poll = set.pollToArray(poll);
    assertEquals(10, poll.length);

    for (Integer i : poll) {
      // should be in original items
      assertTrue(list.contains(i));
      // should not be in the set anymore
      assertFalse(set.contains(i));
    }",Eager Test
"@Test
  public void testRemoveAll() {
    LOG.info(""Test remove all"");
    for (Integer i : list) {
      assertTrue(set.add(i));
    }",Eager Test
"@Test
  public void testOneElementBasic() {
    LOG.info(""Test one element basic"");
    set.add(list.get(0));
    // set should be non-empty
    assertEquals(1, set.size());
    assertFalse(set.isEmpty());

    // iterator should have next
    Iterator<Integer> iter = set.iterator();
    assertTrue(iter.hasNext());

    // iterator should not have next
    assertEquals(list.get(0), iter.next());
    assertFalse(iter.hasNext());
    LOG.info(""Test one element basic - DONE"");
  }",No Smells
"@Test
  public void testPollAll() {
    LOG.info(""Test poll all"");
    for (Integer i : list) {
      assertTrue(set.add(i));
    }",Eager Test
"@Test
  public void testPollMulti() {
    LOG.info(""Test poll multi"");
    for (Integer i : list) {
      assertTrue(set.add(i));
    }",Eager Test
"@Test
  public void testPollNMulti() {
    LOG.info(""Test pollN multi"");

    // use addAll
    set.addAll(list);

    // poll existing elements
    List<Integer> l = set.pollN(10);
    assertEquals(10, l.size());

    for (int i = 0; i < 10; i++) {
      assertEquals(list.get(i), l.get(i));
    }",Eager Test
"@Test
  public void testRemoveMulti() {
    LOG.info(""Test remove multi"");
    for (Integer i : list) {
      assertTrue(set.add(i));
    }",Eager Test
"@Test
  public void testVerifyMD5FileBadDigest() throws Exception {
    MD5FileUtils.saveMD5File(TEST_FILE, MD5Hash.digest(new byte[0]));
    try {
      MD5FileUtils.verifySavedMD5(TEST_FILE, TEST_MD5);
      fail(""Did not throw"");
    }",Mystery Guest + Resource Optimism
"@Test
  public void testDivideByteRangeIntoStripes() {
    ByteBuffer assembled =
        ByteBuffer.allocate(stripesPerBlock * stripeSize);
    for (int bgSize : blockGroupSizes) {
      LocatedStripedBlock blockGroup = createDummyLocatedBlock(bgSize);
      byte[][] internalBlkBufs = createInternalBlkBuffers(bgSize);
      for (int brStart : byteRangeStartOffsets) {
        for (int brSize : byteRangeSizes) {
          if (brStart + brSize > bgSize) {
            continue;
          }",Eager Test
"@Test
  public void testInvalidSequence() throws Exception {
    try {
      XMLUtils.unmangleXmlString(""\\000g;foo"", false);
      Assert.fail(""expected an unmangling error"");
    }",No Smells
"@Test
  public void testMangleStringWithBackSlash() throws Exception {
    testRoundTrip(""a\\bcdef"", ""a\\005c;bcdef"");
    testRoundTrip(""\\\\"", ""\\005c;\\005c;"");
  }",No Smells
"@Test
  public void testAvailableStreamClosed() throws IOException {
    ByteRangeInputStream bris =
            mock(ByteRangeInputStream.class, CALLS_REAL_METHODS);
    InputStreamAndFileLength mockStream = new InputStreamAndFileLength(null,
            mock(InputStream.class));
    doReturn(mockStream).when(bris).openInputStream(Mockito.anyLong());
    Whitebox.setInternalState(bris, ""status"",
            ByteRangeInputStream.StreamStatus.SEEK);

    bris.close();
    try{
      bris.available();
      fail(""Exception should be thrown when stream is closed"");
    }",No Smells
"@Test
  public void testByteRange() throws IOException {
    ByteRangeInputStream.URLOpener oMock = getMockURLOpener(
        new URL(""http://test""));
    ByteRangeInputStream.URLOpener rMock = getMockURLOpener(null);
    ByteRangeInputStream bris = new ByteRangeInputStreamImpl(oMock, rMock);

    bris.seek(0);

    assertEquals(""getPos wrong"", 0, bris.getPos());

    bris.read();

    assertEquals(""Initial call made incorrectly (offset check)"",
        0, bris.startPos);
    assertEquals(""getPos should return 1 after reading one byte"", 1,
        bris.getPos());
    verify(oMock, times(1)).connect(0, false);

    bris.read();

    assertEquals(""getPos should return 2 after reading two bytes"", 2,
        bris.getPos());
    // No additional connections should have been made (no seek)
    verify(oMock, times(1)).connect(0, false);

    rMock.setURL(new URL(""http://resolvedurl/""));

    bris.seek(100);
    bris.read();

    assertEquals(""Seek to 100 bytes made incorrectly (offset Check)"",
        100, bris.startPos);
    assertEquals(""getPos should return 101 after reading one byte"", 101,
        bris.getPos());
    verify(rMock, times(1)).connect(100, true);

    bris.seek(101);
    bris.read();

    // Seek to 101 should not result in another request
    verify(rMock, times(1)).connect(100, true);
    verify(rMock, times(0)).connect(101, true);

    bris.seek(2500);
    bris.read();

    assertEquals(""Seek to 2500 bytes made incorrectly (offset Check)"",
        2500, bris.startPos);

    doReturn(getMockConnection(null))
        .when(rMock).connect(anyLong(), anyBoolean());
    bris.seek(500);
    try {
      bris.read();
      fail(""Exception should be thrown when content-length is not given"");
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testPropagatedClose() throws IOException {
    ByteRangeInputStream bris =
        mock(ByteRangeInputStream.class, CALLS_REAL_METHODS);
    InputStreamAndFileLength mockStream = new InputStreamAndFileLength(1L,
        mock(InputStream.class));
    doReturn(mockStream).when(bris).openInputStream(Mockito.anyLong());
    Whitebox.setInternalState(bris, ""status"",
                              ByteRangeInputStream.StreamStatus.SEEK);

    int brisOpens = 0;
    int brisCloses = 0;
    int isCloses = 0;

    // first open, shouldn't close underlying stream
    bris.getInputStream();
    verify(bris, times(++brisOpens)).openInputStream(Mockito.anyLong());
    verify(bris, times(brisCloses)).close();
    verify(mockStream.in, times(isCloses)).close();

    // stream is open, shouldn't close underlying stream
    bris.getInputStream();
    verify(bris, times(brisOpens)).openInputStream(Mockito.anyLong());
    verify(bris, times(brisCloses)).close();
    verify(mockStream.in, times(isCloses)).close();

    // seek forces a reopen, should close underlying stream
    bris.seek(1);
    bris.getInputStream();
    verify(bris, times(++brisOpens)).openInputStream(Mockito.anyLong());
    verify(bris, times(brisCloses)).close();
    verify(mockStream.in, times(++isCloses)).close();

    // verify that the underlying stream isn't closed after a seek
    // ie. the state was correctly updated
    bris.getInputStream();
    verify(bris, times(brisOpens)).openInputStream(Mockito.anyLong());
    verify(bris, times(brisCloses)).close();
    verify(mockStream.in, times(isCloses)).close();

    // seeking to same location should be a no-op
    bris.seek(1);
    bris.getInputStream();
    verify(bris, times(brisOpens)).openInputStream(Mockito.anyLong());
    verify(bris, times(brisCloses)).close();
    verify(mockStream.in, times(isCloses)).close();

    // close should of course close
    bris.close();
    verify(bris, times(++brisCloses)).close();
    verify(mockStream.in, times(++isCloses)).close();

    // it's already closed, underlying stream should not close
    bris.close();
    verify(bris, times(++brisCloses)).close();
    verify(mockStream.in, times(isCloses)).close();

    // it's closed, don't reopen it
    boolean errored = false;
    try {
      bris.getInputStream();
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testToJsonFromAclStatus() {
    String jsonString =
        ""{\""AclStatus\"":{\""entries\"":[\""user:user1:rwx\"",\""group::rw-\""],\""group\"":\""supergroup\"",\""owner\"":\""testuser\"",\""stickyBit\"":false}",No Smells
"@Test
  public void testContentSummary() throws Exception {
    final Configuration conf = WebHdfsTestUtil.createConf();
    final Path path = new Path(""/QuotaDir"");
    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    final WebHdfsFileSystem webHdfs = WebHdfsTestUtil.getWebHdfsFileSystem(conf,
        WebHdfsConstants.WEBHDFS_SCHEME);
    final DistributedFileSystem dfs = cluster.getFileSystem();
    dfs.mkdirs(path);
    dfs.setQuotaByStorageType(path, StorageType.DISK, 100000);
    ContentSummary contentSummary = webHdfs.getContentSummary(path);
    Assert
        .assertTrue((contentSummary.getTypeQuota(StorageType.DISK) == 100000));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testFsserverDefaultsBackwardsCompatible() throws Exception {
    final Configuration conf = WebHdfsTestUtil.createConf();
    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    final WebHdfsFileSystem webfs = WebHdfsTestUtil.getWebHdfsFileSystem(conf,
        WebHdfsConstants.WEBHDFS_SCHEME);
    FSNamesystem fsnSpy =
        NameNodeAdapterMockitoUtil.spyOnNamesystem(cluster.getNameNode());
    Mockito.when(fsnSpy.getServerDefaults())
        .thenThrow(new UnsupportedOperationException());
    try {
      webfs.getServerDefaults();
      Assert.fail(""should have thrown UnSupportedOperationException."");
    }",No Smells
"@Test
  public void testGetTrashRoot() throws Exception {
    final Configuration conf = WebHdfsTestUtil.createConf();
    final String currentUser =
        UserGroupInformation.getCurrentUser().getShortUserName();
    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    final WebHdfsFileSystem webFS = WebHdfsTestUtil.getWebHdfsFileSystem(conf,
        WebHdfsConstants.WEBHDFS_SCHEME);

    Path trashPath = webFS.getTrashRoot(new Path(""/""));
    Path expectedPath = new Path(FileSystem.USER_HOME_PREFIX,
        new Path(currentUser, FileSystem.TRASH_PREFIX));
    assertEquals(expectedPath.toUri().getPath(), trashPath.toUri().getPath());
  }",No Smells
"@Test
  public void testSetStoragePolicyWhenPolicyDisabled() throws Exception {
    Configuration conf = new HdfsConfiguration();
    conf.setBoolean(DFSConfigKeys.DFS_STORAGE_POLICY_ENABLED_KEY, false);
    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(0)
        .build();
    try {
      cluster.waitActive();
      final WebHdfsFileSystem webHdfs = WebHdfsTestUtil.getWebHdfsFileSystem(
          conf, WebHdfsConstants.WEBHDFS_SCHEME);
      webHdfs.setStoragePolicy(new Path(""/""),
          HdfsConstants.COLD_STORAGE_POLICY_NAME);
      fail(""Should throw exception, when storage policy disabled"");
    }",No Smells
"@Test
  public void testStoragePolicy() throws Exception {
    final Configuration conf = WebHdfsTestUtil.createConf();
    final Path path = new Path(""/file"");
    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    final DistributedFileSystem dfs = cluster.getFileSystem();
    final WebHdfsFileSystem webHdfs = WebHdfsTestUtil.getWebHdfsFileSystem(conf,
        WebHdfsConstants.WEBHDFS_SCHEME);

    // test getAllStoragePolicies
    Assert.assertTrue(Arrays.equals(dfs.getAllStoragePolicies().toArray(),
        webHdfs.getAllStoragePolicies().toArray()));

    // test get/set/unset policies
    DFSTestUtil.createFile(dfs, path, 0, (short) 1, 0L);
    // get defaultPolicy
    BlockStoragePolicySpi defaultdfsPolicy = dfs.getStoragePolicy(path);
    // set policy through webhdfs
    webHdfs.setStoragePolicy(path, HdfsConstants.COLD_STORAGE_POLICY_NAME);
    // get policy from dfs
    BlockStoragePolicySpi dfsPolicy = dfs.getStoragePolicy(path);
    // get policy from webhdfs
    BlockStoragePolicySpi webHdfsPolicy = webHdfs.getStoragePolicy(path);
    Assert.assertEquals(HdfsConstants.COLD_STORAGE_POLICY_NAME.toString(),
        webHdfsPolicy.getName());
    Assert.assertEquals(webHdfsPolicy, dfsPolicy);
    // unset policy
    webHdfs.unsetStoragePolicy(path);
    Assert.assertEquals(defaultdfsPolicy, webHdfs.getStoragePolicy(path));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testWebHdfsDeleteSnapshot() throws Exception {
    final Configuration conf = WebHdfsTestUtil.createConf();
    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    cluster.waitActive();
    final DistributedFileSystem dfs = cluster.getFileSystem();
    final FileSystem webHdfs = WebHdfsTestUtil.getWebHdfsFileSystem(conf,
        WebHdfsConstants.WEBHDFS_SCHEME);

    final Path foo = new Path(""/foo"");
    dfs.mkdirs(foo);
    dfs.allowSnapshot(foo);

    webHdfs.createSnapshot(foo, ""s1"");
    final Path spath = webHdfs.createSnapshot(foo, null);
    Assert.assertTrue(webHdfs.exists(spath));
    final Path s1path = SnapshotTestHelper.getSnapshotRoot(foo, ""s1"");
    Assert.assertTrue(webHdfs.exists(s1path));

    // delete operation snapshot name as null
    try {
      webHdfs.deleteSnapshot(foo, null);
      fail(""Expected IllegalArgumentException"");
    }",Mystery Guest
"@Test
  public void testConfiguration() {
    Configuration conf = new Configuration();
    conf.set(CommonConfigurationKeys.HADOOP_HTTP_STATIC_USER, ""joe"");
    assertEquals(""joe"", StaticUserWebFilter.getUsernameFromConf(conf));
  }",No Smells
"@Test
  public void testOldStyleConfiguration() {
    Configuration conf = new Configuration();
    conf.set(""dfs.web.ugi"", ""joe,group1,group2"");
    assertEquals(""joe"", StaticUserWebFilter.getUsernameFromConf(conf));
  }",No Smells
"@Test
  public void testRequestQuoting() throws Exception {
    HttpServletRequest mockReq = Mockito.mock(HttpServletRequest.class);
    HttpServer2.QuotingInputFilter.RequestQuoter quoter =
      new HttpServer2.QuotingInputFilter.RequestQuoter(mockReq);
    
    Mockito.doReturn(""a<b"").when(mockReq).getParameter(""x"");
    assertEquals(""Test simple param quoting"",
        ""a&lt;b"", quoter.getParameter(""x""));
    
    Mockito.doReturn(null).when(mockReq).getParameter(""x"");
    assertEquals(""Test that missing parameters dont cause NPE"",
        null, quoter.getParameter(""x""));

    Mockito.doReturn(new String[]{""a<b"", ""b""}",No Smells
"@Test public void testRoundtrip() throws Exception {
    runRoundTrip("""");
    runRoundTrip(""<>&'\"""");
    runRoundTrip(""ab>cd<ef&ghi'\"""");
    runRoundTrip(""A string\n with no quotable chars in it!"");
    runRoundTrip(null);
    StringBuilder buffer = new StringBuilder();
    for(char ch=0; ch < 127; ++ch) {
      buffer.append(ch);
    }",Eager Test
"@Test
  public void  testClose() {
    TestCompressorStream testCompressorStream = new TestCompressorStream();
    try {
      testCompressorStream.close(); 
    }",Mystery Guest
"@Test
  public void testIdempotentResetState() throws IOException {
    DataOutputBuffer dob = new DataOutputBuffer();
    CompressionOutputStream cmpOut = codec.createOutputStream(dob);
    cmpOut.write(DATA1.getBytes(StandardCharsets.UTF_8));
    cmpOut.finish();
    cmpOut.finish();
    cmpOut.finish();
    cmpOut.resetState();
    cmpOut.resetState();
    cmpOut.finish();
    cmpOut.resetState();
    cmpOut.close();
    dob.close();

    DataInputBuffer dib = new DataInputBuffer();
    dib.reset(dob.getData(), 0, dob.getLength());
    CompressionInputStream cmpIn = codec.createInputStream(dib);
    byte[] buf = new byte[1024];
    StringBuilder result = new StringBuilder();
    int len = 0;
    while (true) {
      len = cmpIn.read(buf);
      if (len < 0) {
        break;
      }",Eager Test
"@Test
  public void testGoodCodec() {
    HHXORErasureCodec codec
        = new HHXORErasureCodec(new Configuration(), options);
    ErasureCoder encoder = codec.createEncoder();
    assertEquals(10, encoder.getNumDataUnits());
    assertEquals(4, encoder.getNumParityUnits());

    ErasureCoder decoder = codec.createDecoder();
    assertEquals(10, decoder.getNumDataUnits());
    assertEquals(4, decoder.getNumParityUnits());
  }",No Smells
"@Test
  public void testGetEmptyChunk() {
    byte[] ret = CoderUtil.getEmptyChunk(chunkSize);
    for (int i = 0; i < chunkSize; i++) {
      assertEquals(0, ret[i]);
    }",Eager Test
"@Test
  public void testGetValidIndexes() {
    byte[][] inputs = new byte[numInputs][];
    inputs[0] = new byte[chunkSize];
    inputs[1] = new byte[chunkSize];
    inputs[7] = new byte[chunkSize];
    inputs[8] = new byte[chunkSize];

    int[] validIndexes = CoderUtil.getValidIndexes(inputs);

    assertEquals(4, validIndexes.length);

    // Check valid indexes
    assertEquals(0, validIndexes[0]);
    assertEquals(1, validIndexes[1]);
    assertEquals(7, validIndexes[2]);
    assertEquals(8, validIndexes[3]);
  }",No Smells
"@Test
  public void testDummyCoder() throws Exception {
    // Dummy coder
    RawErasureCoderBenchmark.performBench(""encode"",
        RawErasureCoderBenchmark.CODER.DUMMY_CODER, 2, 100, 1024);
    RawErasureCoderBenchmark.performBench(""decode"",
        RawErasureCoderBenchmark.CODER.DUMMY_CODER, 5, 150, 100);
  }",No Smells
"@Test
  public void testRSCoder() throws Exception {
    // RS Java coder
    RawErasureCoderBenchmark.performBench(""encode"",
        RawErasureCoderBenchmark.CODER.RS_CODER, 3, 200, 200);
    RawErasureCoderBenchmark.performBench(""decode"",
        RawErasureCoderBenchmark.CODER.RS_CODER, 4, 135, 20);
  }",No Smells
"@Test
  public void testGetCodecs() {
    Set<String> codecs = CodecRegistry.getInstance().getCodecNames();
    assertEquals(3, codecs.size());
    assertTrue(codecs.contains(ErasureCodeConstants.RS_CODEC_NAME));
    assertTrue(codecs.contains(ErasureCodeConstants.RS_LEGACY_CODEC_NAME));
    assertTrue(codecs.contains(ErasureCodeConstants.XOR_CODEC_NAME));
  }",No Smells
"@Test
  public void testUpdateCoders() {
    class RSUserDefinedIncorrectFactory implements RawErasureCoderFactory {
      public RawErasureEncoder createEncoder(ErasureCoderOptions coderOptions) {
        return null;
      }",No Smells
"@Test
  public void testConfigureLZOCodec() throws IOException {
    // Dummy codec
    String defaultCodec = ""org.apache.hadoop.io.compress.DefaultCodec"";
    Compression.Algorithm.conf.set(
        Compression.Algorithm.CONF_LZO_CLASS, defaultCodec);
    assertEquals(defaultCodec,
        Compression.Algorithm.LZO.getCodec().getClass().getName());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testUnsortedTFileFeatures() throws IOException {
    unsortedWithSomeCodec(""none"");
    unsortedWithSomeCodec(""gz"");
  }",Mystery Guest
"@Test
  public void testMultiThreadedStatOnError() throws Exception {
    final String testInvalidFilePath = ""C:\\nonexisting_path\\nonexisting_file"";

    int numOfThreads = 10;
    ExecutorService executorService =
        Executors.newFixedThreadPool(numOfThreads);
    for (int i = 0; i < numOfThreads; i++) {
      try {
        Future<Boolean> result =
            executorService.submit(() -> doStatTest(testInvalidFilePath));
        result.get();
      }",Eager Test + Mystery Guest
"@Test
  public void testExponentialRetry() throws UnreliableException {
    UnreliableInterface unreliable = (UnreliableInterface)
      RetryProxy.create(UnreliableInterface.class, unreliableImpl,
                        exponentialBackoffRetry(5, 1L, TimeUnit.NANOSECONDS));
    unreliable.alwaysSucceeds();
    unreliable.failsOnceThenSucceeds();
    try {
      unreliable.failsTenTimesThenSucceeds();
      fail(""Should fail"");
    }",No Smells
"@Test
  public void testRetryByException() throws UnreliableException {
    Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap =
      Collections.<Class<? extends Exception>, RetryPolicy>singletonMap(FatalException.class, TRY_ONCE_THEN_FAIL);
    
    UnreliableInterface unreliable = (UnreliableInterface)
      RetryProxy.create(UnreliableInterface.class, unreliableImpl,
                        retryByException(RETRY_FOREVER, exceptionToPolicyMap));
    unreliable.failsOnceThenSucceeds();
    try {
      unreliable.alwaysFailsWithFatalException();
      fail(""Should fail"");
    }",No Smells
"@Test
  public void testRetryByRemoteException() {
    Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap =
      Collections.<Class<? extends Exception>, RetryPolicy>singletonMap(FatalException.class, TRY_ONCE_THEN_FAIL);
    
    UnreliableInterface unreliable = (UnreliableInterface)
      RetryProxy.create(UnreliableInterface.class, unreliableImpl,
                        retryByRemoteException(RETRY_FOREVER, exceptionToPolicyMap));
    try {
      unreliable.alwaysFailsWithRemoteFatalException();
      fail(""Should fail"");
    }",No Smells
"@Test
  public void testRetryOtherThanRemoteException() throws Throwable {
    Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap =
        Collections.<Class<? extends Exception>, RetryPolicy>singletonMap(
            IOException.class, RETRY_FOREVER);

    UnreliableInterface unreliable = (UnreliableInterface)
        RetryProxy.create(UnreliableInterface.class, unreliableImpl,
            retryOtherThanRemoteAndSaslException(TRY_ONCE_THEN_FAIL,
                exceptionToPolicyMap));
    // should retry with local IOException.
    unreliable.failsOnceWithIOException();
    try {
      // won't get retry on remote exception
      unreliable.failsOnceWithRemoteException();
      fail(""Should fail"");
    }",No Smells
"@Test
  public void testTryOnceThenFail() throws Exception {
    RetryPolicy policy = mock(TryOnceThenFail.class);
    RetryPolicy realPolicy = TRY_ONCE_THEN_FAIL;
    setupMockPolicy(policy, realPolicy);

    UnreliableInterface unreliable = (UnreliableInterface)
      RetryProxy.create(UnreliableInterface.class, unreliableImpl, policy);
    unreliable.alwaysSucceeds();
    try {
      unreliable.failsOnceThenSucceeds();
      fail(""Should fail"");
    }",No Smells
"@Test
  public void testSpecific() throws Exception {
    AvroRecord before = new AvroRecord();
    before.intField = 5;
    AvroRecord after = SerializationTestUtil.testSerialization(conf, before);
    assertEquals(before, after);
  }",No Smells
"@Test
  public void testSerializationKeyIsInvalid() {
    Configuration conf = new Configuration();
    conf.set(CommonConfigurationKeys.IO_SERIALIZATIONS_KEY, ""INVALID_KEY_XXX"");
    SerializationFactory factory = new SerializationFactory(conf);
  }",No Smells
"@Test
  public void testWritableConfigurable() throws Exception {
    
    //set the configuration parameter
    conf.set(CONF_TEST_KEY, CONF_TEST_VALUE);

    //reuse TestGenericWritable inner classes to test 
    //writables that also implement Configurable.
    FooGenericWritable generic = new FooGenericWritable();
    generic.setConf(conf);
    Baz baz = new Baz();
    generic.set(baz);
    Baz result = SerializationTestUtil.testSerialization(conf, baz);
    assertEquals(baz, result);
    assertNotNull(result.getConf());
  }",No Smells
"@Test
  public void testOldFormat() throws IOException {
    //Make sure we still correctly write the old format if desired.
    
    //Write the data array with old ObjectWritable API
    //which will set allowCompactArrays false.
    ObjectWritable.writeObject(out, i, i.getClass(), null);

    //Get ready to read it back
    in.reset(out.getData(), out.getLength());
    
    //Read the int[] object as written by ObjectWritable, but
    //""going around"" ObjectWritable
    @SuppressWarnings(""deprecation"")
    String className = UTF8.readString(in);
    assertEquals(""The int[] written by ObjectWritable as a non-compact array ""
        + ""was not labelled as an array of int"", 
        i.getClass().getName(), className);
    
    int length = in.readInt();
    assertEquals(""The int[] written by ObjectWritable as a non-compact array ""
        + ""was not expected length"", i.length, length);
    
    int[] readValue = new int[length];
    try {
      for (int i = 0; i < length; i++) {
        readValue[i] = (int)((Integer)ObjectWritable.readObject(in, null));
      }",Eager Test
"@Test
  public void testArrayWritableToArray() {
    Text[] elements = {new Text(""zero""), new Text(""one""), new Text(""two"")}",No Smells
"@Test
  public void testThrowUndefinedValueException() throws IOException {
    // Get a buffer containing a simple text array
    Text[] elements = {new Text(""zero""), new Text(""one""), new Text(""two"")}",Eager Test
"@Test
  public void testIOExceptionInWriterConstructor() {
    Path dirNameSpy = spy(TEST_FILE);
    BloomMapFile.Reader reader = null;
    BloomMapFile.Writer writer = null;
    try {
      writer = new BloomMapFile.Writer(conf, TEST_FILE,
          MapFile.Writer.keyClass(IntWritable.class),
          MapFile.Writer.valueClass(Text.class));
      writer.append(new IntWritable(1), new Text(""123124142""));
      writer.close();

      when(dirNameSpy.getFileSystem(conf)).thenThrow(new IOException());
      reader = new BloomMapFile.Reader(dirNameSpy, conf,
          MapFile.Reader.comparator(new WritableComparator(IntWritable.class)));

      assertNull(""testIOExceptionInWriterConstructor error !!!"",
          reader.getBloomFilter());
    }",Mystery Guest
"@Test
  public void testMembershipVaryingSizedKeysTest1() throws Exception {
    ArrayList<Text> list = new ArrayList<Text>();
    list.add(new Text(""A""));
    list.add(new Text(""BB""));
    checkMembershipVaryingSizedKeys(list);
  }",No Smells
"@Test
  public void testCommonMethods() {    
    assertTrue(""testCommonMethods1 error !!!"", newInstance(true).equals(newInstance(true)));
    assertTrue(""testCommonMethods2 error  !!!"", newInstance(false).equals(newInstance(false)));
    assertFalse(""testCommonMethods3 error !!!"", newInstance(false).equals(newInstance(true)));
    assertTrue(""testCommonMethods4 error !!!"", checkHashCode(newInstance(true), newInstance(true)));
    assertFalse(""testCommonMethods5 error !!! "", checkHashCode(newInstance(true), newInstance(false)));
    assertTrue(""testCommonMethods6 error !!!"", newInstance(true).compareTo(newInstance(false)) > 0 );
    assertTrue(""testCommonMethods7 error !!!"", newInstance(false).compareTo(newInstance(true)) < 0 );
    assertTrue(""testCommonMethods8 error !!!"", newInstance(false).compareTo(newInstance(false)) == 0 );
    assertEquals(""testCommonMethods9 error !!!"", ""true"", newInstance(true).toString());
  }",No Smells
"@Test
  public void testCompare() throws Exception {
    byte[][] values = new byte[][]{""abc"".getBytes(), 
                                   ""ad"".getBytes(),
                                   ""abcd"".getBytes(),
                                   """".getBytes(),
                                   ""b"".getBytes()}",Eager Test
"@Test
  public void testSerializeAndDeserializeNull() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(null);
    }",No Smells
"@Test
  public void testBazWritable() throws Exception {
    System.out.println(""Testing for GenericWritable to find class names"");
    FooGenericWritable generic = new FooGenericWritable();
    generic.setConf(conf);
    Baz baz = new Baz();
    generic.set(baz);
    TestWritable.testWritable(generic, conf);
  }",No Smells
"@Test
  public void testGet() throws Exception {
    Foo foo = new Foo();
    FooGenericWritable generic = new FooGenericWritable();
    generic.set(foo);
    assertEquals(foo, generic.get());
  }",No Smells
"@Test
  public void testSet() throws Exception {
    Foo foo = new Foo();
    FooGenericWritable generic = new FooGenericWritable();
    //exception should not occur
    generic.set(foo);

    try {
      //exception should occur, since IntWritable is not registered
      generic = new FooGenericWritable();
      generic.set(new IntWritable(1));
      fail(""Generic writable should have thrown an exception for a Writable not registered"");
    }",No Smells
"@Test
  public void testCloseStreams() throws IOException {
    File tmpFile = null;
    FileOutputStream fos;
    BufferedOutputStream bos;
    FileOutputStream nullStream = null;

    try {
      tmpFile = new File(GenericTestUtils.getTestDir(), ""testCloseStreams.txt"");
      fos = new FileOutputStream(tmpFile) {
        @Override
        public void close() throws IOException {
          throw new IOException();
        }",Mystery Guest + Resource Optimism
"@Test
  public void testFix() {
    final String INDEX_LESS_MAP_FILE = ""testFix.mapfile"";
    int PAIR_SIZE = 20;
    MapFile.Writer writer = null;
    try {
      FileSystem fs = FileSystem.getLocal(conf);
      Path dir = new Path(TEST_DIR, INDEX_LESS_MAP_FILE);
      writer = createWriter(INDEX_LESS_MAP_FILE, IntWritable.class, Text.class);
      for (int i = 0; i < PAIR_SIZE; i++)
        writer.append(new IntWritable(0), new Text(""value""));
      writer.close();

      File indexFile = new File(""."", ""."" + INDEX_LESS_MAP_FILE + ""/index"");
      boolean isDeleted = false;
      if (indexFile.exists())
        isDeleted = indexFile.delete();

      if (isDeleted)
        assertTrue(""testFix error !!!"",
            MapFile.fix(fs, dir, IntWritable.class, Text.class, true, conf) == PAIR_SIZE);
    }",Mystery Guest + Resource Optimism
"@Test
  public void testGetClosestOnCurrentApi() throws Exception {
    final String TEST_PREFIX = ""testGetClosestOnCurrentApi.mapfile"";
    MapFile.Writer writer = null;
    MapFile.Reader reader = null;
    try {
      writer = createWriter(TEST_PREFIX, Text.class, Text.class);
      int FIRST_KEY = 1;
      // Test keys: 11,21,31,...,91
      for (int i = FIRST_KEY; i < 100; i += 10) {      
        Text t = new Text(Integer.toString(i));
        writer.append(t, t);
      }",Eager Test
"@Test
  public void testPathExplosionWriterCreation() {
    Path path = new Path(TEST_DIR, ""testPathExplosionWriterCreation.mapfile"");
    String TEST_ERROR_MESSAGE = ""Mkdirs failed to create directory ""
        + path.getName();
    MapFile.Writer writer = null;
    try {
      FileSystem fsSpy = spy(FileSystem.get(conf));
      Path pathSpy = spy(path);
      when(fsSpy.mkdirs(path)).thenThrow(new IOException(TEST_ERROR_MESSAGE));

      when(pathSpy.getFileSystem(conf)).thenReturn(fsSpy);

      writer = new MapFile.Writer(conf, pathSpy,
          MapFile.Writer.keyClass(IntWritable.class),
          MapFile.Writer.valueClass(IntWritable.class));
      fail(""fail in testPathExplosionWriterCreation !!!"");
    }",Mystery Guest
"@Test
  public void testReaderGetClosest() throws Exception {
    final String TEST_METHOD_KEY = ""testReaderWithWrongKeyClass.mapfile"";
    MapFile.Writer writer = null;
    MapFile.Reader reader = null;
    try {
      writer = createWriter(TEST_METHOD_KEY, IntWritable.class, Text.class);

      for (int i = 0; i < 10; i++)
        writer.append(new IntWritable(i), new Text(""value"" + i));
      writer.close();

      reader = createReader(TEST_METHOD_KEY, Text.class);
      reader.getClosest(new Text(""2""), new Text(""""));
      fail(""no excepted exception in testReaderWithWrongKeyClass !!!"");
    }",Mystery Guest
"@Test
  public void testRenameWithException() {
    final String ERROR_MESSAGE = ""Can't rename file"";
    final String NEW_FILE_NAME = ""test-new.mapfile"";
    final String OLD_FILE_NAME = ""test-old.mapfile"";
    MapFile.Writer writer = null;
    try {
      FileSystem fs = FileSystem.getLocal(conf);
      FileSystem spyFs = spy(fs);

      writer = createWriter(OLD_FILE_NAME, IntWritable.class, IntWritable.class);
      writer.close();

      Path oldDir = new Path(TEST_DIR, OLD_FILE_NAME);
      Path newDir = new Path(TEST_DIR, NEW_FILE_NAME);
      when(spyFs.rename(oldDir, newDir)).thenThrow(
          new IOException(ERROR_MESSAGE));

      MapFile.rename(spyFs, oldDir.toString(), newDir.toString());
      fail(""testRenameWithException no exception error !!!"");
    }",Mystery Guest
"@Test
  public void testToString() {
    MapWritable map = new MapWritable();
    final IntWritable key = new IntWritable(5);
    final Text value = new Text(""value"");
    map.put(key, value);
    assertEquals(""{5=value}",No Smells
"@Test
  public void testClose() throws IOException {
    Configuration conf = new Configuration();
    LocalFileSystem fs = FileSystem.getLocal(conf);
  
    // create a sequence file 1
    Path path1 = new Path(GenericTestUtils.getTempPath(""test1.seq""));
    SequenceFile.Writer writer = SequenceFile.createWriter(fs, conf, path1,
        Text.class, NullWritable.class, CompressionType.BLOCK);
    writer.append(new Text(""file1-1""), NullWritable.get());
    writer.append(new Text(""file1-2""), NullWritable.get());
    writer.close();
  
    Path path2 = new Path(GenericTestUtils.getTempPath(""test2.seq""));
    writer = SequenceFile.createWriter(fs, conf, path2, Text.class,
        NullWritable.class, CompressionType.BLOCK);
    writer.append(new Text(""file2-1""), NullWritable.get());
    writer.append(new Text(""file2-2""), NullWritable.get());
    writer.close();
  
    // Create a reader which uses 4 BuiltInZLibInflater instances
    SequenceFile.Reader reader = new SequenceFile.Reader(fs, path1, conf);
    // Returns the 4 BuiltInZLibInflater instances to the CodecPool
    reader.close();
    // The second close _could_ erroneously returns the same 
    // 4 BuiltInZLibInflater instances to the CodecPool again
    reader.close();
  
    // The first reader gets 4 BuiltInZLibInflater instances from the CodecPool
    SequenceFile.Reader reader1 = new SequenceFile.Reader(fs, path1, conf);
    // read first value from reader1
    Text text = new Text();
    reader1.next(text);
    assertEquals(""file1-1"", text.toString());
    
    // The second reader _could_ get the same 4 BuiltInZLibInflater 
    // instances from the CodePool as reader1
    SequenceFile.Reader reader2 = new SequenceFile.Reader(fs, path2, conf);
    
    // read first value from reader2
    reader2.next(text);
    assertEquals(""file2-1"", text.toString());
    // read second value from reader1
    reader1.next(text);
    assertEquals(""file1-2"", text.toString());
    // read second value from reader2 (this throws an exception)
    reader2.next(text);
    assertEquals(""file2-2"", text.toString());
  
    assertFalse(reader1.next(text));
    assertFalse(reader2.next(text));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testCreateUsesFsArg() throws Exception {
    FileSystem fs = FileSystem.getLocal(conf);
    FileSystem spyFs = Mockito.spy(fs);
    Path p = new Path(GenericTestUtils.getTempPath(""testCreateUsesFSArg.seq""));
    SequenceFile.Writer writer = SequenceFile.createWriter(
        spyFs, conf, p, NullWritable.class, NullWritable.class);
    writer.close();
    Mockito.verify(spyFs).getDefaultReplication(p);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testCreateWriterOnExistingFile() throws IOException {
    Configuration conf = new Configuration();
    FileSystem fs = FileSystem.getLocal(conf);
    Path name = new Path(new Path(GenericTestUtils.getTempPath(
        ""createWriterOnExistingFile"")), ""file"");

    fs.create(name);
    SequenceFile.createWriter(fs, conf, name, RandomDatum.class,
        RandomDatum.class, 512, (short) 1, 4096, false,
        CompressionType.NONE, null, new Metadata());
  }",Mystery Guest
"@Test
  public void testSerializationAvailability() throws IOException {
    Configuration conf = new Configuration();
    Path path = new Path(GenericTestUtils.getTempPath(
        ""serializationAvailability""));
    // Check if any serializers aren't found.
    try {
      SequenceFile.createWriter(
          conf,
          SequenceFile.Writer.file(path),
          SequenceFile.Writer.keyClass(String.class),
          SequenceFile.Writer.valueClass(NullWritable.class));
      // Note: This may also fail someday if JavaSerialization
      // is activated by default.
      fail(""Must throw IOException for missing serializer for the Key class"");
    }",Eager Test + Mystery Guest
"@Test
  public void testSetFileAccessMethods() {
    try {
      FileSystem fs = FileSystem.getLocal(conf);
      int size = 10;
      writeData(fs, size);
      SetFile.Reader reader = createReader(fs);
      assertTrue(""testSetFileWithConstruction1 error !!!"", reader.next(new IntWritable(0)));
      // don't know why reader.get(i) return i+1
      assertEquals(""testSetFileWithConstruction2 error !!!"", new IntWritable(size/2 + 1), reader.get(new IntWritable(size/2)));      
      assertNull(""testSetFileWithConstruction3 error !!!"", reader.get(new IntWritable(size*2)));
    }",Eager Test + Mystery Guest
"@Test
  public void testAvroReflect() throws Exception {
    AvroTestUtil.testReflect
            (new Text(""foo""),
                    ""{\""type\"":\""string\"",\""java-class\"":\""org.apache.hadoop.io.Text\""}",No Smells
"@Test
  public void testBytesToCodePoint() {
    try {
      ByteBuffer bytes = ByteBuffer.wrap(new byte[] {-2, 45, 23, 12, 76, 89}",No Smells
"@Test
  public void testCoding() throws Exception {
    String before = ""Bad \t encoding \t testcase"";
    Text text = new Text(before);
    String after = text.toString();
    assertTrue(before.equals(after));

    for (int i = 0; i < NUM_ITERATIONS; i++) {
      // generate a random string
      if (i == 0)
        before = getLongString();
      else
        before = getTestString();
    
      // test string to utf8
      ByteBuffer bb = Text.encode(before);
          
      byte[] utf8Text = bb.array();
      byte[] utf8Java = before.getBytes(StandardCharsets.UTF_8);
      assertEquals(0, WritableComparator.compareBytes(
              utf8Text, 0, bb.limit(),
              utf8Java, 0, utf8Java.length));
      // test utf8 to string
      after = Text.decode(utf8Java);
      assertTrue(before.equals(after));
    }",Eager Test
"@Test
  public void testReadWriteOperations() {
    String line = ""adsawseeeeegqewgasddga"";
    byte[] inputBytes = line.getBytes();       
    inputBytes = Bytes.concat(new byte[] {(byte)22}",No Smells
"@Test
  public void testAdvancedVersionedWritable() throws Exception {
    TestWritable.testWritable(new AdvancedVersionedWritable());
  }",No Smells
"@Test
  public void testAddName() throws Exception {
    Configuration conf = new Configuration();
    String altName = testName + "".alt"";

    WritableName.setName(SimpleWritable.class, testName);
    WritableName.addName(SimpleWritable.class, altName);

    Class<?> test = WritableName.getClass(altName, conf);
    assertTrue(test.equals(SimpleWritable.class));

    // check original name still works
    test = WritableName.getClass(testName, conf);
    assertTrue(test.equals(SimpleWritable.class));
  }",No Smells
"@Test
  public void testSetName() throws Exception {
    Configuration conf = new Configuration();
    WritableName.setName(SimpleWritable.class, testName);

    Class<?> test = WritableName.getClass(testName,conf);
    assertTrue(test.equals(SimpleWritable.class));
  }",No Smells
"@Test
  public void testCallQueueConstructorException() throws InterruptedException {
    try {
      new CallQueueManager<ExceptionFakeCall>(exceptionQueueClass,
          schedulerClass, false, 10, """", new Configuration());
      fail();
    }",No Smells
"@Test
  public void testFcqBackwardCompatibility() throws InterruptedException {
    // Test BackwardCompatibility to ensure existing FCQ deployment still
    // work without explicitly specifying DecayRpcScheduler
    Configuration conf = new Configuration();
    final String ns = CommonConfigurationKeys.IPC_NAMESPACE + "".0"";

    final String queueClassName = ""org.apache.hadoop.ipc.FairCallQueue"";
    conf.setStrings(ns + ""."" + CommonConfigurationKeys.IPC_CALLQUEUE_IMPL_KEY,
        queueClassName);

    // Specify only Fair Call Queue without a scheduler
    // Ensure the DecayScheduler will be added to avoid breaking.
    Class<? extends RpcScheduler> scheduler =
        Server.getSchedulerClass(CommonConfigurationKeys.IPC_NAMESPACE, 0,
        conf);
    assertTrue(scheduler.getCanonicalName().
        equals(""org.apache.hadoop.ipc.DecayRpcScheduler""));

    Class<? extends BlockingQueue<FakeCall>> queue =
        (Class<? extends BlockingQueue<FakeCall>>) getQueueClass(ns, conf);
    assertTrue(queue.getCanonicalName().equals(queueClassName));

    manager = new CallQueueManager<FakeCall>(queue, scheduler, false,
        8, """", conf);

    // Default FCQ has 4 levels and the max capacity is 8
    assertCanPut(manager, 3, 3);
  }",No Smells
"@Test
  public void testAllQueuesFullRemainingCapacity() {
    int[] mockedPriorities = {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0}",No Smells
"@Test
  public void testPeekPointsAtHead() {
    Schedulable call = mockCall(""c"", 0);
    Schedulable next = mockCall(""b"", 0);
    fcq.offer(call);
    fcq.offer(next);

    assertEquals(call, fcq.peek()); // Peek points at the head
  }",No Smells
"@Test
  public void testPollSuccess() throws InterruptedException {
    Schedulable call = mockCall(""c"", 0);
    assertTrue(fcq.offer(call));

    assertEquals(call, fcq.poll(10, TimeUnit.MILLISECONDS));

    assertEquals(0, fcq.size());
  }",No Smells
"@Test
  public void testPollTimeout() throws InterruptedException {
    assertNull(fcq.poll(10, TimeUnit.MILLISECONDS));
  }",No Smells
"@Test
  public void testTakeRemovesCall() throws InterruptedException {
    Schedulable call = mockCall(""c"");
    fcq.offer(call);

    assertEquals(call, fcq.take());
    assertEquals(0, fcq.size());
  }",No Smells
"@Test
  public void testSimple() throws Exception {
    Configuration conf = new Configuration();
    conf.set(""hadoop.security.authentication"", ""simple"");
    MiniRPCBenchmark mb = new MiniRPCBenchmark(Level.DEBUG);
    mb.runMiniBenchmark(conf, 10, null, null);
  }",No Smells
"@Test
  public void testLongOperationsSuccessful() throws Exception {
    // Test long successful operations
    // There is no entry in cache expected when the first operation starts
    testOperations(r.nextInt(), 100, 20, true, false, newCall());
  }",Eager Test
"@Test
  public void testRpcMetrics() throws Exception {
    final Server server;
    TestRpcService proxy = null;

    final int interval = 1;
    conf.setBoolean(CommonConfigurationKeys.
        RPC_METRICS_QUANTILE_ENABLE, true);
    conf.set(CommonConfigurationKeys.
        RPC_METRICS_PERCENTILES_INTERVALS_KEY, """" + interval);

    server = setupTestServer(conf, 5);
    String testUser = ""testUser"";
    UserGroupInformation anotherUser =
        UserGroupInformation.createRemoteUser(testUser);
    TestRpcService proxy2 =
        anotherUser.doAs(new PrivilegedAction<TestRpcService>() {
          public TestRpcService run() {
            try {
              return RPC.getProxy(TestRpcService.class, 0,
                  server.getListenerAddress(), conf);
            }",Eager Test
"@Test
  public void testServerAddress() throws IOException {
    Server server;

    server = setupTestServer(conf, 5);
    try {
      InetSocketAddress bindAddr = NetUtils.getConnectAddress(server);
      assertEquals(InetAddress.getLocalHost(), bindAddr.getAddress());
    }",Eager Test
"@Test
  public void testStopProxy() throws IOException {
    RPC.setProtocolEngine(conf,
        StoppedProtocol.class, StoppedRpcEngine.class);

    StoppedProtocol proxy = RPC.getProxy(StoppedProtocol.class,
        StoppedProtocol.versionID, null, conf);
    StoppedInvocationHandler invocationHandler = (StoppedInvocationHandler)
        Proxy.getInvocationHandler(proxy);
    assertEquals(0, invocationHandler.getCloseCalled());
    RPC.stopProxy(proxy);
    assertEquals(1, invocationHandler.getCloseCalled());
  }",Eager Test
"@Test
  public void testBufferWrapperNested() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    DataOutputStream dos = new DataOutputStream(baos);
    writable.write(dos);
    message1.writeDelimitedTo(dos);
    message2.writeDelimitedTo(dos);
    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
    RpcWritable.Buffer buf1 = RpcWritable.Buffer.wrap(bb);
    Assert.assertEquals(baos.size(), bb.remaining());
    Assert.assertEquals(baos.size(), buf1.remaining());

    Object actual = buf1.newInstance(LongWritable.class, null);
    Assert.assertEquals(writable, actual);
    int left = bb.remaining();
    Assert.assertTrue(left > 0);
    Assert.assertEquals(left, buf1.remaining());

    // original bb now appears empty, but rpc writable has a slice of the bb.
    RpcWritable.Buffer buf2 = buf1.newInstance(RpcWritable.Buffer.class, null);
    Assert.assertEquals(0, bb.remaining());
    Assert.assertEquals(0, buf1.remaining());
    Assert.assertEquals(left, buf2.remaining());

    actual = buf2.getValue(EchoRequestProto.getDefaultInstance());
    Assert.assertEquals(message1, actual);
    Assert.assertTrue(buf2.remaining() > 0);

    actual = buf2.getValue(EchoRequestProto.getDefaultInstance());
    Assert.assertEquals(message2, actual);
    Assert.assertEquals(0, buf2.remaining());
  }",Mystery Guest
"@Test
  public void testWritableWrapper() throws IOException {
    // serial writable in byte buffer
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    writable.write(new DataOutputStream(baos));
    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());

    // deserial
    LongWritable actual = RpcWritable.wrap(new LongWritable())
        .readFrom(bb);
    Assert.assertEquals(writable, actual);
    Assert.assertEquals(0, bb.remaining());
  }",Mystery Guest
"@Test
  public void testBindError() throws Exception {
    Configuration conf = new Configuration();
    ServerSocket socket = new ServerSocket();
    InetSocketAddress address = new InetSocketAddress(""0.0.0.0"",0);
    socket.bind(address);
    try {
      int min = socket.getLocalPort();
      conf.set(""TestRange"", min+""-""+min);
      

      ServerSocket socket2 = new ServerSocket();
      InetSocketAddress address2 = new InetSocketAddress(""0.0.0.0"", 0);
      boolean caught = false;
      try {
        Server.bind(socket2, address2, 10, conf, ""TestRange"");
      }",No Smells
"@Test
  public void testLegalInstantiation() {
    Configuration conf = new Configuration();
    conf.setStrings(""namespace."" + IPC_CALLQUEUE_WRRMUX_WEIGHTS_KEY,
      ""1"", ""2"", ""3"");

    // ask for 3 weights with 3 queues
    mux = new WeightedRoundRobinMultiplexer(3, ""namespace."", conf);
  }",No Smells
"@Test
  public void testMissingHostname() throws Exception {
    ServletRequest request = Mockito.mock(ServletRequest.class);
    Mockito.when(request.getRemoteAddr()).thenReturn(null);

    ServletResponse response = Mockito.mock(ServletResponse.class);

    final AtomicBoolean invoked = new AtomicBoolean();

    FilterChain chain = new FilterChain() {
      @Override
      public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse)
        throws IOException, ServletException {
        assertTrue(HostnameFilter.get().contains(""???""));
        invoked.set(true);
      }",No Smells
"@Test
  public void test() throws Exception {
    InputStream is = new ByteArrayInputStream(""abc"".getBytes());
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    InputStreamEntity i = new InputStreamEntity(is);
    i.write(baos);
    baos.close();
    assertEquals(new String(baos.toByteArray()), ""abc"");

    is = new ByteArrayInputStream(""abc"".getBytes());
    baos = new ByteArrayOutputStream();
    i = new InputStreamEntity(is, 1, 1);
    i.write(baos);
    baos.close();
    assertEquals(baos.toByteArray()[0], 'b');
  }",No Smells
"@Test
  public void testBoolean() throws Exception {
    Param<Boolean> param = new BooleanParam(""b"", false) {
    }",No Smells
"@Test
  public void testShort() throws Exception {
    Param<Short> param = new ShortParam(""S"", (short) 1) {
    }",No Smells
"@Test
  public void testString() throws Exception {
    Param<String> param = new StringParam(""s"", ""foo"") {
    }",No Smells
"@Test
  public void testBasicLogging() {
    assertTrue(helper.record().shouldLog());

    for (int i = 0; i < 5; i++) {
      timer.advance(LOG_PERIOD / 10);
      assertFalse(helper.record().shouldLog());
    }",Eager Test
"@Test
  public void testMultipleLoggersWithValues() {
    helper = new LogThrottlingHelper(LOG_PERIOD, ""foo"", timer);

    assertTrue(helper.record(""foo"", 0).shouldLog());
    assertTrue(helper.record(""bar"", 0, 2).shouldLog());
    assertTrue(helper.record(""baz"", 0, 3, 3).shouldLog());

    // ""bar""/""baz"" should not log yet because ""foo"" hasn't been triggered
    assertFalse(helper.record(""bar"", LOG_PERIOD, 2).shouldLog());
    assertFalse(helper.record(""baz"", LOG_PERIOD, 3, 3).shouldLog());

    // All should log once the period has elapsed
    LogAction foo = helper.record(""foo"", LOG_PERIOD);
    LogAction bar = helper.record(""bar"", LOG_PERIOD, 2);
    LogAction baz = helper.record(""baz"", LOG_PERIOD, 3, 3);
    assertTrue(foo.shouldLog());
    assertTrue(bar.shouldLog());
    assertTrue(baz.shouldLog());
    assertEquals(1, foo.getCount());
    assertEquals(2, bar.getCount());
    assertEquals(2, baz.getCount());
    assertEquals(2.0, bar.getStats(0).getMean(), 0.01);
    assertEquals(3.0, baz.getStats(0).getMean(), 0.01);
    assertEquals(3.0, baz.getStats(1).getMean(), 0.01);

    assertEquals(2.0, helper.getCurrentStats(""bar"", 0).getMax(), 0);
    assertEquals(3.0, helper.getCurrentStats(""baz"", 0).getMax(), 0);
  }",No Smells
"@Test
  public void testPool() throws Exception {
    final Random r = new Random();
    final Configuration conf = new Configuration();
    conf.setLong(FilePool.GRIDMIX_MIN_FILE, 3 * 1024);
    final FilePool pool = new FilePool(conf, base);
    pool.refresh();
    final ArrayList<FileStatus> files = new ArrayList<FileStatus>();

    // ensure 1k, 2k files excluded
    final int expectedPoolSize = (NFILES / 2 * (NFILES / 2 + 1) - 6) * 1024;
    assertEquals(expectedPoolSize, pool.getInputFiles(Long.MAX_VALUE, files));
    assertEquals(NFILES - 4, files.size());

    // exact match
    files.clear();
    assertEquals(expectedPoolSize, pool.getInputFiles(expectedPoolSize, files));

    // match random within 12k
    files.clear();
    final long rand = r.nextInt(expectedPoolSize);
    assertTrue(""Missed: "" + rand,
        (NFILES / 2) * 1024 > rand - pool.getInputFiles(rand, files));

    // all files
    conf.setLong(FilePool.GRIDMIX_MIN_FILE, 0);
    pool.refresh();
    files.clear();
    assertEquals((NFILES / 2 * (NFILES / 2 + 1)) * 1024,
        pool.getInputFiles(Long.MAX_VALUE, files));
  }",Mystery Guest
"@Test
  public void testStriper() throws Exception {
    final Random r = new Random();
    final Configuration conf = new Configuration();
    final FileSystem fs = FileSystem.getLocal(conf).getRaw();
    conf.setLong(FilePool.GRIDMIX_MIN_FILE, 3 * 1024);
    final FilePool pool = new FilePool(conf, base) {
      @Override
      public BlockLocation[] locationsFor(FileStatus stat, long start, long len)
          throws IOException {
        return new BlockLocation[] { new BlockLocation() }",Mystery Guest
"@Test
  public void testRepeat() throws Exception {
    final Configuration conf = new Configuration();
    Arrays.fill(loc, """");
    Arrays.fill(start, 0L);
    Arrays.fill(len, BLOCK);

    final ByteArrayOutputStream out = fillVerif();
    final FileQueue q =
      new FileQueue(new CombineFileSplit(paths, start, len, loc), conf);
    final byte[] verif = out.toByteArray();
    final byte[] check = new byte[2 * NFILES * BLOCK];
    q.read(check, 0, NFILES * BLOCK);
    assertArrayEquals(verif, Arrays.copyOf(check, NFILES * BLOCK));

    final byte[] verif2 = new byte[2 * NFILES * BLOCK];
    System.arraycopy(verif, 0, verif2, 0, verif.length);
    System.arraycopy(verif, 0, verif2, verif.length, verif.length);
    q.read(check, 0, 2 * NFILES * BLOCK);
    assertArrayEquals(verif2, check);

  }",Mystery Guest
"@Test
  public void testPseudoLocalFsFileNames() throws IOException {
    PseudoLocalFs pfs = new PseudoLocalFs();
    Configuration conf = new Configuration();
    conf.setClass(""fs.pseudo.impl"", PseudoLocalFs.class, FileSystem.class);

    Path path = new Path(""pseudo:///myPsedoFile.1234"");
    FileSystem testFs = path.getFileSystem(conf);
    assertEquals(""Failed to obtain a pseudo local file system object from path"",
                 pfs.getUri().getScheme(), testFs.getUri().getScheme());

    // Validate PseudoLocalFS operations on URI of some other file system
    path = new Path(""file:///myPsedoFile.12345"");
    validateGetFileStatus(pfs, path, false);
    validateCreate(pfs, path, false);
    validateOpen(pfs, path, false);
    validateExists(pfs, path, false);

    path = new Path(""pseudo:///myPsedoFile"");//.<fileSize> missing
    validateGetFileStatus(pfs, path, false);
    validateCreate(pfs, path, false);
    validateOpen(pfs, path, false);
    validateExists(pfs, path, false);

    // thing after final '.' is not a number
    path = new Path(""pseudo:///myPsedoFile.txt"");
    validateGetFileStatus(pfs, path, false);
    validateCreate(pfs, path, false);
    validateOpen(pfs, path, false);
    validateExists(pfs, path, false);

    // Generate valid file name(relative path) and validate operations on it
    long fileSize = 231456;
    path = PseudoLocalFs.generateFilePath(""my.Psedo.File"", fileSize);
    // Validate the above generateFilePath()
    assertEquals(""generateFilePath() failed."", fileSize,
                 pfs.validateFileNameFormat(path));

    validateGetFileStatus(pfs, path, true);
    validateCreate(pfs, path, true);
    validateOpen(pfs, path, true);
    validateExists(pfs, path, true);

    // Validate operations on valid qualified path
    path = new Path(""myPsedoFile.1237"");
    path = pfs.makeQualified(path);
    validateGetFileStatus(pfs, path, true);
    validateCreate(pfs, path, true);
    validateOpen(pfs, path, true);
    validateExists(pfs, path, true);
  }",Mystery Guest
"@Test
  public void testRandomTextDataGenerator() {
    RandomTextDataGenerator rtdg = new RandomTextDataGenerator(10, 0L, 5);
    List<String> words = rtdg.getRandomWords();

    // check the size
    assertEquals(""List size mismatch"", 10, words.size());

    // check the words
    Set<String> wordsSet = new HashSet<String>(words);
    assertEquals(""List size mismatch due to duplicates"", 10, wordsSet.size());

    // check the word lengths
    for (String word : wordsSet) {
      assertEquals(""Word size mismatch"", 5, word.length());
    }",Eager Test
"@Test
  public void testZero() throws Exception {
    final Random r = new Random();
    final long targetBytes = r.nextInt(1 << 20);
    testFactory(targetBytes, 0);
  }",No Smells
"@Test
  public void testRandomLocation() throws Exception {
    UserGroupInformation ugi = UserGroupInformation.getLoginUser();

    testRandomLocation(1, 10, ugi);
    testRandomLocation(2, 10, ugi);
  }",No Smells
"@Test
  public void testWideTuple() throws Exception {
    Text emptyText = new Text(""Should be empty"");
    Writable[] values = new Writable[64];
    Arrays.fill(values,emptyText);
    values[42] = new Text(""Number 42"");
                                     
    TupleWritable tuple = new TupleWritable(values);
    tuple.setWritten(42);
    
    for (int pos=0; pos<tuple.size();pos++) {
      boolean has = tuple.has(pos);
      if (pos == 42) {
        assertTrue(has);
      }",Eager Test
"@Test
  public void testCollect() throws IOException {
    this.handler = new NativeCollectorOnlyHandler(taskContext, nativeHandler, pusher, combiner);
    handler.collect(new BytesWritable(), new BytesWritable(), 100);
    handler.close();
    handler.close();

    Mockito.verify(pusher, Mockito.times(1)).collect(any(BytesWritable.class),
        any(BytesWritable.class), anyInt());

    Mockito.verify(pusher, Mockito.times(1)).close();
    Mockito.verify(combiner, Mockito.times(1)).close();
    Mockito.verify(nativeHandler, Mockito.times(1)).close();
  }",Mystery Guest
"@Test
  public void testGetCombiner() throws IOException {
    this.handler = new NativeCollectorOnlyHandler(taskContext, nativeHandler, pusher, combiner);
    Mockito.when(combiner.getId()).thenReturn(100L);
    final ReadWriteBuffer result = handler.onCall(
      NativeCollectorOnlyHandler.GET_COMBINE_HANDLER, null);
    Assert.assertEquals(100L, result.readLong());
  }",No Smells
"@Test
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }",No Smells
"@Test
  public void testSerializeNoFlush() throws IOException {
    final DataOutputStream dataOut = Mockito.mock(DataOutputStream.class);

    // suppose there are enough space
    Mockito.when(dataOut.hasUnFlushedData()).thenReturn(true);
    Mockito.when(dataOut.shortOfSpace(anyInt())).thenReturn(false);
    final int written = serializer.serializeKV(dataOut, key, value);

    // flush 0, write 4 int, and 2 byte array
    Mockito.verify(dataOut, Mockito.times(0)).flush();
    Mockito.verify(dataOut, Mockito.times(4)).writeInt(anyInt());
    Mockito.verify(dataOut, Mockito.times(2)).write(any(byte[].class),
        anyInt(), anyInt());

    Assert.assertEquals(written, key.length + value.length + Constants.SIZEOF_KV_LENGTH);
  }",No Smells
"@Test
  public void testBytesIntConversion() {
    final int a = 1000;
    final byte[] intBytes = Ints.toByteArray(a);

    Assert.assertEquals(a, BytesUtil.toInt(intBytes, 0));
  }",No Smells
"@Test
  public void testNoRetryOnAMAuthorizationException() throws Exception {
    if (!isAMReachableFromClient) {
      return;
    }",No Smells
"@Test
  public void testUserMRComparator() throws Exception {
    conf.setMapperClass(IdentityMapper.class);
    conf.setReducerClass(DescendingKeysReducer.class);
    conf.setOutputKeyComparatorClass(DecreasingIntComparator.class);
    
    RunningJob r_job = jc.submitJob(conf);
    while (!r_job.isComplete()) {
      Thread.sleep(1000);
    }",Eager Test
"@Test
  public void testIgnoreDirs() throws Exception {
    Configuration conf = getConfiguration();
    conf.setBoolean(FileInputFormat.INPUT_DIR_NONRECURSIVE_IGNORE_SUBDIRS, true);
    conf.setInt(FileInputFormat.LIST_STATUS_NUM_THREADS, numThreads);
    conf.set(org.apache.hadoop.mapreduce.lib.input.FileInputFormat.INPUT_DIR, ""test:///a1"");
    MockFileSystem mockFs = (MockFileSystem) new Path(""test:///"").getFileSystem(conf);
    JobConf job = new JobConf(conf);
    TextInputFormat fileInputFormat = new TextInputFormat();
    fileInputFormat.configure(job);
    InputSplit[] splits = fileInputFormat.getSplits(job, 1);
    Assert.assertEquals(""Input splits are not correct"", 1, splits.length);
    FileSystem.closeAll();
  }",Mystery Guest
"@Test
  public void testListStatusSimple() throws IOException {
    Configuration conf = new Configuration();
    conf.setInt(FileInputFormat.LIST_STATUS_NUM_THREADS, numThreads);

    List<Path> expectedPaths = org.apache.hadoop.mapreduce.lib.input.TestFileInputFormat
        .configureTestSimple(conf, localFs);

    JobConf jobConf = new JobConf(conf);
    TextInputFormat fif = new TextInputFormat();
    fif.configure(jobConf);
    FileStatus[] statuses = fif.listStatus(jobConf);

    org.apache.hadoop.mapreduce.lib.input.TestFileInputFormat
        .verifyFileStatuses(expectedPaths, Lists.newArrayList(statuses),
            localFs);
  }",Mystery Guest
"@Test
  public void testFailAbortV1() throws Exception {
    testFailAbortInternal(1);
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testMapOnlyNoOutputV2() throws Exception {
    testMapOnlyNoOutputInternal(2);
  }",Mystery Guest
"@Test
  public void testRecoveryV2() throws Exception {
    testRecoveryInternal(2, 2);
  }",Eager Test + Mystery Guest
"@Test
  public void testBadIndex() throws Exception {
    final int parts = 30;
    fs.delete(p, true);
    conf.setInt(MRJobConfig.SHUFFLE_INDEX_CACHE, 1);
    IndexCache cache = new IndexCache(conf);

    Path f = new Path(p, ""badindex"");
    FSDataOutputStream out = fs.create(f, false);
    CheckedOutputStream iout = new CheckedOutputStream(out, new CRC32());
    DataOutputStream dout = new DataOutputStream(iout);
    for (int i = 0; i < parts; ++i) {
      for (int j = 0; j < MapTask.MAP_OUTPUT_INDEX_RECORD_LENGTH / 8; ++j) {
        if (0 == (i % 3)) {
          dout.writeLong(i);
        }",Eager Test + Mystery Guest
"@Test
  public void testRemoveMap() throws Exception {
    // This test case use two thread to call getIndexInformation and 
    // removeMap concurrently, in order to construct race condition.
    // This test case may not repeatable. But on my macbook this test 
    // fails with probability of 100% on code before MAPREDUCE-2541,
    // so it is repeatable in practice.
    fs.delete(p, true);
    conf.setInt(MRJobConfig.SHUFFLE_INDEX_CACHE, 10);
    // Make a big file so removeMapThread almost surely runs faster than 
    // getInfoThread 
    final int partsPerMap = 100000;
    final int bytesPerFile = partsPerMap * 24;
    final IndexCache cache = new IndexCache(conf);

    final Path big = new Path(p, ""bigIndex"");
    final String user = 
      UserGroupInformation.getCurrentUser().getShortUserName();
    writeFile(fs, big, bytesPerFile, partsPerMap);
    
    // run multiple times
    for (int i = 0; i < 20; ++i) {
      Thread getInfoThread = new Thread() {
        @Override
        public void run() {
          try {
            cache.getIndexInformation(""bigIndex"", partsPerMap, big, user);
          }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testGroups() {
    Map<JobACL, AccessControlList> tmpJobACLs = new HashMap<JobACL, AccessControlList>();
    Configuration conf = new Configuration();
    String jobOwner = ""testuser"";
    conf.set(JobACL.VIEW_JOB.getAclName(), jobOwner);
    conf.setBoolean(MRConfig.MR_ACLS_ENABLED, true);
    String user = ""testuser2"";
    String adminGroup = ""adminGroup"";
    conf.set(MRConfig.MR_ADMINS, "" "" + adminGroup);

    JobACLsManager aclsManager = new JobACLsManager(conf);
    tmpJobACLs = aclsManager.constructJobACLs(conf);
    final Map<JobACL, AccessControlList> jobACLs = tmpJobACLs;

    UserGroupInformation callerUGI = UserGroupInformation.createUserForTesting(
     user, new String[] {adminGroup}",No Smells
"@Test
  public void testGetClusterStatusWithLocalJobRunner() throws Exception {
    Configuration conf = new Configuration();
    conf.set(JTConfig.JT_IPC_ADDRESS, MRConfig.LOCAL_FRAMEWORK_NAME);
    conf.set(MRConfig.FRAMEWORK_NAME, MRConfig.LOCAL_FRAMEWORK_NAME);
    JobClient client = new JobClient(conf);
    ClusterStatus clusterStatus = client.getClusterStatus(true);
    Collection<String> activeTrackerNames = clusterStatus
        .getActiveTrackerNames();
    assertEquals(0, activeTrackerNames.size());
    int blacklistedTrackers = clusterStatus.getBlacklistedTrackers();
    assertEquals(0, blacklistedTrackers);
    Collection<BlackListInfo> blackListedTrackersInfo = clusterStatus
        .getBlackListedTrackersInfo();
    assertEquals(0, blackListedTrackersInfo.size());
  }",No Smells
"@Test
  public void testLocalJobRunnerUriSubstitution() throws InterruptedException {
    JobStatus jobStatus = createTestJobStatus(
        ""job_20130313155005308_0001"", JobStatus.SUCCEEDED);
    JobConf jobConf = createTestJobConf(
        new Configuration(), 0,
        baseUrl + ""jobend?jobid=$jobId&status=$jobStatus"");
    JobEndNotifier.localRunnerNotification(jobConf, jobStatus);

    // No need to wait for the notification to go through since calls are
    // synchronous

    // Validate params
    assertEquals(1, JobEndServlet.calledTimes);
    assertEquals(""jobid=job_20130313155005308_0001&status=SUCCEEDED"",
        JobEndServlet.requestUri.getQuery());
  }",No Smells
"@Test
  public void testComplexName() throws Exception {
    OutputStream os = getFileSystem().create(new Path(getInputDir(),
        ""text.txt""));
    Writer wr = new OutputStreamWriter(os);
    wr.write(""b a\n"");
    wr.close();

    JobConf conf = createJobConf();
    conf.setJobName(""[name][some other value that gets truncated internally that this test attempts to aggravate]"");

    conf.setInputFormat(TextInputFormat.class);

    conf.setOutputKeyClass(LongWritable.class);
    conf.setOutputValueClass(Text.class);

    conf.setMapperClass(IdentityMapper.class);

    FileInputFormat.setInputPaths(conf, getInputDir());

    FileOutputFormat.setOutputPath(conf, getOutputDir());

    JobClient.runJob(conf);

    Path[] outputFiles = FileUtil.stat2Paths(
                           getFileSystem().listStatus(getOutputDir(),
                           new Utils.OutputFileUtils.OutputFilesFilter()));
    assertEquals(1, outputFiles.length);
    InputStream is = getFileSystem().open(outputFiles[0]);
    BufferedReader reader = new BufferedReader(new InputStreamReader(is));
    assertEquals(""0\tb a"", reader.readLine());
    assertNull(reader.readLine());
    reader.close();
  }",Mystery Guest
"@Test
  public void testNewLines() throws Exception {
    LineReader in = null;
    try {
      in = makeStream(""a\nbb\n\nccc\rdddd\r\neeeee"");
      Text out = new Text();
      in.readLine(out);
      assertEquals(""line1 length"", 1, out.getLength());
      in.readLine(out);
      assertEquals(""line2 length"", 2, out.getLength());
      in.readLine(out);
      assertEquals(""line3 length"", 0, out.getLength());
      in.readLine(out);
      assertEquals(""line4 length"", 3, out.getLength());
      in.readLine(out);
      assertEquals(""line5 length"", 4, out.getLength());
      in.readLine(out);
      assertEquals(""line5 length"", 5, out.getLength());
      assertEquals(""end of file"", 0, in.readLine(out));
    }",No Smells
"@Test
  public void testUTF8() throws Exception {
    LineReader in = null;

    try {
      in = makeStream(""abcd\u20acbdcd\u20ac"");
      Text line = new Text();
      in.readLine(line);
      assertEquals(""readLine changed utf8 characters"",
                   ""abcd\u20acbdcd\u20ac"", line.toString());
      in = makeStream(""abc\u200axyz"");
      in.readLine(line);
      assertEquals(""split on fake newline"", ""abc\u200axyz"", line.toString());
    }",No Smells
"@Test
  public void testBzipWithMultibyteDelimiter() throws IOException {
    String testFileName = ""compressedMultibyteDelimiter.txt.bz2"";
    // firstSplitLength < (headers + blockMarker) will pass always since no
    // records will be read (in the test file that is byte 0..9)
    // firstSplitlength > (compressed file length - one compressed block
    // size + 1) will also always pass since the second split will be empty
    // (833 bytes is the last block start in the used data file)
    int firstSplitLength = 100;
    URL testFileUrl = getClass().getClassLoader().getResource(testFileName);
    assertNotNull(""Cannot find "" + testFileName, testFileUrl);
    File testFile = new File(testFileUrl.getFile());
    long testFileSize = testFile.length();
    Path testFilePath = new Path(testFile.getAbsolutePath());
    assertTrue(""Split size is smaller than header length"",
        firstSplitLength > 9);
    assertTrue(""Split size is larger than compressed file size "" +
        testFilePath, testFileSize > firstSplitLength);

    Configuration conf = new Configuration();
    conf.setInt(org.apache.hadoop.mapreduce.lib.input.
        LineRecordReader.MAX_LINE_LENGTH, Integer.MAX_VALUE);

    String delimiter = ""<E-LINE>\r\r\n"";
    conf.set(""textinputformat.record.delimiter"", delimiter);
    testSplitRecordsForFile(conf, firstSplitLength, testFileSize,
        testFilePath);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testRecordSpanningMultipleSplits()
      throws IOException {
    checkRecordSpanningMultipleSplits(""recordSpanningMultipleSplits.txt"",
        10, false);
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testRecordSpanningMultipleSplitsCompressed()
      throws IOException {
    // The file is generated with bz2 block size of 100k. The split size
    // needs to be larger than that for the CompressedSplitLineReader to
    // work.
    checkRecordSpanningMultipleSplits(""recordSpanningMultipleSplits.txt.bz2"",
        200 * 1000, true);
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testRenameMapOutputForReduce() throws Exception {
    final JobConf conf = new JobConf();

    final MROutputFiles mrOutputFiles = new MROutputFiles();
    mrOutputFiles.setConf(conf);

    // make sure both dirs are distinct
    //
    conf.set(MRConfig.LOCAL_DIR, localDirs[0].toString());
    final Path mapOut = mrOutputFiles.getOutputFileForWrite(1);
    conf.set(MRConfig.LOCAL_DIR, localDirs[1].toString());
    final Path mapOutIdx = mrOutputFiles.getOutputIndexFileForWrite(1);
    Assert.assertNotEquals(""Paths must be different!"",
        mapOut.getParent(), mapOutIdx.getParent());

    // make both dirs part of LOCAL_DIR
    conf.setStrings(MRConfig.LOCAL_DIR, localDirs);

    final FileContext lfc = FileContext.getLocalFSFileContext(conf);
    lfc.create(mapOut, EnumSet.of(CREATE)).close();
    lfc.create(mapOutIdx, EnumSet.of(CREATE)).close();

    final JobId jobId = MRBuilderUtils.newJobId(12345L, 1, 2);
    final TaskId tid = MRBuilderUtils.newTaskId(jobId, 0, TaskType.MAP);
    final TaskAttemptId taid = MRBuilderUtils.newTaskAttemptId(tid, 0);

    LocalContainerLauncher.renameMapOutputForReduce(conf, taid, mrOutputFiles);
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testDuplicateDownload() throws Exception {
    JobID jobId = new JobID();
    JobConf conf = new JobConf();
    conf.setClass(""fs.mock.impl"", MockFileSystem.class, FileSystem.class);

    URI mockBase = new URI(""mock://test-nn1/"");
    when(mockfs.getUri()).thenReturn(mockBase);
    Path working = new Path(""mock://test-nn1/user/me/"");
    when(mockfs.getWorkingDirectory()).thenReturn(working);
    when(mockfs.resolvePath(any(Path.class))).thenAnswer(
        (Answer<Path>) args -> (Path) args.getArguments()[0]);

    final URI file = new URI(""mock://test-nn1/user/me/file.txt#link"");
    final Path filePath = new Path(file);
    File link = new File(""link"");

    when(mockfs.getFileStatus(any(Path.class))).thenAnswer(new Answer<FileStatus>() {
      @Override
      public FileStatus answer(InvocationOnMock args) throws Throwable {
        Path p = (Path) args.getArguments()[0];
        if (""file.txt"".equals(p.getName())) {
          return createMockTestFileStatus(filePath);
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
    public void testgetLocations() throws IOException{
        JobConf job= new JobConf();
      
      File tmpFile = File.createTempFile(""test"",""txt"");
      tmpFile.createNewFile();
      OutputStream out=new FileOutputStream(tmpFile);
      out.write(""tempfile"".getBytes());
      out.flush();
      out.close();
      Path[] path= {new Path(tmpFile.getAbsolutePath())}",Mystery Guest
"@Test
  public void testValueIterator() throws Exception {
    Path tmpDir = new Path(""build/test/test.reduce.task"");
    Configuration conf = new Configuration();
    for (Pair[] testCase: testCases) {
      runValueIterator(tmpDir, testCase, conf, null);
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testValueIteratorWithCompression() throws Exception {
    Path tmpDir = new Path(""build/test/test.reduce.task.compression"");
    Configuration conf = new Configuration();
    DefaultCodec codec = new DefaultCodec();
    codec.setConf(conf);
    for (Pair[] testCase: testCases) {
      runValueIterator(tmpDir, testCase, conf, codec);
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testPercentFilter() throws Exception {
    LOG.info(""Testing Percent Filter with frequency: 1000"");
    // set the filter class
    SequenceFileInputFilter.setFilterClass(job, 
                                           SequenceFileInputFilter.PercentFilter.class);
    SequenceFileInputFilter.PercentFilter.setFrequency(job, 1000);
      
    // clean input dir
    fs.delete(inDir, true);
    
    // for a variety of lengths
    for (int length = 0; length < MAX_LENGTH;
         length+= random.nextInt(MAX_LENGTH/10)+1) {
      LOG.info(""******Number of records: ""+length);
      createSequenceFile(length);
      int count = countRecords(1);
      LOG.info(""Accepted ""+count+"" records"");
      int expectedCount = length/1000;
      if (expectedCount*1000!=length)
        expectedCount++;
      assertThat(count).isEqualTo(expectedCount);
    }",Eager Test
"@Test
  public void testFormat() throws Exception {
    JobConf job = new JobConf(conf);
    FileSystem fs = FileSystem.getLocal(conf);
    Path dir = new Path(System.getProperty(""test.build.data"",""."") + ""/mapred"");
    Path file = new Path(dir, ""test.seq"");
    
    Reporter reporter = Reporter.NULL;
    
    int seed = new Random().nextInt();
    //LOG.info(""seed = ""+seed);
    Random random = new Random(seed);

    fs.delete(dir, true);

    FileInputFormat.setInputPaths(job, dir);

    // for a variety of lengths
    for (int length = 0; length < MAX_LENGTH;
         length+= random.nextInt(MAX_LENGTH/10)+1) {

      //LOG.info(""creating; entries = "" + length);

      // create a file with length entries
      SequenceFile.Writer writer =
        SequenceFile.createWriter(fs, conf, file,
                                  IntWritable.class, BytesWritable.class);
      try {
        for (int i = 0; i < length; i++) {
          IntWritable key = new IntWritable(i);
          byte[] data = new byte[random.nextInt(10)];
          random.nextBytes(data);
          BytesWritable value = new BytesWritable(data);
          writer.append(key, value);
        }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testRemove() {
    SortedRanges sr = new SortedRanges();
    sr.add(new Range(2,19));
    assertEquals(19, sr.getIndicesCount());
    
    sr.remove(new SortedRanges.Range(15,8));
    assertEquals(13, sr.getIndicesCount());
    
    sr.remove(new SortedRanges.Range(6,5));
    assertEquals(8, sr.getIndicesCount());
    
    sr.remove(new SortedRanges.Range(8,4));
    assertEquals(7, sr.getIndicesCount());
    
    sr.add(new Range(18,5));
    assertEquals(12, sr.getIndicesCount());
    
    sr.add(new Range(25,1));
    assertEquals(13, sr.getIndicesCount());
    
    sr.remove(new SortedRanges.Range(7,24));
    assertEquals(4, sr.getIndicesCount());
    
    sr.remove(new SortedRanges.Range(5,1));
    assertEquals(3, sr.getIndicesCount());
    
    LOG.debug(sr.toString());
  }",No Smells
"@Test
  public void testStatusUpdateDoesNotExitInUberMode() throws Exception {
    setupTest(true);

    task.statusUpdate(umbilical);
  }",Eager Test
"@Test
  public void testStatusUpdateFromUnregisteredTask() throws Exception {
    configureMocks();
    ControlledClock clock = new ControlledClock();
    clock.setTime(0);
    doReturn(clock).when(appCtx).getClock();

    final TaskAttemptListenerImpl tal = new TaskAttemptListenerImpl(appCtx,
        secret, rmHeartbeatHandler, policy) {
      @Override
      protected void startRpcServer() {
        // Empty
      }",No Smells
"@Test
  public void testReduceTaskStatusStartAndFinishTimes() {
    checkTaskStatues(false);
  }",Eager Test
"@Test
  public void testFormat() throws Exception {
    JobConf job = new JobConf();
    job.set(JobContext.TASK_ATTEMPT_ID, attempt);
    FileOutputFormat.setOutputPath(job, workDir.getParent().getParent());
    FileOutputFormat.setWorkOutputPath(job, workDir);
    FileSystem fs = workDir.getFileSystem(job);
    if (!fs.mkdirs(workDir)) {
      fail(""Failed to create output directory"");
    }",Eager Test + Mystery Guest
"@Test
  public void testResourceRequestLocalityInvalid() throws Exception {
    try {
      verifyResourceRequestLocality(""rack/node1"", null,
          new ResourceRequest[]{}",Eager Test
"@Test
  public void testSendJobConf() throws IOException {
    JobConf jobConf = new JobConf();
    jobConf.set(""dfs.nameservices"", ""mycluster1,mycluster2"");
    jobConf.set(""dfs.namenode.rpc-address.mycluster2.nn1"", ""123.0.0.1"");
    jobConf.set(""dfs.namenode.rpc-address.mycluster2.nn2"", ""123.0.0.2"");
    jobConf.set(""dfs.ha.namenodes.mycluster2"", ""nn1,nn2"");
    jobConf.set(""dfs.client.failover.proxy.provider.mycluster2"", ""provider"");
    jobConf.set(""hadoop.tmp.dir"", ""testconfdir"");
    jobConf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,
        ""kerberos"");
    jobConf.set(""mapreduce.job.send-token-conf"",
        ""dfs.nameservices|^dfs.namenode.rpc-address.*$|^dfs.ha.namenodes.*$""
            + ""|^dfs.client.failover.proxy.provider.*$""
            + ""|dfs.namenode.kerberos.principal"");
    UserGroupInformation.setConfiguration(jobConf);

    YARNRunner yarnRunner = new YARNRunner(jobConf);
    ApplicationSubmissionContext submissionContext =
        buildSubmitContext(yarnRunner, jobConf);
    Configuration confSent = BuilderUtils.parseTokensConf(submissionContext);

    // configs that match regex should be included
    Assert.assertEquals(""123.0.0.1"",
        confSent.get(""dfs.namenode.rpc-address.mycluster2.nn1""));
    Assert.assertEquals(""123.0.0.2"",
        confSent.get(""dfs.namenode.rpc-address.mycluster2.nn2""));

    // configs that aren't matching regex should not be included
    Assert.assertTrue(confSent.get(""hadoop.tmp.dir"") == null || !confSent
        .get(""hadoop.tmp.dir"").equals(""testconfdir""));
    UserGroupInformation.reset();
  }",No Smells
"@Test
  public void testCheckpointCreateDirect() throws Exception {
    checkpointCreate(ByteBuffer.allocateDirect(BUFSIZE));
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testDetermineCacheVisibilities() throws IOException {
    fs.setPermission(TEST_VISIBILITY_PARENT_DIR,
        new FsPermission((short)00777));
    fs.setPermission(TEST_VISIBILITY_CHILD_DIR,
        new FsPermission((short)00777));
    fs.setWorkingDirectory(TEST_VISIBILITY_CHILD_DIR);
    Job job = Job.getInstance(conf);
    Path relativePath = new Path(SECOND_CACHE_FILE);
    Path wildcardPath = new Path(""*"");
    Map<URI, FileStatus> statCache = new HashMap<>();
    Configuration jobConf;

    job.addCacheFile(firstCacheFile.toUri());
    job.addCacheFile(relativePath.toUri());
    jobConf = job.getConfiguration();

    // skip test if scratch dir is not PUBLIC
    assumeTrue(TEST_VISIBILITY_PARENT_DIR + "" is not public"",
        ClientDistributedCacheManager.isPublic(
            jobConf, TEST_VISIBILITY_PARENT_DIR.toUri(), statCache));

    ClientDistributedCacheManager.determineCacheVisibilities(jobConf,
        statCache);
    // We use get() instead of getBoolean() so we can tell the difference
    // between wrong and missing
    assertEquals(""The file paths were not found to be publicly visible ""
        + ""even though the full path is publicly accessible"",
        ""true,true"", jobConf.get(MRJobConfig.CACHE_FILE_VISIBILITIES));
    checkCacheEntries(statCache, null, firstCacheFile, relativePath);

    job = Job.getInstance(conf);
    job.addCacheFile(wildcardPath.toUri());
    jobConf = job.getConfiguration();
    statCache.clear();

    ClientDistributedCacheManager.determineCacheVisibilities(jobConf,
        statCache);
    // We use get() instead of getBoolean() so we can tell the difference
    // between wrong and missing
    assertEquals(""The file path was not found to be publicly visible ""
        + ""even though the full path is publicly accessible"",
        ""true"", jobConf.get(MRJobConfig.CACHE_FILE_VISIBILITIES));
    checkCacheEntries(statCache, null, wildcardPath.getParent());

    Path qualifiedParent = fs.makeQualified(TEST_VISIBILITY_PARENT_DIR);
    fs.setPermission(TEST_VISIBILITY_PARENT_DIR,
        new FsPermission((short)00700));
    job = Job.getInstance(conf);
    job.addCacheFile(firstCacheFile.toUri());
    job.addCacheFile(relativePath.toUri());
    jobConf = job.getConfiguration();
    statCache.clear();

    ClientDistributedCacheManager.determineCacheVisibilities(jobConf,
        statCache);
    // We use get() instead of getBoolean() so we can tell the difference
    // between wrong and missing
    assertEquals(""The file paths were found to be publicly visible ""
        + ""even though the parent directory is not publicly accessible"",
        ""false,false"", jobConf.get(MRJobConfig.CACHE_FILE_VISIBILITIES));
    checkCacheEntries(statCache, qualifiedParent,
        firstCacheFile, relativePath);

    job = Job.getInstance(conf);
    job.addCacheFile(wildcardPath.toUri());
    jobConf = job.getConfiguration();
    statCache.clear();

    ClientDistributedCacheManager.determineCacheVisibilities(jobConf,
        statCache);
    // We use get() instead of getBoolean() so we can tell the difference
    // between wrong and missing
    assertEquals(""The file path was found to be publicly visible ""
        + ""even though the parent directory is not publicly accessible"",
        ""false"", jobConf.get(MRJobConfig.CACHE_FILE_VISIBILITIES));
    checkCacheEntries(statCache, qualifiedParent, wildcardPath.getParent());
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testPropertyRedactionForJHS() throws Exception {
    final Configuration conf = new Configuration();

    String sensitivePropertyName = ""aws.fake.credentials.name"";
    String sensitivePropertyValue = ""aws.fake.credentials.val"";
    conf.set(sensitivePropertyName, sensitivePropertyValue);
    conf.set(MRJobConfig.MR_JOB_REDACTED_PROPERTIES,
        sensitivePropertyName);
    conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY,
        dfsCluster.getURI().toString());
    final TestParams params = new TestParams();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR, params.dfsWorkDir);

    final JHEvenHandlerForTest jheh =
        new JHEvenHandlerForTest(params.mockAppContext, 0, false);

    try {
      jheh.init(conf);
      jheh.start();
      handleEvent(jheh, new JobHistoryEvent(params.jobId,
          new AMStartedEvent(params.appAttemptId, 200, params.containerId,
              ""nmhost"", 3000, 4000, -1)));
      handleEvent(jheh, new JobHistoryEvent(params.jobId,
          new JobUnsuccessfulCompletionEvent(TypeConverter.fromYarn(
              params.jobId), 0, 0, 0, 0, 0, 0, 0,
              JobStateInternal.FAILED.toString())));

      // verify the value of the sensitive property in job.xml is restored.
      assertThat(conf.get(sensitivePropertyName))
          .isEqualTo(sensitivePropertyValue)
          .withFailMessage(sensitivePropertyName + "" is modified."");

      // load the job_conf.xml in JHS directory and verify property redaction.
      Path jhsJobConfFile = getJobConfInIntermediateDoneDir(conf, params.jobId);
      Assert.assertTrue(""The job_conf.xml file is not in the JHS directory"",
          FileContext.getFileContext(conf).util().exists(jhsJobConfFile));
      Configuration jhsJobConf = new Configuration();

      try (InputStream input = FileSystem.get(conf).open(jhsJobConfFile)) {
        jhsJobConf.addResource(input);
        Assert.assertEquals(
            sensitivePropertyName + "" is not redacted in HDFS."",
            MRJobConfUtil.REDACTION_REPLACEMENT_VAL,
            jhsJobConf.get(sensitivePropertyName));
      }",No Smells
"@Test
  public void testDateSplits() throws Exception {
    Statement s = connection.createStatement();
    final String DATE_TABLE = ""datetable"";
    final String COL = ""foo"";
    try {
      // delete the table if it already exists.
      s.executeUpdate(""DROP TABLE "" + DATE_TABLE);
    }",No Smells
"@Test
  public void testEvenSplits() throws SQLException {
    List<Long> splits = new IntegerSplitter().split(10, 0, 100);
    long [] expected = { 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }",No Smells
"@Test
  public void testOddSplits() throws SQLException {
    List<Long> splits = new IntegerSplitter().split(10, 0, 95);
    long [] expected = { 0, 9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 95 }",No Smells
"@Test
  public void testSingletonSplit() throws SQLException {
    List<Long> splits = new IntegerSplitter().split(1, 5, 5);
    long [] expected = { 5, 5 }",No Smells
"@Test
  public void testCommonPrefix() throws SQLException {
    // Splits between 'Hand' and 'Hardy'
    TextSplitter splitter = new TextSplitter();
    List<String> splits = splitter.split(5, ""nd"", ""rdy"", ""Ha"");
    // Don't check for exact values in the middle, because the splitter generates some
    // ugly Unicode-isms. But do check that we get multiple splits and that it starts
    // and ends on the correct points.
    assertEquals(""Hand"", splits.get(0));
    assertEquals(""Hardy"", splits.get(splits.size() -1));
    assertEquals(6, splits.size());
  }",No Smells
"@Test
  public void testConvertStr() {
    TextSplitter splitter = new TextSplitter();
    String out = splitter.bigDecimalToString(splitter.stringToBigDecimal(""big str""));
    assertEquals(""big str"", out);
  }",No Smells
"@Test
  public void testStringConvertEmpty() {
    TextSplitter splitter = new TextSplitter();
    BigDecimal emptyBigDec = splitter.stringToBigDecimal("""");
    assertEquals(BigDecimal.ZERO, emptyBigDec);
  }",No Smells
"@Test
  public void testListLocatedStatus() throws Exception {
    Configuration conf = getConfiguration();
    conf.setBoolean(""fs.test.impl.disable.cache"", false);
    conf.setInt(FileInputFormat.LIST_STATUS_NUM_THREADS, numThreads);
    conf.set(org.apache.hadoop.mapreduce.lib.input.FileInputFormat.INPUT_DIR,
        ""test:///a1/a2"");
    MockFileSystem mockFs =
        (MockFileSystem) new Path(""test:///"").getFileSystem(conf);
    Assert.assertEquals(""listLocatedStatus already called"",
        0, mockFs.numListLocatedStatusCalls);
    JobConf job = new JobConf(conf);
    TextInputFormat fileInputFormat = new TextInputFormat();
    fileInputFormat.configure(job);
    InputSplit[] splits = fileInputFormat.getSplits(job, 1);
    Assert.assertEquals(""Input splits are not correct"", 2, splits.length);
    Assert.assertEquals(""listLocatedStatuss calls"",
        1, mockFs.numListLocatedStatusCalls);
    FileSystem.closeAll();
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testListStatusNestedRecursive() throws IOException {
    Configuration conf = new Configuration();
    conf.setInt(FileInputFormat.LIST_STATUS_NUM_THREADS, numThreads);

    List<Path> expectedPaths = org.apache.hadoop.mapreduce.lib.input.TestFileInputFormat
        .configureTestNestedRecursive(conf, localFs);
    JobConf jobConf = new JobConf(conf);
    TextInputFormat fif = new TextInputFormat();
    fif.configure(jobConf);
    FileStatus[] statuses = fif.listStatus(jobConf);

    org.apache.hadoop.mapreduce.lib.input.TestFileInputFormat
        .verifyFileStatuses(expectedPaths, Lists.newArrayList(statuses),
            localFs);
  }",Eager Test + Mystery Guest
"@Test
  public void testMultipleClose() throws IOException {
    URL testFileUrl = getClass().getClassLoader().
        getResource(""recordSpanningMultipleSplits.txt.bz2"");
    assertNotNull(""Cannot find recordSpanningMultipleSplits.txt.bz2"",
        testFileUrl);
    File testFile = new File(testFileUrl.getFile());
    Path testFilePath = new Path(testFile.getAbsolutePath());
    long testFileSize = testFile.length();
    Configuration conf = new Configuration();
    conf.setInt(org.apache.hadoop.mapreduce.lib.input.
        LineRecordReader.MAX_LINE_LENGTH, Integer.MAX_VALUE);
    FileSplit split = new FileSplit(testFilePath, 0, testFileSize,
        (String[])null);

    LineRecordReader reader = new LineRecordReader(conf, split);
    LongWritable key = new LongWritable();
    Text value = new Text();
    //noinspection StatementWithEmptyBody
    while (reader.next(key, value)) ;
    reader.close();
    reader.close();

    BZip2Codec codec = new BZip2Codec();
    codec.setConf(conf);
    Set<Decompressor> decompressors = new HashSet<Decompressor>();
    for (int i = 0; i < 10; ++i) {
      decompressors.add(CodecPool.getDecompressor(codec));
    }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testUncompressedInputWithLargeSplitSize() throws Exception {
    Configuration conf = new Configuration();
    // single char delimiter
    String inputData = ""abcde +fghij+ klmno+pqrst+uvwxyz"";
    Path inputFile = createInputFile(conf, inputData);
    conf.set(""textinputformat.record.delimiter"", ""+"");
    // split size over max value of integer
    long longSplitSize = (long)Integer.MAX_VALUE + 1;
    for (int bufferSize = 1; bufferSize <= inputData.length(); bufferSize++) {
      conf.setInt(""io.file.buffer.size"", bufferSize);
      testLargeSplitRecordForFile(conf, longSplitSize, inputData.length(),
          inputFile);
    }",Eager Test + Mystery Guest
"@Test
  public void testUncompressedInputContainingCRLF() throws Exception {
    Configuration conf = new Configuration();
    String inputData = ""a\r\nb\rc\nd\r\n"";
    Path inputFile = createInputFile(conf, inputData);
    for(int bufferSize = 1; bufferSize <= inputData.length(); bufferSize++) {
      for(int splitSize = 1; splitSize < inputData.length(); splitSize++) {
        conf.setInt(""io.file.buffer.size"", bufferSize);
        testSplitRecordsForFile(conf, splitSize, inputData.length(), inputFile);
      }",Eager Test
"@Test
  public void testUncompressedInputCustomDelimiterPosValue()
      throws Exception {
    Configuration conf = new Configuration();
    conf.setInt(""io.file.buffer.size"", 10);
    conf.setInt(org.apache.hadoop.mapreduce.lib.input.
        LineRecordReader.MAX_LINE_LENGTH, Integer.MAX_VALUE);
    String inputData = ""abcdefghij++kl++mno"";
    Path inputFile = createInputFile(conf, inputData);
    String delimiter = ""++"";
    byte[] recordDelimiterBytes = delimiter.getBytes(StandardCharsets.UTF_8);
    // the first split must contain two records to make sure that it also pulls
    // in the record from the 2nd split
    int splitLength = 15;
    FileSplit split = new FileSplit(inputFile, 0, splitLength, (String[]) null);
    LineRecordReader reader = new LineRecordReader(conf, split,
        recordDelimiterBytes);
    LongWritable key = new LongWritable();
    Text value = new Text();
    // Get first record: ""abcdefghij""
    assertTrue(""Expected record got nothing"", reader.next(key, value));
    assertEquals(""Wrong length for record value"", 10, value.getLength());
    // Position should be 12 right after ""abcdefghij++""
    assertEquals(""Wrong position after record read"", 12, reader.getPos());
    // Get second record: ""kl""
    assertTrue(""Expected record got nothing"", reader.next(key, value));
    assertEquals(""Wrong length for record value"", 2, value.getLength());
    // Position should be 16 right after ""abcdefghij++kl++""
    assertEquals(""Wrong position after record read"", 16, reader.getPos());
    // Get third record: ""mno""
    assertTrue(""Expected record got nothing"", reader.next(key, value));
    assertEquals(""Wrong length for record value"", 3, value.getLength());
    // Position should be 19 right after ""abcdefghij++kl++mno""
    assertEquals(""Wrong position after record read"", 19, reader.getPos());
    assertFalse(reader.next(key, value));
    assertEquals(""Wrong position after record read"", 19, reader.getPos());
    reader.close();
    // No record is in the second split because the second split will drop
    // the first record, which was already reported by the first split.
    split = new FileSplit(inputFile, splitLength,
        inputData.length() - splitLength, (String[]) null);
    reader = new LineRecordReader(conf, split, recordDelimiterBytes);
    // The position should be 19 right after ""abcdefghij++kl++mno"" and should
    // not change
    assertEquals(""Wrong position after record read"", 19, reader.getPos());
    assertFalse(""Unexpected record returned"", reader.next(key, value));
    assertEquals(""Wrong position after record read"", 19, reader.getPos());
    reader.close();

    // multi char delimiter with starting part of the delimiter in the data
    inputData = ""abcd+efgh++ijk++mno"";
    inputFile = createInputFile(conf, inputData);
    splitLength = 5;
    split = new FileSplit(inputFile, 0, splitLength, (String[]) null);
    reader = new LineRecordReader(conf, split, recordDelimiterBytes);
    // Get first record: ""abcd+efgh""
    assertTrue(""Expected record got nothing"", reader.next(key, value));
    assertEquals(""Wrong position after record read"", 11, reader.getPos());
    assertEquals(""Wrong length for record value"", 9, value.getLength());
    // should have jumped over the delimiter, no record
    assertFalse(""Unexpected record returned"", reader.next(key, value));
    assertEquals(""Wrong position after record read"", 11, reader.getPos());
    reader.close();
    // next split: check for duplicate or dropped records
    split = new FileSplit(inputFile, splitLength,
        inputData.length() - splitLength, (String[]) null);
    reader = new LineRecordReader(conf, split, recordDelimiterBytes);
    // Get second record: ""ijk"" first in this split
    assertTrue(""Expected record got nothing"", reader.next(key, value));
    assertEquals(""Wrong position after record read"", 16, reader.getPos());
    assertEquals(""Wrong length for record value"", 3, value.getLength());
    // Get third record: ""mno"" second in this split
    assertTrue(""Expected record got nothing"", reader.next(key, value));
    assertEquals(""Wrong position after record read"", 19, reader.getPos());
    assertEquals(""Wrong length for record value"", 3, value.getLength());
    // should be at the end of the input
    assertFalse(reader.next(key, value));
    assertEquals(""Wrong position after record read"", 19, reader.getPos());
    reader.close();

    inputData = ""abcd|efgh|+|ij|kl|+|mno|pqr"";
    inputFile = createInputFile(conf, inputData);
    delimiter = ""|+|"";
    recordDelimiterBytes = delimiter.getBytes(StandardCharsets.UTF_8);
    // walking over the buffer and split sizes checks for proper processing
    // of the ambiguous bytes of the delimiter
    for (int bufferSize = 1; bufferSize <= inputData.length(); bufferSize++) {
      for (int splitSize = 1; splitSize < inputData.length(); splitSize++) {
        conf.setInt(""io.file.buffer.size"", bufferSize);
        split = new FileSplit(inputFile, 0, bufferSize, (String[]) null);
        reader = new LineRecordReader(conf, split, recordDelimiterBytes);
        // Get first record: ""abcd|efgh"" always possible
        assertTrue(""Expected record got nothing"", reader.next(key, value));
        assertThat(value.toString()).isEqualTo(""abcd|efgh"");
        assertEquals(""Wrong position after record read"", 9, value.getLength());
        // Position should be 12 right after ""|+|""
        int recordPos = 12;
        assertEquals(""Wrong position after record read"", recordPos,
            reader.getPos());
        // get the next record: ""ij|kl"" if the split/buffer allows it
        if (reader.next(key, value)) {
          // check the record info: ""ij|kl""
          assertThat(value.toString()).isEqualTo(""ij|kl"");
          // Position should be 20 right after ""|+|""
          recordPos = 20;
          assertEquals(""Wrong position after record read"", recordPos,
              reader.getPos());
        }",Eager Test + Mystery Guest
"@Test
  public void testAddInputPathWithMapper() {
    final JobConf conf = new JobConf();
    MultipleInputs.addInputPath(conf, new Path(""/foo""), TextInputFormat.class,
       MapClass.class);
    MultipleInputs.addInputPath(conf, new Path(""/bar""),
       KeyValueTextInputFormat.class, MapClass2.class);
    final Map<Path, InputFormat> inputs = MultipleInputs
       .getInputFormatMap(conf);
    final Map<Path, Class<? extends Mapper>> maps = MultipleInputs
       .getMapperTypeMap(conf);

    assertEquals(TextInputFormat.class, inputs.get(new Path(""/foo"")).getClass());
    assertEquals(KeyValueTextInputFormat.class, inputs.get(new Path(""/bar""))
       .getClass());
    assertEquals(MapClass.class, maps.get(new Path(""/foo"")));
    assertEquals(MapClass2.class, maps.get(new Path(""/bar"")));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testRuntimeExRun() throws Exception {
    run(false, true);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testMapFileOutputCommitterV1() throws Exception {
    testMapFileOutputCommitterInternal(1);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testRecoveryV1() throws Exception {
    testRecoveryInternal(1, 1);
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testFileOutputCommitterNullWorkPath() throws Throwable {
    TaskContext context = new TaskContext();
    context.setOutputCommitter(
        new SimpleCommitter(new Path(""/""), context, null));
    assertNull(FileOutputFormat.getWorkOutputPath(context));
  }",No Smells
"@Test
  public void testCommitterFactoryFallbackDefault() throws Throwable {
    createCommitterFactory(FileOutputCommitterFactory.class,
        HDFS_PATH,
        newBondedConfiguration());
  }",No Smells
"@Test
  public void testCommitterFallbackDefault() throws Throwable {
    createCommitter(FileOutputCommitter.class,
        HDFS_PATH,
        taskAttempt(newBondedConfiguration()));
  }",No Smells
"@Test
  public void testFileOutputFormatBinding() throws Throwable {
    Configuration conf = newBondedConfiguration();
    conf.set(FileOutputFormat.OUTDIR, HTTP_PATH.toUri().toString());
    TextOutputFormat<String, String> off = new TextOutputFormat<>();
    SimpleCommitter committer = (SimpleCommitter)
        off.getOutputCommitter(taskAttempt(conf));
    assertEquals(""Wrong output path from ""+ committer,
        HTTP_PATH,
        committer.getOutputPath());
  }",No Smells
"@Test
  public void testNamedCommitterFactory() throws Throwable {
    Configuration conf = new Configuration();
    // set up for the schema factory
    conf.set(COMMITTER_FACTORY_CLASS, NAMED_COMMITTER_FACTORY);
    conf.set(NAMED_COMMITTER_CLASS, SimpleCommitter.class.getName());
    SimpleCommitter sc = createCommitter(
        NamedCommitterFactory.class,
        SimpleCommitter.class, HDFS_PATH, conf);
    assertEquals(""Wrong output path from "" + sc,
        HDFS_PATH,
        sc.getOutputPath());
  }",No Smells
"@Test
  public void testCustomOffsets() {
    Configuration conf = new Configuration();
    BinaryComparable key1 = new BytesWritable(new byte[] { 1, 2, 3, 4, 5 }",No Smells
"@Test
  public void testLowerBound() {
    Configuration conf = new Configuration();
    BinaryPartitioner.setLeftOffset(conf, 0);
    BinaryPartitioner<?> partitioner = 
      ReflectionUtils.newInstance(BinaryPartitioner.class, conf);
    BinaryComparable key1 = new BytesWritable(new byte[] { 1, 2, 3, 4, 5 }",No Smells
"@Test
  public void testUpperBound() {
    Configuration conf = new Configuration();
    BinaryPartitioner.setRightOffset(conf, 4);
    BinaryPartitioner<?> partitioner = 
      ReflectionUtils.newInstance(BinaryPartitioner.class, conf);
    BinaryComparable key1 = new BytesWritable(new byte[] { 1, 2, 3, 4, 5 }",No Smells
"@Test
  public void testCleanUpTokenReferral() throws Exception {
    Configuration conf = new Configuration();
    conf.set(MRJobConfig.MAPREDUCE_JOB_CREDENTIALS_BINARY, ""foo"");
    TokenCache.cleanUpTokenReferral(conf);
    assertNull(conf.get(MRJobConfig.MAPREDUCE_JOB_CREDENTIALS_BINARY));
  }",No Smells
"@Test
  public void testObtainTokens() throws Exception {
    Credentials credentials = new Credentials();
    FileSystem fs = mock(FileSystem.class);
    TokenCache.obtainTokensForNamenodesInternal(fs, credentials, conf, renewer);
    verify(fs).addDelegationTokens(eq(renewer), eq(credentials));
  }",No Smells
"@Test
  public void testCopyFromHostConnectionRejected() throws Exception {
    when(connection.getResponseCode())
        .thenReturn(Fetcher.TOO_MANY_REQ_STATUS_CODE);

    Fetcher<Text, Text> fetcher = new FakeFetcher<>(job, id, ss, mm, r, metrics,
        except, key, connection);
    fetcher.copyFromHost(host);

    assertThat(ss.hostFailureCount(host.getHostName()))
        .withFailMessage(""No host failure is expected."").isEqualTo(0);
    assertThat(ss.fetchFailureCount(map1ID))
        .withFailMessage(""No fetch failure is expected."").isEqualTo(0);
    assertThat(ss.fetchFailureCount(map2ID))
        .withFailMessage(""No fetch failure is expected."").isEqualTo(0);

    verify(ss).penalize(eq(host), anyLong());
    verify(ss).putBackKnownMapOutput(any(MapHost.class), eq(map1ID));
    verify(ss).putBackKnownMapOutput(any(MapHost.class), eq(map2ID));
  }",No Smells
"@Test
  public void testCopyFromHostExtraBytes() throws Exception {
    Fetcher<Text,Text> underTest = new FakeFetcher<Text,Text>(job, id, ss, mm,
        r, metrics, except, key, connection);

    String replyHash = SecureShuffleUtils.generateHash(encHash.getBytes(), key);

    when(connection.getResponseCode()).thenReturn(200);
    when(connection.getHeaderField(ShuffleHeader.HTTP_HEADER_NAME))
        .thenReturn(ShuffleHeader.DEFAULT_HTTP_HEADER_NAME);
    when(connection.getHeaderField(ShuffleHeader.HTTP_HEADER_VERSION))
        .thenReturn(ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION);
    when(connection.getHeaderField(
        SecureShuffleUtils.HTTP_HEADER_REPLY_URL_HASH)).thenReturn(replyHash);
    ShuffleHeader header = new ShuffleHeader(map1ID.toString(), 14, 10, 1);

    ByteArrayOutputStream bout = new ByteArrayOutputStream();
    DataOutputStream dos = new DataOutputStream(bout);
    IFileOutputStream ios = new IFileOutputStream(dos);
    header.write(dos);
    ios.write(""MAPDATA123"".getBytes());
    ios.finish();

    ShuffleHeader header2 = new ShuffleHeader(map2ID.toString(), 14, 10, 1);
    IFileOutputStream ios2 = new IFileOutputStream(dos);
    header2.write(dos);
    ios2.write(""MAPDATA456"".getBytes());
    ios2.finish();

    ByteArrayInputStream in = new ByteArrayInputStream(bout.toByteArray());
    when(connection.getInputStream()).thenReturn(in);
    // 8 < 10 therefore there appear to be extra bytes in the IFileInputStream
    IFileWrappedMapOutput<Text,Text> mapOut = new InMemoryMapOutput<Text, Text>(
        job, map1ID, mm, 8, null, true );
    IFileWrappedMapOutput<Text,Text> mapOut2 = new InMemoryMapOutput<Text, Text>(
        job, map2ID, mm, 10, null, true );

    when(mm.reserve(eq(map1ID), anyLong(), anyInt())).thenReturn(mapOut);
    when(mm.reserve(eq(map2ID), anyLong(), anyInt())).thenReturn(mapOut2);

    underTest.copyFromHost(host);

    verify(allErrs).increment(1);
    verify(ss).copyFailed(map1ID, host, true, false);
    verify(ss, never()).copyFailed(map2ID, host, true, false);

    verify(ss).putBackKnownMapOutput(any(MapHost.class), eq(map1ID));
    verify(ss).putBackKnownMapOutput(any(MapHost.class), eq(map2ID));
  }",No Smells
"@Test
  public void testIoSortDefaults() {
    final JobConf jobConf = new JobConf();
    assertEquals(10, jobConf.getInt(MRJobConfig.IO_SORT_FACTOR, 100));
    assertEquals(100, jobConf.getInt(MRJobConfig.IO_SORT_MB, 10));
  }",No Smells
"@Test
  public void testEncryptedMerger() throws Throwable {
    // Enable intermediate encryption.
    MRJobConfUtil.initEncryptedIntermediateConfigsForTesting(jobConf);
    Credentials credentials = UserGroupInformation.getCurrentUser().getCredentials();
    TokenCache.setEncryptedSpillKey(new byte[16], credentials);
    UserGroupInformation.getCurrentUser().addCredentials(credentials);
    testInMemoryAndOnDiskMerger();
  }",No Smells
"@Test
  public void testCloneContext() throws Exception {
    ContextFactory.cloneContext(jobContext, conf);
  }",No Smells
"@Test
  public void testCountersIncrement() {
    Counters fCounters = new Counters();
    Counter fCounter = fCounters.findCounter(FRAMEWORK_COUNTER);
    fCounter.setValue(100);
    Counter gCounter = fCounters.findCounter(""test"", ""foo"");
    gCounter.setValue(200);

    Counters counters = new Counters();
    counters.incrAllCounters(fCounters);
    Counter counter;
    for (CounterGroup cg : fCounters) {
      CounterGroup group = counters.getGroup(cg.getName());
      if (group.getName().equals(""test"")) {
        counter = counters.findCounter(""test"", ""foo"");
        assertEquals(200, counter.getValue());
      }",Eager Test
"@Test
  public void testAtResourceLimit() throws IOException {
    ResourceConf.Builder b = new ResourceConf.Builder();
    b.setNumOfDCArchives(1);
    b.setNumOfDCFiles(1);
    b.setNumOfTmpArchives(1);
    b.setNumOfTmpFiles(1);
    b.setNumOfTmpLibJars(1);
    b.setJobJar(true);
    b.setMaxResources(6);
    runLimitsTest(b.build(), true, null);
  }",No Smells
"@Test
  public void testErasureCodingDefault() throws IOException {
    testErasureCodingSetting(true);
  }",No Smells
"@Test
  public void testOverSingleResourceMBLimit() throws IOException {
    ResourceConf.Builder b = new ResourceConf.Builder();
    b.setNumOfDCArchives(1);
    b.setNumOfDCFiles(2);
    b.setNumOfTmpArchives(1);
    b.setNumOfTmpFiles(2);
    b.setNumOfTmpLibJars(1);
    b.setJobJar(true);
    b.setMaxSingleResourceMB(1);
    b.setSizeOfResource(10);
    runLimitsTest(b.build(), false, ResourceViolation.SINGLE_RESOURCE_SIZE);
  }",No Smells
"@Test
  public void testPathsWithFragNoSchemeAbsolute() throws IOException {
    ResourceConf.Builder b = new ResourceConf.Builder();
    b.setNumOfTmpFiles(5);
    b.setNumOfTmpLibJars(2);
    b.setNumOfTmpArchives(2);
    b.setJobJar(true);
    b.setPathsWithFrags(true);
    b.setPathsWithScheme(false);
    b.setAbsolutePaths(true);
    ResourceConf rConf = b.build();
    JobConf jConf = new JobConf();
    JobResourceUploader uploader = new StubedUploader(jConf);

    runTmpResourcePathTest(uploader, rConf, jConf, expectedFilesWithFrags,
        expectedArchivesWithFrags, basicExpectedJobJar);
  }",Mystery Guest
"@Test
  public void testPathsWithNoFragWithSchemeAbsolute() throws IOException {
    ResourceConf.Builder b = new ResourceConf.Builder();
    b.setNumOfTmpFiles(5);
    b.setNumOfTmpLibJars(2);
    b.setNumOfTmpArchives(2);
    b.setJobJar(true);
    b.setPathsWithFrags(false);
    b.setPathsWithScheme(true);
    b.setAbsolutePaths(true);
    ResourceConf rConf = b.build();
    JobConf jConf = new JobConf();
    JobResourceUploader uploader = new StubedUploader(jConf);

    runTmpResourcePathTest(uploader, rConf, jConf, expectedFilesNoFrags,
        expectedArchivesNoFrags, basicExpectedJobJar);
  }",Mystery Guest
"@Test
  public void testGetAllTaskTypes() {
    assertEquals(""The getAllTaskTypes method did not return the expected ""
        + ""string"", ""(m|r|s|c|t)"", TaskID.getAllTaskTypes());
  }",No Smells
"@Test
  public void testGetRepresentingCharacter() {
    assertEquals(""The getRepresentingCharacter() method did not return the ""
        + ""expected character"", 'm',
        TaskID.getRepresentingCharacter(TaskType.MAP));
    assertEquals(""The getRepresentingCharacter() method did not return the ""
        + ""expected character"", 'r',
        TaskID.getRepresentingCharacter(TaskType.REDUCE));
    assertEquals(""The getRepresentingCharacter() method did not return the ""
        + ""expected character"", 's',
        TaskID.getRepresentingCharacter(TaskType.JOB_SETUP));
    assertEquals(""The getRepresentingCharacter() method did not return the ""
        + ""expected character"", 'c',
        TaskID.getRepresentingCharacter(TaskType.JOB_CLEANUP));
    assertEquals(""The getRepresentingCharacter() method did not return the ""
        + ""expected character"", 't',
        TaskID.getRepresentingCharacter(TaskType.TASK_CLEANUP));
  }",No Smells
"@Test
  public void testGetTaskTypeChar() {
    assertEquals(""The getTaskType() method did not return the expected type"",
        TaskType.MAP,
        TaskID.getTaskType('m'));
    assertEquals(""The getTaskType() method did not return the expected type"",
        TaskType.REDUCE,
        TaskID.getTaskType('r'));
    assertEquals(""The getTaskType() method did not return the expected type"",
        TaskType.JOB_SETUP,
        TaskID.getTaskType('s'));
    assertEquals(""The getTaskType() method did not return the expected type"",
        TaskType.JOB_CLEANUP,
        TaskID.getTaskType('c'));
    assertEquals(""The getTaskType() method did not return the expected type"",
        TaskType.TASK_CLEANUP,
        TaskID.getTaskType('t'));
    assertNull(""The getTaskType() method did not return null for an unknown ""
        + ""type"", TaskID.getTaskType('x'));
  }",No Smells
"@Test
  public void testHashCode() {
    TaskType[] types = TaskType.values();

    for (int i = 0; i < types.length; i++) {
      JobID jobId = new JobID(""1234"" + i, i);
      TaskID taskId1 = new TaskID(jobId, types[i], i);
      TaskID taskId2 = new TaskID(jobId, types[i], i);

      assertTrue(""The hashcode() method gave unequal hash codes for two equal ""
          + ""task IDs"", taskId1.hashCode() == taskId2.hashCode());
    }",Eager Test
"@Test
  public void testFromYarnApplicationReport() {
    ApplicationId mockAppId = mock(ApplicationId.class);
    when(mockAppId.getClusterTimestamp()).thenReturn(12345L);
    when(mockAppId.getId()).thenReturn(6789);

    ApplicationReport mockReport = mock(ApplicationReport.class);
    when(mockReport.getTrackingUrl()).thenReturn(""dummy-tracking-url"");
    when(mockReport.getApplicationId()).thenReturn(mockAppId);
    when(mockReport.getYarnApplicationState()).thenReturn(YarnApplicationState.KILLED);
    when(mockReport.getUser()).thenReturn(""dummy-user"");
    when(mockReport.getQueue()).thenReturn(""dummy-queue"");
    when(mockReport.getPriority()).thenReturn(Priority.newInstance(4));
    String jobFile = ""dummy-path/job.xml"";

    try {
      JobStatus status = TypeConverter.fromYarn(mockReport, jobFile);
    }",No Smells
"@Test
  public void testFromYarnQueueInfo() {
    org.apache.hadoop.yarn.api.records.QueueInfo queueInfo = Records
        .newRecord(org.apache.hadoop.yarn.api.records.QueueInfo.class);
    queueInfo.setQueueState(org.apache.hadoop.yarn.api.records.QueueState.STOPPED);
    org.apache.hadoop.mapreduce.QueueInfo returned =
        TypeConverter.fromYarn(queueInfo, new Configuration());
    assertEquals(returned.getState().toString(),
        StringUtils.toLowerCase(queueInfo.getQueueState().toString()),
        ""queueInfo translation didn't work."");
  }",No Smells
"@Test
  public void testClusterGetDelegationToken() throws Exception {

    Configuration conf = new Configuration(false);
    Cluster cluster = null;
    try {
      conf = new Configuration();
      conf.set(MRConfig.FRAMEWORK_NAME, MRConfig.YARN_FRAMEWORK_NAME);
      cluster = new Cluster(conf);
      YARNRunner yrunner = (YARNRunner) cluster.getClient();
      GetDelegationTokenResponse getDTResponse = 
          recordFactory.newRecordInstance(GetDelegationTokenResponse.class);
      org.apache.hadoop.yarn.api.records.Token rmDTToken = recordFactory.newRecordInstance(
        org.apache.hadoop.yarn.api.records.Token.class);
      rmDTToken.setIdentifier(ByteBuffer.wrap(new byte[2]));
      rmDTToken.setKind(""Testclusterkind"");
      rmDTToken.setPassword(ByteBuffer.wrap(""testcluster"".getBytes()));
      rmDTToken.setService(""0.0.0.0:8032"");
      getDTResponse.setRMDelegationToken(rmDTToken);
      final ApplicationClientProtocol cRMProtocol =
          MockitoUtil.mockProtocol(ApplicationClientProtocol.class);
      when(cRMProtocol.getDelegationToken(any(
          GetDelegationTokenRequest.class))).thenReturn(getDTResponse);
      ResourceMgrDelegate rmgrDelegate = new ResourceMgrDelegate(
          new YarnConfiguration(conf)) {
        @Override
        protected void serviceStart() throws Exception {
          assertTrue(this.client instanceof YarnClientImpl);
          this.client = spy(this.client);
          doNothing().when(this.client).close();
          ((YarnClientImpl) this.client).setRMClient(cRMProtocol);
        }",No Smells
"@Test
  public void testClusterWithYarnClientProtocolProvider() throws Exception {

    Configuration conf = new Configuration(false);
    Cluster cluster = null;

    try {
      cluster = new Cluster(conf);
    }",No Smells
"@Test
  public void testMRAsyncDiskService() throws Throwable {
  
    FileSystem localFileSystem = FileSystem.getLocal(new Configuration());
    String[] vols = new String[]{TEST_ROOT_DIR + ""/0"",
        TEST_ROOT_DIR + ""/1""}",Mystery Guest
"@Test
  public void testSetCountersToNull() {
    // Create basic class
    TaskAttemptReport report = Records.newRecord(TaskAttemptReport.class);
    // Set raw counters to null
    report.setCounters(null);
    // Verify properties still null
    assertThat(report.getCounters()).isNull();
    assertThat(report.getRawCounters()).isNull();
  }",No Smells
"@Test
  public void testSetNonNullCountersToNull() {
    // Create basic class
    TaskAttemptReport report = Records.newRecord(TaskAttemptReport.class);
    // Set raw counters
    org.apache.hadoop.mapreduce.Counters rCounters = MockJobs.newCounters();
    report.setRawCounters(rCounters);
    // Verify getCounters converts properly from raw to real
    Counters counters = report.getCounters();
    assertNotEquals(null, counters);
    // Clear counters to null and then verify
    report.setCounters(null);
    assertThat(report.getCounters()).isNull();
    assertThat(report.getRawCounters()).isNull();
  }",No Smells
"@Test
  public void testSetRawCountersToNull() {
    // Create basic class
    TaskAttemptReport report = Records.newRecord(TaskAttemptReport.class);
    // Set raw counters to null
    report.setRawCounters(null);
    // Verify properties still null
    assertThat(report.getCounters()).isNull();
    assertThat(report.getRawCounters()).isNull();

  }",No Smells
"@Test
  public void testUninitializedCounters() {
    // Create basic class
    TaskAttemptReport report = Records.newRecord(TaskAttemptReport.class);
    // Verify properties initialized to null
    assertThat(report.getCounters()).isNull();
    assertThat(report.getRawCounters()).isNull();
  }",No Smells
"@Test
  public void testBuildImplicitRawCounters() {
    // Create basic class
    TaskReportPBImpl report = new TaskReportPBImpl();
    org.apache.hadoop.mapreduce.Counters rCounters = MockJobs.newCounters();
    // Set raw counters
    report.setRawCounters(rCounters);
    // Verify getProto method implicitly converts/sets real counters
    MRProtos.TaskReportProto protoVal = report.getProto();
    assertTrue(protoVal.hasCounters());
  }",No Smells
"@Test
  public void testSetCountersToNull() {
    // Create basic class
    TaskReport report = Records.newRecord(TaskReport.class);
    // Set raw counters to null
    report.setCounters(null);
    // Verify properties still null
    assertThat(report.getCounters()).isNull();
    assertThat(report.getRawCounters()).isNull();
  }",No Smells
"@Test
  public void testSetNonNullRawCountersToNull() {
    // Create basic class
    TaskReport report = Records.newRecord(TaskReport.class);
    // Set raw counters
    org.apache.hadoop.mapreduce.Counters rCounters = MockJobs.newCounters();
    report.setRawCounters(rCounters);
    // Verify getCounters converts properly from raw to real
    Counters counters = report.getCounters();
    assertNotEquals(null, counters);
    // Clear counters to null and then verify
    report.setRawCounters(null);
    assertThat(report.getCounters()).isNull();
    assertThat(report.getRawCounters()).isNull();
  }",No Smells
"@Test
  public void testCommitWindow() throws Exception {
    Configuration conf = new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR, stagingDir);
    AsyncDispatcher dispatcher = new AsyncDispatcher();
    dispatcher.init(conf);
    dispatcher.start();

    TestingJobEventHandler jeh = new TestingJobEventHandler();
    dispatcher.register(JobEventType.class, jeh);

    SystemClock clock = SystemClock.getInstance();
    AppContext appContext = mock(AppContext.class);
    ApplicationAttemptId attemptid = ApplicationAttemptId.fromString(
        ""appattempt_1234567890000_0001_0"");
    when(appContext.getApplicationID()).thenReturn(attemptid.getApplicationId());
    when(appContext.getApplicationAttemptId()).thenReturn(attemptid);
    when(appContext.getEventHandler()).thenReturn(
        dispatcher.getEventHandler());
    when(appContext.getClock()).thenReturn(clock);
    OutputCommitter committer = mock(OutputCommitter.class);
    TestingRMHeartbeatHandler rmhh =
        new TestingRMHeartbeatHandler();

    CommitterEventHandler ceh = new CommitterEventHandler(appContext,
        committer, rmhh);
    ceh.init(conf);
    ceh.start();

    // verify trying to commit when RM heartbeats are stale does not commit
    ceh.handle(new CommitterJobCommitEvent(null, null));
    long timeToWaitMs = 5000;
    while (rmhh.getNumCallbacks() != 1 && timeToWaitMs > 0) {
      Thread.sleep(10);
      timeToWaitMs -= 10;
    }",Eager Test
"@Test
  public void testJobNotCompletedWhenAllReducersAreFinished()
      throws Exception {
    testJobCompletionWhenReducersAreFinished(false);
  }",Eager Test
"@Test
  public void testReportDiagnostics() throws Exception {
    JobID jobID = JobID.forName(""job_1234567890000_0001"");
    JobId jobId = TypeConverter.toYarn(jobID);
    final String diagMsg = ""some diagnostic message"";
    final JobDiagnosticsUpdateEvent diagUpdateEvent =
        new JobDiagnosticsUpdateEvent(jobId, diagMsg);
    MRAppMetrics mrAppMetrics = MRAppMetrics.create();
    AppContext mockContext = mock(AppContext.class);
    when(mockContext.hasSuccessfullyUnregistered()).thenReturn(true);
    JobImpl job = new JobImpl(jobId, Records
        .newRecord(ApplicationAttemptId.class), new Configuration(),
        mock(EventHandler.class),
        null, mock(JobTokenSecretManager.class), null,
        SystemClock.getInstance(), null,
        mrAppMetrics, null, true, null, 0, null, mockContext, null, null);
    job.handle(diagUpdateEvent);
    String diagnostics = job.getReport().getDiagnostics();
    Assert.assertNotNull(diagnostics);
    Assert.assertTrue(diagnostics.contains(diagMsg));

    job = new JobImpl(jobId, Records
        .newRecord(ApplicationAttemptId.class), new Configuration(),
        mock(EventHandler.class),
        null, mock(JobTokenSecretManager.class), null,
        SystemClock.getInstance(), null,
        mrAppMetrics, null, true, null, 0, null, mockContext, null, null);
    job.handle(new JobEvent(jobId, JobEventType.JOB_KILL));
    job.handle(diagUpdateEvent);
    diagnostics = job.getReport().getDiagnostics();
    Assert.assertNotNull(diagnostics);
    Assert.assertTrue(diagnostics.contains(diagMsg));
  }",No Smells
"@Test
  public void testUberDecision() throws Exception {

    // with default values, no of maps is 2
    Configuration conf = new Configuration();
    boolean isUber = testUberDecision(conf);
    Assert.assertFalse(isUber);

    // enable uber mode, no of maps is 2
    conf = new Configuration();
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, true);
    isUber = testUberDecision(conf);
    Assert.assertTrue(isUber);

    // enable uber mode, no of maps is 2, no of reduces is 1 and uber task max
    // reduces is 0
    conf = new Configuration();
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, true);
    conf.setInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 0);
    conf.setInt(MRJobConfig.NUM_REDUCES, 1);
    isUber = testUberDecision(conf);
    Assert.assertFalse(isUber);

    // enable uber mode, no of maps is 2, no of reduces is 1 and uber task max
    // reduces is 1
    conf = new Configuration();
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, true);
    conf.setInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);
    conf.setInt(MRJobConfig.NUM_REDUCES, 1);
    isUber = testUberDecision(conf);
    Assert.assertTrue(isUber);

    // enable uber mode, no of maps is 2 and uber task max maps is 0
    conf = new Configuration();
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, true);
    conf.setInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 1);
    isUber = testUberDecision(conf);
    Assert.assertFalse(isUber);
    
 // enable uber mode of 0 reducer no matter how much memory assigned to reducer
    conf = new Configuration();
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, true);  
    conf.setInt(MRJobConfig.NUM_REDUCES, 0);           
    conf.setInt(MRJobConfig.REDUCE_MEMORY_MB, 2048);
    conf.setInt(MRJobConfig.REDUCE_CPU_VCORES, 10);
    isUber = testUberDecision(conf);
    Assert.assertTrue(isUber);
  }",No Smells
"@Test
  public void testEnvironmentVariables() throws Exception {
    MyMRApp app = new MyMRApp(1, 0, true, this.getClass().getName(), true);
    Configuration conf = new Configuration();
    conf.set(JobConf.MAPRED_MAP_TASK_ENV, ""HADOOP_CLIENT_OPTS=test"");
    conf.setStrings(MRJobConfig.MAP_LOG_LEVEL, ""WARN"");
    conf.setBoolean(MRConfig.MAPREDUCE_APP_SUBMISSION_CROSS_PLATFORM, false);
    Job job = app.submit(conf);
    app.waitForState(job, JobState.SUCCEEDED);
    app.verifyCompleted();
    
    Assert.assertTrue(""HADOOP_ROOT_LOGGER not set for job"",
        app.cmdEnvironment.containsKey(""HADOOP_ROOT_LOGGER""));
    Assert.assertEquals(""WARN,console"",
        app.cmdEnvironment.get(""HADOOP_ROOT_LOGGER""));
    Assert.assertTrue(""HADOOP_CLIENT_OPTS not set for job"",
        app.cmdEnvironment.containsKey(""HADOOP_CLIENT_OPTS""));
    Assert.assertEquals(""test"", app.cmdEnvironment.get(""HADOOP_CLIENT_OPTS""));

    // Try one more.
    app = new MyMRApp(1, 0, true, this.getClass().getName(), true);
    conf = new Configuration();
    conf.set(JobConf.MAPRED_MAP_TASK_ENV, ""HADOOP_ROOT_LOGGER=trace"");
    job = app.submit(conf);
    app.waitForState(job, JobState.SUCCEEDED);
    app.verifyCompleted();
    
    Assert.assertTrue(""HADOOP_ROOT_LOGGER not set for job"",
        app.cmdEnvironment.containsKey(""HADOOP_ROOT_LOGGER""));
    Assert.assertEquals(""trace"",
        app.cmdEnvironment.get(""HADOOP_ROOT_LOGGER""));

    // Try one using the mapreduce.task.env.var=value syntax
    app = new MyMRApp(1, 0, true, this.getClass().getName(), true);
    conf = new Configuration();
    conf.set(JobConf.MAPRED_MAP_TASK_ENV + "".HADOOP_ROOT_LOGGER"",
        ""DEBUG,console"");
    job = app.submit(conf);
    app.waitForState(job, JobState.SUCCEEDED);
    app.verifyCompleted();

    Assert.assertTrue(""HADOOP_ROOT_LOGGER not set for job"",
        app.cmdEnvironment.containsKey(""HADOOP_ROOT_LOGGER""));
    Assert.assertEquals(""DEBUG,console"",
        app.cmdEnvironment.get(""HADOOP_ROOT_LOGGER""));
  }",No Smells
"@Test
  public void testAppDiagnosticEventOnNewTask() {
    ApplicationId appId = ApplicationId.newInstance(1, 2);
    ApplicationAttemptId appAttemptId = ApplicationAttemptId.newInstance(
        appId, 0);
    JobId jobId = MRBuilderUtils.newJobId(appId, 1);
    TaskId taskId = MRBuilderUtils.newTaskId(jobId, 1, TaskType.MAP);
    TaskAttemptId attemptId = MRBuilderUtils.newTaskAttemptId(taskId, 0);
    Path jobFile = mock(Path.class);

    MockEventHandler eventHandler = new MockEventHandler();
    TaskAttemptListener taListener = mock(TaskAttemptListener.class);
    when(taListener.getAddress()).thenReturn(
        new InetSocketAddress(""localhost"", 0));

    JobConf jobConf = new JobConf();
    jobConf.setClass(""fs.file.impl"", StubbedFS.class, FileSystem.class);
    jobConf.setBoolean(""fs.file.impl.disable.cache"", true);
    jobConf.set(JobConf.MAPRED_MAP_TASK_ENV, """");
    jobConf.set(MRJobConfig.APPLICATION_ATTEMPT_ID, ""10"");

    TaskSplitMetaInfo splits = mock(TaskSplitMetaInfo.class);
    when(splits.getLocations()).thenReturn(new String[] { ""127.0.0.1"" }",No Smells
"@Test
  public void testAppDiagnosticEventOnUnassignedTask() {
    ApplicationId appId = ApplicationId.newInstance(1, 2);
    ApplicationAttemptId appAttemptId = ApplicationAttemptId.newInstance(
        appId, 0);
    JobId jobId = MRBuilderUtils.newJobId(appId, 1);
    TaskId taskId = MRBuilderUtils.newTaskId(jobId, 1, TaskType.MAP);
    TaskAttemptId attemptId = MRBuilderUtils.newTaskAttemptId(taskId, 0);
    Path jobFile = mock(Path.class);

    MockEventHandler eventHandler = new MockEventHandler();
    TaskAttemptListener taListener = mock(TaskAttemptListener.class);
    when(taListener.getAddress()).thenReturn(
        new InetSocketAddress(""localhost"", 0));

    JobConf jobConf = new JobConf();
    jobConf.setClass(""fs.file.impl"", StubbedFS.class, FileSystem.class);
    jobConf.setBoolean(""fs.file.impl.disable.cache"", true);
    jobConf.set(JobConf.MAPRED_MAP_TASK_ENV, """");
    jobConf.set(MRJobConfig.APPLICATION_ATTEMPT_ID, ""10"");

    TaskSplitMetaInfo splits = mock(TaskSplitMetaInfo.class);
    when(splits.getLocations()).thenReturn(new String[] { ""127.0.0.1"" }",No Smells
"@Test
  public void testContainerKillWhileRunning() throws Exception {
    ApplicationId appId = ApplicationId.newInstance(1, 2);
    ApplicationAttemptId appAttemptId = ApplicationAttemptId.newInstance(appId,
        0);
    JobId jobId = MRBuilderUtils.newJobId(appId, 1);
    TaskId taskId = MRBuilderUtils.newTaskId(jobId, 1, TaskType.MAP);
    TaskAttemptId attemptId = MRBuilderUtils.newTaskAttemptId(taskId, 0);
    Path jobFile = mock(Path.class);

    MockEventHandler eventHandler = new MockEventHandler();
    TaskAttemptListener taListener = mock(TaskAttemptListener.class);
    when(taListener.getAddress()).thenReturn(
        new InetSocketAddress(""localhost"", 0));

    JobConf jobConf = new JobConf();
    jobConf.setClass(""fs.file.impl"", StubbedFS.class, FileSystem.class);
    jobConf.setBoolean(""fs.file.impl.disable.cache"", true);
    jobConf.set(JobConf.MAPRED_MAP_TASK_ENV, """");
    jobConf.set(MRJobConfig.APPLICATION_ATTEMPT_ID, ""10"");

    TaskSplitMetaInfo splits = mock(TaskSplitMetaInfo.class);
    when(splits.getLocations()).thenReturn(new String[] { ""127.0.0.1"" }",No Smells
"@Test
  public void testMillisCountersUpdate() throws Exception {
    verifyMillisCounters(Resource.newInstance(1024, 1), 512);
    verifyMillisCounters(Resource.newInstance(2048, 4), 1024);
    verifyMillisCounters(Resource.newInstance(10240, 8), 2048);
  }",No Smells
"@Test
  public void testMRAppHistoryForTAFailedInAssigned() throws Exception {
    // test TA_CONTAINER_LAUNCH_FAILED for map
    FailingAttemptsDuringAssignedMRApp app = null;

    try {
      app =
          new FailingAttemptsDuringAssignedMRApp(1, 0,
              TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED);
      testTaskAttemptAssignedFailHistory(app);
      app.close();

      // test TA_CONTAINER_LAUNCH_FAILED for reduce
      app =
          new FailingAttemptsDuringAssignedMRApp(0, 1,
              TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED);
      testTaskAttemptAssignedFailHistory(app);
      app.close();

      // test TA_CONTAINER_COMPLETED for map
      app =
          new FailingAttemptsDuringAssignedMRApp(1, 0,
              TaskAttemptEventType.TA_CONTAINER_COMPLETED);
      testTaskAttemptAssignedFailHistory(app);
      app.close();

      // test TA_CONTAINER_COMPLETED for reduce
      app =
          new FailingAttemptsDuringAssignedMRApp(0, 1,
              TaskAttemptEventType.TA_CONTAINER_COMPLETED);
      testTaskAttemptAssignedFailHistory(app);
      app.close();

      // test TA_FAILMSG for map
      app =
          new FailingAttemptsDuringAssignedMRApp(1, 0,
              TaskAttemptEventType.TA_FAILMSG);
      testTaskAttemptAssignedFailHistory(app);
      app.close();

      // test TA_FAILMSG for reduce
      app =
          new FailingAttemptsDuringAssignedMRApp(0, 1,
              TaskAttemptEventType.TA_FAILMSG);
      testTaskAttemptAssignedFailHistory(app);
      app.close();

      // test TA_FAILMSG_BY_CLIENT for map
      app =
          new FailingAttemptsDuringAssignedMRApp(1, 0,
              TaskAttemptEventType.TA_FAILMSG_BY_CLIENT);
      testTaskAttemptAssignedFailHistory(app);
      app.close();

      // test TA_FAILMSG_BY_CLIENT for reduce
      app =
          new FailingAttemptsDuringAssignedMRApp(0, 1,
              TaskAttemptEventType.TA_FAILMSG_BY_CLIENT);
      testTaskAttemptAssignedFailHistory(app);
      app.close();

      // test TA_KILL for map
      app =
          new FailingAttemptsDuringAssignedMRApp(1, 0,
              TaskAttemptEventType.TA_KILL);
      testTaskAttemptAssignedKilledHistory(app);
      app.close();

      // test TA_KILL for reduce
      app =
          new FailingAttemptsDuringAssignedMRApp(0, 1,
              TaskAttemptEventType.TA_KILL);
      testTaskAttemptAssignedKilledHistory(app);
      app.close();
    }",No Smells
"@Test
  public void testReducerCpuRequestOverriding() {
    TestAppender testAppender = new TestAppender();
    final Logger logger = Logger.getLogger(TaskAttemptImpl.class);
    try {
      logger.addAppender(testAppender);
      EventHandler eventHandler = mock(EventHandler.class);
      Clock clock = SystemClock.getInstance();
      JobConf jobConf = new JobConf();
      jobConf.set(MRJobConfig.REDUCE_RESOURCE_TYPE_PREFIX +
          MRJobConfig.RESOURCE_TYPE_NAME_VCORE, ""7"");
      jobConf.setInt(MRJobConfig.REDUCE_CPU_VCORES, 9);
      TaskAttemptImpl taImpl =
          createReduceTaskAttemptImplForTest(eventHandler, clock, jobConf);
      long vCores =
          getResourceInfoFromContainerRequest(taImpl, eventHandler).
          getVirtualCores();
      assertEquals(7, vCores);
      assertTrue(testAppender.getLogEvents().stream().anyMatch(
          e -> e.getLevel() == Level.WARN && (""Configuration "" +
              ""mapreduce.reduce.resource.vcores=7 is overriding the "" +
              ""mapreduce.reduce.cpu.vcores=9 configuration"").equals(
                  e.getMessage())));
    }",No Smells
"@Test
  public void testReducerCpuRequestViaMapreduceReduceCpuVcores() {
    EventHandler eventHandler = mock(EventHandler.class);
    Clock clock = SystemClock.getInstance();
    JobConf jobConf = new JobConf();
    jobConf.setInt(MRJobConfig.REDUCE_CPU_VCORES, 3);
    TaskAttemptImpl taImpl =
        createReduceTaskAttemptImplForTest(eventHandler, clock, jobConf);
    int vCores =
        getResourceInfoFromContainerRequest(taImpl, eventHandler).
        getVirtualCores();
    assertEquals(3, vCores);
  }",No Smells
"@Test
  public void testReducerMemoryRequestOverriding() {
    for (String memoryName : ImmutableList.of(
        MRJobConfig.RESOURCE_TYPE_NAME_MEMORY,
        MRJobConfig.RESOURCE_TYPE_ALTERNATIVE_NAME_MEMORY)) {
      TestAppender testAppender = new TestAppender();
      final Logger logger = Logger.getLogger(TaskAttemptImpl.class);
      try {
        TaskAttemptImpl.RESOURCE_REQUEST_CACHE.clear();
        logger.addAppender(testAppender);
        EventHandler eventHandler = mock(EventHandler.class);
        Clock clock = SystemClock.getInstance();
        JobConf jobConf = new JobConf();
        jobConf.set(MRJobConfig.REDUCE_RESOURCE_TYPE_PREFIX + memoryName,
            ""3Gi"");
        jobConf.setInt(MRJobConfig.REDUCE_MEMORY_MB, 2048);
        TaskAttemptImpl taImpl =
            createReduceTaskAttemptImplForTest(eventHandler, clock, jobConf);
        long memorySize =
            getResourceInfoFromContainerRequest(taImpl, eventHandler).
            getMemorySize();
        assertEquals(3072, memorySize);
        assertTrue(testAppender.getLogEvents().stream()
            .anyMatch(e -> e.getLevel() == Level.WARN && (""Configuration "" +
                ""mapreduce.reduce.resource."" + memoryName + ""=3Gi is "" +
                ""overriding the mapreduce.reduce.memory.mb=2048 configuration"")
                    .equals(e.getMessage())));
      }",No Smells
"@Test
  public void testReducerMemoryRequestViaMapreduceReduceMemoryMb() {
    EventHandler eventHandler = mock(EventHandler.class);
    Clock clock = SystemClock.getInstance();
    JobConf jobConf = new JobConf();
    jobConf.setInt(MRJobConfig.REDUCE_MEMORY_MB, 2048);
    TaskAttemptImpl taImpl =
        createReduceTaskAttemptImplForTest(eventHandler, clock, jobConf);
    long memorySize =
        getResourceInfoFromContainerRequest(taImpl, eventHandler).
        getMemorySize();
    assertEquals(2048, memorySize);
  }",No Smells
"@Test
  public void testReducerMemoryRequestWithoutUnits() {
    Clock clock = SystemClock.getInstance();
    for (String memoryResourceName : ImmutableList.of(
        MRJobConfig.RESOURCE_TYPE_NAME_MEMORY,
        MRJobConfig.RESOURCE_TYPE_ALTERNATIVE_NAME_MEMORY)) {
      EventHandler eventHandler = mock(EventHandler.class);
      JobConf jobConf = new JobConf();
      jobConf.setInt(MRJobConfig.REDUCE_RESOURCE_TYPE_PREFIX +
          memoryResourceName, 2048);
      TaskAttemptImpl taImpl =
          createReduceTaskAttemptImplForTest(eventHandler, clock, jobConf);
      long memorySize =
          getResourceInfoFromContainerRequest(taImpl, eventHandler).
          getMemorySize();
      assertEquals(2048, memorySize);
    }",Eager Test
"@Test
  public void testInit() {
    LOG.info(""--- START: testInit ---"");
    mockTask = createMockTask(TaskType.MAP);        
    assertTaskNewState();
    assert(taskAttempts.size() == 0);
  }",No Smells
"@Test
  public void testMapSpeculativeTaskAttemptSucceedsEvenIfFirstFails() {
    mockTask = createMockTask(TaskType.MAP);        
    runSpeculativeTaskAttemptSucceeds(TaskEventType.T_ATTEMPT_FAILED);
  }",No Smells
"@Test
  public void testAllocResponseId() throws Exception {
    ApplicationMasterProtocol scheduler = new MockScheduler();
    Configuration conf = new Configuration();
    LocalContainerAllocator lca =
        new StubbedLocalContainerAllocator(scheduler);
    lca.init(conf);
    lca.start();

    // do two heartbeats to verify the response ID is being tracked
    lca.heartbeat();
    lca.heartbeat();
    lca.close();
  }",No Smells
"@Test
  public void testRMConnectionRetry() throws Exception {
    // verify the connection exception is thrown
    // if we haven't exhausted the retry interval
    ApplicationMasterProtocol mockScheduler =
        mock(ApplicationMasterProtocol.class);
    when(mockScheduler.allocate(isA(AllocateRequest.class)))
      .thenThrow(RPCUtil.getRemoteException(new IOException(""forcefail"")));
    Configuration conf = new Configuration();
    LocalContainerAllocator lca =
        new StubbedLocalContainerAllocator(mockScheduler);
    lca.init(conf);
    lca.start();
    try {
      lca.heartbeat();
      Assert.fail(""heartbeat was supposed to throw"");
    }",No Smells
"@Test
  public void testComputeAvailableContainers() throws Exception {
    Resource clusterAvailableResources = Resource.newInstance(81920, 40);

    Resource nonZeroResource = Resource.newInstance(1024, 2);

    int expectedNumberOfContainersForMemory = 80;
    int expectedNumberOfContainersForCPU = 20;

    verifyDifferentResourceTypes(clusterAvailableResources, nonZeroResource,
        expectedNumberOfContainersForMemory,
        expectedNumberOfContainersForCPU);

    Resource zeroMemoryResource = Resource.newInstance(0,
        nonZeroResource.getVirtualCores());

    verifyDifferentResourceTypes(clusterAvailableResources, zeroMemoryResource,
        Integer.MAX_VALUE,
        expectedNumberOfContainersForCPU);

    Resource zeroCpuResource = Resource.newInstance(
        nonZeroResource.getMemorySize(), 0);

    verifyDifferentResourceTypes(clusterAvailableResources, zeroCpuResource,
        expectedNumberOfContainersForMemory,
        expectedNumberOfContainersForMemory);
  }",No Smells
"@Test
  public void testConcurrentTaskLimitsDisabledIfSmaller() throws Exception {
    final int MAP_COUNT = 1;
    final int REDUCE_COUNT = 1;
    final int MAP_LIMIT = 1;
    final int REDUCE_LIMIT = 1;
    Configuration conf = new Configuration();
    conf.setInt(MRJobConfig.JOB_RUNNING_MAP_LIMIT, MAP_LIMIT);
    conf.setInt(MRJobConfig.JOB_RUNNING_REDUCE_LIMIT, REDUCE_LIMIT);
    conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART, 0.0f);
    ApplicationId appId = ApplicationId.newInstance(1, 1);
    ApplicationAttemptId appAttemptId =
        ApplicationAttemptId.newInstance(appId, 1);
    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);
    Job mockJob = mock(Job.class);
    when(mockJob.getReport()).thenReturn(
        MRBuilderUtils.newJobReport(jobId, ""job"", ""user"", JobState.RUNNING, 0,
            0, 0, 0, 0, 0, 0, ""jobfile"", null, false, """"));
    when(mockJob.getTotalMaps()).thenReturn(MAP_COUNT);
    when(mockJob.getTotalReduces()).thenReturn(REDUCE_COUNT);

    final MockScheduler mockScheduler = new MockScheduler(appAttemptId);
    MyContainerAllocator allocator =
        new MyContainerAllocator(null, conf, appAttemptId, mockJob,
            SystemClock.getInstance()) {
          @Override
          protected void register() {
          }",Eager Test
"@Test
  public void testExcludeSchedReducesFromHeadroom() throws Exception {
    LOG.info(""Running testExcludeSchedReducesFromHeadroom"");
    Configuration conf = new Configuration();
    conf.setInt(MRJobConfig.MR_JOB_REDUCER_UNCONDITIONAL_PREEMPT_DELAY_SEC, -1);
    MyResourceManager rm = new MyResourceManager(conf);
    rm.start();

    // Submit the application
    RMApp app = MockRMAppSubmitter.submitWithMemory(1024, rm);
    rm.drainEvents();

    MockNM amNodeManager = rm.registerNode(""amNM:1234"", 1260);
    amNodeManager.nodeHeartbeat(true);
    rm.drainEvents();

    ApplicationAttemptId appAttemptId = app.getCurrentAppAttempt()
        .getAppAttemptId();
    rm.sendAMLaunched(appAttemptId);
    rm.drainEvents();

    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);
    Job mockJob = mock(Job.class);
    when(mockJob.getReport()).thenReturn(
        MRBuilderUtils.newJobReport(jobId, ""job"", ""user"", JobState.RUNNING, 0,
            0, 0, 0, 0, 0, 0, ""jobfile"", null, false, """"));
    Task mockTask = mock(Task.class);
    TaskAttempt mockTaskAttempt = mock(TaskAttempt.class);
    when(mockJob.getTask((TaskId)any())).thenReturn(mockTask);
    when(mockTask.getAttempt((TaskAttemptId)any())).thenReturn(mockTaskAttempt);
    when(mockTaskAttempt.getProgress()).thenReturn(0.01f);
    MyContainerAllocator allocator = new MyContainerAllocator(rm, conf,
        appAttemptId, mockJob);

    MockNM nodeManager = rm.registerNode(""h1:1234"", 4096);
    rm.drainEvents();
    // Register nodes to RM.
    MockNM nodeManager2 = rm.registerNode(""h2:1234"", 1024);
    rm.drainEvents();

    // Request 2 maps and 1 reducer(sone on nodes which are not registered).
    ContainerRequestEvent event1 =
            ContainerRequestCreator.createRequest(jobId, 1,
                    Resource.newInstance(1024, 1),
                    new String[]{""h1""}",Eager Test
"@Test
  public void testReportedAppProgressWithOnlyMaps() throws Exception {

    LOG.info(""Running testReportedAppProgressWithOnlyMaps"");

    Configuration conf = new Configuration();
    final MyResourceManager rm = new MyResourceManager(conf);
    rm.start();
    DrainDispatcher rmDispatcher = (DrainDispatcher) rm.getRMContext()
        .getDispatcher();

    // Submit the application
    RMApp rmApp = MockRMAppSubmitter.submitWithMemory(1024, rm);
    rm.drainEvents();

    MockNM amNodeManager = rm.registerNode(""amNM:1234"", 11264);
    amNodeManager.nodeHeartbeat(true);
    rm.drainEvents();

    final ApplicationAttemptId appAttemptId = rmApp.getCurrentAppAttempt()
        .getAppAttemptId();
    rm.sendAMLaunched(appAttemptId);
    rm.drainEvents();

    MRApp mrApp = new MRApp(appAttemptId, ContainerId.newContainerId(
      appAttemptId, 0), 10, 0, false, this.getClass().getName(), true, 1) {
      @Override
        protected Dispatcher createDispatcher() {
          return new DrainDispatcher();
        }",Eager Test
"@Test
  public void testResource() throws Exception {

    LOG.info(""Running testResource"");

    Configuration conf = new Configuration();
    MyResourceManager rm = new MyResourceManager(conf);
    rm.start();

    // Submit the application
    RMApp app = MockRMAppSubmitter.submitWithMemory(1024, rm);
    rm.drainEvents();

    MockNM amNodeManager = rm.registerNode(""amNM:1234"", 2048);
    amNodeManager.nodeHeartbeat(true);
    rm.drainEvents();

    ApplicationAttemptId appAttemptId = app.getCurrentAppAttempt()
        .getAppAttemptId();
    rm.sendAMLaunched(appAttemptId);
    rm.drainEvents();

    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);
    Job mockJob = mock(Job.class);
    when(mockJob.getReport()).thenReturn(
        MRBuilderUtils.newJobReport(jobId, ""job"", ""user"", JobState.RUNNING, 0,
            0, 0, 0, 0, 0, 0, ""jobfile"", null, false, """"));
    MyContainerAllocator allocator = new MyContainerAllocator(rm, conf,
        appAttemptId, mockJob);

    // add resources to scheduler
    MockNM nodeManager1 = rm.registerNode(""h1:1234"", 10240);
    MockNM nodeManager2 = rm.registerNode(""h2:1234"", 10240);
    MockNM nodeManager3 = rm.registerNode(""h3:1234"", 10240);
    rm.drainEvents();

    // create the container request
    ContainerRequestEvent event1 = ContainerRequestCreator.createRequest(
            jobId, 1, Resource.newInstance(1024, 1),
        new String[] {""h1""}",No Smells
"@Test
  public void testRMUnavailable()
      throws Exception {
    Configuration conf = new Configuration();
    conf.setInt(
      MRJobConfig.MR_AM_TO_RM_WAIT_INTERVAL_MS, 0);
    MyResourceManager rm1 = new MyResourceManager(conf);
    rm1.start();

    RMApp app = MockRMAppSubmitter.submitWithMemory(1024, rm1);
    rm1.drainEvents();

    MockNM nm1 = new MockNM(""h1:1234"", 15120, rm1.getResourceTrackerService());
    nm1.registerNode();
    nm1.nodeHeartbeat(true);
    rm1.drainEvents();

    ApplicationAttemptId appAttemptId =
        app.getCurrentAppAttempt().getAppAttemptId();
    rm1.sendAMLaunched(appAttemptId);
    rm1.drainEvents();

    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);
    Job mockJob = mock(Job.class);
    when(mockJob.getReport()).thenReturn(
        MRBuilderUtils.newJobReport(jobId, ""job"", ""user"", JobState.RUNNING, 0,
        0, 0, 0, 0, 0, 0, ""jobfile"", null, false, """"));
    MyContainerAllocator2 allocator =
        new MyContainerAllocator2(rm1, conf, appAttemptId, mockJob);
    allocator.jobEvents.clear();
    try {
      allocator.schedule();
      Assert.fail(""Should Have Exception"");
    }",No Smells
"@Test
  public void testSimple() throws Exception {

    LOG.info(""Running testSimple"");

    Configuration conf = new Configuration();
    MyResourceManager rm = new MyResourceManager(conf);
    rm.start();

    // Submit the application
    RMApp app = MockRMAppSubmitter.submitWithMemory(1024, rm);
    rm.drainEvents();

    MockNM amNodeManager = rm.registerNode(""amNM:1234"", 2048);
    amNodeManager.nodeHeartbeat(true);
    rm.drainEvents();

    ApplicationAttemptId appAttemptId = app.getCurrentAppAttempt()
        .getAppAttemptId();
    rm.sendAMLaunched(appAttemptId);
    rm.drainEvents();

    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);
    Job mockJob = mock(Job.class);
    when(mockJob.getReport()).thenReturn(
        MRBuilderUtils.newJobReport(jobId, ""job"", ""user"", JobState.RUNNING, 0,
            0, 0, 0, 0, 0, 0, ""jobfile"", null, false, """"));
    MyContainerAllocator allocator = new MyContainerAllocator(rm, conf,
        appAttemptId, mockJob);

    // add resources to scheduler
    MockNM nodeManager1 = rm.registerNode(""h1:1234"", 10240);
    MockNM nodeManager2 = rm.registerNode(""h2:1234"", 10240);
    MockNM nodeManager3 = rm.registerNode(""h3:1234"", 10240);
    rm.drainEvents();

    // create the container request
    ContainerRequestEvent event1 = ContainerRequestCreator.createRequest(jobId,
        1, Resource.newInstance(1024, 1), new String[] {""h1""}",Eager Test
"@Test
  public void testUnregistrationOnlyIfRegistered() throws Exception {
    Configuration conf = new Configuration();
    final MyResourceManager rm = new MyResourceManager(conf);
    rm.start();

    // Submit the application
    RMApp rmApp = MockRMAppSubmitter.submitWithMemory(1024, rm);
    rm.drainEvents();

    MockNM amNodeManager = rm.registerNode(""127.0.0.1:1234"", 11264);
    amNodeManager.nodeHeartbeat(true);
    rm.drainEvents();

    final ApplicationAttemptId appAttemptId =
        rmApp.getCurrentAppAttempt().getAppAttemptId();
    rm.sendAMLaunched(appAttemptId);
    rm.drainEvents();

    MRApp mrApp =
        new MRApp(appAttemptId, ContainerId.newContainerId(appAttemptId, 0), 10,
            0, false, this.getClass().getName(), true, 1) {
          @Override
          protected Dispatcher createDispatcher() {
            return new DrainDispatcher();
          }",No Smells
"@Test
  public void testUnsupportedMapContainerRequirement() throws Exception {
    final Resource maxContainerSupported = Resource.newInstance(1, 1);

    final ApplicationId appId = ApplicationId.newInstance(1, 1);
    final ApplicationAttemptId appAttemptId =
        ApplicationAttemptId.newInstance(appId, 1);
    final JobId jobId =
        MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);

    final MockScheduler mockScheduler = new MockScheduler(appAttemptId);
    final Configuration conf = new Configuration();

    final MyContainerAllocator allocator = new MyContainerAllocator(null,
        conf, appAttemptId, mock(Job.class), SystemClock.getInstance()) {
      @Override
      protected void register() {
      }",No Smells
"@Test
  public void testUnsupportedReduceContainerRequirement() throws Exception {
    final Resource maxContainerSupported = Resource.newInstance(1, 1);

    final ApplicationId appId = ApplicationId.newInstance(1, 1);
    final ApplicationAttemptId appAttemptId = ApplicationAttemptId.newInstance(
        appId, 1);
    final JobId jobId =
        MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);

    final MockScheduler mockScheduler = new MockScheduler(appAttemptId);
    final Configuration conf = new Configuration();

    final MyContainerAllocator allocator = new MyContainerAllocator(null,
        conf, appAttemptId, mock(Job.class), SystemClock.getInstance()) {
      @Override
      protected void register() {
      }",No Smells
"@Test
  public void testUpdateCollectorInfo() throws Exception {
    LOG.info(""Running testUpdateCollectorInfo"");
    Configuration conf = new Configuration();
    conf.setBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED, true);
    conf.setFloat(YarnConfiguration.TIMELINE_SERVICE_VERSION, 2.0f);
    ApplicationId appId = ApplicationId.newInstance(1, 1);
    ApplicationAttemptId attemptId = ApplicationAttemptId.newInstance(appId, 1);
    JobId jobId = MRBuilderUtils.newJobId(appId, 0);
    Job mockJob = mock(Job.class);
    when(mockJob.getReport()).thenReturn(
        MRBuilderUtils.newJobReport(jobId, ""job"", ""user"", JobState.RUNNING, 0,
            0, 0, 0, 0, 0, 0, ""jobfile"", null, false, """"));
    String localAddr = ""localhost:1234"";
    UserGroupInformation ugi = UserGroupInformation.getCurrentUser();

    // Generate a timeline delegation token.
    TimelineDelegationTokenIdentifier ident =
        new TimelineDelegationTokenIdentifier(new Text(ugi.getUserName()),
        new Text(""renewer""), null);
    ident.setSequenceNumber(1);
    Token<TimelineDelegationTokenIdentifier> collectorToken =
        new Token<TimelineDelegationTokenIdentifier>(ident.getBytes(),
        new byte[0], TimelineDelegationTokenIdentifier.KIND_NAME,
        new Text(localAddr));
    org.apache.hadoop.yarn.api.records.Token token =
        org.apache.hadoop.yarn.api.records.Token.newInstance(
            collectorToken.getIdentifier(), collectorToken.getKind().toString(),
            collectorToken.getPassword(),
            collectorToken.getService().toString());
    CollectorInfo collectorInfo = CollectorInfo.newInstance(localAddr, token);
    // Mock scheduler to server Allocate request.
    final MockSchedulerForTimelineCollector mockScheduler =
        new MockSchedulerForTimelineCollector(collectorInfo);
    MyContainerAllocator allocator =
        new MyContainerAllocator(null, conf, attemptId, mockJob,
            SystemClock.getInstance()) {
          @Override
          protected void register() {
          }",Eager Test
"@Test
  public void testUpdatedNodes() throws Exception {
    Configuration conf = new Configuration();
    MyResourceManager rm = new MyResourceManager(conf);
    rm.start();

    // Submit the application
    RMApp app = MockRMAppSubmitter.submitWithMemory(1024, rm);
    rm.drainEvents();
    MockNM amNodeManager = rm.registerNode(""amNM:1234"", 2048);
    amNodeManager.nodeHeartbeat(true);
    rm.drainEvents();

    ApplicationAttemptId appAttemptId = app.getCurrentAppAttempt()
        .getAppAttemptId();
    rm.sendAMLaunched(appAttemptId);
    rm.drainEvents();

    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);
    Job mockJob = mock(Job.class);
    MyContainerAllocator allocator = new MyContainerAllocator(rm, conf,
        appAttemptId, mockJob);

    // add resources to scheduler
    MockNM nm1 = rm.registerNode(""h1:1234"", 10240);
    MockNM nm2 = rm.registerNode(""h2:1234"", 10240);
    rm.drainEvents();

    // create the map container request
    ContainerRequestEvent event =
            ContainerRequestCreator.createRequest(jobId, 1,
                    Resource.newInstance(1024, 1),
                    new String[] {""h1""}",Eager Test
"@Test
  public void testEmptyDataStatistics() throws Exception {
    DataStatistics statistics = new DataStatistics();
    Assert.assertEquals(0, statistics.count(), TOL);
    Assert.assertEquals(0, statistics.mean(), TOL);
    Assert.assertEquals(0, statistics.var(), TOL);
    Assert.assertEquals(0, statistics.std(), TOL);
    Assert.assertEquals(0, statistics.outlier(1.0f), TOL);
  }",No Smells
"@Test
  public void testUpdateStatistics() throws Exception {
    DataStatistics statistics = new DataStatistics(17);
    statistics.add(29);
    Assert.assertEquals(2, statistics.count(), TOL);
    Assert.assertEquals(23.0, statistics.mean(), TOL);
    Assert.assertEquals(36.0, statistics.var(), TOL);

    statistics.updateStatistics(17, 29);
    Assert.assertEquals(2, statistics.count(), TOL);
    Assert.assertEquals(29.0, statistics.mean(), TOL);
    Assert.assertEquals(0.0, statistics.var(), TOL);
  }",No Smells
"@Test
  public void testMapReduce() throws Exception {
    MRApp app = new MRApp(2, 2, true, this.getClass().getName(), true);
    Job job = app.submit(new Configuration());
    app.waitForState(job, JobState.SUCCEEDED);
    app.verifyCompleted();
    Assert.assertEquals(System.getProperty(""user.name""),job.getUserName());
  }",No Smells
"@Test
  public void testZeroMaps() throws Exception {
    MRApp app = new MRApp(0, 1, true, this.getClass().getName(), true);
    Job job = app.submit(new Configuration());
    app.waitForState(job, JobState.SUCCEEDED);
    app.verifyCompleted();
  }",No Smells
"@Test
  public void testMRAppMasterCredentials() throws Exception {

    GenericTestUtils.setRootLogLevel(Level.DEBUG);

    // Simulate credentials passed to AM via client->RM->NM
    Credentials credentials = new Credentials();
    byte[] identifier = ""MyIdentifier"".getBytes();
    byte[] password = ""MyPassword"".getBytes();
    Text kind = new Text(""MyTokenKind"");
    Text service = new Text(""host:port"");
    Token<? extends TokenIdentifier> myToken =
        new Token<TokenIdentifier>(identifier, password, kind, service);
    Text tokenAlias = new Text(""myToken"");
    credentials.addToken(tokenAlias, myToken);

    Text appTokenService = new Text(""localhost:0"");
    Token<AMRMTokenIdentifier> appToken =
        new Token<AMRMTokenIdentifier>(identifier, password,
            AMRMTokenIdentifier.KIND_NAME, appTokenService);
    credentials.addToken(appTokenService, appToken);

    Text keyAlias = new Text(""mySecretKeyAlias"");
    credentials.addSecretKey(keyAlias, ""mySecretKey"".getBytes());
    Token<? extends TokenIdentifier> storedToken =
        credentials.getToken(tokenAlias);

    JobConf conf = new JobConf();

    Path tokenFilePath = new Path(testDir, ""tokens-file"");
    Map<String, String> newEnv = new HashMap<String, String>();
    newEnv.put(UserGroupInformation.HADOOP_TOKEN_FILE_LOCATION, tokenFilePath
      .toUri().getPath());
    setNewEnvironmentHack(newEnv);
    credentials.writeTokenStorageFile(tokenFilePath, conf);

    ApplicationId appId = ApplicationId.newInstance(12345, 56);
    ApplicationAttemptId applicationAttemptId =
        ApplicationAttemptId.newInstance(appId, 1);
    ContainerId containerId =
        ContainerId.newContainerId(applicationAttemptId, 546);
    String userName = UserGroupInformation.getCurrentUser().getShortUserName();

    // Create staging dir, so MRAppMaster doesn't barf.
    File stagingDir =
        new File(MRApps.getStagingAreaDir(conf, userName).toString());
    stagingDir.mkdirs();

    // Set login-user to null as that is how real world MRApp starts with.
    // This is null is the reason why token-file is read by UGI.
    UserGroupInformation.setLoginUser(null);

    MRAppMasterTest appMaster =
        new MRAppMasterTest(applicationAttemptId, containerId, ""host"", -1, -1,
          System.currentTimeMillis(), false, true);
    MRAppMaster.initAndStartAppMaster(appMaster, conf, userName);

    // Now validate the task credentials
    Credentials appMasterCreds = appMaster.getCredentials();
    Assert.assertNotNull(appMasterCreds);
    Assert.assertEquals(1, appMasterCreds.numberOfSecretKeys());
    Assert.assertEquals(1, appMasterCreds.numberOfTokens());

    // Validate the tokens - app token should not be present
    Token<? extends TokenIdentifier> usedToken =
        appMasterCreds.getToken(tokenAlias);
    Assert.assertNotNull(usedToken);
    Assert.assertEquals(storedToken, usedToken);

    // Validate the keys
    byte[] usedKey = appMasterCreds.getSecretKey(keyAlias);
    Assert.assertNotNull(usedKey);
    Assert.assertEquals(""mySecretKey"", new String(usedKey));

    // The credentials should also be added to conf so that OuputCommitter can
    // access it - app token should not be present
    Credentials confCredentials = conf.getCredentials();
    Assert.assertEquals(1, confCredentials.numberOfSecretKeys());
    Assert.assertEquals(1, confCredentials.numberOfTokens());
    Assert.assertEquals(storedToken, confCredentials.getToken(tokenAlias));
    Assert.assertEquals(""mySecretKey"",
      new String(confCredentials.getSecretKey(keyAlias)));

    // Verify the AM's ugi - app token should be present
    Credentials ugiCredentials = appMaster.getUgi().getCredentials();
    Assert.assertEquals(1, ugiCredentials.numberOfSecretKeys());
    Assert.assertEquals(2, ugiCredentials.numberOfTokens());
    Assert.assertEquals(storedToken, ugiCredentials.getToken(tokenAlias));
    Assert.assertEquals(appToken, ugiCredentials.getToken(appTokenService));
    Assert.assertEquals(""mySecretKey"",
      new String(ugiCredentials.getSecretKey(keyAlias)));


  }",No Smells
"@Test
  public void testViewAclOnlyCannotModify() throws Exception {
    final MRAppWithClientService app = new MRAppWithClientService(1, 0, false);
    final Configuration conf = new Configuration();
    conf.setBoolean(MRConfig.MR_ACLS_ENABLED, true);
    conf.set(MRJobConfig.JOB_ACL_VIEW_JOB, ""viewonlyuser"");
    Job job = app.submit(conf);
    app.waitForState(job, JobState.RUNNING);
    Assert.assertEquals(""Num tasks not correct"", 1, job.getTasks().size());
    Iterator<Task> it = job.getTasks().values().iterator();
    Task task = it.next();
    app.waitForState(task, TaskState.RUNNING);
    TaskAttempt attempt = task.getAttempts().values().iterator().next();
    app.waitForState(attempt, TaskAttemptState.RUNNING);

    UserGroupInformation viewOnlyUser =
        UserGroupInformation.createUserForTesting(
            ""viewonlyuser"", new String[] {}",No Smells
"@Test
  public void testTaskTimeoutConfigWithoutTaskProgressReportInterval() {
    final long taskTimeoutConfiged = 2000L;

    final Configuration conf = new Configuration();
    conf.setLong(MRJobConfig.TASK_TIMEOUT, taskTimeoutConfiged);

    final long expectedTimeout = taskTimeoutConfiged;
    verifyTaskTimeoutConfig(conf, expectedTimeout);
  }",No Smells
"@Test public void testConfView() {
    WebAppTests.testPage(JobConfPage.class, AppContext.class,
                         new MockAppContext(0, 1, 1, 1));
  }",No Smells
"@Test public void testJobView() {
    AppContext appContext = new MockAppContext(0, 1, 1, 1);
    Map<String, String> params = getJobParams(appContext);
    WebAppTests.testPage(JobPage.class, AppContext.class, appContext, params);
  }",No Smells
"@Test
  public void testMRWebAppRedirection() throws Exception {

    String[] schemePrefix =
        { WebAppUtils.HTTP_PREFIX, WebAppUtils.HTTPS_PREFIX }",Eager Test + Mystery Guest
"@Test public void testTasksView() {
    AppContext appContext = new MockAppContext(0, 1, 1, 1);
    Map<String, String> params = getTaskParams(appContext);
    WebAppTests.testPage(TasksPage.class, AppContext.class, appContext, params);
  }",No Smells
"@Test
  public void testBlacklistedNodesXML() throws Exception {
    WebResource r = resource();
    ClientResponse response = r.path(""ws"").path(""v1"").path(""mapreduce"")
        .path(""blacklistednodes"").accept(MediaType.APPLICATION_XML)
        .get(ClientResponse.class);
    assertEquals(MediaType.APPLICATION_XML + ""; "" + JettyUtils.UTF_8,
        response.getType().toString());
    String xml = response.getEntity(String.class);
    verifyBlacklistedNodesInfoXML(xml, appContext);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testBadRequest() {
    String message = ""test string"";
    appController.badRequest(message);
    verifyExpectations(message);
  }",No Smells
"@Test
  public void testDownloadConfiguration() {
    appController.downloadConf();
    String jobConfXml = appController.getData();
    assertTrue(""Error downloading the job configuration file."",
        !jobConfXml.contains(""Error""));
  }",No Smells
"@Test
  public void testGetSingleJobCounter() throws IOException {
    appController.singleJobCounter();
    assertEquals(SingleCounterPage.class, appController.getClazz());
  }",No Smells
"@Test
  public void testCreateDirsWithFileSystemInSafeMode() throws Exception {
    dfsCluster.getFileSystem().setSafeMode(
        SafeModeAction.ENTER);
    Assert.assertTrue(dfsCluster.getFileSystem().isInSafeMode());
    testTryCreateHistoryDirs(dfsCluster.getConfiguration(0), false);
  }",No Smells
"@Test
  public void testCreateDirsWithoutFileSystem() throws Exception {
    Configuration conf = new YarnConfiguration();
    conf.set(FileSystem.FS_DEFAULT_NAME_KEY, ""hdfs://localhost:1"");
    testTryCreateHistoryDirs(conf, false);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testTokenStore() throws IOException {
    testTokenStore(testDir.getAbsoluteFile().toURI().toString());
  }",Eager Test
"@Test
  public void testJobCacheLimitLargerThanMax() throws Exception {
    HistoryFileManager historyManager = mock(HistoryFileManager.class);
    JobHistory jobHistory = spy(new JobHistory());
    doReturn(historyManager).when(jobHistory).createHistoryFileManager();

    Configuration conf = new Configuration();
    // Set the cache threshold to 50 tasks
    conf.setInt(JHAdminConfig.MR_HISTORY_LOADED_TASKS_CACHE_SIZE, 500);
    jobHistory.init(conf);
    jobHistory.start();

    CachedHistoryStorage storage = spy((CachedHistoryStorage) jobHistory
        .getHistoryStorage());

    assertTrue(storage.getUseLoadedTasksCache());
    assertThat(storage.getLoadedTasksCacheSize()).isEqualTo(500);

    // Create a bunch of large jobs (>> 50 tasks)
    Job[] lgJobs = new Job[10];
    JobId[] lgJobIds = new JobId[10];
    for (int i = 0; i < lgJobs.length; i++) {
      lgJobs[i] = mock(Job.class);
      lgJobIds[i] = mock(JobId.class);
      when(lgJobs[i].getID()).thenReturn(lgJobIds[i]);
      when(lgJobs[i].getTotalMaps()).thenReturn(700);
      when(lgJobs[i].getTotalReduces()).thenReturn(50);
    }",Eager Test
"@Test
  public void testLoadedTasksEmptyConfiguration() {
    Configuration conf = new Configuration();
    conf.set(JHAdminConfig.MR_HISTORY_LOADED_TASKS_CACHE_SIZE, """");

    HistoryFileManager historyManager = mock(HistoryFileManager.class);
    JobHistory jobHistory = spy(new JobHistory());
    doReturn(historyManager).when(jobHistory).createHistoryFileManager();
    jobHistory.init(conf);
    jobHistory.start();

    CachedHistoryStorage storage = spy((CachedHistoryStorage) jobHistory
        .getHistoryStorage());

    assertFalse(storage.getUseLoadedTasksCache());
  }",No Smells
"@Test
  public void testRefreshLoadedJobCache() throws Exception {
    HistoryFileManager historyManager = mock(HistoryFileManager.class);
    jobHistory = spy(new JobHistory());
    doReturn(historyManager).when(jobHistory).createHistoryFileManager();

    Configuration conf = new Configuration();
    // Set the cache size to 2
    conf.setInt(JHAdminConfig.MR_HISTORY_LOADED_JOB_CACHE_SIZE, 2);
    jobHistory.init(conf);
    jobHistory.start();

    CachedHistoryStorage storage = spy((CachedHistoryStorage) jobHistory
        .getHistoryStorage());

    assertFalse(storage.getUseLoadedTasksCache());

    Job[] jobs = new Job[3];
    JobId[] jobIds = new JobId[3];

    for (int i = 0; i < 3; i++) {
      jobs[i] = mock(Job.class);
      jobIds[i] = mock(JobId.class);
      when(jobs[i].getID()).thenReturn(jobIds[i]);
    }",Eager Test
"@Test
  public void testRefreshLoadedJobCacheUnSupportedOperation() {
    jobHistory = spy(new JobHistory());
    HistoryStorage storage = new HistoryStorage() {

      @Override
      public void setHistoryFileManager(HistoryFileManager hsManager) {
        // TODO Auto-generated method stub

      }",No Smells
"@Test
  public void testHsJobBlockForNormalSizeJobShouldNotDisplayWarningMessage() {

    Configuration config = new Configuration();
    config.setInt(JHAdminConfig.MR_HS_LOADED_JOBS_TASKS_MAX, -1);

    JobHistory jobHistory = new JobHitoryStubWithAllNormalSizeJobs();
    jobHistory.init(config);

    HsJobBlock jobBlock = new HsJobBlock(jobHistory) {
      // override this so that the job block can fetch a job id.
      @Override
      public Map<String, String> moreParams() {
        Map<String, String> map = new HashMap<>();
        map.put(AMParams.JOB_ID, ""job_0000_0001"");
        return map;
      }",No Smells
"@Test public void testAppControllerIndex() {
    MockAppContext ctx = new MockAppContext(0, 1, 1, 1);
    Injector injector = WebAppTests.createMockInjector(AppContext.class, ctx);
    HsController controller = injector.getInstance(HsController.class);
    controller.index();
    assertEquals(ctx.getApplicationID().toString(), controller.get(APP_ID,""""));
  }",No Smells
"@Test public void testJobView() {
    LOG.info(""HsJobPage"");
    AppContext appContext = new MockAppContext(0, 1, 1, 1);
    Map<String, String> params = TestAMWebApp.getJobParams(appContext);
    WebAppTests.testPage(HsJobPage.class, AppContext.class, appContext, params);
  }",No Smells
"@Test public void testSingleCounterView() {
    LOG.info(""HsSingleCounterPage"");
    WebAppTests.testPage(HsSingleCounterPage.class, AppContext.class,
                         new MockAppContext(0, 1, 1, 1));
  }",No Smells
"@Test
  public void testTasksViewNaturalSortType() {
    LOG.info(""HsTasksPage"");
    AppContext appContext = new MockAppContext(0, 1, 1, 1);
    Map<String, String> params = TestAMWebApp.getTaskParams(appContext);
    Injector testPage = WebAppTests.testPage(HsTasksPage.class, AppContext.class, appContext, params);
    View viewInstance = testPage.getInstance(HsTasksPage.class);
    Map<String, String> moreParams = viewInstance.context().requestContext().moreParams();
    String appTableColumnsMeta = moreParams.get(""ui.dataTables.selector.init"");
    Assert.assertTrue(appTableColumnsMeta.indexOf(""natural"") != -1);
  }",No Smells
"@Test
  public void testTaskView() {
    LOG.info(""HsTaskPage"");
    AppContext appContext = new MockAppContext(0, 1, 1, 1);
    Map<String, String> params = TestAMWebApp.getTaskParams(appContext);
    WebAppTests
        .testPage(HsTaskPage.class, AppContext.class, appContext, params);
  }",No Smells
"@Test
  public void testTaskViewNaturalSortType() {
    LOG.info(""HsTaskPage"");
    AppContext appContext = new MockAppContext(0, 1, 1, 1);
    Map<String, String> params = TestAMWebApp.getTaskParams(appContext);
    Injector testPage = WebAppTests.testPage(HsTaskPage.class, AppContext.class, appContext, params);
    View viewInstance = testPage.getInstance(HsTaskPage.class);
    Map<String, String> moreParams = viewInstance.context().requestContext().moreParams();
    String appTableColumnsMeta = moreParams.get(""ui.dataTables.attempts.init"");
    Assert.assertTrue(appTableColumnsMeta.indexOf(""natural"") != -1);
  }",No Smells
"@Test
  public void testUserNamePercentEncoding() throws IOException {
    JobIndexInfo info = new JobIndexInfo();
    JobID oldJobId = JobID.forName(JOB_ID);
    JobId jobId = TypeConverter.toYarn(oldJobId);
    info.setJobId(jobId);
    info.setSubmitTime(Long.parseLong(SUBMIT_TIME));
    info.setUser(USER_NAME_WITH_DELIMITER);
    info.setJobName(JOB_NAME);
    info.setFinishTime(Long.parseLong(FINISH_TIME));
    info.setNumMaps(Integer.parseInt(NUM_MAPS));
    info.setNumReduces(Integer.parseInt(NUM_REDUCES));
    info.setJobStatus(JOB_STATUS);
    info.setQueueName(QUEUE_NAME);
    info.setJobStartTime(Long.parseLong(JOB_START_TIME));

    String jobHistoryFile = FileNameIndexUtils.getDoneFileName(info);
    assertTrue(jobHistoryFile.contains(USER_NAME_WITH_DELIMITER_ESCAPE),
        ""User name not encoded correctly into job history file"");
  }",No Smells
"@Test
  public void testTaskStateUI() {
    assertTrue(MRApps.TaskStateUI.PENDING.correspondsTo(TaskState.SCHEDULED));
    assertTrue(MRApps.TaskStateUI.COMPLETED.correspondsTo(TaskState.SUCCEEDED));
    assertTrue(MRApps.TaskStateUI.COMPLETED.correspondsTo(TaskState.FAILED));
    assertTrue(MRApps.TaskStateUI.COMPLETED.correspondsTo(TaskState.KILLED));
    assertTrue(MRApps.TaskStateUI.RUNNING.correspondsTo(TaskState.RUNNING));
  }",No Smells
"@Test
  public void testGetMetricsAndJmx() throws Exception {
    // create test source with a single metric counter of value 0
    TestSource source = new TestSource(""test"");
    MetricsSourceBuilder sb = MetricsAnnotations.newSourceBuilder(source);
    final MetricsSource s = sb.build();

    List<MetricsTag> injectedTags = new ArrayList<MetricsTag>();
    MetricsSourceAdapter sa = new MetricsSourceAdapter(
        ""test"", ""test"", ""test desc"", s, injectedTags, null, null, 1, false);

    // all metrics are initially assumed to have changed
    MetricsCollectorImpl builder = new MetricsCollectorImpl();
    Iterable<MetricsRecordImpl> metricsRecords = sa.getMetrics(builder, true);

    // Validate getMetrics and JMX initial values
    MetricsRecordImpl metricsRecord = metricsRecords.iterator().next();
    assertEquals(0L,
        metricsRecord.metrics().iterator().next().value().longValue());

    Thread.sleep(100); // skip JMX cache TTL
    assertEquals(0L, (Number)sa.getAttribute(""C1""));

    // change metric value
    source.incrementCnt();

    // validate getMetrics and JMX
    builder = new MetricsCollectorImpl();
    metricsRecords = sa.getMetrics(builder, true);
    metricsRecord = metricsRecords.iterator().next();
    assertTrue(metricsRecord.metrics().iterator().hasNext());
    Thread.sleep(100); // skip JMX cache TTL
    assertEquals(1L, (Number)sa.getAttribute(""C1""));
  }",No Smells
"@Test
  public void testPurgeOldMetrics() throws Exception {
    // create test source with a single metric counter of value 1
    PurgableSource source = new PurgableSource();
    MetricsSourceBuilder sb = MetricsAnnotations.newSourceBuilder(source);
    final MetricsSource s = sb.build();

    List<MetricsTag> injectedTags = new ArrayList<MetricsTag>();
    MetricsSourceAdapter sa = new MetricsSourceAdapter(
        ""tst"", ""tst"", ""testdesc"", s, injectedTags, null, null, 1, false);

    MBeanInfo info = sa.getMBeanInfo();
    boolean sawIt = false;
    for (MBeanAttributeInfo mBeanAttributeInfo : info.getAttributes()) {
      sawIt |= mBeanAttributeInfo.getName().equals(source.lastKeyName);
    }",Eager Test
"@Test public void testRegisterSourceWithoutName() {
    MetricsSystem ms = new MetricsSystemImpl();
    TestSource ts = new TestSource(""ts"");
    TestSource2 ts2 = new TestSource2(""ts2"");
    ms.register(ts);
    ms.register(ts2);
    ms.init(""TestMetricsSystem"");
    // if metrics source is registered without name,
    // the class name will be used as the name
    MetricsSourceAdapter sa = ((MetricsSystemImpl) ms)
        .getSourceAdapter(""TestSource"");
    assertNotNull(sa);
    MetricsSourceAdapter sa2 = ((MetricsSystemImpl) ms)
        .getSourceAdapter(""TestSource2"");
    assertNotNull(sa2);
    ms.shutdown();
  }",No Smells
"@Test public void testStartStopStart() {
    DefaultMetricsSystem.shutdown(); // Clear pre-existing source names.
    MetricsSystemImpl ms = new MetricsSystemImpl(""test"");
    TestSource ts = new TestSource(""ts"");
    ms.start();
    ms.register(""ts"", """", ts);
    MetricsSourceAdapter sa = ms.getSourceAdapter(""ts"");
    assertNotNull(sa);
    assertNotNull(sa.getMBeanName());
    ms.stop();
    ms.shutdown();
    ms.start();
    sa = ms.getSourceAdapter(""ts"");
    assertNotNull(sa);
    assertNotNull(sa.getMBeanName());
    ms.stop();
    ms.shutdown();
  }",No Smells
"@Test public void testUnregisterSource() {
    MetricsSystem ms = new MetricsSystemImpl();
    TestSource ts1 = new TestSource(""ts1"");
    TestSource ts2 = new TestSource(""ts2"");
    ms.register(""ts1"", """", ts1);
    ms.register(""ts2"", """", ts2);
    MetricsSource s1 = ms.getSource(""ts1"");
    assertNotNull(s1);
    // should work when metrics system is not started
    ms.unregisterSource(""ts1"");
    s1 = ms.getSource(""ts1"");
    assertNull(s1);
    MetricsSource s2 = ms.getSource(""ts2"");
    assertNotNull(s2);
    ms.shutdown();
  }",No Smells
"@Test public void testCommon() {
    MetricsVisitor visitor = mock(MetricsVisitor.class);
    MetricsRegistry registry = new MetricsRegistry(""test"");
    List<AbstractMetric> metrics = MetricsLists.builder(""test"")
        .addCounter(info(""c1"", ""int counter""), 1)
        .addCounter(info(""c2"", ""long counter""), 2L)
        .addGauge(info(""g1"", ""int gauge""), 5)
        .addGauge(info(""g2"", ""long gauge""), 6L)
        .addGauge(info(""g3"", ""float gauge""), 7f)
        .addGauge(info(""g4"", ""double gauge""), 8d)
        .metrics();

    for (AbstractMetric metric : metrics) {
      metric.visit(visitor);
    }",Eager Test
"@Test public void testClear() {
    final SinkQueue<Integer> q = new SinkQueue<Integer>(128);
    for (int i = 0; i < q.capacity() + 97; ++i) {
      q.enqueue(i);
    }",Eager Test
"@Test public void testHangingConsumer() throws Exception {
    SinkQueue<Integer> q = newSleepingConsumerQueue(2, 1, 2);
    assertEquals(""queue back"", 2, (int) q.back());
    assertTrue(""should drop"", !q.enqueue(3)); // should not block
    assertEquals(""queue size"", 2, q.size());
    assertEquals(""queue head"", 1, (int) q.front());
    assertEquals(""queue back"", 2, (int) q.back());
  }",No Smells
"@Test public void testInfoOverflow() {
    MetricsInfo i0 = info(""m0"", ""m desc"");
    for (int i = 0; i < MAX_INFO_NAMES + 1; ++i) {
      info(""m""+ i, ""m desc"");
      if (i < MAX_INFO_NAMES) {
        assertSame(""m0 is still there"", i0, info(""m0"", ""m desc""));
      }",Eager Test
"@Test public void testTag() {
    MetricsTag tag = tag(""t"", ""t desc"", ""t value"");
    assertSame(""same tag"", tag, tag(""t"", ""t desc"", ""t value""));
  }",No Smells
"@Test public void testTagOverflow() {
    MetricsTag t0 = tag(""t0"", ""t desc"", ""t value"");
    for (int i = 0; i < MAX_TAG_NAMES + 1; ++i) {
      tag(""t""+ i, ""t desc"", ""t value"");
      if (i < MAX_TAG_NAMES) {
        assertSame(""t0 still there"", t0, tag(""t0"", ""t desc"", ""t value""));
      }",Eager Test
"@Test public void testClasses() {
    MetricsRecordBuilder rb = getMetrics(
        MetricsAnnotations.makeSource(new MyMetrics3()));
    MetricsCollector collector = rb.parent();

    verify(collector).addRecord(info(""MyMetrics3"", ""My metrics""));
    verify(rb).add(tag(MsInfo.Context, ""foo""));
  }",No Smells
"@Test public void testFields() {
    MyMetrics metrics = new MyMetrics();
    MetricsSource source = MetricsAnnotations.makeSource(metrics);

    metrics.c1.incr();
    metrics.c2.incr();
    metrics.g1.incr();
    metrics.g2.incr();
    metrics.g3.incr();
    metrics.g4.incr();
    metrics.r1.add(1);
    metrics.s1.add(1);
    metrics.rs1.add(""rs1"", 1);

    MetricsRecordBuilder rb = getMetrics(source);

    verify(rb).addCounter(info(""C1"", ""C1""), 1);
    verify(rb).addCounter(info(""Counter2"", ""Counter2 desc""), 1L);
    verify(rb).addGauge(info(""G1"", ""G1""), 1);
    verify(rb).addGauge(info(""G2"", ""G2""), 1);
    verify(rb).addGauge(info(""G3"", ""g3 desc""), 1L);
    verify(rb).addGauge(info(""G4"", ""g4 desc""), 1f);
    verify(rb).addCounter(info(""R1NumOps"", ""Number of ops for r1""), 1L);
    verify(rb).addGauge(info(""R1AvgTime"", ""Average time for r1""), 1.0);
    verify(rb).addCounter(info(""S1NumOps"", ""Number of ops for s1""), 1L);
    verify(rb).addGauge(info(""S1AvgTime"", ""Average time for s1""), 1.0);
    verify(rb).addCounter(info(""Rs1NumOps"", ""Number of ops for rs1""), 1L);
    verify(rb).addGauge(info(""Rs1AvgTime"", ""Average time for rs1""), 1.0);
  }",No Smells
"@Test public void testNewMetrics() {
    final MetricsRegistry r = new MetricsRegistry(""test"");
    r.newCounter(""c1"", ""c1 desc"", 1);
    r.newCounter(""c2"", ""c2 desc"", 2L);
    r.newGauge(""g1"", ""g1 desc"", 3);
    r.newGauge(""g2"", ""g2 desc"", 4L);
    r.newGauge(""g3"", ""g3 desc"", 5f);
    r.newStat(""s1"", ""s1 desc"", ""ops"", ""time"");

    assertEquals(""num metrics in registry"", 6, r.metrics().size());
    assertTrue(""c1 found"", r.get(""c1"") instanceof MutableCounterInt);
    assertTrue(""c2 found"", r.get(""c2"") instanceof MutableCounterLong);
    assertTrue(""g1 found"", r.get(""g1"") instanceof MutableGaugeInt);
    assertTrue(""g2 found"", r.get(""g2"") instanceof MutableGaugeLong);
    assertTrue(""g3 found"", r.get(""g3"") instanceof MutableGaugeFloat);
    assertTrue(""s1 found"", r.get(""s1"") instanceof MutableStat);

    expectMetricsException(""Metric name c1 already exists"", new Runnable() {
      @Override
      public void run() { r.newCounter(""c1"", ""test dup"", 0); }",No Smells
"@Test
  public void testQuantileError() throws IOException {
    final int count = 100000;
    Random rnd = new Random(0xDEADDEAD);
    int[] values = new int[count];
    for (int i = 0; i < count; i++) {
      values[i] = i + 1;
    }",Eager Test
"@Test
  public void testLocalHostHasAnAddress() throws Exception {
    assertNotNull(getLocalIPAddr());
  }",No Smells
"@Test
  public void testNullInterface() throws Exception {
    String host = DNS.getDefaultHost(null);  // should work.
    Assertions.assertThat(host).isEqualTo(DNS.getDefaultHost(DEFAULT));
    try {
      String ip = DNS.getDefaultIP(null);
      fail(""Expected a NullPointerException, got "" + ip);
    }",No Smells
"@Test
  public void testCanonicalUriWithNoAuthority() {
    URI uri;

    uri = NetUtils.getCanonicalUri(URI.create(""scheme:/""), 2);
    assertEquals(""scheme:/"", uri.toString());

    uri = NetUtils.getCanonicalUri(URI.create(""scheme:/path""), 2);
    assertEquals(""scheme:/path"", uri.toString());

    uri = NetUtils.getCanonicalUri(URI.create(""scheme:///""), 2);
    assertEquals(""scheme:///"", uri.toString());

    uri = NetUtils.getCanonicalUri(URI.create(""scheme:///path""), 2);
    assertEquals(""scheme:///path"", uri.toString());
  }",No Smells
"@Test
  public void testCanonicalUriWithPath() {
    URI uri;

    uri = NetUtils.getCanonicalUri(URI.create(""path""), 2);
    assertEquals(""path"", uri.toString());

    uri = NetUtils.getCanonicalUri(URI.create(""/path""), 2);
    assertEquals(""/path"", uri.toString());
  }",No Smells
"@Test
  public void testGetLocalInetAddress() throws Exception {
    assertNotNull(NetUtils.getLocalInetAddress(""127.0.0.1""));
    assertNull(NetUtils.getLocalInetAddress(""invalid-address-for-test""));
    assertNull(NetUtils.getLocalInetAddress(null));
  }",Mystery Guest
"@Test
  public void testIsLocalAddress() throws Exception {
    // Test - local host is local address
    assertTrue(NetUtils.isLocalAddress(InetAddress.getLocalHost()));
    
    // Test - all addresses bound network interface is local address
    Enumeration<NetworkInterface> interfaces = NetworkInterface
        .getNetworkInterfaces();
    if (interfaces != null) { // Iterate through all network interfaces
      while (interfaces.hasMoreElements()) {
        NetworkInterface i = interfaces.nextElement();
        Enumeration<InetAddress> addrs = i.getInetAddresses();
        if (addrs == null) {
          continue;
        }",Eager Test
"@Test
  public void testResolverGetByNameUnqualifiedWithDomain() {
    String host = ""unknown.domain"";
    verifyGetByName(host, host+""."", host+"".a.b."", host+"".b."", host+"".c."");
  }",No Smells
"@Test
  public void testSocketReadTimeoutWithChannel() throws Exception {
    doSocketReadTimeoutTest(true);
  }",No Smells
"@Test
  public void testWrapBindException() throws Throwable {
    IOException e = new BindException(""failed"");
    IOException wrapped = verifyExceptionClass(e, BindException.class);
    assertInException(wrapped, ""failed"");
    assertLocalDetailsIncluded(wrapped);
    assertNotInException(wrapped, DEST_PORT_NAME);
    assertInException(wrapped, ""/BindException"");
  }",No Smells
"@Test
  public void testWrapIOEWithPrivateStringConstructor() throws Throwable {
    class TestIOException extends CharacterCodingException{
      private  TestIOException(String cause){
      }",No Smells
"@Test
  public void testWrapUnknownHostException() throws Throwable {
    IOException e = new UnknownHostException(""failed"");
    IOException wrapped = verifyExceptionClass(e, UnknownHostException.class);
    assertInException(wrapped, ""failed"");
    assertWikified(wrapped);
    assertInException(wrapped, ""localhost"");
    assertRemoteDetailsIncluded(wrapped);
    assertInException(wrapped, ""/UnknownHost"");
  }",No Smells
"@Test
  public void testChooseRandomInclude3() {
    String scope = ""/d1"";
    Map<Node, Integer> frequency = pickNodesAtRandom(200, scope, null);
    LOG.info(""No node is excluded."");
    for (int i = 0; i < 5; ++i) {
      // all nodes should be more than zero
      assertTrue(dataNodes[i] + "" should have been chosen."",
          frequency.get(dataNodes[i]) > 0);
    }",Eager Test
"@Test
  public void testCreateInvalidTopology() throws Exception {
    NetworkTopology invalCluster =
        NetworkTopology.getInstance(new Configuration());
    DatanodeDescriptor invalDataNodes[] = new DatanodeDescriptor[] {
        DFSTestUtil.getDatanodeDescriptor(""1.1.1.1"", ""/d1/r1""),
        DFSTestUtil.getDatanodeDescriptor(""2.2.2.2"", ""/d1/r1""),
        DFSTestUtil.getDatanodeDescriptor(""3.3.3.3"", ""/d1"")
    }",No Smells
"@Test
  public void testGetDistance() throws Exception {
    assertEquals(cluster.getDistance(dataNodes[0], dataNodes[0]), 0);
    assertEquals(cluster.getDistance(dataNodes[0], dataNodes[1]), 2);
    assertEquals(cluster.getDistance(dataNodes[0], dataNodes[3]), 4);
    assertEquals(cluster.getDistance(dataNodes[0], dataNodes[6]), 6);
    // verify the distance is zero as long as two nodes have the same path.
    // They don't need to refer to the same object.
    NodeBase node1 = new NodeBase(dataNodes[0].getHostName(),
        dataNodes[0].getNetworkLocation());
    NodeBase node2 = new NodeBase(dataNodes[0].getHostName(),
        dataNodes[0].getNetworkLocation());
    assertEquals(0, cluster.getDistance(node1, node2));
    // verify the distance can be computed by path.
    // They don't need to refer to the same object or parents.
    NodeBase node3 = new NodeBase(dataNodes[3].getHostName(),
        dataNodes[3].getNetworkLocation());
    NodeBase node4 = new NodeBase(dataNodes[6].getHostName(),
        dataNodes[6].getNetworkLocation());
    assertEquals(0, NetworkTopology.getDistanceByPath(node1, node2));
    assertEquals(4, NetworkTopology.getDistanceByPath(node2, node3));
    assertEquals(6, NetworkTopology.getDistanceByPath(node2, node4));
  }",No Smells
"@Test
  public void testNumOfChildren() throws Exception {
    assertEquals(cluster.getNumOfLeaves(), dataNodes.length);
  }",No Smells
"@Test
  public void testRacks() throws Exception {
    assertEquals(cluster.getNumOfRacks(), 6);
    assertTrue(cluster.isOnSameRack(dataNodes[0], dataNodes[1]));
    assertFalse(cluster.isOnSameRack(dataNodes[1], dataNodes[2]));
    assertTrue(cluster.isOnSameRack(dataNodes[2], dataNodes[3]));
    assertTrue(cluster.isOnSameRack(dataNodes[3], dataNodes[4]));
    assertFalse(cluster.isOnSameRack(dataNodes[4], dataNodes[5]));
    assertTrue(cluster.isOnSameRack(dataNodes[5], dataNodes[6]));
  }",No Smells
"@Test
  public void testRemove() throws Exception {
    // this cluster topology is:
    // /d1/r1, /d1/r2, /d2/r3, /d3/r1, /d3/r2, /d4/r1
    // so root """" has four children
    assertEquals(4, cluster.clusterMap.getNumOfChildren());
    for(int i=0; i<dataNodes.length; i++) {
      cluster.remove(dataNodes[i]);
    }",Eager Test
"@Test
  public void testAddNodeWithInvalidTopology() {
    // The last node is a node with invalid topology
    try {
      cluster.add(rackOnlyNode);
      fail(""Exception should be thrown, so we should not have reached here."");
    }",No Smells
"@Test
  public void testChooseRandomExcludedNode() {
    String scope = ""~"" + NodeBase.getPath(dataNodes[0]);
    Map<Node, Integer> frequency = pickNodesAtRandom(100, scope);

    for (Node key : dataNodes) {
      // all nodes except the first should be more than zero
      assertTrue(frequency.get(key) > 0 || key == dataNodes[0]);
    }",Eager Test
"@Test
  public void testGetDistance() throws Exception {
    assertEquals(0, cluster.getDistance(dataNodes[0], dataNodes[0]));
    assertEquals(2, cluster.getDistance(dataNodes[0], dataNodes[1]));
    assertEquals(4, cluster.getDistance(dataNodes[0], dataNodes[2]));
    assertEquals(6, cluster.getDistance(dataNodes[0], dataNodes[3]));
    assertEquals(8, cluster.getDistance(dataNodes[0], dataNodes[6]));
  }",No Smells
"@Test
  public void testNodeGroups() throws Exception {
    assertEquals(3, cluster.getNumOfRacks());
    assertTrue(cluster.isOnSameNodeGroup(dataNodes[0], dataNodes[1]));
    assertFalse(cluster.isOnSameNodeGroup(dataNodes[1], dataNodes[2]));
    assertFalse(cluster.isOnSameNodeGroup(dataNodes[2], dataNodes[3]));
    assertTrue(cluster.isOnSameNodeGroup(dataNodes[3], dataNodes[4]));
    assertFalse(cluster.isOnSameNodeGroup(dataNodes[4], dataNodes[5]));
    assertFalse(cluster.isOnSameNodeGroup(dataNodes[5], dataNodes[6]));
    assertFalse(cluster.isOnSameNodeGroup(dataNodes[6], dataNodes[7]));
  }",No Smells
"@Test
  public void testNumOfRacks() throws Exception {
    assertEquals(3, cluster.getNumOfRacks());
  }",No Smells
"@Test
  public void testSortByDistance() throws Exception {
    NodeBase[] testNodes = new NodeBase[4];

    // array contains both local node, local node group & local rack node
    testNodes[0] = dataNodes[1];
    testNodes[1] = dataNodes[2];
    testNodes[2] = dataNodes[3];
    testNodes[3] = dataNodes[0];
    cluster.sortByDistance(dataNodes[0], testNodes, testNodes.length);
    assertTrue(testNodes[0] == dataNodes[0]);
    assertTrue(testNodes[1] == dataNodes[1]);
    assertTrue(testNodes[2] == dataNodes[2]);
    assertTrue(testNodes[3] == dataNodes[3]);

    // array contains local node & local node group
    testNodes[0] = dataNodes[3];
    testNodes[1] = dataNodes[4];
    testNodes[2] = dataNodes[1];
    testNodes[3] = dataNodes[0];
    cluster.sortByDistance(dataNodes[0], testNodes, testNodes.length);
    assertTrue(testNodes[0] == dataNodes[0]);
    assertTrue(testNodes[1] == dataNodes[1]);

    // array contains local node & rack node
    testNodes[0] = dataNodes[5];
    testNodes[1] = dataNodes[3];
    testNodes[2] = dataNodes[2];
    testNodes[3] = dataNodes[0];
    cluster.sortByDistance(dataNodes[0], testNodes, testNodes.length);
    assertTrue(testNodes[0] == dataNodes[0]);
    assertTrue(testNodes[1] == dataNodes[2]);

    // array contains local-nodegroup node (not a data node also) & rack node
    testNodes[0] = dataNodes[6];
    testNodes[1] = dataNodes[7];
    testNodes[2] = dataNodes[2];
    testNodes[3] = dataNodes[0];
    cluster.sortByDistance(computeNode, testNodes, testNodes.length);
    assertTrue(testNodes[0] == dataNodes[0]);
    assertTrue(testNodes[1] == dataNodes[2]);
  }",No Smells
"@Test
  public void testNoArgsMeansNoResult() {
    Configuration conf = new Configuration();
    conf.setInt(ScriptBasedMapping.SCRIPT_ARG_COUNT_KEY,
                ScriptBasedMapping.MIN_ALLOWABLE_ARGS - 1);
    conf.set(ScriptBasedMapping.SCRIPT_FILENAME_KEY, ""any-filename"");
    conf.set(ScriptBasedMapping.SCRIPT_FILENAME_KEY, ""any-filename"");
    ScriptBasedMapping mapping = createMapping(conf);
    List<String> names = new ArrayList<String>();
    names.add(""some.machine.name"");
    names.add(""other.machine.name"");
    List<String> result = mapping.resolve(names);
    assertNull(""Expected an empty list"", result);
  }",No Smells
"@Test
  public void testFilenameMeansMultiSwitch() throws Throwable {
    Configuration conf = new Configuration();
    conf.set(ScriptBasedMapping.SCRIPT_FILENAME_KEY, ""any-filename"");
    ScriptBasedMapping mapping = createMapping(conf);
    assertFalse(""Expected to be multi switch"", mapping.isSingleSwitch());
    mapping.setConf(new Configuration());
    assertTrue(""Expected to be single switch"", mapping.isSingleSwitch());
  }",No Smells
"@Test
  public void testNoFilenameMeansSingleSwitch() throws Throwable {
    Configuration conf = new Configuration();
    ScriptBasedMapping mapping = createMapping(conf);
    assertTrue(""Expected to be single switch"", mapping.isSingleSwitch());
    assertTrue(""Expected to be single switch"",
               AbstractDNSToSwitchMapping.isMappingSingleSwitch(mapping));
  }",No Smells
"@Test
  public void testCachingRelaysMultiSwitchQueries() throws Throwable {
    StaticMapping staticMapping = newInstance(""top"");
    assertMultiSwitch(staticMapping);
    CachedDNSToSwitchMapping cachedMap =
        new CachedDNSToSwitchMapping(staticMapping);
    LOG.info(""Mapping: "" + cachedMap + ""\n"" + cachedMap.dumpTopology());
    assertMultiSwitch(cachedMap);
  }",No Smells
"@Test
  public void testStaticIsSingleSwitchOnNullScript() throws Throwable {
    StaticMapping mapping = newInstance(null);
    mapping.setConf(createConf(null));
    assertSingleSwitch(mapping);
  }",No Smells
"@Test
  public void testClearingCachedMappings() throws IOException {
    File mapFile = File.createTempFile(getClass().getSimpleName() +
        "".testClearingCachedMappings"", "".txt"");
    Files.asCharSink(mapFile, StandardCharsets.UTF_8).write(
        hostName1 + "" /rack1\n"" + hostName2 + ""\t/rack2\n"");
    mapFile.deleteOnExit();

    TableMapping mapping = new TableMapping();

    Configuration conf = new Configuration();
    conf.set(NET_TOPOLOGY_TABLE_MAPPING_FILE_KEY, mapFile.getCanonicalPath());
    mapping.setConf(conf);

    List<String> names = new ArrayList<String>();
    names.add(hostName1);
    names.add(hostName2);

    List<String> result = mapping.resolve(names);
    assertEquals(names.size(), result.size());
    assertEquals(""/rack1"", result.get(0));
    assertEquals(""/rack2"", result.get(1));

    Files.asCharSink(mapFile, StandardCharsets.UTF_8).write("""");

    mapping.reloadCachedMappings();

    names = new ArrayList<String>();
    names.add(hostName1);
    names.add(hostName2);

    result = mapping.resolve(names);
    assertEquals(names.size(), result.size());
    assertEquals(NetworkTopology.DEFAULT_RACK, result.get(0));
    assertEquals(NetworkTopology.DEFAULT_RACK, result.get(1));
  }",Mystery Guest
"@Test
  public void testFileDoesNotExist() {
    TableMapping mapping = new TableMapping();

    Configuration conf = new Configuration();
    conf.set(NET_TOPOLOGY_TABLE_MAPPING_FILE_KEY, ""/this/file/does/not/exist"");
    mapping.setConf(conf);

    List<String> names = new ArrayList<String>();
    names.add(hostName1);
    names.add(hostName2);

    List<String> result = mapping.resolve(names);
    assertEquals(names.size(), result.size());
    assertEquals(result.get(0), NetworkTopology.DEFAULT_RACK);
    assertEquals(result.get(1), NetworkTopology.DEFAULT_RACK);
  }",No Smells
"@Test
  public void testNoFile() {
    TableMapping mapping = new TableMapping();

    Configuration conf = new Configuration();
    mapping.setConf(conf);

    List<String> names = new ArrayList<String>();
    names.add(hostName1);
    names.add(hostName2);

    List<String> result = mapping.resolve(names);
    assertEquals(names.size(), result.size());
    assertEquals(NetworkTopology.DEFAULT_RACK, result.get(0));
    assertEquals(NetworkTopology.DEFAULT_RACK, result.get(1));
  }",No Smells
"@Test
  public void testCidrLongRW() {
    NfsExports matcher = new NfsExports(CacheSize, ExpirationPeriod, 
        ""192.168.0.0/255.255.252.0 rw"");
    Assert.assertEquals(AccessPrivilege.READ_WRITE,
        matcher.getAccessPrivilege(address1, hostname1));
    Assert.assertEquals(AccessPrivilege.NONE,
        matcher.getAccessPrivilege(address2, hostname1));
  }",No Smells
"@Test
  public void testExactAddressRO() {
    NfsExports matcher = new NfsExports(CacheSize, ExpirationPeriod, address1);
    Assert.assertEquals(AccessPrivilege.READ_ONLY,
        matcher.getAccessPrivilege(address1, hostname1));
    Assert.assertEquals(AccessPrivilege.NONE,
        matcher.getAccessPrivilege(address2, hostname1));
  }",No Smells
"@Test
  public void testRegexGrouping() {
    NfsExports matcher = new NfsExports(CacheSize, ExpirationPeriod,
        ""192.168.0.(12|34)"");
    Assert.assertEquals(AccessPrivilege.READ_ONLY,
        matcher.getAccessPrivilege(address1, hostname1));
    // address1 will hit the cache
    Assert.assertEquals(AccessPrivilege.READ_ONLY,
        matcher.getAccessPrivilege(address1, hostname2));

    matcher = new NfsExports(CacheSize, ExpirationPeriod, ""\\w*.a.b.com"");
    Assert.assertEquals(AccessPrivilege.READ_ONLY,
        matcher.getAccessPrivilege(""1.2.3.4"", ""web.a.b.com""));
    // address ""1.2.3.4"" will hit the cache
    Assert.assertEquals(AccessPrivilege.READ_ONLY,
        matcher.getAccessPrivilege(""1.2.3.4"", ""email.a.b.org""));
  }",No Smells
"@Test
  public void testRegexHostRO() {
    NfsExports matcher = new NfsExports(CacheSize, ExpirationPeriod,
        ""[a-z]+.b.com"");
    Assert.assertEquals(AccessPrivilege.READ_ONLY,
        matcher.getAccessPrivilege(address1, hostname1));
    // address1 will hit the cache
    Assert.assertEquals(AccessPrivilege.READ_ONLY,
        matcher.getAccessPrivilege(address1, hostname2));
  }",No Smells
"@Test
  public void testRegexHostRW() {
    NfsExports matcher = new NfsExports(CacheSize, ExpirationPeriod,
        ""[a-z]+.b.com rw"");
    Assert.assertEquals(AccessPrivilege.READ_WRITE,
        matcher.getAccessPrivilege(address1, hostname1));
    // address1 will hit the cache
    Assert.assertEquals(AccessPrivilege.READ_WRITE,
        matcher.getAccessPrivilege(address1, hostname2));
  }",No Smells
"@Test
  public void testRegexIPRO() {
    NfsExports matcher = new NfsExports(CacheSize, ExpirationPeriod,
        ""192.168.0.[0-9]+"");
    Assert.assertEquals(AccessPrivilege.READ_ONLY,
        matcher.getAccessPrivilege(address1, hostname1));
    Assert.assertEquals(AccessPrivilege.NONE,
        matcher.getAccessPrivilege(address2, hostname1));
  }",No Smells
"@Test
  public void testConstructor() {
    NfsTime nfstime = new NfsTime(1001);
    Assert.assertEquals(1, nfstime.getSeconds());
    Assert.assertEquals(1000000, nfstime.getNseconds());
  }",No Smells
"@Test
  public void testHostNameNotMultipleOf4() {
    CredentialsSys credential = new CredentialsSys();
    credential.setUID(0);
    credential.setGID(1);
    credential.setStamp(1234);
    credential.setHostName(""hadoop-nfs"");

    XDR xdr = new XDR();
    credential.write(xdr);

    CredentialsSys newCredential = new CredentialsSys();
    newCredential.read(xdr.asReadOnlyWrap());

    assertEquals(0, newCredential.getUID());
    assertEquals(1, newCredential.getGID());
    assertEquals(1234, newCredential.getStamp());
    assertEquals(32, newCredential.getCredentialLength());
  }",No Smells
"@Test
  public void testReadWrite() {
    CredentialsSys credential = new CredentialsSys();
    credential.setUID(0);
    credential.setGID(1);
    credential.setStamp(1234);

    XDR xdr = new XDR();
    credential.write(xdr);

    CredentialsSys newCredential = new CredentialsSys();
    newCredential.read(xdr.asReadOnlyWrap());

    assertEquals(0, newCredential.getUID());
    assertEquals(1, newCredential.getGID());
    assertEquals(1234, newCredential.getStamp());
  }",No Smells
"@Test
  public void testAcceptState() {
    assertEquals(AcceptState.SUCCESS, AcceptState.fromValue(0));
    assertEquals(AcceptState.PROG_UNAVAIL, AcceptState.fromValue(1));
    assertEquals(AcceptState.PROG_MISMATCH, AcceptState.fromValue(2));
    assertEquals(AcceptState.PROC_UNAVAIL, AcceptState.fromValue(3));
    assertEquals(AcceptState.GARBAGE_ARGS, AcceptState.fromValue(4));
    assertEquals(AcceptState.SYSTEM_ERR, AcceptState.fromValue(5));
  }",No Smells
"@Test
  public void testRpcCallCacheConstructor(){
    RpcCallCache cache = new RpcCallCache(""test"", 100);
    assertEquals(""test"", cache.getProgram());
  }",No Smells
"@Test
  public void testRpcMessage() {
    RpcMessage msg = getRpcMessage(0, RpcMessage.Type.RPC_CALL);
    Assert.assertEquals(0, msg.getXid());
    Assert.assertEquals(RpcMessage.Type.RPC_CALL, msg.getMessageType());
  }",No Smells
"@Test
  public void testValidateMessage() {
    RpcMessage msg = getRpcMessage(0, RpcMessage.Type.RPC_CALL);
    msg.validateMessageType(RpcMessage.Type.RPC_CALL);
  }",No Smells
"@Test
  public void testRpcReply() {
    RpcReply reply = new RpcReply(0, ReplyState.MSG_ACCEPTED,
        new VerifierNone()) {
          @Override
          public XDR write(XDR xdr) {
            return null;
          }",No Smells
"@Test
  public void testRRPolicyExceptionMessage() throws Exception {
    final RoundRobinVolumeChoosingPolicy<FsVolumeSpi> policy
        = new RoundRobinVolumeChoosingPolicy<FsVolumeSpi>();
    testRRPolicyExceptionMessage(policy);
  }",No Smells
"@Test
  public void testContainerMetricsFlow() throws InterruptedException {
    final String ERR = ""Error in number of records"";

    MetricsCollectorImpl collector = new MetricsCollectorImpl();
    ContainerId containerId = mock(ContainerId.class);
    ContainerMetrics metrics = ContainerMetrics.forContainer(containerId,
        100, 1);

    metrics.recordMemoryUsage(1024);
    metrics.getMetrics(collector, true);
    assertEquals(ERR, 0, collector.getRecords().size());

    Thread.sleep(110);
    metrics.getMetrics(collector, true);
    assertEquals(ERR, 1, collector.getRecords().size());
    collector.clear();

    Thread.sleep(110);
    metrics.getMetrics(collector, true);
    assertEquals(ERR, 1, collector.getRecords().size());
    collector.clear();

    metrics.finished(false);
    metrics.getMetrics(collector, true);
    assertEquals(ERR, 1, collector.getRecords().size());
    collector.clear();

    metrics.getMetrics(collector, true);
    assertEquals(ERR, 1, collector.getRecords().size());
    collector.clear();

    Thread.sleep(110);
    metrics.getMetrics(collector, true);
    assertEquals(ERR, 1, collector.getRecords().size());
  }",No Smells
"@Test
  public void testInvalidNumArgs() throws Exception {
    assertResult(cli, -1, ""ls"");
    assertResult(cli, -1, ""ls"", ""/path"", ""/extraPath"");
    assertResult(cli, -1, ""resolve"");
    assertResult(cli, -1, ""resolve"", ""/path"", ""/extraPath"");
    assertResult(cli, -1, ""mknode"");
    assertResult(cli, -1, ""mknode"", ""/path"", ""/extraPath"");
    assertResult(cli, -1, ""rm"");
    assertResult(cli, -1, ""rm"", ""/path"", ""/extraPath"");
    assertResult(cli, -1, ""bind"");
    assertResult(cli, -1, ""bind"", ""foo"");
    assertResult(cli, -1, ""bind"", ""-inet"", ""foo"");
    assertResult(cli, -1, ""bind"", ""-inet"", ""-api"", ""-p"", ""378"", ""-h"", ""host"", ""/foo"");
    assertResult(cli, -1, ""bind"", ""-inet"", ""-api"", ""Api"", ""-p"", ""-h"", ""host"", ""/foo"");
    assertResult(cli, -1, ""bind"", ""-inet"", ""-api"", ""Api"", ""-p"", ""378"", ""-h"", ""/foo"");
    assertResult(cli, -1, ""bind"", ""-inet"", ""-api"", ""Api"", ""-p"", ""378"", ""-h"", ""host"");
    assertResult(cli, -1, ""bind"", ""-api"", ""Api"", ""-p"", ""378"", ""-h"", ""host"", ""/foo"");
    assertResult(cli, -1, ""bind"", ""-webui"", ""foo"");
    assertResult(cli, -1, ""bind"", ""-webui"", ""-api"", ""Api"", ""/foo"");
    assertResult(cli, -1, ""bind"", ""-webui"", ""uriString"", ""-api"", ""/foo"");
    assertResult(cli, -1, ""bind"", ""-webui"", ""uriString"", ""-api"", ""Api"");
    assertResult(cli, -1, ""bind"", ""-rest"", ""foo"");
    assertResult(cli, -1, ""bind"", ""-rest"", ""uriString"", ""-api"", ""Api"");
    assertResult(cli, -1, ""bind"", ""-rest"", ""-api"", ""Api"", ""/foo"");
    assertResult(cli, -1, ""bind"", ""-rest"", ""uriString"", ""-api"", ""/foo"");
    assertResult(cli, -1, ""bind"", ""uriString"", ""-api"", ""Api"", ""/foo"");
  }",No Smells
"@Test
  public void testFormatIdempotent() throws Throwable {
    assertConverted(""xn--lzg"", RegistryPathUtils.encodeForRegistry(EURO));
  }",No Smells
"@Test
  public void testParentOf() throws Throwable {
    assertEquals(""/"", parentOf(""/a""));
    assertEquals(""/"", parentOf(""/a/""));
    assertEquals(""/a"", parentOf(""/a/b""));
    assertEquals(""/a/b"", parentOf(""/a/b/c""));
  }",No Smells
"@Test
  public void testExistsMissing() throws Throwable {
    assertFalse(curatorService.zkPathExists(MISSING));
  }",No Smells
"@Test
  public void testRMRf() throws Throwable {
    mkPath(""/rm"", CreateMode.PERSISTENT);
    mkPath(""/rm/child"", CreateMode.PERSISTENT);
    curatorService.zkDelete(""/rm"", true, null);
    verifyNotExists(""/rm"");
    curatorService.zkDelete(""/rm"", true, null);
  }",Mystery Guest
"@Test
  public void testVerifyExists() throws Throwable {
    pathMustExist(""/"");
  }",Mystery Guest
"@Test
  public void testExists() throws IOException {
    System.out.println(""pre-create test path"");
    fs.mkdirs(new Path(""test/registryTestNode""));

    System.out.println(""Check for existing node"");
    boolean exists = registry.exists(""test/registryTestNode"");
    Assert.assertTrue(exists);

    System.out.println(""Check for  non-existing node"");
    exists = registry.exists(""test/nonExistentNode"");
    Assert.assertFalse(exists);
  }",Mystery Guest
"@Test
  public void testMkNodeRecursive() throws IOException {
    boolean result = false;
    System.out.println(""Make node with parent already made, recursive"");
    result = registry.mknode(""test/registryTestNode"", true);
    Assert.assertTrue(result);
    Assert.assertTrue(fs.exists(new Path(""test/registryTestNode"")));

    result = false;
    System.out.println(""Try to make node with no parent, recursive"");
    result = registry.mknode(""test/parent/registryTestNode"", true);
    Assert.assertTrue(result);
    Assert.assertTrue(fs.exists(new Path(""test/parent/registryTestNode"")));

  }",Resource Optimism
"@Test
  public void testDeleteServiceEntry() throws Throwable {
    putExampleServiceEntry(ENTRY_PATH, 0);
    operations.delete(ENTRY_PATH, false);
  }",Mystery Guest
"@Test
  public void testMkdirNoParent() throws Throwable {
    String path = ENTRY_PATH + ""/missing"";
    try {
      operations.mknode(path, false);
      RegistryPathStatus stat = operations.stat(path);
      fail(""Got a status "" + stat);
    }",Mystery Guest
"@Test
  public void testPutGetServiceEntry() throws Throwable {
    ServiceRecord written = putExampleServiceEntry(ENTRY_PATH, 0,
        PersistencePolicies.APPLICATION);
    ServiceRecord resolved = operations.resolve(ENTRY_PATH);
    validateEntry(resolved);
    assertMatches(written, resolved);
  }",Mystery Guest
"@Test
  public void testStatDirectory() throws Throwable {
    String empty = ""/empty"";
    operations.mknode(empty, false);
    operations.stat(empty);
  }",Mystery Guest
"@Test
  public void testStatRootPath() throws Throwable {
    operations.mknode(""/"", false);
    operations.stat(""/"");
    operations.list(""/"");
    operations.list(""/"");
  }",Mystery Guest
"@Test
  public void testAAAALookup() throws Exception {
    ServiceRecord record = getMarshal().fromBytes(""somepath"",
        CONTAINER_RECORD.getBytes());
    getRegistryDNS().register(
        ""/registry/users/root/services/org-apache-slider/test1/components/""
            + ""ctr-e50-1451931954322-0016-01-000002"",
        record);

    // start assessing whether correct records are available
    List<Record> recs = assertDNSQuery(
        ""ctr-e50-1451931954322-0016-01-000002.dev.test."", Type.AAAA, 1);
    assertEquals(""wrong result"", ""172.17.0.19"",
        ((AAAARecord) recs.get(0)).getAddress().getHostAddress());

    recs = assertDNSQuery(""httpd-1.test1.root.dev.test."", Type.AAAA, 1);
    assertTrue(""not an ARecord"", recs.get(0) instanceof AAAARecord);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testContainerRegistrationPersistanceAbsent() throws Exception {
    ServiceRecord record = marshal.fromBytes(""somepath"",
        CONTAINER_RECORD_YARN_PERSISTANCE_ABSENT.getBytes());
    registryDNS.register(
        ""/registry/users/root/services/org-apache-slider/test1/components/""
            + ""ctr-e50-1451931954322-0016-01-000003"",
         record);

    Name name =
        Name.fromString(""ctr-e50-1451931954322-0016-01-000002.dev.test."");
    Record question = Record.newRecord(name, Type.A, DClass.IN);
    Message query = Message.newQuery(question);
    byte[] responseBytes = registryDNS.generateReply(query, null);
    Message response = new Message(responseBytes);
    assertEquals(""Excepting NXDOMAIN as Record must not have regsisterd wrong"",
        Rcode.NXDOMAIN, response.getRcode());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testNegativeLookup() throws Exception {
    ServiceRecord record = getMarshal().fromBytes(""somepath"",
        CONTAINER_RECORD.getBytes());
    getRegistryDNS().register(
        ""/registry/users/root/services/org-apache-slider/test1/components/""
            + ""ctr-e50-1451931954322-0016-01-000002"",
        record);

    // start assessing whether correct records are available
    Name name = Name.fromString(""missing.dev.test."");
    Record question = Record.newRecord(name, Type.A, DClass.IN);
    Message query = Message.newQuery(question);

    byte[] responseBytes = getRegistryDNS().generateReply(query, null);
    Message response = new Message(responseBytes);
    assertEquals(""not successful"", Rcode.NXDOMAIN, response.getRcode());
    assertNotNull(""Null response"", response);
    assertEquals(""Questions do not match"", query.getQuestion(),
        response.getQuestion());
    List<Record> sectionArray = response.getSection(Section.AUTHORITY);
    assertEquals(""Wrong number of recs in AUTHORITY"", isSecure() ? 2 : 1,
        sectionArray.size());
    boolean soaFound = false;
    for (Record rec : sectionArray) {
      soaFound = rec.getType() == Type.SOA;
      if (soaFound) {
        break;
      }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testReverseLookup() throws Exception {
    ServiceRecord record = getMarshal().fromBytes(""somepath"",
        CONTAINER_RECORD.getBytes());
    getRegistryDNS().register(
        ""/registry/users/root/services/org-apache-slider/test1/components/""
            + ""ctr-e50-1451931954322-0016-01-000002"",
        record);

    // start assessing whether correct records are available
    List<Record> recs = assertDNSQuery(
        ""19.0.17.172.in-addr.arpa."", Type.PTR, 1);
    assertEquals(""wrong result"",
        ""httpd-1.test1.root.dev.test."",
        ((PTRRecord) recs.get(0)).getTarget().toString());
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testSplitReverseZoneNames() throws Exception {
    Configuration conf = new Configuration();
    registryDNS = new RegistryDNS(""TestRegistry"");
    conf.set(RegistryConstants.KEY_DNS_DOMAIN, ""example.com"");
    conf.set(KEY_DNS_SPLIT_REVERSE_ZONE, ""true"");
    conf.set(KEY_DNS_SPLIT_REVERSE_ZONE_RANGE, ""256"");
    conf.set(KEY_DNS_ZONE_SUBNET, ""172.26.32.0"");
    conf.set(KEY_DNS_ZONE_MASK, ""255.255.224.0"");
    conf.setTimeDuration(RegistryConstants.KEY_DNS_TTL, 30L, TimeUnit.SECONDS);
    conf.set(RegistryConstants.KEY_DNS_ZONES_DIR,
        getClass().getResource(""/"").getFile());
    if (isSecure()) {
      conf.setBoolean(RegistryConstants.KEY_DNSSEC_ENABLED, true);
      conf.set(RegistryConstants.KEY_DNSSEC_PUBLIC_KEY,
          ""AwEAAe1Jev0Az1khlQCvf0nud1/CNHQwwPEu8BNchZthdDxKPVn29yrD ""
              + ""CHoAWjwiGsOSw3SzIPrawSbHzyJsjn0oLBhGrH6QedFGnydoxjNsw3m/ ""
              + ""SCmOjR/a7LGBAMDFKqFioi4gOyuN66svBeY+/5uw72+0ei9AQ20gqf6q ""
              + ""l9Ozs5bV"");
      conf.set(RegistryConstants.KEY_DNSSEC_PRIVATE_KEY_FILE,
          getClass().getResource(""/test.private"").getFile());
    }",No Smells
"@Test
  public void testGetReverseZoneNetworkAddress() throws Exception {
    assertEquals(""172.17.4.0"",
        ReverseZoneUtils.getReverseZoneNetworkAddress(NET, RANGE, INDEX));
  }",No Smells
"@Test
  public void testSplitIp() throws Exception {
    long[] splitIp = ReverseZoneUtils.splitIp(NET);
    assertEquals(172, splitIp[0]);
    assertEquals(17, splitIp[1]);
    assertEquals(4, splitIp[2]);
    assertEquals(0, splitIp[3]);
  }",No Smells
"@Test
  public void testThrowIllegalArgumentExceptionIfIndexIsNegative()
      throws Exception {
    exception.expect(IllegalArgumentException.class);
    ReverseZoneUtils.getReverseZoneNetworkAddress(NET, RANGE, -1);
  }",No Smells
"@Test
  public void testThrowUnknownHostExceptionIfIpIsInvalid() throws Exception {
    exception.expect(UnknownHostException.class);
    ReverseZoneUtils
        .getReverseZoneNetworkAddress(""213124.21231.14123.13"", RANGE, INDEX);
  }",No Smells
"@Test
  public void testJksProvider() throws Exception {
    Configuration conf = new Configuration();
    final Path jksPath = new Path(tmpDir.toString(), ""test.jks"");
    final String ourUrl =
        JavaKeyStoreProvider.SCHEME_NAME + ""://file"" + jksPath.toUri();

    File file = new File(tmpDir, ""test.jks"");
    file.delete();
    conf.set(CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH, ourUrl);
    checkSpecificProvider(conf, ourUrl);
    Path path = ProviderUtils.unnestUri(new URI(ourUrl));
    FileSystem fs = path.getFileSystem(conf);
    FileStatus s = fs.getFileStatus(path);
    assertEquals(""rw-------"", s.getPermission().toString());
    assertTrue(file + "" should exist"", file.isFile());

    // check permission retention after explicit change
    fs.setPermission(path, new FsPermission(""777""));
    checkPermissionRetention(conf, ourUrl, path);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testGetAuthenticator() throws Exception {
    Authenticator authenticator = Mockito.mock(Authenticator.class);

    AuthenticatedURL aURL = new AuthenticatedURL(authenticator);
    Assert.assertEquals(authenticator, aURL.getAuthenticator());
  }",No Smells
"@Test
  public void testAuthenticationAnonymousDisallowedWithPost() throws Exception {
    AuthenticatorTestCase auth = new AuthenticatorTestCase();
    AuthenticatorTestCase.setAuthenticationHandlerConfig(
            getAuthenticationHandlerConfiguration(false));
    auth._testAuthentication(new PseudoAuthenticator(), true);
  }",No Smells
"@Test
  public void testAnonymous() {
    Assert.assertNotNull(AuthenticationToken.ANONYMOUS);
    Assert.assertEquals(null, AuthenticationToken.ANONYMOUS.getUserName());
    Assert.assertEquals(null, AuthenticationToken.ANONYMOUS.getName());
    Assert.assertEquals(null, AuthenticationToken.ANONYMOUS.getType());
    Assert.assertEquals(-1, AuthenticationToken.ANONYMOUS.getExpires());
    Assert.assertFalse(AuthenticationToken.ANONYMOUS.isExpired());
  }",No Smells
"@Test
  public void testNoProviderURLJWT() throws Exception {
    try {
      handler.setPublicKey(publicKey);

      Properties props = getProperties();
      props
          .remove(JWTRedirectAuthenticationHandler.AUTHENTICATION_PROVIDER_URL);
      handler.init(props);

      SignedJWT jwt = getJWT(""bob"", new Date(new Date().getTime() + 5000),
          privateKey);

      Cookie cookie = new Cookie(""hadoop-jwt"", jwt.serialize());
      HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
      Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie }",No Smells
"@Test
  public void testOrigURLWithQueryString() throws Exception {
    handler.setPublicKey(publicKey);

    Properties props = getProperties();
    handler.init(props);

    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
    Mockito.when(request.getRequestURL()).thenReturn(
        new StringBuffer(SERVICE_URL));
    Mockito.when(request.getQueryString()).thenReturn(""name=value"");

    String loginURL = handler.constructLoginURL(request);
    Assert.assertNotNull(""loginURL should not be null."", loginURL);
    Assert.assertEquals(""https://localhost:8443/authserver?originalUrl="" + SERVICE_URL + ""?name=value"", loginURL);
  }",No Smells
"@Test
  public void testUnableToParseJWT() throws Exception {
    try {
      KeyPairGenerator kpg = KeyPairGenerator.getInstance(""RSA"");
      kpg.initialize(2048);

      KeyPair kp = kpg.genKeyPair();
      RSAPublicKey publicKey = (RSAPublicKey) kp.getPublic();

      handler.setPublicKey(publicKey);

      Properties props = getProperties();
      handler.init(props);

      SignedJWT jwt = getJWT(""bob"", new Date(new Date().getTime() + 5000),
          privateKey);

      Cookie cookie = new Cookie(""hadoop-jwt"", ""ljm"" + jwt.serialize());
      HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
      Mockito.when(request.getCookies()).thenReturn(new Cookie[] { cookie }",No Smells
"@Test
  public void testDynamicPrincipalDiscoveryMissingPrincipals()
      throws Exception {
    String[] keytabUsers = new String[]{""hdfs/localhost""}",No Smells
"@Test
  public void testAnonymousOn() throws Exception {
    PseudoAuthenticationHandler handler = new PseudoAuthenticationHandler();
    try {
      Properties props = new Properties();
      props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED, ""true"");
      handler.init(props);

      HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
      HttpServletResponse response = Mockito.mock(HttpServletResponse.class);

      AuthenticationToken token = handler.authenticate(request, response);

      Assert.assertEquals(AuthenticationToken.ANONYMOUS, token);
    }",No Smells
"@Test
  public void testUserNameAnonymousOff() throws Exception {
    _testUserName(false);
  }",No Smells
"@Test
  public void testValidPEM() throws Exception {
    String pem = ""MIICOjCCAaOgAwIBAgIJANXi/oWxvJNzMA0GCSqGSIb3DQEBBQUAMF8xCzAJBgNVBAYTAlVTMQ0w""
        + ""CwYDVQQIEwRUZXN0MQ0wCwYDVQQHEwRUZXN0MQ8wDQYDVQQKEwZIYWRvb3AxDTALBgNVBAsTBFRl""
        + ""c3QxEjAQBgNVBAMTCWxvY2FsaG9zdDAeFw0xNTAxMDIyMTE5MjRaFw0xNjAxMDIyMTE5MjRaMF8x""
        + ""CzAJBgNVBAYTAlVTMQ0wCwYDVQQIEwRUZXN0MQ0wCwYDVQQHEwRUZXN0MQ8wDQYDVQQKEwZIYWRv""
        + ""b3AxDTALBgNVBAsTBFRlc3QxEjAQBgNVBAMTCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOB""
        + ""jQAwgYkCgYEAwpfpLdi7dWTHNzETt+L7618/dWUQFb/C7o1jIxFgbKOVIB6d5YmvUbJck5PYxFkz""
        + ""C25fmU5H71WGOI1Kle5TFDmIo+hqh5xqu1YNRZz9i6D94g+2AyYr9BpvH4ZfdHs7r9AU7c3kq68V""
        + ""7OPuuaHb25J8isiOyA3RiWuJGQlXTdkCAwEAATANBgkqhkiG9w0BAQUFAAOBgQAdRUyCUqE9sdim""
        + ""Fbll9BuZDKV16WXeWGq+kTd7ETe7l0fqXjq5EnrifOai0L/pXwVvS2jrFkKQRlRxRGUNaeEBZ2Wy""
        + ""9aTyR+HGHCfvwoCegc9rAVw/DLaRriSO/jnEXzYK6XLVKH+hx5UXrJ7Oyc7JjZUc3g9kCWORThCX""
        + ""Mzc1xA=="";
    try {
      RSAPublicKey pk = CertificateUtil.parseRSAPublicKey(pem);
      assertNotNull(pk);
      assertEquals(""RSA"", pk.getAlgorithm());
    }",No Smells
"@Test
  public void testGetSecrets() throws Exception {
    File testDir = new File(System.getProperty(""test.build.data"",
        ""target/test-dir""));
    testDir.mkdirs();
    String secretValue = ""hadoop"";
    File secretFile = new File(testDir, ""http-secret.txt"");
    Writer writer = new FileWriter(secretFile);
    writer.write(secretValue);
    writer.close();

    FileSignerSecretProvider secretProvider
            = new FileSignerSecretProvider();
    Properties secretProviderProps = new Properties();
    secretProviderProps.setProperty(
            AuthenticationFilter.SIGNATURE_SECRET_FILE,
        secretFile.getAbsolutePath());
    secretProvider.init(secretProviderProps, null, -1);
    Assert.assertArrayEquals(secretValue.getBytes(),
        secretProvider.getCurrentSecret());
    byte[][] allSecrets = secretProvider.getAllSecrets();
    Assert.assertEquals(1, allSecrets.length);
    Assert.assertArrayEquals(secretValue.getBytes(), allSecrets[0]);
  }",Mystery Guest
"@Test
  public void testToLowerCase() throws Exception {
    String rules =
        ""RULE:[1:$1]/L\n"" +
        ""RULE:[2:$1]/L\n"" +
        ""RULE:[2:$1;$2](^.*;admin$)s/;admin$///L\n"" +
        ""RULE:[2:$1;$2](^.*;guest$)s/;guest$//g/L\n"" +
        ""DEFAULT"";
    KerberosName.setRules(rules);
    KerberosName.printRules();
    checkTranslation(""Joe@FOO.COM"", ""joe"");
    checkTranslation(""Joe/root@FOO.COM"", ""joe"");
    checkTranslation(""Joe/admin@FOO.COM"", ""joe"");
    checkTranslation(""Joe/guestguest@FOO.COM"", ""joe"");
  }",No Smells
"@Test
  public void testGetAndRollSecrets() throws Exception {
    // Use the same seed and a ""plain"" Random so we can predict the RNG
    long seed = System.currentTimeMillis();
    Random rand = new Random(seed);
    byte[] secret1 = generateNewSecret(rand);
    byte[] secret2 = generateNewSecret(rand);
    byte[] secret3 = generateNewSecret(rand);
    MockRandomSignerSecretProvider secretProvider =
        spy(new MockRandomSignerSecretProvider(seed));
    try {
      secretProvider.init(null, null, rolloverFrequency);

      byte[] currentSecret = secretProvider.getCurrentSecret();
      byte[][] allSecrets = secretProvider.getAllSecrets();
      Assert.assertArrayEquals(secret1, currentSecret);
      Assert.assertEquals(2, allSecrets.length);
      Assert.assertArrayEquals(secret1, allSecrets[0]);
      Assert.assertNull(allSecrets[1]);
      verify(secretProvider, timeout(timeout).atLeastOnce()).rollSecret();
      secretProvider.realRollSecret();

      currentSecret = secretProvider.getCurrentSecret();
      allSecrets = secretProvider.getAllSecrets();
      Assert.assertArrayEquals(secret2, currentSecret);
      Assert.assertEquals(2, allSecrets.length);
      Assert.assertArrayEquals(secret2, allSecrets[0]);
      Assert.assertArrayEquals(secret1, allSecrets[1]);
      verify(secretProvider, timeout(timeout).atLeast(2)).rollSecret();
      secretProvider.realRollSecret();

      currentSecret = secretProvider.getCurrentSecret();
      allSecrets = secretProvider.getAllSecrets();
      Assert.assertArrayEquals(secret3, currentSecret);
      Assert.assertEquals(2, allSecrets.length);
      Assert.assertArrayEquals(secret3, allSecrets[0]);
      Assert.assertArrayEquals(secret2, allSecrets[1]);
      verify(secretProvider, timeout(timeout).atLeast(3)).rollSecret();
      secretProvider.realRollSecret();
    }",No Smells
"@Test
  public void testInvalidSignedText() throws Exception {
    Signer signer = new Signer(createStringSignerSecretProvider());
    try {
      signer.verifyAndExtract(""test"");
      Assert.fail();
    }",No Smells
"@Test
  public void testSignature() throws Exception {
    Signer signer = new Signer(createStringSignerSecretProvider());
    String s1 = signer.sign(""ok"");
    String s2 = signer.sign(""ok"");
    String s3 = signer.sign(""wrong"");
    Assert.assertEquals(s1, s2);
    Assert.assertNotEquals(s1, s3);
  }",No Smells
"@Test
  public void testTampering() throws Exception {
    Signer signer = new Signer(createStringSignerSecretProvider());
    String t = ""test"";
    String s = signer.sign(t);
    s += ""x"";
    try {
      signer.verifyAndExtract(s);
      Assert.fail();
    }",No Smells
"@Test
  public void testGetSecrets() throws Exception {
    String secretStr = ""secret"";
    StringSignerSecretProvider secretProvider
            = new StringSignerSecretProvider();
    Properties secretProviderProps = new Properties();
    secretProviderProps.setProperty(
            AuthenticationFilter.SIGNATURE_SECRET, ""secret"");
    secretProvider.init(secretProviderProps, null, -1);
    byte[] secretBytes = secretStr.getBytes();
    Assert.assertArrayEquals(secretBytes, secretProvider.getCurrentSecret());
    byte[][] allSecrets = secretProvider.getAllSecrets();
    Assert.assertEquals(1, allSecrets.length);
    Assert.assertArrayEquals(secretBytes, allSecrets[0]);
  }",No Smells
"@Test
  public void testMultiple1() throws Exception {
    testMultiple(1);
  }",Eager Test
"@Test
  public void testMultiple1() throws Exception {
    testMultiple(1);
  }",Eager Test
"@Test
  public void testAccessControlList() throws Exception {
    AccessControlList acl;
    Collection<String> users;
    Collection<String> groups;
    
    acl = new AccessControlList(""drwho tardis"");
    users = acl.getUsers();
    assertThat(users.size()).isOne();
    assertThat(users.iterator().next()).isEqualTo(""drwho"");
    groups = acl.getGroups();
    assertThat(groups.size()).isOne();
    assertThat(groups.iterator().next()).isEqualTo(""tardis"");
    
    acl = new AccessControlList(""drwho"");
    users = acl.getUsers();
    assertThat(users.size()).isOne();
    assertThat(users.iterator().next()).isEqualTo(""drwho"");
    groups = acl.getGroups();
    assertThat(groups.size()).isZero();
    
    acl = new AccessControlList(""drwho "");
    users = acl.getUsers();
    assertThat(users.size()).isOne();
    assertThat(users.iterator().next()).isEqualTo(""drwho"");
    groups = acl.getGroups();
    assertThat(groups.size()).isZero();
    
    acl = new AccessControlList("" tardis"");
    users = acl.getUsers();
    assertThat(users.size()).isZero();
    groups = acl.getGroups();
    assertThat(groups.size()).isOne();
    assertThat(groups.iterator().next()).isEqualTo(""tardis"");

    Iterator<String> iter;    
    acl = new AccessControlList(""drwho,joe tardis, users"");
    users = acl.getUsers();
    assertThat(users.size()).isEqualTo(2);
    iter = users.iterator();
    assertThat(iter.next()).isEqualTo(""drwho"");
    assertThat(iter.next()).isEqualTo(""joe"");
    groups = acl.getGroups();
    assertThat(groups.size()).isEqualTo(2);
    iter = groups.iterator();
    assertThat(iter.next()).isEqualTo(""tardis"");
    assertThat(iter.next()).isEqualTo(""users"");
  }",No Smells
"@Test
  public void testAuthorizationFailure() throws Exception {
    user = ""dummyUser"";
    proxyUser = ""test user2"";
    when(realUserUGI.getShortUserName()).thenReturn(proxyUser);
    when(realUserUGI.getUserName()).thenReturn(proxyUser);
    when(userGroupInformation.getUserName()).thenReturn(user);
    when(userGroupInformation.getRealUser()).thenReturn(realUserUGI);
    LambdaTestUtils.intercept(AuthorizationException.class, ""User: ""
        + proxyUser + "" is not allowed to impersonate "" + user, () ->
        provider.authorize(userGroupInformation, ""2.2.2.2""));
  }",No Smells
"@Test
  public void testAuthorizationSuccess() throws AuthorizationException {
    proxyUser = ""fakeuser"";
    user = ""dummyUser"";
    when(realUserUGI.getShortUserName()).thenReturn(proxyUser);
    when(userGroupInformation.getRealUser()).thenReturn(realUserUGI);
    provider.authorize(userGroupInformation, ""2.2.2.2"");

    user = ""somerandomuser"";
    proxyUser = ""test.user"";
    when(realUserUGI.getShortUserName()).thenReturn(proxyUser);
    when(userGroupInformation.getRealUser()).thenReturn(realUserUGI);
    provider.authorize(userGroupInformation, ""2.2.2.2"");
  }",No Smells
"@Test
  public void testWithDuplicateProxyGroups() throws Exception {
    Configuration conf = new Configuration();
    conf.set(
      DefaultImpersonationProvider.getTestProvider().
          getProxySuperuserGroupConfKey(REAL_USER_NAME),
      StringUtils.join("","", Arrays.asList(GROUP_NAMES,GROUP_NAMES)));
    conf.set(
      DefaultImpersonationProvider.getTestProvider().
          getProxySuperuserIpConfKey(REAL_USER_NAME),
      PROXY_IP);
    ProxyUsers.refreshSuperUserGroupsConfiguration(conf);
    
    Collection<String> groupsToBeProxied = 
        ProxyUsers.getDefaultImpersonationProvider().getProxyGroups().get(
        DefaultImpersonationProvider.getTestProvider().
            getProxySuperuserGroupConfKey(REAL_USER_NAME));
    
    assertEquals (1,groupsToBeProxied.size());
  }",No Smells
"@Test
  public void testCrossOriginFilterAfterRestart() throws ServletException {

    // Setup the configuration settings of the server
    Map<String, String> conf = new HashMap<String, String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS, ""example.com"");
    conf.put(CrossOriginFilter.ALLOWED_HEADERS, ""X-Requested-With,Accept"");
    conf.put(CrossOriginFilter.ALLOWED_METHODS, ""GET,POST"");
    FilterConfig filterConfig = new FilterConfigTest(conf);

    // Object under test
    CrossOriginFilter filter = new CrossOriginFilter();
    filter.init(filterConfig);

    //verify filter values
    Assert.assertTrue(""Allowed headers do not match"",
        filter.getAllowedHeadersHeader()
        .compareTo(""X-Requested-With,Accept"") == 0);
    Assert.assertTrue(""Allowed methods do not match"",
        filter.getAllowedMethodsHeader()
        .compareTo(""GET,POST"") == 0);
    Assert.assertTrue(filter.areOriginsAllowed(""example.com""));

    //destroy filter values and clear conf
    filter.destroy();
    conf.clear();

    // Setup the configuration settings of the server
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS, ""newexample.com"");
    conf.put(CrossOriginFilter.ALLOWED_HEADERS, ""Content-Type,Origin"");
    conf.put(CrossOriginFilter.ALLOWED_METHODS, ""GET,HEAD"");
    filterConfig = new FilterConfigTest(conf);

    //initialize filter
    filter.init(filterConfig);

    //verify filter values
    Assert.assertTrue(""Allowed headers do not match"",
        filter.getAllowedHeadersHeader()
        .compareTo(""Content-Type,Origin"") == 0);
    Assert.assertTrue(""Allowed methods do not match"",
        filter.getAllowedMethodsHeader()
        .compareTo(""GET,HEAD"") == 0);
    Assert.assertTrue(filter.areOriginsAllowed(""newexample.com""));

    //destroy filter values
    filter.destroy();
  }",No Smells
"@Test
  public void testServerCredProviderPasswords() throws Exception {
    KeyStoreTestUtil.provisionPasswordsToCredentialProvider();
    checkSSLFactoryInitWithPasswords(SSLFactory.Mode.SERVER,
        ""storepass"", ""keypass"", null, null, true);
  }",No Smells
"@Test
  public void testResolver() {
    Configuration conf = new Configuration();
    conf.set(""ingress.port.sasl.configured.ports"", ""444,555,666,777"");
    conf.set(""ingress.port.sasl.prop.444"", ""authentication"");
    conf.set(""ingress.port.sasl.prop.555"", ""authentication,privacy"");
    conf.set(""ingress.port.sasl.prop.666"", ""privacy"");

    IngressPortBasedResolver resolver = new IngressPortBasedResolver();
    resolver.setConf(conf);

    // the client address does not matter, give it a null
    assertEquals(""auth"",
        resolver.getServerProperties(null, 444).get(Sasl.QOP));
    assertEquals(""auth,auth-conf"",
        resolver.getServerProperties(null, 555).get(Sasl.QOP));
    assertEquals(""auth-conf"",
        resolver.getServerProperties(null, 666).get(Sasl.QOP));
    assertEquals(""auth-conf"",
        resolver.getServerProperties(null, 777).get(Sasl.QOP));
    assertEquals(""auth"",
        resolver.getServerProperties(null, 888).get(Sasl.QOP));
  }",No Smells
"@Test
  public void testFileOutput() throws Throwable {
    File f = new File(""target/kdiag.txt"");
    kdiag(ARG_KEYLEN, KEYLEN,
        ARG_KEYTAB, keytab.getAbsolutePath(),
        ARG_PRINCIPAL, ""foo@EXAMPLE.COM"",
        ARG_OUTPUT, f.getAbsolutePath());
    LOG.info(""Output of {}",Mystery Guest + Resource Optimism
"@Test
  public void testKeytabAndPrincipal() throws Throwable {
    kdiag(ARG_KEYLEN, KEYLEN,
        ARG_KEYTAB, keytab.getAbsolutePath(),
        ARG_PRINCIPAL, ""foo@EXAMPLE.COM"");
  }",Mystery Guest + Resource Optimism
"@Test
  public void testNoKeytab() throws Throwable {
    kdiagFailure(CAT_KERBEROS, ARG_KEYLEN, KEYLEN,
        ARG_KEYTAB, ""target/nofile"");
  }",Mystery Guest + Resource Optimism
"@Test
  public void testSecure() throws Throwable {
    kdiagFailure(CAT_CONFIG, ARG_KEYLEN, KEYLEN, ARG_SECURE);
  }",Mystery Guest + Resource Optimism
"@Test
  public void testGetGroups() throws NamingException {
    // The search functionality of the mock context is reused, so we will
    // return the user NamingEnumeration first, and then the group
    when(getContext().search(anyString(), anyString(), any(Object[].class),
        any(SearchControls.class)))
        .thenReturn(getUserNames(), getGroupNames());
    doTestGetGroups(Arrays.asList(getTestGroups()), 2);
  }",No Smells
"@Test
  public void testGetGroupsWithDifferentBaseDNs() throws Exception {
    Configuration conf = getBaseConf(TEST_LDAP_URL);
    String userBaseDN = ""ou=Users,dc=xxx,dc=com "";
    String groupBaseDN = "" ou=Groups,dc=xxx,dc=com"";
    conf.set(LdapGroupsMapping.USER_BASE_DN_KEY, userBaseDN);
    conf.set(LdapGroupsMapping.GROUP_BASE_DN_KEY, groupBaseDN);

    doTestGetGroupsWithBaseDN(conf, userBaseDN.trim(), groupBaseDN.trim());
  }",No Smells
"@Test
  public void testGetGroupsWithHierarchy() throws NamingException {
    // The search functionality of the mock context is reused, so we will
    // return the user NamingEnumeration first, and then the group
    // The parent search is run once for each level, and is a different search
    // The parent group is returned once for each group, yet the final list
    // should be unique
    when(getContext().search(anyString(), anyString(), any(Object[].class),
        any(SearchControls.class)))
        .thenReturn(getUserNames(), getGroupNames());
    when(getContext().search(anyString(), anyString(),
        any(SearchControls.class)))
        .thenReturn(getParentGroupNames());
    doTestGetGroupsWithParent(Arrays.asList(getTestParentGroups()), 2, 1);
  }",No Smells
"@Test
  public void testCreate() throws Exception {
    Configuration conf = new HdfsConfiguration();
    conf.setBoolean(DFSConfigKeys.DFS_PERMISSIONS_ENABLED_KEY, true);
    conf.set(FsPermission.UMASK_LABEL, ""000"");
    MiniDFSCluster cluster = null;
    FileSystem fs = null;

    try {
      cluster = new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
      cluster.waitActive();
      fs = FileSystem.get(conf);
      FsPermission rootPerm = checkPermission(fs, ""/"", null);
      FsPermission inheritPerm = FsPermission.createImmutable(
          (short)(rootPerm.toShort() | 0300));

      FsPermission dirPerm = new FsPermission((short)0777);
      fs.mkdirs(new Path(""/a1/a2/a3""), dirPerm);
      checkPermission(fs, ""/a1"", dirPerm);
      checkPermission(fs, ""/a1/a2"", dirPerm);
      checkPermission(fs, ""/a1/a2/a3"", dirPerm);

      dirPerm = new FsPermission((short)0123);
      FsPermission permission = FsPermission.createImmutable(
        (short)(dirPerm.toShort() | 0300));
      fs.mkdirs(new Path(""/aa/1/aa/2/aa/3""), dirPerm);
      checkPermission(fs, ""/aa/1"", permission);
      checkPermission(fs, ""/aa/1/aa/2"", permission);
      checkPermission(fs, ""/aa/1/aa/2/aa/3"", dirPerm);

      FsPermission filePerm = new FsPermission((short)0444);
      Path p = new Path(""/b1/b2/b3.txt"");
      FSDataOutputStream out = fs.create(p, filePerm,
          true, conf.getInt(CommonConfigurationKeys.IO_FILE_BUFFER_SIZE_KEY, 4096),
          fs.getDefaultReplication(p), fs.getDefaultBlockSize(p), null);
      out.write(123);
      out.close();
      checkPermission(fs, ""/b1"", inheritPerm);
      checkPermission(fs, ""/b1/b2"", inheritPerm);
      checkPermission(fs, ""/b1/b2/b3.txt"", filePerm);
      
      conf.set(FsPermission.UMASK_LABEL, ""022"");
      permission = 
        FsPermission.createImmutable((short)0666);
      FileSystem.mkdirs(fs, new Path(""/c1""), new FsPermission(permission));
      FileSystem.create(fs, new Path(""/c1/c2.txt""),
          new FsPermission(permission));
      checkPermission(fs, ""/c1"", permission);
      checkPermission(fs, ""/c1/c2.txt"", permission);
    }",Mystery Guest + Resource Optimism
"@Test
  public void testGetHostFromPrincipal() {
    assertEquals(""host"", 
        SecurityUtil.getHostFromPrincipal(""service/host@realm""));
    assertEquals(null,
        SecurityUtil.getHostFromPrincipal(""service@realm""));
  }",No Smells
"@Test
  public void testGetServerPrincipal() throws IOException {
    String service = ""hdfs/"";
    String realm = ""@REALM"";
    String hostname = ""foohost"";
    String userPrincipal = ""foo@FOOREALM"";
    String shouldReplace = service + SecurityUtil.HOSTNAME_PATTERN + realm;
    String replaced = service + hostname + realm;
    verify(shouldReplace, hostname, replaced);
    String shouldNotReplace = service + SecurityUtil.HOSTNAME_PATTERN + ""NAME""
        + realm;
    verify(shouldNotReplace, hostname, shouldNotReplace);
    verify(userPrincipal, hostname, userPrincipal);
    // testing reverse DNS lookup doesn't happen
    InetAddress notUsed = Mockito.mock(InetAddress.class);
    assertEquals(shouldNotReplace,
                 SecurityUtil.getServerPrincipal(shouldNotReplace, notUsed));
    Mockito.verify(notUsed, Mockito.never()).getCanonicalHostName();
  }",No Smells
"@Test
  public void testSetAuthenticationMethod() {
    Configuration conf = new Configuration();
    // default
    SecurityUtil.setAuthenticationMethod(null, conf);
    assertEquals(""simple"", conf.get(HADOOP_SECURITY_AUTHENTICATION));
    // simple
    SecurityUtil.setAuthenticationMethod(SIMPLE, conf);
    assertEquals(""simple"", conf.get(HADOOP_SECURITY_AUTHENTICATION));
    // kerberos
    SecurityUtil.setAuthenticationMethod(KERBEROS, conf);
    assertEquals(""kerberos"", conf.get(HADOOP_SECURITY_AUTHENTICATION));
  }",No Smells
"@Test
  public void testSocketAddrWithNameToStaticIP() {
    String staticHost = ""host3"";
    NetUtils.addStaticResolution(staticHost, ""255.255.255.255"");
    verifyServiceAddr(staticHost, ""255.255.255.255"");
  }",No Smells
"@Test
  public void testStaticMapUpdate() throws IOException {
    assumeNotWindows();
    File tempStaticMapFile = File.createTempFile(""nfs-"", "".map"");
    tempStaticMapFile.delete();
    Configuration conf = new Configuration();
    conf.setLong(IdMappingConstant.USERGROUPID_UPDATE_MILLIS_KEY, 1000);    
    conf.set(IdMappingConstant.STATIC_ID_MAPPING_FILE_KEY,
        tempStaticMapFile.getPath());

    ShellBasedIdMapping refIdMapping =
        new ShellBasedIdMapping(conf, true);
    ShellBasedIdMapping incrIdMapping = new ShellBasedIdMapping(conf);

    BiMap<Integer, String> uidNameMap = refIdMapping.getUidNameMap();
    BiMap<Integer, String> gidNameMap = refIdMapping.getGidNameMap();

    // Force empty map, to see effect of incremental map update of calling
    // getUid()
    incrIdMapping.clearNameMaps();
    uidNameMap = refIdMapping.getUidNameMap();
    for (BiMap.Entry<Integer, String> me : uidNameMap.entrySet()) {
      tempStaticMapFile.delete();
      incrIdMapping.clearNameMaps();
      Integer id = me.getKey();
      String name = me.getValue();

      // The static map is empty, so the id found for ""name"" would be
      // the same as ""id""
      Integer nid = incrIdMapping.getUid(name);
      assertEquals(id, nid);
      
      // Clear map and update staticMap file
      incrIdMapping.clearNameMaps();
      Integer rid = id + 10000;
      String smapStr = ""uid "" + rid + "" "" + id;
      createStaticMapFile(tempStaticMapFile, smapStr);

      // Now the id found for ""name"" should be the id specified by
      // the staticMap
      nid = incrIdMapping.getUid(name);
      assertEquals(rid, nid);
    }",Eager Test + Mystery Guest
"@Test
  public void testGetGroupsResolvable() throws Exception {
    TestGroupResolvable mapping = new TestGroupResolvable();

    List<String> groups = mapping.getGroups(""user"");
    assertTrue(groups.size() == 3);
    assertTrue(groups.contains(""abc""));
    assertTrue(groups.contains(""def""));
    assertTrue(groups.contains(""hij""));
  }",No Smells
"@Test
  public void testGetNumericGroupsResolvable() throws Exception {
    TestNumericGroupResolvable mapping = new TestNumericGroupResolvable();

    List<String> groups = mapping.getGroups(""user"");
    assertTrue(groups.size() == 3);
    assertTrue(groups.contains(""23""));
    assertTrue(groups.contains(""groupname""));
    assertTrue(groups.contains(""zzz""));
  }",No Smells
"@Test
  public void testExternalTokenFiles() throws Exception {
    StringBuilder tokenFullPathnames = new StringBuilder();
    String tokenFilenames = ""token1,token2"";
    String tokenFiles[] = StringUtils.getTrimmedStrings(tokenFilenames);
    final File testDir = new File(""target"",
        TestUserGroupInformation.class.getName() + ""-tmpDir"").getAbsoluteFile();
    String testDirPath = testDir.getAbsolutePath();

    // create path for token files
    for (String tokenFile: tokenFiles) {
      if (tokenFullPathnames.length() > 0) {
        tokenFullPathnames.append("","");
      }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testKerberosTicketIsDestroyedChecked() throws Exception {
    // Create UserGroupInformation
    GenericTestUtils.setLogLevel(UserGroupInformation.LOG, Level.DEBUG);
    Set<User> users = new HashSet<>();
    users.add(new User(""Foo""));
    Subject subject =
        new Subject(true, users, new HashSet<>(), new HashSet<>());
    UserGroupInformation ugi = spy(new UserGroupInformation(subject));

    // throw IOException in the middle of the autoRenewalForUserCreds
    doThrow(new IOException()).when(ugi).reloginFromTicketCache();

    // Create and destroy the KerberosTicket, so endTime will be null
    Date d = new Date();
    KerberosPrincipal kp = new KerberosPrincipal(""Foo"");
    KerberosTicket tgt = spy(new KerberosTicket(new byte[]{}",No Smells
"@Test
  public void testFixedAndLocalWhiteList() throws IOException {

    String[] fixedIps = {""10.119.103.112"", ""10.221.102.0/23""}",Mystery Guest
"@Test
  public void testStopThreads() throws Exception {
    DelegationTokenManager tm1 = null;
    String connectString = zkServer.getConnectString();

    // let's make the update interval short and the shutdown interval
    // comparatively longer, so if the update thread runs after shutdown,
    // it will cause an error.
    final long updateIntervalSeconds = 1;
    final long shutdownTimeoutMillis = updateIntervalSeconds * 1000 * 5;
    Configuration conf = getSecretConf(connectString);
    conf.setLong(DelegationTokenManager.UPDATE_INTERVAL, updateIntervalSeconds);
    conf.setLong(DelegationTokenManager.REMOVAL_SCAN_INTERVAL, updateIntervalSeconds);
    conf.setLong(DelegationTokenManager.RENEW_INTERVAL, updateIntervalSeconds);

    conf.setLong(ZKDelegationTokenSecretManager.ZK_DTSM_ZK_SHUTDOWN_TIMEOUT, shutdownTimeoutMillis);
    tm1 = new DelegationTokenManager(conf, new Text(""foo""));
    tm1.init();

    Token<DelegationTokenIdentifier> token =
      (Token<DelegationTokenIdentifier>)
    tm1.createToken(UserGroupInformation.getCurrentUser(), ""foo"");
    Assert.assertNotNull(token);
    tm1.destroy();
  }",No Smells
"@Test
  public void testEdit() throws Exception {
    String oldService = SERVICE2.toString();
    String newAlias = ""newName:12345"";
    args = new String[] {""edit"",
        ""-service"", oldService, ""-alias"", newAlias, tokenFilename2}",No Smells
"@Test
  public void testFormatJavaFlag() throws Exception {
    args = new String[] {""get"", getUrl, ""-format"", ""java"", tokenFilenameGet}",No Smells
"@Test
  public void testFormatProtoFlag() throws Exception {
    args = new String[] {
        ""get"", getUrl, ""-format"", ""protobuf"", tokenFilenameGet}",No Smells
"@Test
  public void testGetWithServiceFlag() throws Exception {
    args = new String[] {""get"", getUrl2, ""-service"", SERVICE_GET.toString(),
                         tokenFilenameGet}",No Smells
"@Test
  public void testPrint() throws Exception {
    args = new String[] {""print"", tokenFilename}",No Smells
"@Test
  public void testDecodeIdentifier() throws IOException {
    TestDelegationTokenSecretManager secretManager =
      new TestDelegationTokenSecretManager(0, 0, 0, 0);
    secretManager.startThreads();
    TestDelegationTokenIdentifier id = new TestDelegationTokenIdentifier(
        new Text(""owner""), new Text(""renewer""), new Text(""realUser""));
    
    Token<TestDelegationTokenIdentifier> token =
        new Token<>(id, secretManager);
    TokenIdentifier idCopy = token.decodeIdentifier();
    
    assertNotSame(id, idCopy);
    assertEquals(id, idCopy);
  }",No Smells
"@Test
  public void testDecodeWritableArgSanityCheck() throws Exception {
    Token<AbstractDelegationTokenIdentifier> token = new Token<>();
    intercept(HadoopIllegalArgumentException.class,
        () -> token.decodeFromUrlString(null));
  }",No Smells
"@Test
  public void testBasicExceptionFormatting() throws Throwable {
    ServiceLaunchException ex = new ServiceLaunchException(0, ""%03x"", 32);
    assertExceptionContains(""020"", ex);
  }",No Smells
"@Test
  public void testFailingHookCaught() throws Throwable {
    BreakableService service = new BreakableService(false, false, true);
    setServiceToTeardown(service);
    ServiceShutdownHook hook = new ServiceShutdownHook(service);
    hook.run();
    assertStopped(service);
  }",No Smells
"@Test
  public void testInnerCause() throws Throwable {

    Exception cause = new Exception(""cause"");
    ServiceLaunchException ex =
        new ServiceLaunchException(0, ""%03x: %s"", 32, cause);
    assertExceptionContains(""020"", ex);
    assertExceptionContains(""cause"", ex);
    assertSame(cause, ex.getCause());
  }",No Smells
"@Test
  public void testRunNoArgsAllowedService() throws Throwable {
    assertRuns(NoArgsAllowedService.NAME);
  }",No Smells
"@Test
  public void testServiceLaunchStringConstructor() throws Throwable {
    assertRuns(StringConstructorOnlyService.NAME);
  }",No Smells
"@Test
  public void testShutdownHookNullReference() throws Throwable {
    new ServiceShutdownHook(null).run();
  }",No Smells
"@Test
  public void testStoppingInStartLaunchableService() throws Throwable {
    assertRuns(StoppingInStartLaunchableService.NAME);
  }",No Smells
"@Test
  public void testAddServiceInInit() throws Throwable {
    BreakableService child = new BreakableService();
    assertInState(STATE.NOTINITED, child);
    CompositeServiceAddingAChild composite =
      new CompositeServiceAddingAChild(child);
    composite.init(new Configuration());
    assertInState(STATE.INITED, child);
  }",No Smells
"@Test
  public void testServiceStartup() {
    ServiceManager serviceManager = new ServiceManager(""ServiceManager"");

    // Add services
    for (int i = 0; i < NUM_OF_SERVICES; i++) {
      CompositeServiceImpl service = new CompositeServiceImpl(i);
      if (i == FAILED_SERVICE_SEQ_NUMBER) {
        service.setThrowExceptionOnStart(true);
      }",Eager Test
"@Test
  public void testServiceStopFromInited() {
    ServiceManager serviceManager = new ServiceManager(""ServiceManager"");

    // Add services
    for (int i = 0; i < NUM_OF_SERVICES; i++) {
      CompositeServiceImpl service = new CompositeServiceImpl(i);
      serviceManager.addTestService(service);
    }",Eager Test
"@Test
  public void testCommandLine() throws Exception {
    try {
      try {
        FileUtil.fullyDelete(OUTPUT_DIR.getAbsoluteFile());
      }",Mystery Guest + Resource Optimism
"@Test
  public void testAtomicCommitExistingFinal() throws IOException {
    TaskAttemptContext taskAttemptContext = getTaskAttemptContext(config);
    JobContext jobContext = new JobContextImpl(taskAttemptContext.getConfiguration(),
        taskAttemptContext.getTaskAttemptID().getJobID());
    Configuration conf = jobContext.getConfiguration();


    String workPath = ""/tmp1/"" + String.valueOf(rand.nextLong());
    String finalPath = ""/tmp1/"" + String.valueOf(rand.nextLong());
    FileSystem fs = null;
    try {
      OutputCommitter committer = new CopyCommitter(null, taskAttemptContext);
      fs = FileSystem.get(conf);
      fs.mkdirs(new Path(workPath));
      fs.mkdirs(new Path(finalPath));

      conf.set(CONF_LABEL_TARGET_WORK_PATH, workPath);
      conf.set(CONF_LABEL_TARGET_FINAL_PATH, finalPath);
      conf.setBoolean(DistCpConstants.CONF_LABEL_ATOMIC_COPY, true);

      assertPathExists(fs, ""Work path"", new Path(workPath));
      assertPathExists(fs, ""Final path"", new Path(finalPath));
      try {
        committer.commitJob(jobContext);
        Assert.fail(""Should not be able to atomic-commit to pre-existing path."");
      }",Mystery Guest + Resource Optimism
"@Test
  public void testFileInRootDir() throws Throwable {
    expectShouldDelete(FILE0, false);
    expectShouldDelete(FILE0, false);
  }",Mystery Guest
"@Test
  public void testDistCh() throws Exception {
    final Configuration conf = new Configuration();

    conf.set(CapacitySchedulerConfiguration.PREFIX+CapacitySchedulerConfiguration.ROOT+"".""+CapacitySchedulerConfiguration.QUEUES, ""default"");
    conf.set(CapacitySchedulerConfiguration.PREFIX+CapacitySchedulerConfiguration.ROOT+"".default.""+CapacitySchedulerConfiguration.CAPACITY, ""100"");
    final MiniDFSCluster cluster=  new MiniDFSCluster.Builder(conf).numDataNodes(2).format(true).build();
    
    final FileSystem fs = cluster.getFileSystem();
    final FsShell shell = new FsShell(conf);
    
    try {
      final FileTree tree = new FileTree(fs, ""testDistCh"");
      final FileStatus rootstatus = fs.getFileStatus(tree.rootdir);

      runLsr(shell, tree.root, 0);

      final String[] args = new String[NUN_SUBS];
      final ChPermissionStatus[] newstatus = new ChPermissionStatus[NUN_SUBS];

      
      args[0]=""/test/testDistCh/sub0:sub1::"";
      newstatus[0] = new ChPermissionStatus(rootstatus, ""sub1"", """", """");

      args[1]=""/test/testDistCh/sub1::sub2:"";
      newstatus[1] = new ChPermissionStatus(rootstatus, """", ""sub2"", """");

      args[2]=""/test/testDistCh/sub2:::437"";
      newstatus[2] = new ChPermissionStatus(rootstatus, """", """", ""437"");

      args[3]=""/test/testDistCh/sub3:sub1:sub2:447"";
      newstatus[3] = new ChPermissionStatus(rootstatus, ""sub1"", ""sub2"", ""447"");
 
      args[4]=""/test/testDistCh/sub4::sub5:437"";
      newstatus[4] = new ChPermissionStatus(rootstatus, """", ""sub5"", ""437"");

      args[5]=""/test/testDistCh/sub5:sub1:sub5:"";
      newstatus[5] = new ChPermissionStatus(rootstatus, ""sub1"", ""sub5"", """");

      args[6]=""/test/testDistCh/sub6:sub3::437"";
      newstatus[6] = new ChPermissionStatus(rootstatus, ""sub3"", """", ""437"");
      
      System.out.println(""args="" + Arrays.asList(args).toString().replace("","", "",\n  ""));
      System.out.println(""newstatus="" + Arrays.asList(newstatus).toString().replace("","", "",\n  ""));

      //run DistCh
      new DistCh(MiniMRClientClusterFactory.create(this.getClass(), 2, conf).getConfig()).run(args);
      runLsr(shell, tree.root, 0);

      //check results
      for(int i = 0; i < NUN_SUBS; i++) {
        Path sub = new Path(tree.root + ""/sub"" + i);
        checkFileStatus(newstatus[i], fs.getFileStatus(sub));
        for(FileStatus status : fs.listStatus(sub)) {
          checkFileStatus(newstatus[i], status);
        }",Eager Test
"@Test
  public void testAppendOption() {
    final DistCpOptions.Builder builder = new DistCpOptions.Builder(
        Collections.singletonList(new Path(""hdfs://localhost:8020/source"")),
        new Path(""hdfs://localhost:8020/target/""))
        .withSyncFolder(true)
        .withAppend(true);
    Assert.assertTrue(builder.build().shouldAppend());

    try {
      // make sure -append is only valid when -update is specified
      new DistCpOptions.Builder(
          Collections.singletonList(new Path(""hdfs://localhost:8020/source"")),
          new Path(""hdfs://localhost:8020/target/""))
          .withAppend(true)
          .build();
      fail(""Append should fail if update option is not specified"");
    }",Mystery Guest + Resource Optimism
"@Test
  public void testPreserve() {
    DistCpOptions options = new DistCpOptions.Builder(
        new Path(""hdfs://localhost:8020/source/first""),
        new Path(""hdfs://localhost:8020/target/""))
        .build();
    Assert.assertFalse(options.shouldPreserve(FileAttribute.BLOCKSIZE));
    Assert.assertFalse(options.shouldPreserve(FileAttribute.REPLICATION));
    Assert.assertFalse(options.shouldPreserve(FileAttribute.PERMISSION));
    Assert.assertFalse(options.shouldPreserve(FileAttribute.USER));
    Assert.assertFalse(options.shouldPreserve(FileAttribute.GROUP));
    Assert.assertFalse(options.shouldPreserve(FileAttribute.CHECKSUMTYPE));

    options = new DistCpOptions.Builder(
        new Path(""hdfs://localhost:8020/source/first""),
        new Path(""hdfs://localhost:8020/target/""))
        .preserve(FileAttribute.ACL)
        .build();
    Assert.assertFalse(options.shouldPreserve(FileAttribute.BLOCKSIZE));
    Assert.assertFalse(options.shouldPreserve(FileAttribute.REPLICATION));
    Assert.assertFalse(options.shouldPreserve(FileAttribute.PERMISSION));
    Assert.assertFalse(options.shouldPreserve(FileAttribute.USER));
    Assert.assertFalse(options.shouldPreserve(FileAttribute.GROUP));
    Assert.assertFalse(options.shouldPreserve(FileAttribute.CHECKSUMTYPE));
    Assert.assertTrue(options.shouldPreserve(FileAttribute.ACL));

    options = new DistCpOptions.Builder(
        new Path(""hdfs://localhost:8020/source/first""),
        new Path(""hdfs://localhost:8020/target/""))
        .preserve(FileAttribute.BLOCKSIZE)
        .preserve(FileAttribute.REPLICATION)
        .preserve(FileAttribute.PERMISSION)
        .preserve(FileAttribute.USER)
        .preserve(FileAttribute.GROUP)
        .preserve(FileAttribute.CHECKSUMTYPE)
        .build();

    Assert.assertTrue(options.shouldPreserve(FileAttribute.BLOCKSIZE));
    Assert.assertTrue(options.shouldPreserve(FileAttribute.REPLICATION));
    Assert.assertTrue(options.shouldPreserve(FileAttribute.PERMISSION));
    Assert.assertTrue(options.shouldPreserve(FileAttribute.USER));
    Assert.assertTrue(options.shouldPreserve(FileAttribute.GROUP));
    Assert.assertTrue(options.shouldPreserve(FileAttribute.CHECKSUMTYPE));
    Assert.assertFalse(options.shouldPreserve(FileAttribute.XATTR));
  }",Mystery Guest + Resource Optimism
"@Test
  public void testSetNumListtatusThreads() {
    final DistCpOptions.Builder builder = new DistCpOptions.Builder(
        new Path(""hdfs://localhost:8020/source/first""),
        new Path(""hdfs://localhost:8020/target/""));
    // If command line argument isn't set, we expect .getNumListstatusThreads
    // option to be zero (so that we know when to override conf properties).
    Assert.assertEquals(0, builder.build().getNumListstatusThreads());

    builder.withNumListstatusThreads(12);
    Assert.assertEquals(12, builder.build().getNumListstatusThreads());

    builder.withNumListstatusThreads(0);
    Assert.assertEquals(0, builder.build().getNumListstatusThreads());

    // Ignore large number of threads.
    builder.withNumListstatusThreads(MAX_NUM_LISTSTATUS_THREADS * 2);
    Assert.assertEquals(MAX_NUM_LISTSTATUS_THREADS,
        builder.build().getNumListstatusThreads());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testSetOverwrite() {
    final DistCpOptions.Builder builder = new DistCpOptions.Builder(
        Collections.singletonList(new Path(""hdfs://localhost:8020/source"")),
        new Path(""hdfs://localhost:8020/target/""));
    Assert.assertFalse(builder.build().shouldOverwrite());

    builder.withOverwrite(true);
    Assert.assertTrue(builder.build().shouldOverwrite());

    try {
      builder.withSyncFolder(true).build();
      Assert.fail(""Update and overwrite aren't allowed together"");
    }",Mystery Guest + Resource Optimism
"@Test
  public void testSetWorkPath() {
    final DistCpOptions.Builder builder = new DistCpOptions.Builder(
        Collections.singletonList(new Path(""hdfs://localhost:8020/source"")),
        new Path(""hdfs://localhost:8020/target/""));
    Assert.assertNull(builder.build().getAtomicWorkPath());

    builder.withAtomicCommit(true);
    Assert.assertNull(builder.build().getAtomicWorkPath());

    final Path workPath = new Path(""hdfs://localhost:8020/work"");
    builder.withAtomicWorkPath(workPath);
    Assert.assertEquals(workPath, builder.build().getAtomicWorkPath());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testVerboseLog() {
    final DistCpOptions.Builder builder = new DistCpOptions.Builder(
        Collections.singletonList(new Path(""hdfs://localhost:8020/source"")),
        new Path(""hdfs://localhost:8020/target/""));
    Assert.assertFalse(builder.build().shouldVerboseLog());

    try {
      builder.withVerboseLog(true).build();
      fail(""-v should fail if -log option is not specified"");
    }",Mystery Guest + Resource Optimism
"@Test
  public void testFallback() throws Exception {
    // the source/target dir are not snapshottable dir
    Assert.assertFalse(sync());
    // make sure the source path has been updated to the snapshot path
    final Path spath = new Path(source,
        HdfsConstants.DOT_SNAPSHOT_DIR + Path.SEPARATOR + ""s2"");
    Assert.assertEquals(spath, context.getSourcePaths().get(0));

    // reset source path in options
    context.setSourcePaths(Collections.singletonList(source));
    // the source/target does not have the given snapshots
    dfs.allowSnapshot(source);
    dfs.allowSnapshot(target);
    Assert.assertFalse(sync());
    Assert.assertEquals(spath, context.getSourcePaths().get(0));

    // reset source path in options
    context.setSourcePaths(Collections.singletonList(source));
    dfs.createSnapshot(source, ""s1"");
    dfs.createSnapshot(source, ""s2"");
    dfs.createSnapshot(target, ""s1"");
    Assert.assertTrue(sync());

    // reset source paths in options
    context.setSourcePaths(Collections.singletonList(source));
    // changes have been made in target
    final Path subTarget = new Path(target, ""sub"");
    dfs.mkdirs(subTarget);
    Assert.assertFalse(sync());
    // make sure the source path has been updated to the snapshot path
    Assert.assertEquals(spath, context.getSourcePaths().get(0));

    // reset source paths in options
    context.setSourcePaths(Collections.singletonList(source));
    dfs.delete(subTarget, true);
    Assert.assertTrue(sync());
  }",Mystery Guest
"@Test
  public void testSync7() throws Exception {
    initData7(source);
    initData7(target);
    enableAndCreateFirstSnapshot();
    int numCreatedModified = changeData7(source);
    dfs.createSnapshot(source, ""s2"");

    testAndVerify(numCreatedModified);
  }",Mystery Guest
"@Test
  public void testMultiFileTargetMissing() {
    caseMultiFileTargetMissing(false);
    caseMultiFileTargetMissing(true);
  }",Mystery Guest
"@Test
  public void testMultiFileTargetPresent() {
    caseMultiFileTargetPresent(false);
    caseMultiFileTargetPresent(true);
  }",Mystery Guest
"@Test
  public void testSingleFileTargetFile() {
    caseSingleFileTargetFile(false);
    caseSingleFileTargetFile(true);
  }",Mystery Guest
"@Test
  public void testRun() throws Exception {
    final URI uri = cluster.getFileSystem().getUri();
    final String pathString = uri.toString();
    Path fileSystemPath = new Path(pathString);
    Path source = new Path(fileSystemPath.toString() + ""/tmp/source"");
    Path target = new Path(fileSystemPath.toString() + ""/tmp/target"");
    Path listingPath = new Path(fileSystemPath.toString() + ""/tmp/META/fileList.seq"");
    DistCpOptions options = new DistCpOptions.Builder(
        Collections.singletonList(source), target).build();
    DistCpContext context = new DistCpContext(options);
    context.setTargetPathExists(false);
    new GlobbedCopyListing(new Configuration(), CREDENTIALS)
        .buildListing(listingPath, context);

    verifyContents(listingPath);
  }",Mystery Guest
"@Test
  public void testGlobFiles() throws Exception {
    final Path sub1 = new Path(inputPath, ""dir1"");
    final Path sub2 = new Path(inputPath, ""dir2"");
    fs.mkdirs(sub1);
    String fileName = ""a"";
    createFile(inputPath, fs, sub1.getName(), fileName);
    createFile(inputPath, fs, sub2.getName(), fileName);
    createFile(inputPath, fs, sub1.getName(), ""b""); // not part of result

    final String glob =  ""dir{1,2}",Mystery Guest
"@Test
  public void testRelativePath() throws Exception {
    final Path sub1 = new Path(inputPath, ""dir1"");
    fs.mkdirs(sub1);
    createFile(inputPath, fs, sub1.getName(), ""a"");
    final FsShell shell = new FsShell(conf);

    final List<String> originalPaths = lsr(shell, ""input"");
    System.out.println(""originalPaths: "" + originalPaths);

    // make the archive:
    final String fullHarPathStr = makeArchive();

    // compare results:
    final List<String> harPaths = lsr(shell, fullHarPathStr);
    Assert.assertEquals(originalPaths, harPaths);
  }",Mystery Guest
"@Test
  public void testDiffOption() {
    testSnapshotDiffOption(true);
  }",No Smells
"@Test
  public void testExclusionsOption() {
    DistCpOptions options = OptionsParser.parse(new String[] {
        ""hdfs://localhost:8020/source/first"",
        ""hdfs://localhost:8020/target/""}",Mystery Guest + Resource Optimism
"@Test
  public void testMissingSourceInfo() {
    try {
      OptionsParser.parse(new String[] {
          ""hdfs://localhost:8020/target/""}",No Smells
"@Test
  public void testOptionsAppendToConfDoesntOverwriteBandwidth() {
    Configuration conf = new Configuration();
    Assert.assertEquals(
        conf.getRaw(DistCpOptionSwitch.BANDWIDTH.getConfigLabel()), null);
    DistCpOptions options = OptionsParser.parse(new String[] {
        ""hdfs://localhost:8020/source/first"",
        ""hdfs://localhost:8020/target/""}",No Smells
"@Test
  public void testParseAtomicCommit() {
    DistCpOptions options = OptionsParser.parse(new String[] {
        ""hdfs://localhost:8020/source/first"",
        ""hdfs://localhost:8020/target/""}",No Smells
"@Test
  public void testParsebandwidth() {
    DistCpOptions options = OptionsParser.parse(new String[] {
        ""hdfs://localhost:8020/source/first"",
        ""hdfs://localhost:8020/target/""}",No Smells
"@Test
  public void testParseIgnoreFailure() {
    DistCpOptions options = OptionsParser.parse(new String[] {
        ""hdfs://localhost:8020/source/first"",
        ""hdfs://localhost:8020/target/""}",No Smells
"@Test
  public void testParseMaps() {
    DistCpOptions options = OptionsParser.parse(new String[] {
        ""hdfs://localhost:8020/source/first"",
        ""hdfs://localhost:8020/target/""}",No Smells
"@Test
  public void testParseSkipCRC() {
    DistCpOptions options = OptionsParser.parse(new String[] {
        ""hdfs://localhost:8020/source/first"",
        ""hdfs://localhost:8020/target/""}",No Smells
"@Test
  public void testParseSyncFolders() {
    DistCpOptions options = OptionsParser.parse(new String[] {
        ""hdfs://localhost:8020/source/first"",
        ""hdfs://localhost:8020/target/""}",No Smells
"@Test
  public void testSourceListing() {
    DistCpOptions options = OptionsParser.parse(new String[] {
        ""-f"",
        ""hdfs://localhost:8020/source/first"",
        ""hdfs://localhost:8020/target/""}",No Smells
"@Test
  public void testShouldCopyFalse() {
    List<Pattern> filters = new ArrayList<>();
    filters.add(Pattern.compile("".*test.*""));

    RegexCopyFilter regexCopyFilter = new RegexCopyFilter(""fakeFile"");
    regexCopyFilter.setFilters(filters);

    Path shouldNotCopyPath = new Path(""/user/testing"");
    Assert.assertFalse(regexCopyFilter.shouldCopy(shouldNotCopyPath));
  }",No Smells
"@Test
  public void testShouldCopy() {
    Assert.assertTrue(new TrueCopyFilter().shouldCopy(new Path(""fake"")));
  }",No Smells
"@Test
  public void testGetRelativePathRoot() {
    Path root = new Path(""/"");
    Path child = new Path(""/a"");
    assertThat(DistCpUtils.getRelativePath(root, child)).isEqualTo(""/a"");
  }",No Smells
"@Test
  public void testPreserveNothingOnDirectory() throws IOException {
    FileSystem fs = FileSystem.get(config);
    EnumSet<FileAttribute> attributes = EnumSet.noneOf(FileAttribute.class);

    Path dst = new Path(""/tmp/abc"");
    Path src = new Path(""/tmp/src"");

    createDirectory(fs, src);
    createDirectory(fs, dst);

    fs.setPermission(src, fullPerm);
    fs.setOwner(src, ""somebody"", ""somebody-group"");
    fs.setTimes(src, 0, 0);

    fs.setPermission(dst, noPerm);
    fs.setOwner(dst, ""nobody"", ""nobody-group"");
    fs.setTimes(dst, 100, 100);

    CopyListingFileStatus srcStatus = new CopyListingFileStatus(fs.getFileStatus(src));

    DistCpUtils.preserve(fs, dst, srcStatus, attributes, false);

    CopyListingFileStatus dstStatus = new CopyListingFileStatus(fs.getFileStatus(dst));

    // FileStatus.equals only compares path field, must explicitly compare all fields
    Assert.assertFalse(srcStatus.getPermission().equals(dstStatus.getPermission()));
    Assert.assertFalse(srcStatus.getOwner().equals(dstStatus.getOwner()));
    Assert.assertFalse(srcStatus.getGroup().equals(dstStatus.getGroup()));
    Assert.assertTrue(dstStatus.getAccessTime() == 100);
    Assert.assertTrue(dstStatus.getModificationTime() == 100);
    Assert.assertTrue(dstStatus.getReplication() == 0);
  }",No Smells
"@Test
  public void testPreserveOnFileUpwardRecursion() throws IOException {
    FileSystem fs = FileSystem.get(config);
    EnumSet<FileAttribute> attributes = EnumSet.allOf(FileAttribute.class);
    // Remove ACL because tests run with dfs.namenode.acls.enabled false
    attributes.remove(FileAttribute.ACL);
    
    Path src = new Path(""/tmp/src2"");
    Path f0 = new Path(""/f0"");
    Path f1 = new Path(""/d1/f1"");
    Path f2 = new Path(""/d1/d2/f2"");
    Path d1 = new Path(""/d1/"");
    Path d2 = new Path(""/d1/d2/"");

    createFile(fs, src);
    createFile(fs, f0);
    createFile(fs, f1);
    createFile(fs, f2);

    fs.setPermission(src, almostFullPerm);
    fs.setOwner(src, ""somebody"", ""somebody-group"");
    fs.setTimes(src, 0, 0);
    fs.setReplication(src, (short) 1);

    fs.setPermission(d1, fullPerm);
    fs.setOwner(d1, ""anybody"", ""anybody-group"");
    fs.setTimes(d1, 400, 400);
    fs.setReplication(d1, (short) 3);

    fs.setPermission(d2, fullPerm);
    fs.setOwner(d2, ""anybody"", ""anybody-group"");
    fs.setTimes(d2, 300, 300);
    fs.setReplication(d2, (short) 3);

    fs.setPermission(f0, fullPerm);
    fs.setOwner(f0, ""anybody"", ""anybody-group"");
    fs.setTimes(f0, 200, 200);
    fs.setReplication(f0, (short) 3);

    fs.setPermission(f1, fullPerm);
    fs.setOwner(f1, ""anybody"", ""anybody-group"");
    fs.setTimes(f1, 200, 200);
    fs.setReplication(f1, (short) 3);

    fs.setPermission(f2, fullPerm);
    fs.setOwner(f2, ""anybody"", ""anybody-group"");
    fs.setTimes(f2, 200, 200);
    fs.setReplication(f2, (short) 3);

    CopyListingFileStatus srcStatus = new CopyListingFileStatus(fs.getFileStatus(src));

    DistCpUtils.preserve(fs, f2, srcStatus, attributes, false);

    cluster.triggerHeartbeats();

    // FileStatus.equals only compares path field, must explicitly compare all fields
    // attributes of src -> f2 ? should be yes
    assertStatusEqual(fs, f2, srcStatus);

    // attributes of src -> f1 ? should be no
    CopyListingFileStatus f1Status = new CopyListingFileStatus(fs.getFileStatus(f1));
    Assert.assertFalse(srcStatus.getPermission().equals(f1Status.getPermission()));
    Assert.assertFalse(srcStatus.getOwner().equals(f1Status.getOwner()));
    Assert.assertFalse(srcStatus.getGroup().equals(f1Status.getGroup()));
    Assert.assertFalse(srcStatus.getAccessTime() == f1Status.getAccessTime());
    Assert.assertFalse(srcStatus.getModificationTime() == f1Status.getModificationTime());
    Assert.assertFalse(srcStatus.getReplication() == f1Status.getReplication());

    // attributes of src -> f0 ? should be no
    CopyListingFileStatus f0Status = new CopyListingFileStatus(fs.getFileStatus(f0));
    Assert.assertFalse(srcStatus.getPermission().equals(f0Status.getPermission()));
    Assert.assertFalse(srcStatus.getOwner().equals(f0Status.getOwner()));
    Assert.assertFalse(srcStatus.getGroup().equals(f0Status.getGroup()));
    Assert.assertFalse(srcStatus.getAccessTime() == f0Status.getAccessTime());
    Assert.assertFalse(srcStatus.getModificationTime() == f0Status.getModificationTime());
    Assert.assertFalse(srcStatus.getReplication() == f0Status.getReplication());

    // attributes of src -> d2 ? should be no
    CopyListingFileStatus d2Status = new CopyListingFileStatus(fs.getFileStatus(d2));
    Assert.assertFalse(srcStatus.getPermission().equals(d2Status.getPermission()));
    Assert.assertFalse(srcStatus.getOwner().equals(d2Status.getOwner()));
    Assert.assertFalse(srcStatus.getGroup().equals(d2Status.getGroup()));
    Assert.assertTrue(d2Status.getAccessTime() == 300);
    Assert.assertTrue(d2Status.getModificationTime() == 300);
    Assert.assertFalse(srcStatus.getReplication() == d2Status.getReplication());

    // attributes of src -> d1 ? should be no
    CopyListingFileStatus d1Status = new CopyListingFileStatus(fs.getFileStatus(d1));
    Assert.assertFalse(srcStatus.getPermission().equals(d1Status.getPermission()));
    Assert.assertFalse(srcStatus.getOwner().equals(d1Status.getOwner()));
    Assert.assertFalse(srcStatus.getGroup().equals(d1Status.getGroup()));
    Assert.assertTrue(d1Status.getAccessTime() == 400);
    Assert.assertTrue(d1Status.getModificationTime() == 400);
    Assert.assertFalse(srcStatus.getReplication() == d1Status.getReplication());
  }",Mystery Guest
"@Test
  public void testPreserveUserOnFile() throws IOException {
    FileSystem fs = FileSystem.get(config);
    EnumSet<FileAttribute> attributes = EnumSet.of(FileAttribute.USER);

    Path dst = new Path(""/tmp/dest2"");
    Path src = new Path(""/tmp/src2"");

    createFile(fs, src);
    createFile(fs, dst);

    fs.setPermission(src, fullPerm);
    fs.setOwner(src, ""somebody"", ""somebody-group"");
    fs.setTimes(src, 0, 0);
    fs.setReplication(src, (short) 1);

    fs.setPermission(dst, noPerm);
    fs.setOwner(dst, ""nobody"", ""nobody-group"");
    fs.setTimes(dst, 100, 100);
    fs.setReplication(dst, (short) 2);

    CopyListingFileStatus srcStatus = new CopyListingFileStatus(fs.getFileStatus(src));

    DistCpUtils.preserve(fs, dst, srcStatus, attributes, false);

    CopyListingFileStatus dstStatus = new CopyListingFileStatus(fs.getFileStatus(dst));

    // FileStatus.equals only compares path field, must explicitly compare all fields
    Assert.assertFalse(srcStatus.getPermission().equals(dstStatus.getPermission()));
    Assert.assertTrue(srcStatus.getOwner().equals(dstStatus.getOwner()));
    Assert.assertFalse(srcStatus.getGroup().equals(dstStatus.getGroup()));
    Assert.assertFalse(srcStatus.getAccessTime() == dstStatus.getAccessTime());
    Assert.assertFalse(srcStatus.getModificationTime() == dstStatus.getModificationTime());
    Assert.assertFalse(srcStatus.getReplication() == dstStatus.getReplication());
  }",Mystery Guest
"@Test
  public void testMultipleProducerConsumer() {
    ProducerConsumer<Integer, Integer> workers =
        new ProducerConsumer<Integer, Integer>(10);
    for (int i = 0; i < 10; i++) {
      workers.addWorker(new CopyProcessor());
    }",Eager Test
"@Test
  public void testIO() throws IOException {
    TypedBytesWritable tbw = new TypedBytesWritable();
    tbw.setValue(12345);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    DataOutput dout = new DataOutputStream(baos);
    tbw.write(dout);
    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
    DataInput din = new DataInputStream(bais);
    TypedBytesWritable readTbw = new TypedBytesWritable();
    readTbw.readFields(din);
    assertEquals(tbw, readTbw);
  }",No Smells
"@Test
  public void testGetStringData() throws Exception {
    String node1 = ""/node1"";
    String node2 = ""/node2"";
    assertFalse(curator.exists(node1));
    curator.create(node1);
    assertNull(curator.getStringData(node1));

    byte[] setData = ""setData"".getBytes(StandardCharsets.UTF_8);
    curator.setData(node1, setData, -1);
    assertEquals(""setData"", curator.getStringData(node1));

    Stat stat = new Stat();
    assertFalse(curator.exists(node2));
    curator.create(node2);
    assertNull(curator.getStringData(node2, stat));

    curator.setData(node2, setData, -1);
    assertEquals(""setData"", curator.getStringData(node2, stat));

  }",No Smells
"@Test
  public void testConstructUrlsFromClasspath() throws Exception {
    File file = new File(testDir, ""file"");
    assertTrue(""Create file"", file.createNewFile());

    File dir = new File(testDir, ""dir"");
    assertTrue(""Make dir"", dir.mkdir());

    File jarsDir = new File(testDir, ""jarsdir"");
    assertTrue(""Make jarsDir"", jarsDir.mkdir());
    File nonJarFile = new File(jarsDir, ""nonjar"");
    assertTrue(""Create non-jar file"", nonJarFile.createNewFile());
    File jarFile = new File(jarsDir, ""a.jar"");
    assertTrue(""Create jar file"", jarFile.createNewFile());

    File nofile = new File(testDir, ""nofile"");
    // don't create nofile

    StringBuilder cp = new StringBuilder();
    cp.append(file.getAbsolutePath()).append(File.pathSeparator)
      .append(dir.getAbsolutePath()).append(File.pathSeparator)
      .append(jarsDir.getAbsolutePath() + ""/*"").append(File.pathSeparator)
      .append(nofile.getAbsolutePath()).append(File.pathSeparator)
      .append(nofile.getAbsolutePath() + ""/*"").append(File.pathSeparator);
    
    URL[] urls = constructUrlsFromClasspath(cp.toString());
    
    assertEquals(3, urls.length);
    assertEquals(file.toURI().toURL(), urls[0]);
    assertEquals(dir.toURI().toURL(), urls[1]);
    assertEquals(jarFile.toURI().toURL(), urls[2]);
    // nofile should be ignored
  }",Mystery Guest + Resource Optimism
"@Test
  public void testGetResource() throws IOException {
    URL testJar = makeTestJar().toURI().toURL();
    
    ClassLoader currentClassLoader = getClass().getClassLoader();
    ClassLoader appClassloader = new ApplicationClassLoader(
        new URL[] { testJar }",Mystery Guest + Resource Optimism
"@Test
  public void testRemovals() throws Exception {
    final int NUM_ELEMS = 100000;
    ChunkedArrayList<Integer> list = new ChunkedArrayList<Integer>();
    for (int i = 0; i < NUM_ELEMS; i++) {
      list.add(i);
    }",Eager Test
"@Test
  public void testHelp() {
    Classpath.main(new String[] { ""--help"" }",No Smells
"@Test
  public void testJarReplace() throws IOException {
    // Run the command twice with the same output jar file, and expect success.
    testJar();
    testJar();
  }",Mystery Guest + Resource Optimism
"@Test
  public void testUpdateByteArrayLengthUnalignedWithCrcSize()
      throws Exception {
    CrcComposer digester = CrcComposer.newCrcComposer(type, chunkSize);

    LambdaTestUtils.intercept(
        IllegalArgumentException.class,
        ""length"",
        () -> digester.update(crcBytesByChunk, 0, 6, chunkSize));
  }",No Smells
"@Test
  public void testIntSerialization() {
    byte[] bytes = CrcUtil.intToBytes(0xCAFEBEEF);
    assertEquals(0xCAFEBEEF, CrcUtil.readInt(bytes, 0));

    bytes = new byte[8];
    CrcUtil.writeInt(bytes, 0, 0xCAFEBEEF);
    assertEquals(0xCAFEBEEF, CrcUtil.readInt(bytes, 0));
    CrcUtil.writeInt(bytes, 4, 0xABCDABCD);
    assertEquals(0xABCDABCD, CrcUtil.readInt(bytes, 4));

    // Assert big-endian format for general Java consistency.
    assertEquals(0xBEEFABCD, CrcUtil.readInt(bytes, 2));
  }",No Smells
"@Test
  public void testToMultiCrcStringMultipleElements() {
    byte[] buf = new byte[12];
    CrcUtil.writeInt(buf, 0, 0xcafebeef);
    CrcUtil.writeInt(buf, 4, 0xababcccc);
    CrcUtil.writeInt(buf, 8, 0xddddefef);
    assertEquals(
        ""[0xcafebeef, 0xababcccc, 0xddddefef]"",
        CrcUtil.toMultiCrcString(buf));
  }",No Smells
"@Test
  public void testCrc32() throws Exception {
    new Crc32PerformanceTest(8, 3, true).run();
    new Crc32PerformanceTest(8, 3, false).run();
  }",No Smells
"@Test
  public void testEquality() {
    assertEquals(
        DataChecksum.newDataChecksum(DataChecksum.Type.CRC32, 512),
        DataChecksum.newDataChecksum(DataChecksum.Type.CRC32, 512));
    assertFalse(
        DataChecksum.newDataChecksum(DataChecksum.Type.CRC32, 512).equals(
        DataChecksum.newDataChecksum(DataChecksum.Type.CRC32, 1024)));
    assertFalse(
        DataChecksum.newDataChecksum(DataChecksum.Type.CRC32, 512).equals(
        DataChecksum.newDataChecksum(DataChecksum.Type.CRC32C, 512)));        
  }",No Smells
"@Test
  public void testToString() {
    assertEquals(""DataChecksum(type=CRC32, chunkSize=512)"",
        DataChecksum.newDataChecksum(DataChecksum.Type.CRC32, 512).toString());
  }",No Smells
"@Test
  public void testBuffersAreReset() {
    ByteBuffer a = pool.getBuffer(100);
    a.putInt(0xdeadbeef);
    assertEquals(96, a.remaining());
    pool.returnBuffer(a);

    // Even though we return the same buffer,
    // its position should be reset to 0
    ByteBuffer b = pool.getBuffer(100);
    assertSame(a, b);
    assertEquals(100, a.remaining());
    pool.returnBuffer(b);
  }",No Smells
"@Test
  public void testForBadFIle() throws IOException {
    String[] ips = { ""10.221.102/23""}",Mystery Guest
"@Test
  public void testSubnetsAndIPs() throws IOException {

    String[] ips = {""10.119.103.112"", ""10.221.102.0/23""}",No Smells
"@Test
  public void testWithMultipleSubnetAndIPs() throws IOException {

    String[] ips = {""10.119.103.112"", ""10.221.102.0/23"", ""10.222.0.0/16"",
    ""10.113.221.221""}",No Smells
"@Test
  public void testCreateFailsInConstructor() throws Throwable {
    run(FindClass.E_CREATE_FAILED,
        FindClass.A_CREATE,
        ""org.apache.hadoop.util.TestFindClass$FailInConstructor"");
  }",Mystery Guest
"@Test
  public void testCreateFailsInPrivateConstructor() throws Throwable {
    run(FindClass.E_CREATE_FAILED,
        FindClass.A_CREATE,
        ""org.apache.hadoop.util.TestFindClass$PrivateConstructor"");
  }",Mystery Guest
"@Test
  public void testFailsNoSuchResource() throws Throwable {
    run(FindClass.E_NOT_FOUND,
        FindClass.A_RESOURCE,
        ""org/apache/hadoop/util/ThereIsNoSuchClass.class"");
  }",Mystery Guest
"@Test
  public void testLoadPrivateClass() throws Throwable {
    run(FindClass.SUCCESS,
        FindClass.A_LOAD, ""org.apache.hadoop.util.TestFindClass$PrivateClass"");
  }",Mystery Guest
"@Test
  public void testConfWithMultipleOpts() throws Exception {
    String[] args = new String[2];
    args[0] = ""--conf=foo"";
    args[1] = ""--conf=bar"";
    GenericOptionsParser g = new GenericOptionsParser(args);
    assertEquals(""1st conf param is incorrect"",
      ""foo"", g.getCommandLine().getOptionValues(""conf"")[0]);
    assertEquals(""2st conf param is incorrect"",
      ""bar"", g.getCommandLine().getOptionValues(""conf"")[1]);
  }",Mystery Guest
"@Test
  public void testGetClass() {

    //test with Integer
    Integer x = new Integer(42);
    Class<Integer> c = GenericsUtil.getClass(x);
    assertEquals(""Correct generic type is acquired from object"",
            Integer.class, c);

    //test with GenericClass<Integer>
    GenericClass<Integer> testSubject = new GenericClass<Integer>();
    Class<GenericClass<Integer>> c2 = GenericsUtil.getClass(testSubject);
    assertEquals(""Inner generics are acquired from object."",
            GenericClass.class, c2);
  }",No Smells
"@Test
  public void testWithEmptyList2() {
    List<String> list = new ArrayList<String>();
    //this method should not throw IndexOutOfBoundsException
    String[] arr = GenericsUtil.<String>toArray(String.class, list);

    assertEquals(""Assert list creation w/ no elements results in length 0"",
            0, arr.length);
  }",No Smells
"@Test
  public void testHostFileReaderWithSpaces() throws Exception {
    FileWriter efw = new FileWriter(excludesFile);
    FileWriter ifw = new FileWriter(includesFile);

    efw.write(""#DFS-Hosts-excluded\n"");
    efw.write(""   somehost somehost2"");
    efw.write(""   somehost3 # somehost4"");
    efw.close();

    ifw.write(""#Hosts-in-DFS\n"");
    ifw.write(""   somehost somehost2"");
    ifw.write(""   somehost3 # somehost4"");
    ifw.close();

    HostsFileReader hfp = new HostsFileReader(includesFile, excludesFile);

    int includesLen = hfp.getHosts().size();
    int excludesLen = hfp.getExcludedHosts().size();

    assertEquals(3, includesLen);
    assertEquals(3, excludesLen);

    assertTrue(hfp.getHosts().contains(""somehost3""));
    assertFalse(hfp.getHosts().contains(""somehost5""));
    assertFalse(hfp.getHosts().contains(""somehost4""));

    assertTrue(hfp.getExcludedHosts().contains(""somehost3""));
    assertFalse(hfp.getExcludedHosts().contains(""somehost5""));
    assertFalse(hfp.getExcludedHosts().contains(""somehost4""));

  }",Mystery Guest + Resource Optimism
"@Test
  public void testValidateResponseFailNoErrorMessage() throws Exception {
    HttpURLConnection conn = Mockito.mock(HttpURLConnection.class);
    Mockito.when(conn.getResponseCode()).thenReturn(HttpURLConnection.HTTP_BAD_REQUEST);
    LambdaTestUtils.intercept(IOException.class,
        () -> HttpExceptionUtils.validateResponse(conn, HttpURLConnection.HTTP_CREATED));
  }",No Smells
"@Test
  public void testValidateResponseJsonErrorKnownException() throws Exception {
    Map<String, Object> json = new HashMap<String, Object>();
    json.put(HttpExceptionUtils.ERROR_EXCEPTION_JSON, IllegalStateException.class.getSimpleName());
    json.put(HttpExceptionUtils.ERROR_CLASSNAME_JSON, IllegalStateException.class.getName());
    json.put(HttpExceptionUtils.ERROR_MESSAGE_JSON, ""EX"");
    Map<String, Object> response = new HashMap<String, Object>();
    response.put(HttpExceptionUtils.ERROR_JSON, json);
    ObjectMapper jsonMapper = new ObjectMapper();
    String msg = jsonMapper.writeValueAsString(response);
    InputStream is = new ByteArrayInputStream(msg.getBytes(StandardCharsets.UTF_8));
    HttpURLConnection conn = Mockito.mock(HttpURLConnection.class);
    Mockito.when(conn.getErrorStream()).thenReturn(is);
    Mockito.when(conn.getResponseMessage()).thenReturn(""msg"");
    Mockito.when(conn.getResponseCode()).thenReturn(HttpURLConnection.HTTP_BAD_REQUEST);
    LambdaTestUtils.intercept(IllegalStateException.class,
        ""EX"",
        () -> HttpExceptionUtils.validateResponse(conn, HttpURLConnection.HTTP_CREATED));
  }",No Smells
"@Test
  public void testShouldAddElement() {
    IntrusiveCollection<SimpleElement> intrusiveCollection =
      new IntrusiveCollection<>();

    SimpleElement element = new SimpleElement();
    intrusiveCollection.add(element);

    assertFalse(""Collection should not be empty"",
        intrusiveCollection.isEmpty());
    assertTrue(""Collection should contain added element"",
        intrusiveCollection.contains(element));
  }",No Smells
"@Test
  public void testExistingManifest() throws Exception {
    File dir = GenericTestUtils
        .getTestDir(TestJarFinder.class.getName() + ""-testExistingManifest"");
    delete(dir);
    dir.mkdirs();

    File metaInfDir = new File(dir, ""META-INF"");
    metaInfDir.mkdirs();
    File manifestFile = new File(metaInfDir, ""MANIFEST.MF"");
    Manifest manifest = new Manifest();
    OutputStream os = new FileOutputStream(manifestFile);
    manifest.write(os);
    os.close();

    File propsFile = new File(dir, ""props.properties"");
    Writer writer = new FileWriter(propsFile);
    new Properties().store(writer, """");
    writer.close();
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    JarOutputStream zos = new JarOutputStream(baos);
    JarFinder.jarDir(dir, """", zos);
    JarInputStream jis =
      new JarInputStream(new ByteArrayInputStream(baos.toByteArray()));
    Assert.assertNotNull(jis.getManifest());
    jis.close();
  }",Mystery Guest
"@Test
  public void testExpandedClasspath() throws Exception {
    //picking a class that is for sure in a directory in the classpath
    //in this case the JAR is created on the fly
    String jar = JarFinder.getJar(TestJarFinder.class);
    Assert.assertTrue(new File(jar).exists());
  }",Mystery Guest
"@Test
  public void testJar() throws Exception {

    //picking a class that is for sure in a JAR in the classpath
    String jar = JarFinder.getJar(LoggerFactory.class);
    Assert.assertTrue(new File(jar).exists());
  }",Mystery Guest
"@Test
  public void testFileSystemEmptyPath() throws Throwable {
    File tempFile = File.createTempFile(""Keyval"", "".json"");
    Path tempPath = new Path(tempFile.toURI());
    LocalFileSystem fs = FileSystem.getLocal(new Configuration());
    try {
      LambdaTestUtils.intercept(PathIOException.class,
          () -> serDeser.load(fs, tempPath));
      fs.delete(tempPath, false);
      LambdaTestUtils.intercept(FileNotFoundException.class,
          () -> serDeser.load(fs, tempPath));
    }",Mystery Guest
"@Test
  public void testFileSystemRoundTrip() throws Throwable {
    File tempFile = File.createTempFile(""Keyval"", "".json"");
    tempFile.delete();
    Path tempPath = new Path(tempFile.toURI());
    LocalFileSystem fs = FileSystem.getLocal(new Configuration());
    try {
      serDeser.save(fs, tempPath, source, false);
      assertEquals(""JSON loaded with load(fs, path)"",
          source,
          serDeser.load(fs, tempPath));
      assertEquals(""JSON loaded with load(fs, path, status)"",
          source,
          serDeser.load(fs, tempPath, fs.getFileStatus(tempPath)));
    }",Mystery Guest
"@Test
  public void testCustomDelimiter1() throws Exception {

    final String delimiter = ""</entity>"";

    // Ending part of Input Data Buffer
    // It contains '</' ie delimiter character
    final String currentBufferTailToken = ""</entity><entity><id>Gelesh</"";

    // Supposing the start of next buffer is this
    final String nextBufferHeadToken = ""id><name>Omathil</name></entity>"";

    // Expected must capture from both the buffer, excluding Delimiter
    final String expected =
        (currentBufferTailToken + nextBufferHeadToken).replace(delimiter, """");

    final String testPartOfInput = currentBufferTailToken + nextBufferHeadToken;

    final int bufferSize = 64 * 1024;
    int numberOfCharToFillTheBuffer =
        bufferSize - currentBufferTailToken.length();

    final char[] fillBuffer = new char[numberOfCharToFillTheBuffer];

    // char 'a' as a filler for the test string
    Arrays.fill(fillBuffer, 'a');

    final StringBuilder fillerString = new StringBuilder();

    final String testData = fillerString + testPartOfInput;

    final LineReader lineReader = new LineReader(
        new ByteArrayInputStream(testData.getBytes(StandardCharsets.UTF_8)),
        delimiter.getBytes(StandardCharsets.UTF_8));

    final Text line = new Text();
    lineReader.readLine(line);
    lineReader.close();

    Assert.assertEquals(fillerString.toString(), line.toString());

    lineReader.readLine(line);
    Assert.assertEquals(expected, line.toString());
  }",No Smells
"@Test
  public void testCIDRs() {
    //create MachineList with a list of of ip ranges specified in CIDR format
    MachineList ml = new MachineList(CIDR_LIST, new TestAddressFactory());

    //test for inclusion/exclusion 
    assertFalse(ml.includes(""10.221.255.255""));
    assertTrue(ml.includes(""10.222.0.0"")); 
    assertTrue(ml.includes(""10.222.0.1""));
    assertTrue(ml.includes(""10.222.0.255""));
    assertTrue(ml.includes(""10.222.255.0""));
    assertTrue(ml.includes(""10.222.255.254""));
    assertTrue(ml.includes(""10.222.255.255""));
    assertFalse(ml.includes(""10.223.0.0""));

    assertTrue(ml.includes(""10.241.23.0""));
    assertTrue(ml.includes(""10.241.23.1""));
    assertTrue(ml.includes(""10.241.23.254""));
    assertTrue(ml.includes(""10.241.23.255""));

    //test for exclusion with an unknown IP
    assertFalse(ml.includes(""10.119.103.111""));
  }",No Smells
"@Test
  public void testWildCard() {
    //create MachineList with a list of of IPs
    MachineList ml = new MachineList(""*"", new TestAddressFactory());

    //test for inclusion with any IP
    assertTrue(ml.includes(""10.119.103.112""));
    assertTrue(ml.includes(""1.2.3.4""));
  }",No Smells
"@Test
  public void testCalculateChunkedSumsByteArrayFail() throws ChecksumException {
    allocateArrayByteBuffers();
    fillDataAndInvalidChecksums();
    NativeCrc32.calculateChunkedSumsByteArray(bytesPerChecksum, checksumType.id,
      checksums.array(), checksums.position(), data.array(), data.position(),
      data.remaining());
  }",No Smells
"@Test
  public void testCalculateChunkedSumsByteArraySuccess() throws ChecksumException {
    allocateArrayByteBuffers();
    fillDataAndValidChecksums();
    NativeCrc32.calculateChunkedSumsByteArray(bytesPerChecksum, checksumType.id,
      checksums.array(), checksums.position(), data.array(), data.position(),
      data.remaining());
  }",No Smells
"@Test
  public void testVerifyChunkedSumsByteArrayFail() {
    allocateArrayByteBuffers();
    fillDataAndInvalidChecksums();
    assertThrows(ChecksumException.class,
        () -> NativeCrc32.verifyChunkedSumsByteArray(bytesPerChecksum,
            checksumType.id, checksums.array(), checksums.position(),
            data.array(), data.position(), data.remaining(), fileName,
            BASE_POSITION));
  }",No Smells
"@Test
  public void testVerifyChunkedSumsByteArraySuccess() throws ChecksumException {
    allocateArrayByteBuffers();
    fillDataAndValidChecksums();
    NativeCrc32.verifyChunkedSumsByteArray(bytesPerChecksum, checksumType.id,
      checksums.array(), checksums.position(), data.array(), data.position(),
      data.remaining(), fileName, BASE_POSITION);
  }",No Smells
"@Test
  public void testVerifyChunkedSumsSuccess() throws ChecksumException {
    allocateDirectByteBuffers();
    fillDataAndValidChecksums();
    NativeCrc32.verifyChunkedSums(bytesPerChecksum, checksumType.id,
      checksums, data, fileName, BASE_POSITION);
  }",No Smells
"@Test
  public void testVerifyChunkedSumsSuccessOddSize() throws ChecksumException {
    // Test checksum with an odd number of bytes. This is a corner case that
    // is often broken in checksum calculation, because there is an loop which
    // handles an even multiple or 4 or 8 bytes and then some additional code
    // to finish the few odd bytes at the end. This code can often be broken
    // but is never tested because we are always calling it with an even value
    // such as 512.
    bytesPerChecksum--;
    allocateDirectByteBuffers();
    fillDataAndValidChecksums();
    NativeCrc32.verifyChunkedSums(bytesPerChecksum, checksumType.id,
      checksums, data, fileName, BASE_POSITION);
    bytesPerChecksum++;
  }",No Smells
"@Test
  public void testNativeLibraryCheckerOutput(){
    expectOutput(new String[]{""-a""}",No Smells
"@Test
  public void testNodeHealthScriptShouldRun() throws IOException {
    assertFalse(""Node health script should start"",
        NodeHealthScriptRunner.shouldRun(""script"",
            nodeHealthscriptFile.getAbsolutePath()));
    writeNodeHealthScriptFile("""", false);
    // Node health script should not start if the node health script is not
    // executable.
    assertFalse(""Node health script should start"",
        NodeHealthScriptRunner.shouldRun(""script"",
            nodeHealthscriptFile.getAbsolutePath()));
    writeNodeHealthScriptFile("""", true);
    assertTrue(""Node health script should start"",
        NodeHealthScriptRunner.shouldRun(""script"",
            nodeHealthscriptFile.getAbsolutePath()));
  }",No Smells
"@Test
  public void testRpcClientId() {
    byte[] uuid = ClientId.getClientId();
    RpcRequestHeaderProto header = ProtoUtil.makeRpcRequestHeader(
        RpcKind.RPC_PROTOCOL_BUFFER, OperationProto.RPC_FINAL_PACKET, 0,
        RpcConstants.INVALID_RETRY_COUNT, uuid);
    assertTrue(Arrays.equals(uuid, header.getClientId().toByteArray()));
  }",No Smells
"@Test
  public void testGetDeclaredFieldsIncludingInherited() {
    Parent child = new Parent() {
      private int childField;
      @SuppressWarnings(""unused"")
      public int getChildField() { return childField; }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testBigJar() throws Exception {
    Random r = new Random(System.currentTimeMillis());
    File dir = new File(TEST_ROOT_DIR, Long.toHexString(r.nextLong()));
    Assert.assertTrue(dir.mkdirs());
    File input = generateBigJar(dir);
    File output = new File(dir, ""job2.jar"");
    try {
      try (InputStream is = new FileInputStream(input)) {
        RunJar.unJarAndSave(is, dir, ""job2.jar"", Pattern.compile("".*""));
      }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testUnJarDoesNotLooseLastModify() throws Exception {
    File unjarDir = getUnjarDir(""unjar-lastmod"");

    // Unjar everything
    RunJar.unJar(new File(TEST_ROOT_DIR, TEST_JAR_NAME),
            unjarDir, MATCH_ANY);

    String failureMessage = ""Last modify time was lost during unJar"";
    assertEquals(failureMessage, MOCKED_NOW, new File(unjarDir, TestRunJar.FOOBAR_TXT).lastModified());
    assertEquals(failureMessage, MOCKED_NOW_PLUS_TWO_SEC, new File(unjarDir, FOOBAZ_TXT).lastModified());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testUnJarWithPattern() throws Exception {
    File unjarDir = getUnjarDir(""unjar-pattern"");

    // Unjar only a regex
    RunJar.unJar(new File(TEST_ROOT_DIR, TEST_JAR_NAME),
                 unjarDir,
                 Pattern.compile("".*baz.*""));
    assertFalse(""foobar not unpacked"",
                new File(unjarDir, TestRunJar.FOOBAR_TXT).exists());
    assertTrue(""foobaz unpacked"",
               new File(unjarDir, FOOBAZ_TXT).exists());
  }",Mystery Guest + Resource Optimism
"@Test
  public void testBinWinUtilsNotAFile() throws Throwable {
    try {
      File bin = new File(methodDir, ""bin"");
      File winutils = new File(bin, WINUTILS_EXE);
      winutils.mkdirs();
      assertWinutilsResolveFailed(methodDir, E_NOT_EXECUTABLE_FILE);
    }",Mystery Guest
"@Test
  public void testEnvVarsWithInheritance() throws Exception {
    Assume.assumeFalse(WINDOWS);
    testEnvHelper(true);
  }",No Smells
"@Test
  public void testEnvVarsWithInheritance() throws Exception {
    Assume.assumeFalse(WINDOWS);
    testEnvHelper(true);
  }",No Smells
"@Test
  public void testEnvVarsWithoutInheritance() throws Exception {
    Assume.assumeFalse(WINDOWS);
    testEnvHelper(false);
  }",No Smells
"@Test
  public void testHadoopBinNotADir() throws Throwable {
    File bin = new File(methodDir, ""bin"");
    touch(bin);
    try {
      assertWinutilsResolveFailed(methodDir, E_NOT_DIRECTORY);
    }",Mystery Guest
"@Test
  public void testHadoopHomeEmptyDoubleQuotes() throws Throwable {
    assertHomeResolveFailed(""\""\"""", E_HADOOP_PROPS_EMPTY);
  }",Mystery Guest
"@Test
  public void testHadoopHomeValid() throws Throwable {
    File f = checkHadoopHomeInner(rootTestDir.getCanonicalPath());
    assertEquals(rootTestDir, f);
  }",Mystery Guest
"@Test
  public void testHadoopHomeValidQuoted() throws Throwable {
    File f = checkHadoopHomeInner('""'+ rootTestDir.getCanonicalPath() + '""');
    assertEquals(rootTestDir, f);
  }",Mystery Guest
"@Test
  public void testInterval() throws IOException {
    testInterval(Long.MIN_VALUE / 60000);  // test a negative interval
    testInterval(0L);  // test a zero interval
    testInterval(10L); // interval equal to 10mins
    testInterval(Time.now() / 60000 + 60); // test a very big interval
  }",No Smells
"@Test
  public void testShellCommandTimeout() throws Throwable {
    Assume.assumeFalse(WINDOWS);
    String rootDir = rootTestDir.getAbsolutePath();
    File shellFile = new File(rootDir, ""timeout.sh"");
    String timeoutCommand = ""sleep 4; echo \""hello\"""";
    Shell.ShellCommandExecutor shexc;
    try (PrintWriter writer = new PrintWriter(new FileOutputStream(shellFile))) {
      writer.println(timeoutCommand);
      writer.close();
    }",Mystery Guest + Resource Optimism
"@Test
  public void testFormatTimeSortable() {
    long timeDiff = 523452311;
    String timeDiffStr = ""99hrs, 59mins, 59sec"";

    assertEquals(""Incorrect time diff string returned"", timeDiffStr,
        StringUtils.formatTimeSortable(timeDiff));
  }",No Smells
"@Test
  public void testIsAlpha() {
    assertTrue(""Reported hello as non-alpha string"",
        StringUtils.isAlpha(""hello""));
    assertFalse(""Reported hello1 as alpha string"",
        StringUtils.isAlpha(""hello1""));
  }",No Smells
"@Test
  public void testFindByte() {
    byte[] data = ""Hello, world!"".getBytes();
    assertEquals(""Character 'a' does not exist in string"", -1,
        UTF8ByteArrayUtils.findByte(data, 0, data.length, (byte) 'a'));
    assertEquals(""Did not find first occurrence of character 'o'"", 4,
        UTF8ByteArrayUtils.findByte(data, 0, data.length, (byte) 'o'));
  }",No Smells
"@Test
  public void testFindBytes() {
    byte[] data = ""Hello, world!"".getBytes();
    assertEquals(""Did not find first occurrence of pattern 'ello'"", 1,
        UTF8ByteArrayUtils.findBytes(data, 0, data.length, ""ello"".getBytes()));
    assertEquals(
        ""Substring starting at position 2 does not contain pattern 'ello'"", -1,
        UTF8ByteArrayUtils.findBytes(data, 2, data.length, ""ello"".getBytes()));
  }",No Smells
"@Test
  public void testEmptyACL() {
    List<ACL> result = ZKUtil.parseACLs("""");
    assertTrue(result.isEmpty());
  }",No Smells
"@Test
  public void testGoodACLs() {
    List<ACL> result = ZKUtil.parseACLs(
        ""sasl:hdfs/host1@MY.DOMAIN:cdrwa, sasl:hdfs/host2@MY.DOMAIN:ca"");
    ACL acl0 = result.get(0);
    assertEquals(Perms.CREATE | Perms.DELETE | Perms.READ |
        Perms.WRITE | Perms.ADMIN, acl0.getPerms());
    assertEquals(""sasl"", acl0.getId().getScheme());
    assertEquals(""hdfs/host1@MY.DOMAIN"", acl0.getId().getId());
    
    ACL acl1 = result.get(1);
    assertEquals(Perms.CREATE | Perms.ADMIN, acl1.getPerms());
    assertEquals(""sasl"", acl1.getId().getScheme());
    assertEquals(""hdfs/host2@MY.DOMAIN"", acl1.getId().getId());
  }",No Smells
"@Test
  public void testNullAuth() {
    List<ZKAuthInfo> result = ZKUtil.parseAuth(null);
    assertTrue(result.isEmpty());
  }",No Smells
"@Test
  public void testAndConstraint() {
    AbstractConstraint constraintExpr =
        and(targetIn(RACK, allocationTag(""spark"")),
            maxCardinality(NODE, 3, ""spark""),
            targetCardinality(RACK, 2, 10, allocationTag(""zk"")));

    And andExpr = (And) constraintExpr;
    assertEquals(3, andExpr.getChildren().size());
    SingleConstraint sConstr = (SingleConstraint) andExpr.getChildren().get(0);
    TargetExpression tExpr = sConstr.getTargetExpressions().iterator().next();
    assertEquals(""spark"", tExpr.getTargetValues().iterator().next());

    sConstr = (SingleConstraint) andExpr.getChildren().get(1);
    assertEquals(0, sConstr.getMinCardinality());
    assertEquals(3, sConstr.getMaxCardinality());

    sConstr = (SingleConstraint) andExpr.getChildren().get(2);
    assertEquals(2, sConstr.getMinCardinality());
    assertEquals(10, sConstr.getMaxCardinality());
  }",No Smells
"@Test
  public void testClientStop() {
    Configuration conf = new Configuration();
    AHSClient client = AHSClient.createAHSClient();
    client.init(conf);
    client.start();
    client.stop();
  }",No Smells
"@Test
  public void testAMRMContainerPromotionAndDemotionWithAutoUpdate()
      throws Exception {
    AMRMClientImpl<AMRMClient.ContainerRequest> amClient =
        (AMRMClientImpl<AMRMClient.ContainerRequest>) AMRMClient
            .createAMRMClient();
    amClient.init(conf);
    amClient.start();

    // start am nm client
    NMClientImpl nmClient = (NMClientImpl) NMClient.createNMClient();
    Assert.assertNotNull(nmClient);
    nmClient.init(conf);
    nmClient.start();
    assertEquals(STATE.STARTED, nmClient.getServiceState());

    amClient.registerApplicationMaster(""Host"", 10000, """");

    // setup container request
    assertEquals(0, amClient.ask.size());
    assertEquals(0, amClient.release.size());

    // START OPPORTUNISTIC Container, Send allocation request to RM
    Resource reqResource = Resource.newInstance(512, 1);
    amClient.addContainerRequest(
        new AMRMClient.ContainerRequest(reqResource, null, null, priority2, 0,
            true, null, ExecutionTypeRequest
            .newInstance(ExecutionType.OPPORTUNISTIC, true)));

    // RM should allocate container within 1 calls to allocate()
    AllocateResponse allocResponse = waitForAllocation(amClient, 1, 0);

    assertEquals(1, allocResponse.getAllocatedContainers().size());
    startContainer(allocResponse, nmClient);

    Container c = allocResponse.getAllocatedContainers().get(0);
    amClient.requestContainerUpdate(c,
        UpdateContainerRequest.newInstance(c.getVersion(),
            c.getId(), ContainerUpdateType.PROMOTE_EXECUTION_TYPE,
            null, ExecutionType.GUARANTEED));

    allocResponse = waitForAllocation(amClient, 0, 1);

    // Make sure container is updated.
    UpdatedContainer updatedContainer = allocResponse
        .getUpdatedContainers().get(0);

    // If container auto update is not enabled, we need to notify
    // NM about this update.
    if (!autoUpdate) {
      nmClient.updateContainerResource(updatedContainer.getContainer());
    }",Eager Test
"@Test
  public void testSignalContainer() throws Exception {
    @SuppressWarnings(""resource"")
    final YarnClient client = new MockYarnClient();
    client.init(getConf());
    client.start();
    ApplicationId applicationId = ApplicationId.newInstance(1234, 5);
    ApplicationAttemptId appAttemptId = ApplicationAttemptId.newInstance(
        applicationId, 1);
    ContainerId containerId = ContainerId.newContainerId(appAttemptId, 1);
    SignalContainerCommand command = SignalContainerCommand.OUTPUT_THREAD_DUMP;
    client.signalToContainer(containerId, command);
    final ArgumentCaptor<SignalContainerRequest> signalReqCaptor =
        ArgumentCaptor.forClass(SignalContainerRequest.class);
    verify(((MockYarnClient) client).getRMClient())
        .signalToContainer(signalReqCaptor.capture());
    SignalContainerRequest request = signalReqCaptor.getValue();
    Assert.assertEquals(containerId, request.getContainerId());
    Assert.assertEquals(command, request.getCommand());
  }",No Smells
"@Test
  public void testAsyncAPIPollTimeout() {
    testAsyncAPIPollTimeoutHelper(null, false);
    testAsyncAPIPollTimeoutHelper(0L, true);
    testAsyncAPIPollTimeoutHelper(1L, true);
  }",No Smells
"@Test
  public void testAutomaticTimelineDelegationTokenLoading()
          throws Exception {
    Configuration conf = getConf();
    conf.setBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED, true);
    SecurityUtil.setAuthenticationMethod(UserGroupInformation.AuthenticationMethod.KERBEROS, conf);
    conf.set(YarnConfiguration.TIMELINE_HTTP_AUTH_TYPE,
            KerberosAuthenticationHandler.TYPE);
    TimelineDelegationTokenIdentifier timelineDT =
            new TimelineDelegationTokenIdentifier();
    final Token<TimelineDelegationTokenIdentifier> dToken =
            new Token<>(
                    timelineDT.getBytes(), new byte[0], timelineDT.getKind(), new Text());
    // create a mock client
    YarnClientImpl client = spy(new YarnClientImpl() {

      @Override
      TimelineClient createTimelineClient() throws IOException, YarnException {
        timelineClient = mock(TimelineClient.class);
        when(timelineClient.getDelegationToken(any())).thenReturn(dToken);
        return timelineClient;
      }",Eager Test
"@Test
  public void testBestEffortTimelineDelegationToken()
          throws Exception {
    Configuration conf = getConf();
    conf.setBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED, true);
    SecurityUtil.setAuthenticationMethod(UserGroupInformation.AuthenticationMethod.KERBEROS, conf);
    conf.set(YarnConfiguration.TIMELINE_HTTP_AUTH_TYPE,
            KerberosAuthenticationHandler.TYPE);
    YarnClientImpl client = spy(new YarnClientImpl() {

      @Override
      TimelineClient createTimelineClient() throws IOException, YarnException {
        timelineClient = mock(TimelineClient.class);
        when(timelineClient.getDelegationToken(any()))
                .thenThrow(new RuntimeException(""Best effort test exception""));
        return timelineClient;
      }",No Smells
"@Test
  public void testParseTimelineDelegationTokenRenewer() {
    // Client side
    YarnClientImpl client = (YarnClientImpl) YarnClient.createYarnClient();
    Configuration conf = getConf();
    conf.setBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED, true);
    conf.set(YarnConfiguration.RM_PRINCIPAL, ""rm/_HOST@EXAMPLE.COM"");
    conf.set(
            YarnConfiguration.RM_ADDRESS, ""localhost:8188"");
    try {
      client.init(conf);
      client.start();
      Assert.assertEquals(""rm/localhost@EXAMPLE.COM"", client.timelineDTRenewer);
    }",No Smells
"@Test
  public void testGetClusterNodeLabels() throws Exception {
    when(client.getClusterNodeLabels()).thenReturn(
        Arrays.asList(NodeLabel.newInstance(""label1""),
            NodeLabel.newInstance(""label2"")));
    ClusterCLI cli = createAndGetClusterCLI();
    
    int rc =
        cli.run(new String[] { ClusterCLI.CMD, ""-"" + ClusterCLI.LIST_LABELS_CMD }",No Smells
"@Test
  public void testAddToClusterNodeLabelsWithExclusivitySetting()
      throws Exception {
    // Parenthese not match
    String[] args = new String[] { ""-addToClusterNodeLabels"", ""x("" }",No Smells
"@Test
  public void testCheckHealth() throws Exception {
    String[] args = {""-checkHealth"", ""rm1""}",No Smells
"@Test
  public void testGetAllServiceState() throws Exception {
    HAServiceStatus standbyStatus = new HAServiceStatus(
        HAServiceState.STANDBY).setReadyToBecomeActive();
    Mockito.doReturn(standbyStatus).when(haadmin).getServiceStatus();
    ByteArrayOutputStream dataOut = new ByteArrayOutputStream();
    rmAdminCLIWithHAEnabled.setOut(new PrintStream(dataOut));
    String[] args = {""-getAllServiceState""}",No Smells
"@Test
  public void testRefreshAdminAcls() throws Exception {
    String[] args = { ""-refreshAdminAcls"" }",No Smells
"@Test
  public void testRefreshNodesGracefulHitTimeout() throws Exception {
    // Forceful decommission when timeout occurs
    String[] forcefulDecomArgs = {""-refreshNodes"", ""-g"", ""1"", ""-client""}",No Smells
"@Test
  public void testRefreshNodesGracefulInvalidArgs() throws Exception {
    // invalid graceful timeout parameter
    String[] invalidArgs = {""-refreshNodes"", ""-ginvalid"", ""invalid"", ""-client""}",No Smells
"@Test
  public void testRefreshNodesGracefulNoTimeout() throws Exception {
    // no timeout (infinite timeout)
    String[] noTimeoutArgs = {""-refreshNodes"", ""-g"", ""-client""}",No Smells
"@Test
  public void testRefreshUserToGroupsMappings() throws Exception {
    String[] args = { ""-refreshUserToGroupsMappings"" }",No Smells
"@Test
  public void testReplaceMultipleLabelsOnSingleNode() throws Exception {
    // Successfully replace labels
    dummyNodeLabelsManager.addToCluserNodeLabelsWithDefaultExclusivity(ImmutableSet.of(""x"", ""y""));
    String[] args =
        { ""-replaceLabelsOnNode"", ""node1,x,y"",
            ""-directlyAccessNodeLabelStore"" }",No Smells
"@Test
  public void testTransitionToStandby() throws Exception {
    String[] args = {""-transitionToStandby"", ""rm1""}",No Smells
"@Test
  public void testUpdateNodeResourceTypesWithInvalidResource()
      throws Exception {
    String nodeIdStr = ""0.0.0.0:0"";
    String resourceTypes =
        ""memory-mb=1024Mi,vcores=1,resource1=3Gi,resource3=2m"";
    String[] args = {""-updateNodeResource"", nodeIdStr, resourceTypes}",No Smells
"@Test
  public void testUpdateNodeResourceTypesWithInvalidResourceUnit()
      throws Exception {
    String nodeIdStr = ""0.0.0.0:0"";
    String resourceTypes =
        ""memory-mb=1024Mi,vcores=1,resource1=2XYZ,resource2=2m"";
    String[] args = {""-updateNodeResource"", nodeIdStr, resourceTypes}",No Smells
"@Test
  public void testUpdateNodeResourceTypesWithInvalidResourceValue()
      throws Exception {
    String nodeIdStr = ""0.0.0.0:0"";
    String resourceTypes =
        ""memory-mb=1024Mi,vcores=1,resource1=ABDC,resource2=2m"";
    String[] args = {""-updateNodeResource"", nodeIdStr, resourceTypes}",No Smells
"@Test
  public void testUpdateNodeResourceTypesWithNonAlphaResourceUnit()
      throws Exception {
    String nodeIdStr = ""0.0.0.0:0"";
    String resourceTypes =
        ""memory-mb=1024M i,vcores=1,resource1=2G,resource2=2m"";
    String[] args = {""-updateNodeResource"", nodeIdStr, resourceTypes}",No Smells
"@Test
  public void testUpdateNodeResourceWithOverCommitTimeout() throws Exception {
    String nodeIdStr = ""0.0.0.0:0"";
    int memSize = 2048;
    int cores = 2;
    int timeout = 1000;
    String[] args = {""-updateNodeResource"", nodeIdStr,
        Integer.toString(memSize), Integer.toString(cores),
        Integer.toString(timeout)}",No Smells
"@Test
  public void testAbsentNodeStatus() throws Exception {
    NodeId nodeId = NodeId.newInstance(""Absenthost0"", 0);

    when(client.getNodeReports()).thenReturn(
                getNodeReports(0, NodeState.RUNNING));
    NodeCLI cli = createAndGetNodeCLI();
    int result = cli.run(new String[] { ""-status"", nodeId.toString() }",No Smells
"@Test
  public void testAppCLIUsageInfo() throws Exception {
    verifyUsageInfo(new ApplicationCLI());
  }",No Smells
"@Test
  public void testGetApplicationAttemptReport() throws Exception {
    ApplicationCLI cli = createAndGetAppCLI();
    ApplicationId applicationId = ApplicationId.newInstance(1234, 5);
    ApplicationAttemptId attemptId = ApplicationAttemptId.newInstance(
        applicationId, 1);
    ApplicationAttemptReport attemptReport =
        ApplicationAttemptReport.newInstance(attemptId, ""host"", 124, ""url"",
            ""oUrl"", ""diagnostics"", YarnApplicationAttemptState.FINISHED,
            ContainerId.newContainerId(attemptId, 1), 1000l, 2000l);
    when(
        client
            .getApplicationAttemptReport(any(ApplicationAttemptId.class)))
        .thenReturn(attemptReport);
    int result = cli.run(new String[] { ""applicationattempt"", ""-status"",
        attemptId.toString() }",No Smells
"@Test
  public void testGetApplicationAttemptReportException() throws Exception {
    ApplicationCLI cli = createAndGetAppCLI();
    ApplicationId applicationId = ApplicationId.newInstance(1234, 5);
    ApplicationAttemptId attemptId1 = ApplicationAttemptId.newInstance(
        applicationId, 1);
    when(client.getApplicationAttemptReport(attemptId1)).thenThrow(
        new ApplicationNotFoundException(""History file for application""
            + applicationId + "" is not found""));

    int exitCode = cli.run(new String[] { ""applicationattempt"", ""-status"",
        attemptId1.toString() }",No Smells
"@Test
  public void testGetContainerReportException() throws Exception {
    ApplicationCLI cli = createAndGetAppCLI();
    ApplicationId applicationId = ApplicationId.newInstance(1234, 5);
    ApplicationAttemptId attemptId = ApplicationAttemptId.newInstance(
        applicationId, 1);
    long cntId = 1;
    ContainerId containerId1 = ContainerId.newContainerId(attemptId, cntId++);
    when(client.getContainerReport(containerId1)).thenThrow(
        new ApplicationNotFoundException(""History file for application""
            + applicationId + "" is not found""));

    int exitCode = cli.run(new String[] { ""container"", ""-status"",
        containerId1.toString() }",No Smells
"@Test
  public void testGetQueueInfo() throws Exception {
    QueueCLI cli = createAndGetQueueCLI();
    Set<String> nodeLabels = new HashSet<String>();
    nodeLabels.add(""GPU"");
    nodeLabels.add(""JDK_7"");
    QueueInfo queueInfo = QueueInfo.
        newInstance(""queueA"", ""root.queueA"",
            0.4f, 0.8f, 0.5f,
        null, null, QueueState.RUNNING, nodeLabels,
        ""GPU"", null, false, -1.0f, 10,
            null, false);
    when(client.getQueueInfo(any(String.class))).thenReturn(queueInfo);
    int result = cli.run(new String[] { ""-status"", ""queueA"" }",No Smells
"@Test
  public void testGetQueueInfoOverrideIntraQueuePreemption() throws Exception {
    CapacitySchedulerConfiguration conf = new CapacitySchedulerConfiguration();
    ReservationSystemTestUtil.setupQueueConfiguration(conf);
    conf.setClass(YarnConfiguration.RM_SCHEDULER, CapacityScheduler.class,
        ResourceScheduler.class);
    conf.setBoolean(YarnConfiguration.RM_SCHEDULER_ENABLE_MONITORS, true);
    conf.set(YarnConfiguration.RM_SCHEDULER_MONITOR_POLICIES,
        ""org.apache.hadoop.yarn.server.resourcemanager.monitor.capacity.""
        + ""ProportionalCapacityPreemptionPolicy"");
    // Turn on cluster-wide intra-queue preemption
    conf.setBoolean(
        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED, true);
    // Disable intra-queue preemption for all queues
    conf.setBoolean(CapacitySchedulerConfiguration.PREFIX
        + ""root.intra-queue-preemption.disable_preemption"", true);
    // Enable intra-queue preemption for the a1 queue
    conf.setBoolean(CapacitySchedulerConfiguration.PREFIX
        + ""root.a.a1.intra-queue-preemption.disable_preemption"", false);
    MiniYARNCluster cluster =
        new MiniYARNCluster(""testGetQueueInfoOverrideIntraQueuePreemption"",
            2, 1, 1);

    YarnClient yarnClient = null;
    try {
      cluster.init(conf);
      cluster.start();
      final Configuration yarnConf = cluster.getConfig();
      yarnClient = YarnClient.createYarnClient();
      yarnClient.init(yarnConf);
      yarnClient.start();

      QueueCLI cli = createAndGetQueueCLI(yarnClient);
      sysOutStream.reset();
      // Get status for the root.a queue
      int result = cli.run(new String[] { ""-status"", ""a"" }",No Smells
"@Test
  public void testGetQueueInfoPreemptionDisabled() throws Exception {
    CapacitySchedulerConfiguration conf = new CapacitySchedulerConfiguration();
    ReservationSystemTestUtil.setupQueueConfiguration(conf);
    conf.setClass(YarnConfiguration.RM_SCHEDULER, CapacityScheduler.class,
        ResourceScheduler.class);
    conf.setBoolean(YarnConfiguration.RM_SCHEDULER_ENABLE_MONITORS, true);
    conf.set(YarnConfiguration.RM_SCHEDULER_MONITOR_POLICIES,
        ""org.apache.hadoop.yarn.server.resourcemanager.monitor.capacity.""
        + ""ProportionalCapacityPreemptionPolicy"");
    conf.setBoolean(YarnConfiguration.RM_SCHEDULER_ENABLE_MONITORS, true);
    conf.setBoolean(PREFIX + ""root.a.a1.disable_preemption"", true);

    try (MiniYARNCluster cluster =
        new MiniYARNCluster(""testReservationAPIs"", 2, 1, 1);
         YarnClient yarnClient = YarnClient.createYarnClient()) {
      cluster.init(conf);
      cluster.start();
      final Configuration yarnConf = cluster.getConfig();
      yarnClient.init(yarnConf);
      yarnClient.start();

      QueueCLI cli = createAndGetQueueCLI(yarnClient);
      sysOutStream.reset();
      int result = cli.run(new String[] { ""-status"", ""a1"" }",No Smells
"@Test
  public void testListClusterNodes() throws Exception {
    List<NodeReport> nodeReports = new ArrayList<NodeReport>();
    nodeReports.addAll(getNodeReports(1, NodeState.NEW));
    nodeReports.addAll(getNodeReports(2, NodeState.RUNNING));
    nodeReports.addAll(getNodeReports(1, NodeState.UNHEALTHY));
    nodeReports.addAll(getNodeReports(1, NodeState.DECOMMISSIONED));
    nodeReports.addAll(getNodeReports(1, NodeState.REBOOTED));
    nodeReports.addAll(getNodeReports(1, NodeState.LOST));

    NodeCLI cli = createAndGetNodeCLI();

    Set<NodeState> nodeStates = new HashSet<NodeState>();
    nodeStates.add(NodeState.NEW);
    NodeState[] states = nodeStates.toArray(new NodeState[0]);
    when(client.getNodeReports(states))
        .thenReturn(getNodeReports(nodeReports, nodeStates));
    int result = cli.run(new String[] {""-list"", ""-states"", ""NEW""}",Eager Test
"@Test
  public void testMoveApplicationAcrossQueues() throws Exception {
    ApplicationCLI cli = createAndGetAppCLI();
    ApplicationId applicationId = ApplicationId.newInstance(1234, 5);

    ApplicationReport newApplicationReport2 = ApplicationReport.newInstance(
        applicationId, ApplicationAttemptId.newInstance(applicationId, 1),
        ""user"", ""queue"", ""appname"", ""host"", 124, null,
        YarnApplicationState.FINISHED, ""diagnostics"", ""url"", 0, 0, 0,
        FinalApplicationStatus.SUCCEEDED, null, ""N/A"", 0.53789f, ""YARN"", null);
    when(client.getApplicationReport(any(ApplicationId.class))).thenReturn(
        newApplicationReport2);
    int result = cli.run(new String[] { ""application"", ""-movetoqueue"",
        applicationId.toString(), ""-queue"", ""targetqueue""}",No Smells
"@Test
  public void testNodeStatus() throws Exception {
    NodeId nodeId = NodeId.newInstance(""host0"", 0);
    when(client.getNodeReports())
        .thenReturn(getNodeReports(3, NodeState.RUNNING, false, false, false));
    NodeCLI cli = createAndGetNodeCLI();
    int result = cli.run(new String[] { ""-status"", nodeId.toString() }",No Smells
"@Test
  public void testRefreshNodes() throws Exception {
    resourceManager.getClientRMService();
    RefreshNodesRequest request = RefreshNodesRequest
        .newInstance(DecommissionType.NORMAL);
    RefreshNodesResponse response = client.refreshNodes(request);
    assertNotNull(response);
  }",No Smells
"@Test
  public void testGetRMPrincipalHA_Configuration() throws IOException {
    Configuration conf = new Configuration();

    conf.set(YarnConfiguration.RM_ADDRESS, ""myhost"");
    conf.setBoolean(YarnConfiguration.RM_HA_ENABLED, true);

    String result = YarnClientUtils.getRmPrincipal(conf);

    assertNull(""The hostname translation did return null when the principal is ""
        + ""missing from the conf: "" + result, result);

    conf = new Configuration();

    conf.set(YarnConfiguration.RM_ADDRESS + "".rm0"", ""myhost"");
    conf.set(YarnConfiguration.RM_PRINCIPAL, ""test/_HOST@REALM"");
    conf.setBoolean(YarnConfiguration.RM_HA_ENABLED, true);
    conf.set(YarnConfiguration.RM_HA_IDS, ""rm0"");

    result = YarnClientUtils.getRmPrincipal(conf);

    assertEquals(""The hostname translation did not produce the expected ""
        + ""results: "" + result, ""test/myhost@REALM"", result);

    conf = new Configuration();

    conf.set(YarnConfiguration.RM_ADDRESS + "".rm0"", ""myhost"");
    conf.set(YarnConfiguration.RM_PRINCIPAL, ""test/_HOST@REALM"");
    conf.setBoolean(YarnConfiguration.RM_HA_ENABLED, true);

    try {
      result = YarnClientUtils.getRmPrincipal(conf);
      fail(""The hostname translation succeeded even though no RM ids were ""
          + ""set: "" + result);
    }",No Smells
"@Test
  public void testGetRMPrincipalHA_String() throws IOException {
    Configuration conf = new Configuration();

    conf.set(YarnConfiguration.RM_ADDRESS + "".rm0"", ""myhost"");
    conf.setBoolean(YarnConfiguration.RM_HA_ENABLED, true);
    conf.set(YarnConfiguration.RM_HA_IDS, ""rm0"");

    String result = YarnClientUtils.getRmPrincipal(""test/_HOST@REALM"", conf);

    assertEquals(""The hostname translation did not produce the expected ""
        + ""results: "" + result, ""test/myhost@REALM"", result);

    try {
      result = YarnClientUtils.getRmPrincipal(null, conf);
      fail(""The hostname translation succeeded even though the RM principal ""
          + ""was null: "" + result);
    }",No Smells
"@Test
  public void testRegisterNodeManagerRequest() {
    RegisterNodeManagerRequest request =
        RegisterNodeManagerRequest.newInstance(
          NodeId.newInstance(""host"", 1234), 1234, Resource.newInstance(0, 0),
          ""version"", Arrays.asList(NMContainerStatus.newInstance(
            ContainerId.newContainerId(
              ApplicationAttemptId.newInstance(
                ApplicationId.newInstance(1234L, 1), 1), 1), 0,
            ContainerState.RUNNING, Resource.newInstance(1024, 1), ""good"", -1,
            Priority.newInstance(0), 1234)), Arrays.asList(
            ApplicationId.newInstance(1234L, 1),
            ApplicationId.newInstance(1234L, 2)));

    // serialze to proto, and get request from proto
    RegisterNodeManagerRequest request1 =
        new RegisterNodeManagerRequestPBImpl(
            ((RegisterNodeManagerRequestPBImpl) request).getProto());

    // check values
    Assert.assertEquals(request1.getNMContainerStatuses().size(), request
        .getNMContainerStatuses().size());
    Assert.assertEquals(request1.getNMContainerStatuses().get(0).getContainerId(),
        request.getNMContainerStatuses().get(0).getContainerId());
    Assert.assertEquals(request1.getRunningApplications().size(), request
        .getRunningApplications().size());
    Assert.assertEquals(request1.getRunningApplications().get(0), request
        .getRunningApplications().get(0));
    Assert.assertEquals(request1.getRunningApplications().get(1), request
        .getRunningApplications().get(1));
  }",No Smells
"@Test
  public void testRoundTrip() throws Exception {
    RegisterNodeManagerResponse resp = recordFactory
    .newRecordInstance(RegisterNodeManagerResponse.class);

    byte b [] = {0,1,2,3,4,5}",No Smells
"@Test
  public void testIntegerAssignment() throws YarnException {
    float[] weights =
        new float[] {0, 0.1f, 0.2f, 0.2f, -0.1f, 0.1f, 0.2f, 0.1f, 0.1f}",Eager Test
"@Test
  public void testSubClusterExpiry() throws Exception {

    // Tests how the headroom info are used to split based on the capacity
    // each RM claims to give us.
    // Configure policy to be 100% headroom based
    getPolicyInfo().setHeadroomAlpha(1.0f);

    YarnConfiguration conf = new YarnConfiguration();
    // Set expiry to 500ms
    conf.setLong(YarnConfiguration.FEDERATION_AMRMPROXY_SUBCLUSTER_TIMEOUT,
        500);

    initializePolicy(conf);
    List<ResourceRequest> resourceRequests = createSimpleRequest();

    prepPolicyWithHeadroom(true);

    // For first time, no sub-cluster expired
    Set<SubClusterId> expiredSCList = new HashSet<>();
    Map<SubClusterId, List<ResourceRequest>> response =
        ((FederationAMRMProxyPolicy) getPolicy())
            .splitResourceRequests(resourceRequests, expiredSCList);

    // pretty print requests
    prettyPrintRequests(response);

    validateSplit(response, resourceRequests);

    /*
     * based on headroom, we expect 75 containers to got to subcluster0 (60) and
     * subcluster2 (15) according to the advertised headroom (40 and 10), no
     * containers for sublcuster1 as it advertise zero headroom, and 25 to
     * subcluster5 which has unknown headroom, and so it gets 1/4th of the load
     */
    checkExpectedAllocation(response, ""subcluster0"", 1, 60);
    checkExpectedAllocation(response, ""subcluster1"", 1, -1);
    checkExpectedAllocation(response, ""subcluster2"", 1, 15);
    checkExpectedAllocation(response, ""subcluster5"", 1, 25);
    checkTotalContainerAllocation(response, 100);

    Thread.sleep(800);

    // For the second time, sc0 and sc5 expired
    expiredSCList.add(SubClusterId.newInstance(""subcluster0""));
    expiredSCList.add(SubClusterId.newInstance(""subcluster5""));
    response = ((FederationAMRMProxyPolicy) getPolicy())
        .splitResourceRequests(resourceRequests, expiredSCList);

    // pretty print requests
    prettyPrintRequests(response);

    validateSplit(response, resourceRequests);

    checkExpectedAllocation(response, ""subcluster0"", 1, -1);
    checkExpectedAllocation(response, ""subcluster1"", 1, -1);
    checkExpectedAllocation(response, ""subcluster2"", 1, 100);
    checkExpectedAllocation(response, ""subcluster5"", 1, -1);
    checkTotalContainerAllocation(response, 100);
  }",No Smells
"@Test
  public void testGetHomeSubcluster() throws YarnException {

    ApplicationSubmissionContext applicationSubmissionContext =
        mock(ApplicationSubmissionContext.class);
    when(applicationSubmissionContext.getQueue()).thenReturn(queue1);

    // the facade only contains the fallback behavior
    Assert.assertTrue(routerFacade.globalPolicyMap.containsKey(defQueueKey)
        && routerFacade.globalPolicyMap.size() == 1);

    // when invoked it returns the expected SubClusterId.
    SubClusterId chosen =
        routerFacade.getHomeSubcluster(applicationSubmissionContext, null);
    Assert.assertTrue(subClusterIds.contains(chosen));

    // now the caching of policies must have added an entry for this queue
    Assert.assertTrue(routerFacade.globalPolicyMap.size() == 2);

    // after the facade is used the policyMap contains the expected policy type.
    Assert.assertTrue(routerFacade.globalPolicyMap
        .get(queue1) instanceof UniformRandomRouterPolicy);

    // the facade is again empty after reset
    routerFacade.reset();
    // the facade only contains the fallback behavior
    Assert.assertTrue(routerFacade.globalPolicyMap.containsKey(defQueueKey)
        && routerFacade.globalPolicyMap.size() == 1);

  }",No Smells
"@Test
  public void testAggregateMetricInit() {
    LOG.info(""Test: aggregate metrics are initialized correctly"");

    Assert.assertEquals(0,
        FederationStateStoreClientMetrics.getNumSucceededCalls());
    Assert.assertEquals(0,
        FederationStateStoreClientMetrics.getNumFailedCalls());

    LOG.info(""Test: aggregate metrics are updated correctly"");
  }",No Smells
"@Test
  public void testBasicCase() {
    ApplicationId appId = ApplicationId.newInstance(0, 0);
    String scId1 = ""subcluster1"";
    String scId2 = ""subcluster2"";

    this.registryClient.writeAMRMTokenForUAM(appId, scId1,
        new Token<AMRMTokenIdentifier>());
    this.registryClient.writeAMRMTokenForUAM(appId, scId2,
        new Token<AMRMTokenIdentifier>());
    // Duplicate entry, should overwrite
    this.registryClient.writeAMRMTokenForUAM(appId, scId1,
        new Token<AMRMTokenIdentifier>());

    Assert.assertEquals(1, this.registryClient.getAllApplications().size());
    Assert.assertEquals(2,
        this.registryClient.loadStateFromRegistry(appId).size());

    this.registryClient.removeAppFromRegistry(appId);

    Assert.assertEquals(0, this.registryClient.getAllApplications().size());
    Assert.assertEquals(0,
        this.registryClient.loadStateFromRegistry(appId).size());
  }",No Smells
"@Test
  public void testAddApplicationHomeSubCluster() throws YarnException {

    // Inserting <AppId, Home1> into FederationStateStore
    ApplicationId appId = ApplicationId.newInstance(clusterTs, numApps + 1);
    SubClusterId subClusterId1 = SubClusterId.newInstance(""Home1"");

    ApplicationHomeSubCluster appHomeSubCluster =
        ApplicationHomeSubCluster.newInstance(appId, subClusterId1);

    SubClusterId result =
        facade.addApplicationHomeSubCluster(appHomeSubCluster);

    Assert.assertEquals(facade.getApplicationHomeSubCluster(appId), result);
    Assert.assertEquals(subClusterId1, result);

    // Inserting <AppId, Home2> into FederationStateStore.
    // The application is already present.
    // FederationFacade will return Home1 as SubClusterId.
    SubClusterId subClusterId2 = SubClusterId.newInstance(""Home2"");
    appHomeSubCluster =
        ApplicationHomeSubCluster.newInstance(appId, subClusterId2);

    result = facade.addApplicationHomeSubCluster(appHomeSubCluster);

    Assert.assertEquals(facade.getApplicationHomeSubCluster(appId), result);
    Assert.assertEquals(subClusterId1, result);
  }",No Smells
"@Test
  public void testGetSubCluster() throws YarnException {
    for (int i = 0; i < numSubClusters; i++) {
      SubClusterId subClusterId =
          SubClusterId.newInstance(FederationStateStoreTestUtil.SC_PREFIX + i);
      Assert.assertEquals(stateStoreTestUtil.querySubClusterInfo(subClusterId),
          facade.getSubCluster(subClusterId));
    }",Eager Test
"@Test
  public void testGetSubClusterFlushCache() throws YarnException {
    for (int i = 0; i < numSubClusters; i++) {
      SubClusterId subClusterId =
          SubClusterId.newInstance(FederationStateStoreTestUtil.SC_PREFIX + i);
      Assert.assertEquals(stateStoreTestUtil.querySubClusterInfo(subClusterId),
          facade.getSubCluster(subClusterId, true));
    }",Eager Test
"@Test
  public void testAllocateAndReleaseContainers() throws Exception {
    int testAppId = 1;
    RegisterApplicationMasterResponse registerResponse =
        registerApplicationMaster(testAppId);
    Assert.assertNotNull(registerResponse);
    List<Container> containers = getContainersAndAssert(testAppId, 10);
    releaseContainersAndAssert(testAppId, containers);
    finishApplicationMaster(testAppId, FinalApplicationStatus.SUCCEEDED);
  }",No Smells
"@Test
  public void testAllocateAndReleaseContainersForMultipleAM()
      throws Exception {
    int numberOfApps = 5;
    for (int testAppId = 0; testAppId < numberOfApps; testAppId++) {
      RegisterApplicationMasterResponse registerResponse =
          registerApplicationMaster(testAppId);
      Assert.assertNotNull(registerResponse);
      List<Container> containers = getContainersAndAssert(testAppId, 10);
      releaseContainersAndAssert(testAppId, containers);
    }",Eager Test
"@Test
  public void testMultipleAttemptsSameNode() throws Exception {

    String user = ""hadoop"";
    ApplicationId appId = ApplicationId.newInstance(1, 1);
    ApplicationAttemptId applicationAttemptId;

    // First Attempt

    RegisterApplicationMasterResponse response1 =
        registerApplicationMaster(appId.getId());
    Assert.assertNotNull(response1);

    AllocateResponse allocateResponse = allocate(appId.getId());
    Assert.assertNotNull(allocateResponse);

    // Second Attempt

    applicationAttemptId = ApplicationAttemptId.newInstance(appId, 2);
    getAMRMProxyService().initializePipeline(applicationAttemptId, user,
        new Token<>(), null, null, false, null);

    RequestInterceptorChainWrapper chain2 =
        getAMRMProxyService().getPipelines().get(appId);
    Assert.assertEquals(applicationAttemptId, chain2.getApplicationAttemptId());

    allocateResponse = allocate(appId.getId());
    Assert.assertNotNull(allocateResponse);
  }",No Smells
"@Test
  public void testExceptionCases() {
    testExceptionCases(false);
    testExceptionCases(true);
  }",No Smells
"@Test
  public void testCorrectness() throws Exception {
    checkSame();

    theirs.update(104);
    ours.update(104);
    checkSame();

    checkOnBytes(new byte[] {40, 60, 97, -70}",No Smells
"@Test
  public void parsingProcNetFile() throws IOException {
    long numBytesReadIntf1 = 2097172468L;
    long numBytesWrittenIntf1 = 1355620114L;
    long numBytesReadIntf2 = 1097172460L;
    long numBytesWrittenIntf2 = 1055620110L;
    File tempFile = new File(FAKE_NETFILE);
    tempFile.deleteOnExit();
    FileWriter fWriter = new FileWriter(FAKE_NETFILE);
    fWriter.write(String.format(NETINFO_FORMAT,
                            numBytesReadIntf1, numBytesWrittenIntf1,
                            numBytesReadIntf2, numBytesWrittenIntf2));
    fWriter.close();
    assertEquals(plugin.getNetworkBytesRead(), numBytesReadIntf1 + numBytesReadIntf2);
    assertEquals(plugin.getNetworkBytesWritten(), numBytesWrittenIntf1 + numBytesWrittenIntf2);
  }",Eager Test
"@Test
  public void parsingProcStatAndCpuFile() throws IOException {
    // Write fake /proc/cpuinfo file.
    long numProcessors = 8;
    long cpuFrequencyKHz = 2392781;
    String fileContent = """";
    for (int i = 0; i < numProcessors; i++) {
      fileContent +=
          String.format(CPUINFO_FORMAT, i, cpuFrequencyKHz / 1000D, 0, 0)
              + ""\n"";
    }",Eager Test
"@Test
  public void testStartTimelineClientWithErrors()
      throws Exception {
    // If timeline client failed to init with a NoClassDefFoundError
    // it should be wrapped with an informative error message
    testCreateTimelineClientWithError(
        1.5f,
        true,
        false,
        new NoClassDefFoundError(""Mock a NoClassDefFoundError""),
        new CreateTimelineClientErrorVerifier(1) {
          @Override
          public void verifyError(Throwable e) {
            Assert.assertTrue(e instanceof NoClassDefFoundError);
            Assert.assertTrue(e.getMessage() != null &&
                e.getMessage().contains(
                    YarnConfiguration.TIMELINE_SERVICE_ENABLED));
          }",No Smells
"@Test
  public void testAsyncAPIPollTimeout() {
    testAsyncAPIPollTimeoutHelper(null, false);
    testAsyncAPIPollTimeoutHelper(0L, true);
    testAsyncAPIPollTimeoutHelper(1L, true);
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testAppCLIUsageInfo() throws Exception {
    verifyUsageInfo(new ApplicationCLI());
  }",No Smells
"@Test
  public void testSplitBasedOnHeadroom() throws Exception {

    // Tests how the headroom info are used to split based on the capacity
    // each RM claims to give us.
    // Configure policy to be 100% headroom based
    getPolicyInfo().setHeadroomAlpha(1.0f);

    initializePolicy();
    List<ResourceRequest> resourceRequests = createSimpleRequest();

    prepPolicyWithHeadroom(true);

    Map<SubClusterId, List<ResourceRequest>> response =
        ((FederationAMRMProxyPolicy) getPolicy()).splitResourceRequests(
            resourceRequests, new HashSet<SubClusterId>());

    // pretty print requests
    LOG.info(""Initial headroom"");
    prettyPrintRequests(response);

    validateSplit(response, resourceRequests);

    /*
     * based on headroom, we expect 75 containers to got to subcluster0 (60) and
     * subcluster2 (15) according to the advertised headroom (40 and 10), no
     * containers for sublcuster1 as it advertise zero headroom, and 25 to
     * subcluster5 which has unknown headroom, and so it gets 1/4th of the load
     */
    checkExpectedAllocation(response, ""subcluster0"", 1, 60);
    checkExpectedAllocation(response, ""subcluster1"", 1, -1);
    checkExpectedAllocation(response, ""subcluster2"", 1, 15);
    checkExpectedAllocation(response, ""subcluster5"", 1, 25);
    checkTotalContainerAllocation(response, 100);

    // notify a change in headroom and try again
    AllocateResponse ar = getAllocateResponseWithTargetHeadroom(40);
    ((FederationAMRMProxyPolicy) getPolicy())
        .notifyOfResponse(SubClusterId.newInstance(""subcluster2""), ar);
    response = ((FederationAMRMProxyPolicy) getPolicy())
        .splitResourceRequests(resourceRequests, new HashSet<SubClusterId>());

    LOG.info(""After headroom update"");
    prettyPrintRequests(response);
    validateSplit(response, resourceRequests);

    /*
     * we simulated a change in headroom for subcluster2, which will now have
     * the same headroom of subcluster0, so each 37.5, note that the odd one
     * will be assigned to either one of the two subclusters
     */
    checkExpectedAllocation(response, ""subcluster0"", 1, 37);
    checkExpectedAllocation(response, ""subcluster1"", 1, -1);
    checkExpectedAllocation(response, ""subcluster2"", 1, 37);
    checkExpectedAllocation(response, ""subcluster5"", 1, 25);
    checkTotalContainerAllocation(response, 100);
  }",Eager Test
"@Test
  public void testNormalCase() throws IOException {
    ApplicationId appId = ApplicationId.newInstance(1, 1);
    ApplicationAttemptId attemptId = ApplicationAttemptId.newInstance(appId, 1);

    Token<AMRMTokenIdentifier> localToken =
        secretManager.createAndGetAMRMToken(attemptId);

    AMRMTokenIdentifier identifier = secretManager.createIdentifier();
    identifier.readFields(new DataInputStream(
        new ByteArrayInputStream(localToken.getIdentifier())));

    secretManager.retrievePassword(identifier);

    secretManager.applicationMasterFinished(attemptId);

    try {
      secretManager.retrievePassword(identifier);
      Assert.fail(""Expect InvalidToken exception"");
    }",Eager Test
"@Test
  public void testMultipleSubClusters() throws Exception {
    UserGroupInformation ugi =
        interceptor.getUGIWithToken(interceptor.getAttemptId());
    ugi.doAs((PrivilegedExceptionAction<Object>) () -> {
      // Register the application
      RegisterApplicationMasterRequest registerReq =
          Records.newRecord(RegisterApplicationMasterRequest.class);
      registerReq.setHost(Integer.toString(testAppId));
      registerReq.setRpcPort(0);
      registerReq.setTrackingUrl("""");

      RegisterApplicationMasterResponse registerResponse =
          interceptor.registerApplicationMaster(registerReq);
      Assert.assertNotNull(registerResponse);
      lastResponseId = 0;

      Assert.assertEquals(0, interceptor.getUnmanagedAMPoolSize());

      // Allocate the first batch of containers, with sc1 and sc2 active
      registerSubCluster(SubClusterId.newInstance(""SC-1""));
      registerSubCluster(SubClusterId.newInstance(""SC-2""));

      int numberOfContainers = 3;
      List<Container> containers =
          getContainersAndAssert(numberOfContainers, numberOfContainers * 2);
      Assert.assertEquals(2, interceptor.getUnmanagedAMPoolSize());

      // Allocate the second batch of containers, with sc1 and sc3 active
      deRegisterSubCluster(SubClusterId.newInstance(""SC-2""));
      registerSubCluster(SubClusterId.newInstance(""SC-3""));

      numberOfContainers = 1;
      containers.addAll(
          getContainersAndAssert(numberOfContainers, numberOfContainers * 2));
      Assert.assertEquals(3, interceptor.getUnmanagedAMPoolSize());

      // Allocate the third batch of containers with only in home sub-cluster
      // active
      deRegisterSubCluster(SubClusterId.newInstance(""SC-1""));
      deRegisterSubCluster(SubClusterId.newInstance(""SC-3""));
      registerSubCluster(SubClusterId.newInstance(HOME_SC_ID));

      numberOfContainers = 2;
      containers.addAll(
          getContainersAndAssert(numberOfContainers, numberOfContainers));
      Assert.assertEquals(3, interceptor.getUnmanagedAMPoolSize());

      // Release all containers
      releaseContainersAndAssert(containers);

      // Finish the application
      FinishApplicationMasterRequest finishReq =
          Records.newRecord(FinishApplicationMasterRequest.class);
      finishReq.setDiagnostics("""");
      finishReq.setTrackingUrl("""");
      finishReq.setFinalApplicationStatus(FinalApplicationStatus.SUCCEEDED);

      FinishApplicationMasterResponse finishResponse =
          interceptor.finishApplicationMaster(finishReq);
      Assert.assertNotNull(finishResponse);
      Assert.assertTrue(finishResponse.getIsUnregistered());

      return null;
    }",Eager Test
"@Test
  public void testConvertProtoToDeletionTask() throws Exception {
    DeletionService deletionService = mock(DeletionService.class);
    DeletionServiceDeleteTaskProto.Builder protoBuilder =
        DeletionServiceDeleteTaskProto.newBuilder();
    int id = 0;
    protoBuilder.setId(id);
    DeletionServiceDeleteTaskProto proto = protoBuilder.build();
    DeletionTask deletionTask =
        NMProtoUtils.convertProtoToDeletionTask(proto, deletionService);
    assertEquals(DeletionTaskType.FILE, deletionTask.getDeletionTaskType());
    assertEquals(id, deletionTask.getTaskId());
  }",Eager Test
"@Test
  public void testConvertProtoToDeletionTaskRecoveryInfo() throws Exception {
    long delTime = System.currentTimeMillis();
    List<Integer> successorTaskIds = Arrays.asList(1);
    DeletionTask deletionTask = mock(DeletionTask.class);
    DeletionTaskRecoveryInfo info =
        new DeletionTaskRecoveryInfo(deletionTask, successorTaskIds, delTime);
    assertEquals(deletionTask, info.getTask());
    assertEquals(successorTaskIds, info.getSuccessorTaskIds());
    assertEquals(delTime, info.getDeletionTimestamp());
  }",Eager Test
"@Test
  public void testConvertProtoToDockerContainerDeletionTask() throws Exception {
    DeletionService deletionService = mock(DeletionService.class);
    int id = 0;
    String user = ""user"";
    String dockerContainerId = ""container_e123_12321231_00001"";
    DeletionServiceDeleteTaskProto.Builder protoBuilder =
        DeletionServiceDeleteTaskProto.newBuilder();
    protoBuilder
        .setId(id)
        .setUser(user)
        .setDockerContainerId(dockerContainerId);
    DeletionServiceDeleteTaskProto proto = protoBuilder.build();
    DeletionTask deletionTask =
        NMProtoUtils.convertProtoToDockerContainerDeletionTask(proto,
            deletionService, id);
    assertEquals(DeletionTaskType.DOCKER_CONTAINER.name(),
        deletionTask.getDeletionTaskType().name());
    assertEquals(id, deletionTask.getTaskId());
    assertEquals(dockerContainerId,
        ((DockerContainerDeletionTask) deletionTask).getContainerId());
  }",Eager Test
"@Test
  public void testApplicationInit2() {
    WrappedApplication wa = null;
    try {
      wa = new WrappedApplication(2, 314159265358979L, ""yak"", 3);
      wa.initApplication();
      wa.initContainer(0);
      assertEquals(ApplicationState.INITING, wa.app.getApplicationState());
      assertEquals(1, wa.app.getContainers().size());

      wa.applicationInited();
      assertEquals(ApplicationState.RUNNING, wa.app.getApplicationState());
      verify(wa.containerBus).handle(
          argThat(new ContainerInitMatcher(wa.containers.get(0)
              .getContainerId())));

      wa.initContainer(1);
      wa.initContainer(2);
      assertEquals(ApplicationState.RUNNING, wa.app.getApplicationState());
      assertEquals(3, wa.app.getContainers().size());

      for (int i = 1; i < wa.containers.size(); i++) {
        verify(wa.containerBus).handle(
            argThat(new ContainerInitMatcher(wa.containers.get(i)
                .getContainerId())));
      }",Eager Test + Mystery Guest
"@Test
  public void testApplicationOnAppLogHandlingInitedEvtShouldStoreLogInitedTime()
      throws IOException {
    WrappedApplication wa = new WrappedApplication(5,  314159265358979L,
        ""yak"", 0);
    wa.initApplication();

    ArgumentCaptor<ContainerManagerApplicationProto> applicationProto =
        ArgumentCaptor.forClass(ContainerManagerApplicationProto.class);

    final long timestamp = wa.applicationLogInited();

    verify(wa.stateStoreService).storeApplication(any(ApplicationId.class),
        applicationProto.capture());

    assertEquals(applicationProto.getValue().getAppLogAggregationInitedTime()
        , timestamp);
  }",Eager Test
"@Test
  public void testLocalizationRequest() throws Exception {
    WrappedContainer wc = null;
    try {
      wc = new WrappedContainer(7, 314159265358979L, 4344, ""yak"");
      assertEquals(ContainerState.NEW, wc.c.getContainerState());
      wc.initContainer();

      // Verify request for public/private resources to localizer
      ResourcesRequestedMatcher matchesReq =
          new ResourcesRequestedMatcher(wc.localResources, EnumSet.of(
              LocalResourceVisibility.PUBLIC, LocalResourceVisibility.PRIVATE,
              LocalResourceVisibility.APPLICATION));
      verify(wc.localizerBus).handle(argThat(matchesReq));
      assertEquals(ContainerState.LOCALIZING, wc.c.getContainerState());
    }",Eager Test
"@Test
  public void testGetSubDir() throws Exception {
    assertEquals(SUBDIR, deletionTask.getSubDir());
  }",No Smells
"@Test
  public void testErrorLogOnContainerExit() throws Exception {
    verifyTailErrorLogOnContainerExit(new Configuration(), ""/stderr"", false);
  }",No Smells
"@Test
  public void testSpecialCharSymlinks() throws IOException  {

    File shellFile = null;
    File tempFile = null;
    String badSymlink = Shell.WINDOWS ? ""foo@zz_#!-+bar.cmd"" :
      ""-foo@zz%_#*&!-+= bar()"";
    File symLinkFile = null;

    try {
      shellFile = Shell.appendScriptExtension(tmpDir, ""hello"");
      tempFile = Shell.appendScriptExtension(tmpDir, ""temp"");
      String timeoutCommand = Shell.WINDOWS ? ""@echo \""hello\"""" :
        ""echo \""hello\"""";
      PrintWriter writer = new PrintWriter(new FileOutputStream(shellFile));
      FileUtil.setExecutable(shellFile, true);
      writer.println(timeoutCommand);
      writer.close();

      Map<Path, List<String>> resources =
          new HashMap<Path, List<String>>();
      Path path = new Path(shellFile.getAbsolutePath());
      resources.put(path, Arrays.asList(badSymlink));

      FileOutputStream fos = new FileOutputStream(tempFile);

      Map<String, String> env = new HashMap<String, String>();
      List<String> commands = new ArrayList<String>();
      if (Shell.WINDOWS) {
        commands.add(""cmd"");
        commands.add(""/c"");
        commands.add(""\"""" + badSymlink + ""\"""");
      }",Eager Test + Mystery Guest
"@Test
  public void testExecutorPath() {
    String containerExePath = PrivilegedOperationExecutor
        .getContainerExecutorExecutablePath(nullConf);

    //In case HADOOP_YARN_HOME isn't set, CWD is used. If conf is null or
    //NM_LINUX_CONTAINER_EXECUTOR_PATH is not set, then a defaultPath is
    //constructed.
    String yarnHomeEnvVar = System.getenv(""HADOOP_YARN_HOME"");
    String yarnHome = yarnHomeEnvVar != null ? yarnHomeEnvVar
        : new File("""").getAbsolutePath();
    String expectedPath = yarnHome + ""/bin/container-executor"";

    Assert.assertEquals(expectedPath, containerExePath);

    containerExePath = PrivilegedOperationExecutor
        .getContainerExecutorExecutablePath(emptyConf);
    Assert.assertEquals(expectedPath, containerExePath);

    //if NM_LINUX_CONTAINER_EXECUTOR_PATH is set, this must be returned
    expectedPath = customExecutorPath;
    containerExePath = PrivilegedOperationExecutor
        .getContainerExecutorExecutablePath(confWithExecutorPath);
    Assert.assertEquals(expectedPath, containerExePath);
  }",Eager Test + Mystery Guest
"@Test
  public void testAllocateNumaNodeWithRoundRobinFashionAssignment()
      throws Exception {
    NumaResourceAllocation nodeInfo1 = numaResourceAllocator
        .allocateNumaNodes(getContainer(
            ContainerId.fromString(""container_1481156246874_0001_01_000001""),
            Resource.newInstance(2048, 2)));
    Assert.assertEquals(""0"", String.join("","", nodeInfo1.getMemNodes()));
    Assert.assertEquals(""0"", String.join("","", nodeInfo1.getCpuNodes()));

    NumaResourceAllocation nodeInfo2 = numaResourceAllocator
        .allocateNumaNodes(getContainer(
            ContainerId.fromString(""container_1481156246874_0001_01_000002""),
            Resource.newInstance(2048, 2)));
    Assert.assertEquals(""1"", String.join("","", nodeInfo2.getMemNodes()));
    Assert.assertEquals(""1"", String.join("","", nodeInfo2.getCpuNodes()));

    NumaResourceAllocation nodeInfo3 = numaResourceAllocator
        .allocateNumaNodes(getContainer(
            ContainerId.fromString(""container_1481156246874_0001_01_000003""),
            Resource.newInstance(2048, 2)));
    Assert.assertEquals(""0"", String.join("","", nodeInfo3.getMemNodes()));
    Assert.assertEquals(""0"", String.join("","", nodeInfo3.getCpuNodes()));

    NumaResourceAllocation nodeInfo4 = numaResourceAllocator
        .allocateNumaNodes(getContainer(
            ContainerId.fromString(""container_1481156246874_0001_01_000003""),
            Resource.newInstance(2048, 2)));
    Assert.assertEquals(""1"", String.join("","", nodeInfo4.getMemNodes()));
    Assert.assertEquals(""1"", String.join("","", nodeInfo4.getCpuNodes()));
  }",Eager Test
"@Test
  public void testReadNumaTopologyFromCmdOutput() throws Exception {
    conf.setBoolean(YarnConfiguration.NM_NUMA_AWARENESS_READ_TOPOLOGY, true);
    String cmdOutput = ""available: 2 nodes (0-1)\n\t""
        + ""node 0 cpus: 0 2 4 6\n\t""
        + ""node 0 size: 73717 MB\n\t""
        + ""node 0 free: 17272 MB\n\t""
        + ""node 1 cpus: 1 3 5 7\n\t""
        + ""node 1 size: 73727 MB\n\t""
        + ""node 1 free: 10699 MB\n\t""
        + ""node distances:\n\t""
        + ""node 0 1\n\t""
        + ""0: 10 20\n\t""
        + ""1: 20 10"";
    numaResourceAllocator = new NumaResourceAllocator(mock(Context.class)) {
      @Override
      public String executeNGetCmdOutput(Configuration config)
          throws YarnRuntimeException {
        return cmdOutput;
      }",Eager Test
"@Test
  public void testRecoverNumaResource() throws Exception {
    @SuppressWarnings(""unchecked"")
    ConcurrentHashMap<ContainerId, Container> mockContainers = mock(
        ConcurrentHashMap.class);
    Context mockContext = mock(Context.class);
    Container mockContainer = mock(Container.class);
    ResourceMappings value = new ResourceMappings();
    AssignedResources assignedResources = new AssignedResources();
    assignedResources.updateAssignedResources(
        Arrays.asList(new NumaResourceAllocation(""0"", 70000, ""0"", 4)));
    value.addAssignedResources(""numa"", assignedResources);
    when(mockContainer.getResourceMappings()).thenReturn(value);
    when(mockContainers.get(any())).thenReturn(mockContainer);
    when(mockContext.getContainers()).thenReturn(mockContainers);
    NMStateStoreService mock = mock(NMStateStoreService.class);
    when(mockContext.getNMStateStore()).thenReturn(mock);
    numaResourceAllocator = new NumaResourceAllocator(mockContext);
    numaResourceAllocator.init(conf);
    // Recover the resources
    numaResourceAllocator.recoverNumaResource(
        ContainerId.fromString(""container_1481156246874_0001_01_000001""));

    // Request resources based on the availability
    NumaResourceAllocation numaNode = numaResourceAllocator
        .allocateNumaNodes(getContainer(
            ContainerId.fromString(""container_1481156246874_0001_01_000005""),
            Resource.newInstance(2048, 1)));
    assertEquals(""1"", String.join("","", numaNode.getMemNodes()));
    assertEquals(""1"", String.join("","", numaNode.getCpuNodes()));

    // Request resources more than the available
    numaNode = numaResourceAllocator.allocateNumaNodes(getContainer(
        ContainerId.fromString(""container_1481156246874_0001_01_000006""),
        Resource.newInstance(2048, 4)));
    assertNull(numaNode);
  }",Eager Test
"@Test
  public void testReleaseNumaResourcess() throws Exception {
    NumaResourceAllocation nodeInfo = numaResourceAllocator
        .allocateNumaNodes(getContainer(
            ContainerId.fromString(""container_1481156246874_0001_01_000001""),
            Resource.newInstance(2048, 8)));
    Assert.assertEquals(""0"", String.join("","", nodeInfo.getMemNodes()));
    Assert.assertEquals(""0,1"", String.join("","", nodeInfo.getCpuNodes()));

    // Request the resource when all cpu nodes occupied
    nodeInfo = numaResourceAllocator.allocateNumaNodes(getContainer(
        ContainerId.fromString(""container_1481156246874_0001_01_000002""),
        Resource.newInstance(2048, 4)));
    Assert.assertNull(""Should not assign numa nodes when there""
        + "" are no sufficient cpu resources available."", nodeInfo);

    // Release the resources
    numaResourceAllocator.releaseNumaResource(
        ContainerId.fromString(""container_1481156246874_0001_01_000001""));
    // Request the resources
    nodeInfo = numaResourceAllocator.allocateNumaNodes(getContainer(
        ContainerId.fromString(""container_1481156246874_0001_01_000003""),
        Resource.newInstance(1024, 2)));
    Assert.assertEquals(""0"", String.join("","", nodeInfo.getMemNodes()));
    Assert.assertEquals(""0"", String.join("","", nodeInfo.getCpuNodes()));
  }",Eager Test
"@Test
  public void testReacquireContainer() throws Exception {
    @SuppressWarnings(""unchecked"")
    ConcurrentHashMap<ContainerId, Container> mockContainers = mock(
        ConcurrentHashMap.class);
    Context mockContext = mock(Context.class);
    NMStateStoreService mock = mock(NMStateStoreService.class);
    when(mockContext.getNMStateStore()).thenReturn(mock);
    ResourceMappings resourceMappings = new ResourceMappings();
    AssignedResources assignedRscs = new AssignedResources();
    NumaResourceAllocation numaResourceAllocation = new NumaResourceAllocation(
        ""0"", 70000, ""0"", 4);
    assignedRscs.updateAssignedResources(Arrays.asList(numaResourceAllocation));
    resourceMappings.addAssignedResources(""numa"", assignedRscs);
    when(mockContainer.getResourceMappings()).thenReturn(resourceMappings);
    when(mockContainers.get(any())).thenReturn(mockContainer);
    when(mockContext.getContainers()).thenReturn(mockContainers);
    numaResourceHandler = new NumaResourceHandlerImpl(conf, mockContext);
    numaResourceHandler.bootstrap(conf);
    // recovered numa resources should be added to the used resources and
    // remaining will be available for further allocation.
    numaResourceHandler.reacquireContainer(
        ContainerId.fromString(""container_1481156246874_0001_01_000001""));

    testAllocateNumaResource(""container_1481156246874_0001_01_000005"",
        Resource.newInstance(2048, 1), ""1"", ""1"");
    when(mockContainer.getContainerId()).thenReturn(
        ContainerId.fromString(""container_1481156246874_0001_01_000005""));
    when(mockContainer.getResource()).thenReturn(Resource.newInstance(2048, 4));
    List<PrivilegedOperation> preStart = numaResourceHandler
        .preStart(mockContainer);
    assertNull(preStart);
  }",Eager Test
"@Test
  public void testPostComplete() throws Exception {
    String id = ""container_01_01"";
    ContainerId mockContainerId = mock(ContainerId.class);
    when(mockContainerId.toString()).thenReturn(id);
    Assert.assertNull(cGroupsBlkioResourceHandlerImpl
        .postComplete(mockContainerId));
    verify(mockCGroupsHandler, times(1)).deleteCGroup(
        CGroupsHandler.CGroupController.BLKIO, id);
  }",No Smells
"@Test
  public void testPreStart() throws Exception {
    String id = ""container_01_01"";
    String path = ""test-path/"" + id;
    ContainerId mockContainerId = mock(ContainerId.class);
    when(mockContainerId.toString()).thenReturn(id);
    Container mockContainer = mock(Container.class);
    when(mockContainer.getContainerId()).thenReturn(mockContainerId);
    when(mockCGroupsHandler
        .getPathForCGroupTasks(CGroupsHandler.CGroupController.CPU, id))
        .thenReturn(path);
    when(mockContainer.getResource()).thenReturn(Resource.newInstance(1024, 2));

    List<PrivilegedOperation> ret =
        cGroupsCpuResourceHandler.preStart(mockContainer);
    verify(mockCGroupsHandler, times(1))
        .createCGroup(CGroupsHandler.CGroupController.CPU, id);
    verify(mockCGroupsHandler, times(1))
        .updateCGroupParam(CGroupsHandler.CGroupController.CPU, id,
            CGroupsHandler.CGROUP_CPU_SHARES, String
                .valueOf(CGroupsCpuResourceHandlerImpl.CPU_DEFAULT_WEIGHT * 2));

    // don't set quota or period
    verify(mockCGroupsHandler, never())
        .updateCGroupParam(eq(CGroupsHandler.CGroupController.CPU), eq(id),
            eq(CGroupsHandler.CGROUP_CPU_PERIOD_US), anyString());
    verify(mockCGroupsHandler, never())
        .updateCGroupParam(eq(CGroupsHandler.CGroupController.CPU), eq(id),
            eq(CGroupsHandler.CGROUP_CPU_QUOTA_US), anyString());
    Assert.assertNotNull(ret);
    Assert.assertEquals(1, ret.size());
    PrivilegedOperation op = ret.get(0);
    Assert.assertEquals(PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,
        op.getOperationType());
    List<String> args = op.getArguments();
    Assert.assertEquals(1, args.size());
    Assert.assertEquals(PrivilegedOperation.CGROUP_ARG_PREFIX + path,
        args.get(0));
  }",Eager Test + Mystery Guest
"@Test
  public void testPreStartRestrictedContainers() throws Exception {
    String id = ""container_01_01"";
    String path = ""test-path/"" + id;
    int defaultVCores = 8;
    Configuration conf = new YarnConfiguration();
    conf.setBoolean(
        YarnConfiguration.NM_LINUX_CONTAINER_CGROUPS_STRICT_RESOURCE_USAGE,
        true);
    int cpuPerc = 75;
    conf.setInt(YarnConfiguration.NM_RESOURCE_PERCENTAGE_PHYSICAL_CPU_LIMIT,
        cpuPerc);
    cGroupsCpuResourceHandler.bootstrap(plugin, conf);
    InOrder cpuLimitOrder = inOrder(mockCGroupsHandler);
    cpuLimitOrder.verify(mockCGroupsHandler, times(1))
        .updateCGroupParam(CGroupsHandler.CGroupController.CPU, """",
            CGroupsHandler.CGROUP_CPU_PERIOD_US, String.valueOf(""333333""));
    cpuLimitOrder.verify(mockCGroupsHandler, times(1))
        .updateCGroupParam(CGroupsHandler.CGroupController.CPU, """",
            CGroupsHandler.CGROUP_CPU_QUOTA_US,
            String.valueOf(CGroupsCpuResourceHandlerImpl.MAX_QUOTA_US));
    float yarnCores = (cpuPerc * numProcessors) / 100;
    int[] containerVCores = { 2, 4 }",Eager Test + Mystery Guest
"@Test
  public void testPreMountedControllerEmpty() throws Exception {
    testPreMountedControllerInitialization("""");
  }",Eager Test
"@Test
  public void testOpportunistic() throws Exception {
    Configuration conf = new YarnConfiguration();
    conf.setBoolean(YarnConfiguration.NM_PMEM_CHECK_ENABLED, false);
    conf.setBoolean(YarnConfiguration.NM_VMEM_CHECK_ENABLED, false);

    cGroupsMemoryResourceHandler.bootstrap(conf);
    ContainerTokenIdentifier tokenId = mock(ContainerTokenIdentifier.class);
    when(tokenId.getExecutionType()).thenReturn(ExecutionType.OPPORTUNISTIC);
    Container container = mock(Container.class);
    String id = ""container_01_01"";
    ContainerId mockContainerId = mock(ContainerId.class);
    when(mockContainerId.toString()).thenReturn(id);
    when(container.getContainerId()).thenReturn(mockContainerId);
    when(container.getContainerTokenIdentifier()).thenReturn(tokenId);
    when(container.getResource()).thenReturn(Resource.newInstance(1024, 2));
    cGroupsMemoryResourceHandler.preStart(container);
    verify(mockCGroupsHandler, times(1))
        .updateCGroupParam(CGroupsHandler.CGroupController.MEMORY, id,
            CGroupsHandler.CGROUP_PARAM_MEMORY_SOFT_LIMIT_BYTES, ""0M"");
    verify(mockCGroupsHandler, times(1))
        .updateCGroupParam(CGroupsHandler.CGroupController.MEMORY, id,
            CGroupsHandler.CGROUP_PARAM_MEMORY_SWAPPINESS, ""100"");
    verify(mockCGroupsHandler, times(1))
        .updateCGroupParam(CGroupsHandler.CGroupController.MEMORY, id,
            CGroupsHandler.CGROUP_PARAM_MEMORY_HARD_LIMIT_BYTES, ""1024M"");
  }",Eager Test
"@Test
  public void testCGgroupNotFound() throws Exception {
    writeToFile(""proc/41/cgroup"",
        ""7:devices:/yarn/container_1"",
        ""6:cpuacct,cpu:/yarn/container_1"",
        ""5:pids:/yarn/container_1"",
        ""4:memory:/yarn/container_1""
    );

    CGroupsResourceCalculator calculator = createCalculator();
    calculator.updateProcessTree();
    assertEquals(-1, calculator.getCumulativeCpuTime());
  }",Eager Test + Mystery Guest + Resource Optimism
"@Test
  public void testKillAllContainersUponOOM() throws Exception {
    int currentContainerId = 0;

    ConcurrentHashMap<ContainerId, Container> containers =
        new ConcurrentHashMap<>();
    Container c1 = createContainer(currentContainerId++, false, 1, true);
    containers.put(c1.getContainerId(), c1);
    Container c2 = createContainer(currentContainerId++, false, 2, true);
    containers.put(c2.getContainerId(), c2);
    Container c3 = createContainer(currentContainerId++, true, 1, true);
    containers.put(c3.getContainerId(), c3);

    ContainerExecutor ex = createContainerExecutor(containers);
    Context context = mock(Context.class);
    when(context.getContainers()).thenReturn(containers);
    when(context.getContainerExecutor()).thenReturn(ex);

    CGroupsHandler cGroupsHandler = mock(CGroupsHandler.class);
    when(cGroupsHandler.getCGroupParam(
        CGroupsHandler.CGroupController.MEMORY,
        """",
        CGROUP_PARAM_MEMORY_OOM_CONTROL))
        .thenReturn(""under_oom 1"")
        .thenReturn(""under_oom 1"")
        .thenReturn(""under_oom 1"")
        .thenReturn(""under_oom 0"");
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c1.getContainerId().toString(), CGROUP_PROCS_FILE))
        .thenReturn(""1234"").thenReturn("""");
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c1.getContainerId().toString(), CGROUP_PARAM_MEMORY_USAGE_BYTES))
        .thenReturn(getMB(9));
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c1.getContainerId().toString(), CGROUP_PARAM_MEMORY_MEMSW_USAGE_BYTES))
        .thenReturn(getMB(9));
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c2.getContainerId().toString(), CGROUP_PROCS_FILE))
        .thenReturn(""1235"").thenReturn("""");
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c2.getContainerId().toString(), CGROUP_PARAM_MEMORY_USAGE_BYTES))
        .thenReturn(getMB(9));
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c2.getContainerId().toString(), CGROUP_PARAM_MEMORY_MEMSW_USAGE_BYTES))
        .thenReturn(getMB(9));
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c3.getContainerId().toString(), CGROUP_PROCS_FILE))
        .thenReturn(""1236"").thenReturn("""");
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c3.getContainerId().toString(), CGROUP_PARAM_MEMORY_USAGE_BYTES))
        .thenReturn(getMB(9));
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c3.getContainerId().toString(), CGROUP_PARAM_MEMORY_MEMSW_USAGE_BYTES))
        .thenReturn(getMB(9));

    DefaultOOMHandler handler =
        new DefaultOOMHandler(context, false) {
          @Override
          protected CGroupsHandler getCGroupsHandler() {
            return cGroupsHandler;
          }",Eager Test
"@Test
  public void testKillOneOverLimitOpportunisticContainerUponOOM()
      throws Exception {
    ConcurrentHashMap<ContainerId, Container> containers =
        new ConcurrentHashMap<>();
    int currentContainerId = 0;
    Container c1 = createContainer(currentContainerId++, false, 2, true);
    containers.put(c1.getContainerId(), c1);
    Container c2 = createContainer(currentContainerId++, false, 1, true);
    containers.put(c2.getContainerId(), c2);
    Container c3 = createContainer(currentContainerId++, true, 1, true);
    containers.put(c3.getContainerId(), c3);

    ContainerExecutor ex = createContainerExecutor(containers);
    Context context = mock(Context.class);
    when(context.getContainers()).thenReturn(containers);
    when(context.getContainerExecutor()).thenReturn(ex);

    CGroupsHandler cGroupsHandler = mock(CGroupsHandler.class);
    when(cGroupsHandler.getCGroupParam(
        CGroupsHandler.CGroupController.MEMORY,
        """",
        CGROUP_PARAM_MEMORY_OOM_CONTROL))
        .thenReturn(""under_oom 1"")
        .thenReturn(""under_oom 0"");
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c1.getContainerId().toString(), CGROUP_PROCS_FILE))
        .thenReturn(""1234"").thenReturn("""");
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c1.getContainerId().toString(), CGROUP_PARAM_MEMORY_USAGE_BYTES))
        .thenReturn(getMB(9));
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c1.getContainerId().toString(), CGROUP_PARAM_MEMORY_MEMSW_USAGE_BYTES))
        .thenReturn(getMB(9));

    // container c2 is out of its limit
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c2.getContainerId().toString(), CGROUP_PROCS_FILE))
        .thenReturn(""1235"").thenReturn("""");
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c2.getContainerId().toString(), CGROUP_PARAM_MEMORY_USAGE_BYTES))
        .thenReturn(getMB(11));
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c2.getContainerId().toString(), CGROUP_PARAM_MEMORY_MEMSW_USAGE_BYTES))
        .thenReturn(getMB(11));

    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c3.getContainerId().toString(), CGROUP_PROCS_FILE))
        .thenReturn(""1236"").thenReturn("""");
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c3.getContainerId().toString(), CGROUP_PARAM_MEMORY_USAGE_BYTES))
        .thenReturn(getMB(9));
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c3.getContainerId().toString(), CGROUP_PARAM_MEMORY_MEMSW_USAGE_BYTES))
        .thenReturn(getMB(9));

    DefaultOOMHandler handler =
        new DefaultOOMHandler(context, false) {
          @Override
          protected CGroupsHandler getCGroupsHandler() {
            return cGroupsHandler;
          }",Eager Test
"@Test
  public void testNoGuaranteedContainerOverLimitOOM() throws Exception {
    ConcurrentHashMap<ContainerId, Container> containers =
        new ConcurrentHashMap<>();
    Container c1 = createContainer(1, true, 1L, true);
    containers.put(c1.getContainerId(), c1);
    Container c2 = createContainer(2, true, 2L, true);
    containers.put(c2.getContainerId(), c2);

    ContainerExecutor ex = createContainerExecutor(containers);
    Context context = mock(Context.class);
    when(context.getContainers()).thenReturn(containers);
    when(context.getContainerExecutor()).thenReturn(ex);

    CGroupsHandler cGroupsHandler = mock(CGroupsHandler.class);
    when(cGroupsHandler.getCGroupParam(
        CGroupsHandler.CGroupController.MEMORY,
        """",
        CGROUP_PARAM_MEMORY_OOM_CONTROL))
        .thenReturn(""under_oom 1"").thenReturn(""under_oom 0"");
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c1.getContainerId().toString(), CGROUP_PROCS_FILE))
        .thenReturn(""1234"").thenReturn("""");
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c1.getContainerId().toString(), CGROUP_PARAM_MEMORY_USAGE_BYTES))
        .thenReturn(getMB(9));
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c1.getContainerId().toString(), CGROUP_PARAM_MEMORY_MEMSW_USAGE_BYTES))
        .thenReturn(getMB(9));
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c2.getContainerId().toString(), CGROUP_PROCS_FILE))
        .thenReturn(""1235"").thenReturn("""");
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c2.getContainerId().toString(), CGROUP_PARAM_MEMORY_USAGE_BYTES))
        .thenReturn(getMB(9));
    when(cGroupsHandler.getCGroupParam(CGroupsHandler.CGroupController.MEMORY,
        c2.getContainerId().toString(), CGROUP_PARAM_MEMORY_MEMSW_USAGE_BYTES))
        .thenReturn(getMB(9));

    DefaultOOMHandler handler =
        new DefaultOOMHandler(context, false) {
          @Override
          protected CGroupsHandler getCGroupsHandler() {
            return cGroupsHandler;
          }",Eager Test
"@Test
  public void testLifeCycle() {
    NetworkPacketTaggingHandlerImpl handlerImpl =
        createNetworkPacketTaggingHandlerImpl();
    try {
      handlerImpl.bootstrap(conf);
      testPreStart(handlerImpl);
      testPostComplete(handlerImpl);
    }",Eager Test
"@Test
  public void testLifeCycle() {
    TrafficController trafficControllerSpy = spy(new TrafficController(conf,
        privilegedOperationExecutorMock));
    TrafficControlBandwidthHandlerImpl handlerImpl = new
        TrafficControlBandwidthHandlerImpl(privilegedOperationExecutorMock,
        cGroupsHandlerMock, trafficControllerSpy);

    try {
      handlerImpl.bootstrap(conf);
      testPreStart(trafficControllerSpy, handlerImpl);
      testPostComplete(trafficControllerSpy, handlerImpl);
    }",Eager Test
"@Test
  public void testLifeCycle() {
    TrafficController trafficControllerSpy = spy(new TrafficController(conf,
        privilegedOperationExecutorMock));
    TrafficControlBandwidthHandlerImpl handlerImpl = new
        TrafficControlBandwidthHandlerImpl(privilegedOperationExecutorMock,
        cGroupsHandlerMock, trafficControllerSpy);

    try {
      handlerImpl.bootstrap(conf);
      testPreStart(trafficControllerSpy, handlerImpl);
      testPostComplete(trafficControllerSpy, handlerImpl);
    }",Eager Test
"@Test
  public void testBootstrapRecoveryEnabled() {
    conf.setBoolean(YarnConfiguration.NM_RECOVERY_ENABLED, true);

    TrafficController trafficController = new TrafficController(conf,
        privilegedOperationExecutorMock);

    try {
      //Return a default tc state when attempting to read state
      when(privilegedOperationExecutorMock.executePrivilegedOperation(
          any(PrivilegedOperation.class), eq(true)))
          .thenReturn(DEFAULT_TC_STATE_EXAMPLE);

      trafficController
          .bootstrap(DEVICE, ROOT_BANDWIDTH_MBIT, YARN_BANDWIDTH_MBIT);

      ArgumentCaptor<PrivilegedOperation> readOpCaptor = ArgumentCaptor.forClass
          (PrivilegedOperation.class);

      //NM_RECOVERY_ENABLED - so we expect three privileged operation executions
      //1) read tc state 2) wipe tc state 3) init tc state
      //one for wiping tc state - a second for initializing state
      //First, verify read op
      verify(privilegedOperationExecutorMock, times(1))
          .executePrivilegedOperation(readOpCaptor.capture(), eq(true));
      List<PrivilegedOperation> readOps = readOpCaptor.getAllValues();
      verifyTrafficControlOperation(readOps.get(0),
          PrivilegedOperation.OperationType.TC_READ_STATE,
          Arrays.asList(READ_QDISC_CMD, READ_FILTER_CMD, READ_CLASS_CMD));

      ArgumentCaptor<PrivilegedOperation> writeOpCaptor = ArgumentCaptor
          .forClass(PrivilegedOperation.class);
      verify(privilegedOperationExecutorMock, times(2))
          .executePrivilegedOperation(writeOpCaptor.capture(), eq(false));
      //Now verify that the two write operations were correct
      List<PrivilegedOperation> writeOps = writeOpCaptor.getAllValues();
      verifyTrafficControlOperation(writeOps.get(0),
          PrivilegedOperation.OperationType.TC_MODIFY_STATE,
          Arrays.asList(WIPE_STATE_CMD));

      verifyTrafficControlOperation(writeOps.get(1),
          PrivilegedOperation.OperationType.TC_MODIFY_STATE,
          Arrays.asList(ADD_ROOT_QDISC_CMD, ADD_CGROUP_FILTER_CMD,
              ADD_ROOT_CLASS_CMD, ADD_DEFAULT_CLASS_CMD, ADD_YARN_CLASS_CMD));
    }",Eager Test
"@Test
  public void testInvalidBuilder() {
    conf.setBoolean(YarnConfiguration.NM_RECOVERY_ENABLED, false);

    TrafficController trafficController = new TrafficController(conf,
        privilegedOperationExecutorMock);
    try {
      trafficController
          .bootstrap(DEVICE, ROOT_BANDWIDTH_MBIT, YARN_BANDWIDTH_MBIT);

      try {
        //Invalid op type for TC batch builder
        TrafficController.BatchBuilder invalidBuilder = trafficController.
            new BatchBuilder(
            PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP);
        Assert.fail(""Invalid builder check failed!"");
      }",Eager Test
"@Test
  public void testExecuteDockerCommand() throws Exception {
    DockerStopCommand dockerStopCommand =
        new DockerStopCommand(MOCK_CONTAINER_ID);
    DockerCommandExecutor.executeDockerCommand(dockerStopCommand,
        cId.toString(), env, mockExecutor, false, nmContext);
    List<PrivilegedOperation> ops = MockPrivilegedOperationCaptor
        .capturePrivilegedOperations(mockExecutor, 1, true);
    assertEquals(1, ops.size());
    assertEquals(PrivilegedOperation.OperationType.RUN_DOCKER_CMD.name(),
        ops.get(0).getOperationType().name());
  }",Eager Test
"@Test
  public void testExecuteDockerKillSIGKILL() throws Exception {
    DockerKillCommand dockerKillCommand =
        new DockerKillCommand(MOCK_CONTAINER_ID)
            .setSignal(ContainerExecutor.Signal.KILL.name());
    DockerCommandExecutor.executeDockerCommand(dockerKillCommand,
        MOCK_CONTAINER_ID, env, mockExecutor, false, nmContext);
    List<PrivilegedOperation> ops = MockPrivilegedOperationCaptor
        .capturePrivilegedOperations(mockExecutor, 1, true);
    List<String> dockerCommands = getValidatedDockerCommands(ops);
    assertEquals(1, ops.size());
    assertEquals(PrivilegedOperation.OperationType.RUN_DOCKER_CMD.name(),
        ops.get(0).getOperationType().name());
    assertEquals(4, dockerCommands.size());
    assertEquals(""[docker-command-execution]"", dockerCommands.get(0));
    assertEquals(""  docker-command=kill"", dockerCommands.get(1));
    assertEquals(""  name="" + MOCK_CONTAINER_ID, dockerCommands.get(2));
    assertEquals(""  signal="" + ContainerExecutor.Signal.KILL.name(),
        dockerCommands.get(3));
  }",Eager Test
"@Test
  public void testExecuteDockerRmWithCgroup() throws Exception {
    DockerRmCommand dockerCommand =
        new DockerRmCommand(MOCK_CONTAINER_ID, MOCK_CGROUP_HIERARCHY);
    DockerCommandExecutor.executeDockerCommand(dockerCommand, MOCK_CONTAINER_ID,
        env, mockExecutor, false, nmContext);
    List<PrivilegedOperation> ops = MockPrivilegedOperationCaptor
        .capturePrivilegedOperations(mockExecutor, 1, true);
    PrivilegedOperation privOp = ops.get(0);
    List<String> args = privOp.getArguments();
    assertEquals(1, ops.size());
    assertEquals(PrivilegedOperation.OperationType.
            REMOVE_DOCKER_CONTAINER.name(),
        privOp.getOperationType().name());
    assertEquals(2, args.size());
    assertEquals(MOCK_CGROUP_HIERARCHY, args.get(0));
    assertEquals(MOCK_CONTAINER_ID, args.get(1));
  }",Eager Test
"@Test
  public void testExecuteDockerStop() throws Exception {
    DockerStopCommand dockerCommand = new DockerStopCommand(MOCK_CONTAINER_ID);
    DockerCommandExecutor.executeDockerCommand(dockerCommand, MOCK_CONTAINER_ID,
        env, mockExecutor, false, nmContext);
    List<PrivilegedOperation> ops = MockPrivilegedOperationCaptor
        .capturePrivilegedOperations(mockExecutor, 1, true);
    List<String> dockerCommands = getValidatedDockerCommands(ops);
    assertEquals(1, ops.size());
    assertEquals(PrivilegedOperation.OperationType.RUN_DOCKER_CMD.name(),
        ops.get(0).getOperationType().name());
    assertEquals(3, dockerCommands.size());
    assertEquals(""[docker-command-execution]"", dockerCommands.get(0));
    assertEquals(""  docker-command=stop"", dockerCommands.get(1));
    assertEquals(""  name="" + MOCK_CONTAINER_ID, dockerCommands.get(2));
  }",Eager Test
"@Test
  public void testGetIpAndHost() throws Exception {
    dockerInspectCommand.getIpAndHost();
    assertEquals(""inspect"", StringUtils.join("","",
        dockerInspectCommand.getDockerCommandWithArguments()
            .get(""docker-command"")));
    assertEquals(""{{range(.NetworkSettings.Networks)}",Mystery Guest
"@Test
  public void testGetCommandOption() {
    assertEquals(""kill"", dockerKillCommand.getCommandOption());
  }",No Smells
"@Test
  public void testGetCommandOption() {
    assertEquals(""load"", dockerLoadCommand.getCommandOption());
  }",No Smells
"@Test
  public void testGetCommandWithArguments() {
    assertEquals(""pull"", StringUtils.join("","",
        dockerPullCommand.getDockerCommandWithArguments()
            .get(""docker-command"")));
    assertEquals(""foo"", StringUtils.join("","",
        dockerPullCommand.getDockerCommandWithArguments().get(""image"")));
    assertEquals(2, dockerPullCommand.getDockerCommandWithArguments().size());
  }",No Smells
"@Test
  public void testGetCommandWithArguments() {
    assertEquals(""start"", StringUtils.join("","",
        dockerStartCommand.getDockerCommandWithArguments()
            .get(""docker-command"")));
    assertEquals(""foo"", StringUtils.join("","",
        dockerStartCommand.getDockerCommandWithArguments().get(""name"")));
    assertEquals(2, dockerStartCommand.getDockerCommandWithArguments().size());
  }",No Smells
"@Test
  public void testIsRuntimeAllowedAll() throws Exception {
    conf.set(YarnConfiguration.LINUX_CONTAINER_RUNTIME_ALLOWED_RUNTIMES,
        ""default,docker,javasandbox"");
    delegatingLinuxContainerRuntime.initialize(conf, null);
    assertTrue(delegatingLinuxContainerRuntime.isRuntimeAllowed(
        LinuxContainerRuntimeConstants.RuntimeType.DEFAULT.name()));
    assertTrue(delegatingLinuxContainerRuntime.isRuntimeAllowed(
        LinuxContainerRuntimeConstants.RuntimeType.DOCKER.name()));
    assertTrue(delegatingLinuxContainerRuntime.isRuntimeAllowed(
        LinuxContainerRuntimeConstants.RuntimeType.JAVASANDBOX.name()));
  }",No Smells
"@Test
  public void testIsRuntimeAllowedDocker() throws Exception {
    conf.set(YarnConfiguration.LINUX_CONTAINER_RUNTIME_ALLOWED_RUNTIMES,
        ContainerRuntimeConstants.CONTAINER_RUNTIME_DOCKER);
    delegatingLinuxContainerRuntime.initialize(conf, null);
    assertTrue(delegatingLinuxContainerRuntime.isRuntimeAllowed(
        LinuxContainerRuntimeConstants.RuntimeType.DOCKER.name()));
    assertFalse(delegatingLinuxContainerRuntime.isRuntimeAllowed(
        LinuxContainerRuntimeConstants.RuntimeType.DEFAULT.name()));
    assertFalse(delegatingLinuxContainerRuntime.isRuntimeAllowed(
        LinuxContainerRuntimeConstants.RuntimeType.JAVASANDBOX.name()));
  }",No Smells
"@Test
  public void testJavaSandboxNotAllowedButPermissiveDockerRequested()
      throws Exception {
    env.put(ContainerRuntimeConstants.ENV_CONTAINER_TYPE,
        ContainerRuntimeConstants.CONTAINER_RUNTIME_DOCKER);
    conf.set(YarnConfiguration.LINUX_CONTAINER_RUNTIME_ALLOWED_RUNTIMES,
        ""default,docker"");
    conf.set(YarnConfiguration.YARN_CONTAINER_SANDBOX, ""permissive"");
    delegatingLinuxContainerRuntime.initialize(conf, null);
    ContainerRuntime runtime =
        delegatingLinuxContainerRuntime.pickContainerRuntime(env);
    assertTrue(runtime instanceof DockerLinuxContainerRuntime);
  }",Eager Test
"@Test
  public void testEnabledSandboxWithWhitelist()
      throws ContainerExecutionException{
    String[] inputCommand = {
        ""$JAVA_HOME/bin/java jar -Djava.security.manager MyJob.jar""
    }",Mystery Guest + Resource Optimism
"@Test
  public void testEnforcingMode() throws ContainerExecutionException {
    String[] nonJavaCommands = {
        ""bash malicious_script.sh"",
        ""python malicious_script.py""
    }",Mystery Guest + Resource Optimism
"@Test
  public void testNotifySCMFail() throws Exception {
    Configuration conf = new Configuration();
    conf.setBoolean(YarnConfiguration.SHARED_CACHE_ENABLED, true);
    LocalResource resource = mock(LocalResource.class);
    Path localPath = mock(Path.class);
    when(localPath.getName()).thenReturn(""foo.jar"");
    String user = ""joe"";
    FileSystem fs = mock(FileSystem.class);
    // return false when rename is called
    when(fs.rename(isA(Path.class), isA(Path.class))).thenReturn(true);
    FileSystem localFs = FileSystem.getLocal(conf);
    SharedCacheUploader spied =
        createSpiedUploader(resource, localPath, user, conf, null, fs,
            localFs);
    // stub verifyAccess() to return true
    doReturn(true).when(spied).verifyAccess();
    // stub getActualPath()
    doReturn(localPath).when(spied).getActualPath();
    // stub computeChecksum()
    doReturn(""abcdef0123456789"").when(spied).computeChecksum(isA(Path.class));
    // stub uploadFile() to return true
    doReturn(true).when(spied).uploadFile(isA(Path.class), isA(Path.class));
    // stub notifySharedCacheManager to return true
    doReturn(false).when(spied).notifySharedCacheManager(isA(String.class),
        isA(String.class));

    assertFalse(spied.call());
    verify(fs).delete(isA(Path.class), anyBoolean());
  }",Eager Test + Mystery Guest
"@Test
  public void testSuccess() throws Exception {
    Configuration conf = new Configuration();
    conf.setBoolean(YarnConfiguration.SHARED_CACHE_ENABLED, true);
    LocalResource resource = mock(LocalResource.class);
    Path localPath = mock(Path.class);
    when(localPath.getName()).thenReturn(""foo.jar"");
    String user = ""joe"";
    SCMUploaderProtocol scmClient = mock(SCMUploaderProtocol.class);
    SCMUploaderNotifyResponse response = mock(SCMUploaderNotifyResponse.class);
    when(response.getAccepted()).thenReturn(true);
    when(scmClient.notify(isA(SCMUploaderNotifyRequest.class))).
        thenReturn(response);
    FileSystem fs = mock(FileSystem.class);
    // return false when rename is called
    when(fs.rename(isA(Path.class), isA(Path.class))).thenReturn(true);
    FileSystem localFs = FileSystem.getLocal(conf);
    SharedCacheUploader spied =
        createSpiedUploader(resource, localPath, user, conf, scmClient, fs,
            localFs);
    // stub verifyAccess() to return true
    doReturn(true).when(spied).verifyAccess();
    // stub getActualPath()
    doReturn(localPath).when(spied).getActualPath();
    // stub computeChecksum()
    doReturn(""abcdef0123456789"").when(spied).computeChecksum(isA(Path.class));
    // stub uploadFile() to return true
    doReturn(true).when(spied).uploadFile(isA(Path.class), isA(Path.class));
    // stub notifySharedCacheManager to return true
    doReturn(true).when(spied).notifySharedCacheManager(isA(String.class),
        isA(String.class));

    assertTrue(spied.call());
  }",Eager Test + Mystery Guest
"@Test
  public void testInitEnabled() {
    testInit(true);
  }",No Smells
"@Test
  public void testMain() throws Exception {
    ContainerLocalizerWrapper wrapper = new ContainerLocalizerWrapper();
    ContainerLocalizer localizer =
        wrapper.setupContainerLocalizerForTest();
    Random random = wrapper.random;
    List<Path> localDirs = wrapper.localDirs;
    Path tokenPath = wrapper.tokenPath;
    LocalizationProtocol nmProxy = wrapper.nmProxy;
    AbstractFileSystem spylfs = wrapper.spylfs;
    mockOutDownloads(localizer);

    // verify created cache
    List<Path> privCacheList = new ArrayList<Path>();
    List<Path> appCacheList = new ArrayList<Path>();
    for (Path p : localDirs) {
      Path base = new Path(new Path(p, ContainerLocalizer.USERCACHE), appUser);
      Path privcache = new Path(base, ContainerLocalizer.FILECACHE);
      privCacheList.add(privcache);
      Path appDir =
          new Path(base, new Path(ContainerLocalizer.APPCACHE, appId));
      Path appcache = new Path(appDir, ContainerLocalizer.FILECACHE);
      appCacheList.add(appcache);
    }",Eager Test
"@Test
  public void testMultipleLocalizers() throws Exception {
    FakeContainerLocalizerWrapper testA = new FakeContainerLocalizerWrapper();
    FakeContainerLocalizerWrapper testB = new FakeContainerLocalizerWrapper();

    FakeContainerLocalizer localizerA = testA.init();
    FakeContainerLocalizer localizerB = testB.init();

    // run localization
    Thread threadA = new Thread() {
      @Override
      public void run() {
        try {
          localizerA.runLocalization(nmAddr);
        }",Eager Test
"@Test
  public void testResourceEquality() throws URISyntaxException {
    Random r = new Random();
    long seed = r.nextLong();
    r.setSeed(seed);
    System.out.println(""SEED: "" + seed);

    long basetime = r.nextLong() >>> 2;
    org.apache.hadoop.yarn.api.records.LocalResource yA = getYarnResource(
        new Path(""http://yak.org:80/foobar""), -1, basetime, FILE, PUBLIC, null);
    org.apache.hadoop.yarn.api.records.LocalResource yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), -1, basetime, FILE, PUBLIC, null);
    final LocalResourceRequest a = new LocalResourceRequest(yA);
    LocalResourceRequest b = new LocalResourceRequest(yA);
    checkEqual(a, b);
    b = new LocalResourceRequest(yB);
    checkEqual(a, b);

    // ignore visibility
    yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), -1, basetime, FILE, PRIVATE, null);
    b = new LocalResourceRequest(yB);
    checkEqual(a, b);

    // ignore size
    yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), 0, basetime, FILE, PRIVATE, null);
    b = new LocalResourceRequest(yB);
    checkEqual(a, b);

    // note path
    yB = getYarnResource(
        new Path(""hdfs://dingo.org:80/foobar""), 0, basetime, ARCHIVE, PUBLIC, null);
    b = new LocalResourceRequest(yB);
    checkNotEqual(a, b);

    // note type
    yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), 0, basetime, ARCHIVE, PUBLIC, null);
    b = new LocalResourceRequest(yB);
    checkNotEqual(a, b);

    // note timestamp
    yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), 0, basetime + 1, FILE, PUBLIC, null);
    b = new LocalResourceRequest(yB);
    checkNotEqual(a, b);

    // note pattern
    yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), 0, basetime + 1, FILE, PUBLIC, ""^/foo/.*"");
    b = new LocalResourceRequest(yB);
    checkNotEqual(a, b);
  }",No Smells
"@Test
  public void testResourceEquality() throws URISyntaxException {
    Random r = new Random();
    long seed = r.nextLong();
    r.setSeed(seed);
    System.out.println(""SEED: "" + seed);

    long basetime = r.nextLong() >>> 2;
    org.apache.hadoop.yarn.api.records.LocalResource yA = getYarnResource(
        new Path(""http://yak.org:80/foobar""), -1, basetime, FILE, PUBLIC, null);
    org.apache.hadoop.yarn.api.records.LocalResource yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), -1, basetime, FILE, PUBLIC, null);
    final LocalResourceRequest a = new LocalResourceRequest(yA);
    LocalResourceRequest b = new LocalResourceRequest(yA);
    checkEqual(a, b);
    b = new LocalResourceRequest(yB);
    checkEqual(a, b);

    // ignore visibility
    yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), -1, basetime, FILE, PRIVATE, null);
    b = new LocalResourceRequest(yB);
    checkEqual(a, b);

    // ignore size
    yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), 0, basetime, FILE, PRIVATE, null);
    b = new LocalResourceRequest(yB);
    checkEqual(a, b);

    // note path
    yB = getYarnResource(
        new Path(""hdfs://dingo.org:80/foobar""), 0, basetime, ARCHIVE, PUBLIC, null);
    b = new LocalResourceRequest(yB);
    checkNotEqual(a, b);

    // note type
    yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), 0, basetime, ARCHIVE, PUBLIC, null);
    b = new LocalResourceRequest(yB);
    checkNotEqual(a, b);

    // note timestamp
    yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), 0, basetime + 1, FILE, PUBLIC, null);
    b = new LocalResourceRequest(yB);
    checkNotEqual(a, b);

    // note pattern
    yB = getYarnResource(
        new Path(""http://yak.org:80/foobar""), 0, basetime + 1, FILE, PUBLIC, ""^/foo/.*"");
    b = new LocalResourceRequest(yB);
    checkNotEqual(a, b);
  }",No Smells
"@Test
  public void testAggregatorWhenAllFilesOlderThanRetentionShouldUploadNone()
      throws IOException {

    final ApplicationId applicationId =
        ApplicationId.newInstance(System.currentTimeMillis(), 0);
    final ApplicationAttemptId attemptId =
        ApplicationAttemptId.newInstance(applicationId, 0);
    final ContainerId containerId = ContainerId.newContainerId(attemptId, 0);

    // create artificial log files
    final File appLogDir = new File(LOCAL_LOG_DIR,
        applicationId.toString());
    final File containerLogDir = new File(appLogDir,
        containerId.toString());
    containerLogDir.mkdirs();
    final Set<File> logFiles = createContainerLogFiles(containerLogDir, 3);


    final long week = 7 * 24 * 60 * 60;
    final long recoveredLogInitedTimeMillis = System.currentTimeMillis() -
        2 * week * 1000;
    verifyLogAggregationWithExpectedFiles2DeleteAndUpload(
        applicationId, containerId, week, recoveredLogInitedTimeMillis,
        logFiles, new HashSet<File>());
  }",Eager Test
"@Test
  public void testInvalidThreadPoolSizeNegative() throws IOException {
      testInvalidThreadPoolSizeValue(""-100"");
  }",No Smells
"@Test
  public void testLogAggregationCreateDirsFailsWithoutKillingNM()
      throws Exception {

    this.conf.set(YarnConfiguration.NM_LOG_DIRS,
        localLogDir.getAbsolutePath());
    this.conf.set(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,
        this.remoteRootLogDir.getAbsolutePath());

    DeletionService spyDelSrvc = spy(this.delSrvc);
    LogAggregationFileControllerFactory factory
        = new LogAggregationFileControllerFactory(conf);
    LogAggregationFileController logAggregationFileFormat = factory
        .getFileControllerForWrite();
    LogAggregationFileController spyLogAggregationFileFormat =
        spy(logAggregationFileFormat);
    Exception e =
        new YarnRuntimeException(new SecretManager.InvalidToken(""KABOOM!""));
    doThrow(e).when(spyLogAggregationFileFormat)
        .createAppDir(any(String.class), any(ApplicationId.class),
            any(UserGroupInformation.class));
    LogAggregationService logAggregationService = spy(
        new LogAggregationService(dispatcher, this.context, spyDelSrvc,
            super.dirsHandler){
        @Override
        public LogAggregationFileController getLogAggregationFileController(
            Configuration conf) {
          return spyLogAggregationFileFormat;
        }",Eager Test
"@Test
  public void testLogAggregatorCleanup() throws Exception {
    DeletionService delSrvc = mock(DeletionService.class);

    // get the AppLogAggregationImpl thread to crash
    LocalDirsHandlerService mockedDirSvc = mock(LocalDirsHandlerService.class);

    LogAggregationService logAggregationService =
        new LogAggregationService(dispatcher, this.context, delSrvc,
                                  mockedDirSvc);
    logAggregationService.init(this.conf);
    logAggregationService.start();

    ApplicationId application1 = BuilderUtils.newApplicationId(1234, 1);
    logAggregationService.handle(new LogHandlerAppStartedEvent(
            application1, this.user, null, this.acls));

    logAggregationService.handle(new LogHandlerAppFinishedEvent(application1));
    dispatcher.await();
    int timeToWait = 20 * 1000;
    while (timeToWait > 0 && logAggregationService.getNumAggregators() > 0) {
      Thread.sleep(100);
      timeToWait -= 100;
    }",Eager Test
"@Test
  public void testNoContainerOnNode() throws Exception {
    this.conf.set(YarnConfiguration.NM_LOG_DIRS, localLogDir.getAbsolutePath());
    this.conf.set(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,
        this.remoteRootLogDir.getAbsolutePath());
    
    LogAggregationService logAggregationService =
        new LogAggregationService(dispatcher, this.context, this.delSrvc,
                                  super.dirsHandler);
    logAggregationService.init(this.conf);
    logAggregationService.start();

    ApplicationId application1 = BuilderUtils.newApplicationId(1234, 1);

    // AppLogDir should be created
    File app1LogDir =
      new File(localLogDir, application1.toString());
    app1LogDir.mkdir();
    logAggregationService
        .handle(new LogHandlerAppStartedEvent(
            application1, this.user, null, this.acls));

    logAggregationService.handle(new LogHandlerAppFinishedEvent(
        application1));

    logAggregationService.stop();
    assertEquals(0, logAggregationService.getNumAggregators());
    LogAggregationFileController format1 =
        logAggregationService.getLogAggregationFileController(conf);
    Assert.assertFalse(new File(format1.getRemoteNodeLogFileForApp(
        application1, this.user, this.nodeId).toUri().getPath())
        .exists());

    dispatcher.await();
    
    ApplicationEvent expectedEvents[] = new ApplicationEvent[]{
        new ApplicationEvent(
            application1,
            ApplicationEventType.APPLICATION_LOG_HANDLING_INITED),
        new ApplicationEvent(
            application1,
            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED)
    }",Eager Test
"@Test
  public void testContainerMetricsFlow() throws InterruptedException {
    final String ERR = ""Error in number of records"";

    MetricsCollectorImpl collector = new MetricsCollectorImpl();
    ContainerId containerId = mock(ContainerId.class);
    ContainerMetrics metrics = ContainerMetrics.forContainer(containerId,
        100, 1);

    metrics.recordMemoryUsage(1024);
    metrics.getMetrics(collector, true);
    assertEquals(ERR, 0, collector.getRecords().size());

    Thread.sleep(110);
    metrics.getMetrics(collector, true);
    assertEquals(ERR, 1, collector.getRecords().size());
    collector.clear();

    Thread.sleep(110);
    metrics.getMetrics(collector, true);
    assertEquals(ERR, 1, collector.getRecords().size());
    collector.clear();

    metrics.finished(false);
    metrics.getMetrics(collector, true);
    assertEquals(ERR, 1, collector.getRecords().size());
    collector.clear();

    metrics.getMetrics(collector, true);
    assertEquals(ERR, 1, collector.getRecords().size());
    collector.clear();

    Thread.sleep(110);
    metrics.getMetrics(collector, true);
    assertEquals(ERR, 1, collector.getRecords().size());
  }",Eager Test
"@Test
  public void testGpuDiscover() throws YarnException {
    // Since this is more of a performance unit test, only run if
    // RunUserLimitThroughput is set (-DRunUserLimitThroughput=true)
    Assume.assumeTrue(
        Boolean.valueOf(System.getProperty(""runGpuDiscoverUnitTest"")));
    Configuration conf = new Configuration(false);
    GpuDiscoverer discoverer = new GpuDiscoverer();
    discoverer.initialize(conf, binaryHelper);
    GpuDeviceInformation info = discoverer.getGpuDeviceInformation();

    assertTrue(info.getGpus().size() > 0);
    assertEquals(discoverer.getGpusUsableByYarn().size(),
        info.getGpus().size());
  }",No Smells
"@Test
  public void testAuxServicesMeta() throws IOException {
    Configuration conf = getABConf();
    final AuxServices aux = new AuxServices(MOCK_AUX_PATH_HANDLER,
        MOCK_CONTEXT, MOCK_DEL_SERVICE);
    aux.init(conf);

    int latch = 1;
    for (Service s : aux.getServices()) {
      assertEquals(INITED, s.getServiceState());
      if (s instanceof ServiceA) { latch *= 2; }",Eager Test + Mystery Guest
"@Test
  public void testChangeContainerResource() throws Exception {
    containerManager.start();
    File scriptFile = Shell.appendScriptExtension(tmpDir, ""scriptFile"");
    PrintWriter fileWriter = new PrintWriter(scriptFile);
    // Construct the Container-id
    ContainerId cId = createContainerId(0);
    if (Shell.WINDOWS) {
      fileWriter.println(""@ping -n 100 127.0.0.1 >nul"");
    }",Eager Test + Mystery Guest
"@Test
  public void testMultipleContainersLaunch() throws Exception {
    containerManager.start();

    List<StartContainerRequest> list = new ArrayList<>();
    for (int i = 0; i < 10; i++) {
      ContainerId cId = createContainerId(i);
      long identifier = 0;
      if ((i & 1) == 0)
        // container with even id fail
        identifier = ResourceManagerConstants.RM_INVALID_IDENTIFIER;
      else
        identifier = DUMMY_RM_IDENTIFIER;
      Token containerToken =
          createContainerToken(cId, identifier, context.getNodeId(), user,
            context.getContainerTokenSecretManager());
      StartContainerRequest request =
          StartContainerRequest.newInstance(
              recordFactory.newRecordInstance(ContainerLaunchContext.class),
              containerToken);
      list.add(request);
    }",Eager Test
"@Test
  public void testStartContainerFailureWithNullTypeLocalResource()
      throws Exception {
    containerManager.start();
    LocalResource rsrc_alpha =
        recordFactory.newRecordInstance(LocalResource.class);
    rsrc_alpha.setResource(URL.fromPath(new Path(""./"")));
    rsrc_alpha.setSize(-1);
    rsrc_alpha.setVisibility(LocalResourceVisibility.APPLICATION);
    rsrc_alpha.setType(null);
    rsrc_alpha.setTimestamp(System.currentTimeMillis());
    Map<String, LocalResource> localResources =
        new HashMap<String, LocalResource>();
    localResources.put(""null_type_resource"", rsrc_alpha);
    ContainerLaunchContext containerLaunchContext =
        recordFactory.newRecordInstance(ContainerLaunchContext.class);
    ContainerLaunchContext spyContainerLaunchContext =
        spy(containerLaunchContext);
    Mockito.when(spyContainerLaunchContext.getLocalResources())
        .thenReturn(localResources);

    ContainerId cId = createContainerId(0);
    String user = ""start_container_fail"";
    Token containerToken =
        createContainerToken(cId, DUMMY_RM_IDENTIFIER, context.getNodeId(),
            user, context.getContainerTokenSecretManager());
    StartContainerRequest request = StartContainerRequest
        .newInstance(spyContainerLaunchContext, containerToken);

    // start containers
    List<StartContainerRequest> startRequest =
        new ArrayList<StartContainerRequest>();
    startRequest.add(request);
    StartContainersRequest requestList =
        StartContainersRequest.newInstance(startRequest);

    StartContainersResponse response =
        containerManager.startContainers(requestList);
    Assert.assertTrue(response.getFailedRequests().size() == 1);
    Assert.assertTrue(response.getSuccessfullyStartedContainers().size() == 0);
    Assert.assertTrue(response.getFailedRequests().containsKey(cId));
    Assert.assertTrue(response.getFailedRequests().get(cId).getMessage()
        .contains(""Null resource type for local resource""));
  }",Eager Test
"@Test
  public void testStartContainerFailureWithUnknownAuxService() throws Exception {
    conf.setStrings(YarnConfiguration.NM_AUX_SERVICES,
        new String[] { ""existService"" }",Eager Test
"@Test
  public void testReferenceOfSingletonJvmMetrics()  {
    JvmMetrics jvmMetrics = JvmMetrics.initSingleton(""NodeManagerModule"", null);
    Assert.assertEquals(""NodeManagerMetrics should reference the singleton"" +
        "" JvmMetrics instance"", jvmMetrics, metrics.getJvmMetrics());
  }",No Smells
"@Test
  public void testParseConfiguration() throws IOException {
    // ATTRIBUTE_NAME,ATTRIBUTE_TYPE,ATTRIBUTE_VALUE
    String attributesStr = ""hostname,STRING,host1234:uptime,STRING,321543"";
    Set<NodeAttribute> attributes = nodeAttributesProvider
        .parseAttributes(attributesStr);
    Assert.assertEquals(2, attributes.size());
    Iterator<NodeAttribute> ait = attributes.iterator();

    while(ait.hasNext()) {
      NodeAttribute attr = ait.next();
      NodeAttributeKey at = attr.getAttributeKey();
      if (at.getAttributeName().equals(""hostname"")) {
        Assert.assertEquals(""hostname"", at.getAttributeName());
        Assert.assertEquals(NodeAttribute.PREFIX_DISTRIBUTED,
            at.getAttributePrefix());
        Assert.assertEquals(NodeAttributeType.STRING,
            attr.getAttributeType());
        Assert.assertEquals(""host1234"", attr.getAttributeValue());
      }",Eager Test
"@Test
  public void testFetchInterval() throws Exception {
    // The script returns the pid (as an attribute) each time runs this script
    String simpleScript = ""echo NODE_ATTRIBUTE:pid,STRING,$$"";
    writeNodeAttributeScriptFile(simpleScript, true);

    nodeAttributesProvider.init(getConfForNodeAttributeScript());
    nodeAttributesProvider.start();

    // Wait for at most 3 seconds until we get at least 1
    // different attribute value.
    Set<String> resultSet = new HashSet<>();
    GenericTestUtils.waitFor(() -> {
      Set<NodeAttribute> attributes =
          nodeAttributesProvider.getDescriptors();
      if (attributes != null) {
        Assert.assertEquals(1, attributes.size());
        resultSet.add(attributes.iterator().next().getAttributeValue());
        return resultSet.size() > 1;
      }",Eager Test
"@Test
  public void testNodeLabelsScriptRunnerCreation() throws IOException {
    // If no script configured then initialization of service should fail
    ScriptBasedNodeLabelsProvider nodeLabelsProvider =
        new ScriptBasedNodeLabelsProvider();
    initilizeServiceFailTest(
        ""Expected to fail fast when no script is configured and ""
            + ""ScriptBasedNodeLabelsProvider service is inited"",
        nodeLabelsProvider);

    // If script configured is blank then initialization of service should fail
    nodeLabelsProvider = new ScriptBasedNodeLabelsProvider();
    Configuration conf = new Configuration();
    conf.set(YarnConfiguration.NM_SCRIPT_BASED_NODE_LABELS_PROVIDER_PATH, """");
    initilizeServiceFailTest(
        ""Expected to fail fast when script path configuration is blank""
            + ""and ScriptBasedNodeLabelsProvider service is inited."",
        nodeLabelsProvider);

    // If script configured is not executable then no timertask /
    // NodeLabelsScriptRunner initialized
    nodeLabelsProvider = new ScriptBasedNodeLabelsProvider();
    writeNodeLabelsScriptFile("""", false);
    initilizeServiceFailTest(
        ""Expected to fail fast when script is not executable""
            + ""and ScriptBasedNodeLabelsProvider service is inited."",
        nodeLabelsProvider);

    // If configured script is executable then timertask /
    // NodeLabelsScriptRunner should be initialized
    nodeLabelsProvider = new ScriptBasedNodeLabelsProvider();
    writeNodeLabelsScriptFile("""", true);
    nodeLabelsProvider.init(getConfForNodeLabelScript());
    nodeLabelsProvider.start();
    Assert
        .assertNotNull(""Node Label Script runner should be started when script""
            + "" is executable"", nodeLabelsProvider.getTimerTask());
    nodeLabelsProvider.stop();
  }",No Smells
"@Test
  public void testContainerTokenStorage() throws IOException {
    // test empty when no state
    RecoveredContainerTokensState state =
        stateStore.loadContainerTokensState();
    Map<ContainerId, Long> loadedActiveTokens = loadContainerTokens(state.it);
    assertNull(state.getCurrentMasterKey());
    assertNull(state.getPreviousMasterKey());
    assertTrue(loadedActiveTokens.isEmpty());

    // store a master key and verify recovered
    ContainerTokenKeyGeneratorForTest keygen =
        new ContainerTokenKeyGeneratorForTest(new YarnConfiguration());
    MasterKey currentKey = keygen.generateKey();
    stateStore.storeContainerTokenCurrentMasterKey(currentKey);
    restartStateStore();
    state = stateStore.loadContainerTokensState();
    loadedActiveTokens = loadContainerTokens(state.it);
    assertEquals(currentKey, state.getCurrentMasterKey());
    assertNull(state.getPreviousMasterKey());
    assertTrue(loadedActiveTokens.isEmpty());

    // store a previous key and verify recovered
    MasterKey prevKey = keygen.generateKey();
    stateStore.storeContainerTokenPreviousMasterKey(prevKey);
    restartStateStore();
    state = stateStore.loadContainerTokensState();
    loadedActiveTokens = loadContainerTokens(state.it);
    assertEquals(currentKey, state.getCurrentMasterKey());
    assertEquals(prevKey, state.getPreviousMasterKey());
    assertTrue(loadedActiveTokens.isEmpty());

    // store a few container tokens and verify recovered
    ContainerId cid1 = BuilderUtils.newContainerId(1, 1, 1, 1);
    Long expTime1 = 1234567890L;
    ContainerId cid2 = BuilderUtils.newContainerId(2, 2, 2, 2);
    Long expTime2 = 9876543210L;
    stateStore.storeContainerToken(cid1, expTime1);
    stateStore.storeContainerToken(cid2, expTime2);
    restartStateStore();
    state = stateStore.loadContainerTokensState();
    loadedActiveTokens = loadContainerTokens(state.it);
    assertEquals(currentKey, state.getCurrentMasterKey());
    assertEquals(prevKey, state.getPreviousMasterKey());
    assertEquals(2, loadedActiveTokens.size());
    assertEquals(expTime1, loadedActiveTokens.get(cid1));
    assertEquals(expTime2, loadedActiveTokens.get(cid2));

    // add/update/remove tokens and verify recovered
    ContainerId cid3 = BuilderUtils.newContainerId(3, 3, 3, 3);
    Long expTime3 = 135798642L;
    stateStore.storeContainerToken(cid3, expTime3);
    stateStore.removeContainerToken(cid1);
    expTime2 += 246897531L;
    stateStore.storeContainerToken(cid2, expTime2);
    prevKey = currentKey;
    stateStore.storeContainerTokenPreviousMasterKey(prevKey);
    currentKey = keygen.generateKey();
    stateStore.storeContainerTokenCurrentMasterKey(currentKey);
    restartStateStore();
    state = stateStore.loadContainerTokensState();
    loadedActiveTokens = loadContainerTokens(state.it);
    assertEquals(currentKey, state.getCurrentMasterKey());
    assertEquals(prevKey, state.getPreviousMasterKey());
    assertEquals(2, loadedActiveTokens.size());
    assertNull(loadedActiveTokens.get(cid1));
    assertEquals(expTime2, loadedActiveTokens.get(cid2));
    assertEquals(expTime3, loadedActiveTokens.get(cid3));
  }",Eager Test
"@Test
  public void testEmptyState() throws IOException {
    assertTrue(stateStore.canRecover());
    verifyEmptyState();
  }",No Smells
"@Test
  public void testFinishResourceLocalizationForApplicationResource()
      throws IOException {
    String user = ""somebody"";
    ApplicationId appId = ApplicationId.newInstance(1, 1);

    // start and finish a local resource for an application
    Path appRsrcPath = new Path(""hdfs://some/app/resource"");
    LocalResourcePBImpl rsrcPb = (LocalResourcePBImpl)
        LocalResource.newInstance(
            URL.fromPath(appRsrcPath),
            LocalResourceType.ARCHIVE, LocalResourceVisibility.APPLICATION,
            123L, 456L);
    LocalResourceProto appRsrcProto = rsrcPb.getProto();
    Path appRsrcLocalPath = new Path(""/some/local/dir/for/apprsrc"");
    stateStore.startResourceLocalization(user, appId, appRsrcProto,
        appRsrcLocalPath);
    LocalizedResourceProto appLocalizedProto =
        LocalizedResourceProto.newBuilder()
          .setResource(appRsrcProto)
          .setLocalPath(appRsrcLocalPath.toString())
          .setSize(1234567L)
          .build();
    stateStore.finishResourceLocalization(user, appId, appLocalizedProto);

    List<LocalizedResourceProto> completedResources =
        new ArrayList<LocalizedResourceProto>();
    Map<LocalResourceProto, Path> startedResources =
        new HashMap<LocalResourceProto, Path>();

    // restart and verify only app resource is completed
    restartStateStore();
    RecoveredLocalizationState state = stateStore.loadLocalizationState();
    LocalResourceTrackerState pubts = state.getPublicTrackerState();
    completedResources = loadCompletedResources(
        pubts.getCompletedResourcesIterator());
    startedResources = loadStartedResources(
        pubts.getStartedResourcesIterator());
    assertTrue(completedResources.isEmpty());
    assertTrue(startedResources.isEmpty());
    Map<String, RecoveredUserResources> userResources =
        loadUserResources(state.getIterator());
    assertEquals(1, userResources.size());
    RecoveredUserResources rur = userResources.get(user);
    LocalResourceTrackerState privts = rur.getPrivateTrackerState();
    assertNotNull(privts);
    completedResources = loadCompletedResources(
        privts.getCompletedResourcesIterator());
    startedResources = loadStartedResources(
        privts.getStartedResourcesIterator());
    assertTrue(completedResources.isEmpty());
    assertTrue(startedResources.isEmpty());
    assertEquals(1, rur.getAppTrackerStates().size());
    LocalResourceTrackerState appts = rur.getAppTrackerStates().get(appId);
    assertNotNull(appts);
    completedResources = loadCompletedResources(
        appts.getCompletedResourcesIterator());
    startedResources = loadStartedResources(
        appts.getStartedResourcesIterator());
    assertTrue(startedResources.isEmpty());
    assertEquals(1, completedResources.size());
    assertEquals(appLocalizedProto,
        completedResources.iterator().next());
  }",Eager Test + Mystery Guest
"@Test
  public void testLogDeleterStorage() throws IOException {
    // test empty when no state
    RecoveredLogDeleterState state = stateStore.loadLogDeleterState();
    assertTrue(state.getLogDeleterMap().isEmpty());

    // store log deleter state
    final ApplicationId appId1 = ApplicationId.newInstance(1, 1);
    LogDeleterProto proto1 = LogDeleterProto.newBuilder()
        .setUser(""user1"")
        .setDeletionTime(1234)
        .build();
    stateStore.storeLogDeleter(appId1, proto1);

    // restart state store and verify recovered
    restartStateStore();
    state = stateStore.loadLogDeleterState();
    assertEquals(1, state.getLogDeleterMap().size());
    assertEquals(proto1, state.getLogDeleterMap().get(appId1));

    // store another log deleter
    final ApplicationId appId2 = ApplicationId.newInstance(2, 2);
    LogDeleterProto proto2 = LogDeleterProto.newBuilder()
        .setUser(""user2"")
        .setDeletionTime(5678)
        .build();
    stateStore.storeLogDeleter(appId2, proto2);

    // restart state store and verify recovered
    restartStateStore();
    state = stateStore.loadLogDeleterState();
    assertEquals(2, state.getLogDeleterMap().size());
    assertEquals(proto1, state.getLogDeleterMap().get(appId1));
    assertEquals(proto2, state.getLogDeleterMap().get(appId2));

    // remove a deleter and verify removed after restart and recovery
    stateStore.removeLogDeleter(appId1);
    restartStateStore();
    state = stateStore.loadLogDeleterState();
    assertEquals(1, state.getLogDeleterMap().size());
    assertEquals(proto2, state.getLogDeleterMap().get(appId2));

    // remove last deleter and verify empty after restart and recovery
    stateStore.removeLogDeleter(appId2);
    restartStateStore();
    state = stateStore.loadLogDeleterState();
    assertTrue(state.getLogDeleterMap().isEmpty());
  }",Eager Test
"@Test
  public void testRemoveLocalizedResourceForApplicationResource()
      throws IOException {
    String user = ""somebody"";
    ApplicationId appId = ApplicationId.newInstance(1, 1);

    // go through the complete lifecycle for an application local resource
    Path appRsrcPath = new Path(""hdfs://some/app/resource"");
    LocalResourcePBImpl rsrcPb = (LocalResourcePBImpl)
        LocalResource.newInstance(
            URL.fromPath(appRsrcPath),
            LocalResourceType.ARCHIVE, LocalResourceVisibility.APPLICATION,
            123L, 456L);
    LocalResourceProto appRsrcProto = rsrcPb.getProto();
    Path appRsrcLocalPath = new Path(""/some/local/dir/for/apprsrc"");
    stateStore.startResourceLocalization(user, appId, appRsrcProto,
        appRsrcLocalPath);
    LocalizedResourceProto appLocalizedProto =
        LocalizedResourceProto.newBuilder()
          .setResource(appRsrcProto)
          .setLocalPath(appRsrcLocalPath.toString())
          .setSize(1234567L)
          .build();
    stateStore.finishResourceLocalization(user, appId, appLocalizedProto);
    stateStore.removeLocalizedResource(user, appId, appRsrcLocalPath);

    restartStateStore();
    verifyEmptyState();

    // remove an app resource that didn't finish
    stateStore.startResourceLocalization(user, appId, appRsrcProto,
        appRsrcLocalPath);
    stateStore.removeLocalizedResource(user, appId, appRsrcLocalPath);

    restartStateStore();
    verifyEmptyState();
  }",Eager Test
"@Test
  public void testUnexpectedKeyDoesntThrowException() throws IOException {
    // test empty when no state
    List<RecoveredContainerState> recoveredContainers =
        loadContainersState(stateStore.getContainerStateIterator());
    assertTrue(recoveredContainers.isEmpty());

    ApplicationId appId = ApplicationId.newInstance(1234, 3);
    ApplicationAttemptId appAttemptId = ApplicationAttemptId.newInstance(appId,
        4);
    ContainerId containerId = ContainerId.newContainerId(appAttemptId, 5);
    StartContainerRequest startContainerRequest = storeMockContainer(
        containerId);

    // add a invalid key
    byte[] invalidKey = (""ContainerManager/containers/""
    + containerId.toString() + ""/invalidKey1234"").getBytes();
    stateStore.getDB().put(invalidKey, new byte[1]);
    restartStateStore();
    recoveredContainers =
        loadContainersState(stateStore.getContainerStateIterator());
    assertEquals(1, recoveredContainers.size());
    RecoveredContainerState rcs = recoveredContainers.get(0);
    assertEquals(RecoveredContainerStatus.REQUESTED, rcs.getStatus());
    assertEquals(ContainerExitStatus.INVALID, rcs.getExitCode());
    assertEquals(false, rcs.getKilled());
    assertEquals(startContainerRequest, rcs.getStartRequest());
    assertTrue(rcs.getDiagnostics().isEmpty());
    assertEquals(RecoveredContainerType.KILL, rcs.getRecoveryType());
    // assert unknown keys are cleaned up finally
    assertNotNull(stateStore.getDB().get(invalidKey));
    stateStore.removeContainer(containerId);
    assertNull(stateStore.getDB().get(invalidKey));
  }",Eager Test + Mystery Guest
"@Test
  public void testEmptyState() throws IOException {
    assertTrue(stateStore.canRecover());
    verifyEmptyState();
  }",No Smells
"@Test
  public void testPickDirectory() throws Exception {
    Configuration conf = new Configuration();
    FileContext lfs = FileContext.getLocalFSFileContext(conf);
    DefaultContainerExecutor executor = new DefaultContainerExecutor(lfs);

    long[] availableOnDisk = new long[2];
    availableOnDisk[0] = 100;
    availableOnDisk[1] = 100;
    assertEquals(0, executor.pickDirectory(0L, availableOnDisk));
    assertEquals(0, executor.pickDirectory(99L, availableOnDisk));
    assertEquals(1, executor.pickDirectory(100L, availableOnDisk));
    assertEquals(1, executor.pickDirectory(101L, availableOnDisk));
    assertEquals(1, executor.pickDirectory(199L, availableOnDisk));

    long[] availableOnDisk2 = new long[5];
    availableOnDisk2[0] = 100;
    availableOnDisk2[1] = 10;
    availableOnDisk2[2] = 400;
    availableOnDisk2[3] = 200;
    availableOnDisk2[4] = 350;
    assertEquals(0, executor.pickDirectory(0L, availableOnDisk2));
    assertEquals(0, executor.pickDirectory(99L, availableOnDisk2));
    assertEquals(1, executor.pickDirectory(100L, availableOnDisk2));
    assertEquals(1, executor.pickDirectory(105L, availableOnDisk2));
    assertEquals(2, executor.pickDirectory(110L, availableOnDisk2));
    assertEquals(2, executor.pickDirectory(259L, availableOnDisk2));
    assertEquals(3, executor.pickDirectory(700L, availableOnDisk2));
    assertEquals(4, executor.pickDirectory(710L, availableOnDisk2));
    assertEquals(4, executor.pickDirectory(910L, availableOnDisk2));
  }",Eager Test
"@Test
  public void testRecovery() throws Exception {
    Random r = new Random();
    long seed = r.nextLong();
    r.setSeed(seed);
    System.out.println(""SEED: "" + seed);
    List<Path> baseDirs = buildDirs(r, base, 4);
    createDirs(new Path("".""), baseDirs);
    List<Path> content = buildDirs(r, new Path("".""), 10);
    for (Path b : baseDirs) {
      createDirs(b, content);
    }",Eager Test + Mystery Guest
"@Test
  public void testConcurrentAccess() throws IOException {
    // Initialize DirectoryCollection with a file instead of a directory
    
    String[] dirs = {testFile.getPath()}",Eager Test + Mystery Guest
"@Test
  public void testNonsecureUsernamePattern() throws Exception {
    Assume.assumeTrue(shouldRun());
    try {
      // nonsecure default
      Configuration conf = new YarnConfiguration();
      conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,
        ""simple"");
      UserGroupInformation.setConfiguration(conf);
      LinuxContainerExecutor lce = new LinuxContainerExecutor();
      lce.setConf(conf);
      lce.verifyUsernamePattern(""foo"");
      try {
        lce.verifyUsernamePattern(""foo/x"");
        fail();
      }",Eager Test
"@Test  
  public void testKeyValLogFormat() throws Exception {
    StringBuilder actLog = new StringBuilder();
    StringBuilder expLog = new StringBuilder();
    // add the first k=v pair and check
    NMAuditLogger.start(Keys.USER, USER, actLog);
    expLog.append(""USER=test"");
    assertEquals(expLog.toString(), actLog.toString());

    // append another k1=v1 pair to already added k=v and test
    NMAuditLogger.add(Keys.OPERATION, OPERATION, actLog);
    expLog.append(""\tOPERATION=oper"");
    assertEquals(expLog.toString(), actLog.toString());

    // append another k1=null pair and test
    NMAuditLogger.add(Keys.APPID, (String)null, actLog);
    expLog.append(""\tAPPID=null"");
    assertEquals(expLog.toString(), actLog.toString());

    // now add the target and check of the final string
    NMAuditLogger.add(Keys.TARGET, TARGET, actLog);
    expLog.append(""\tTARGET=tgt"");
    assertEquals(expLog.toString(), actLog.toString());
  }",Eager Test
"@Test  
  public void testNMAuditLoggerWithoutIP() throws Exception {
    // test without ip
    testSuccessLogFormat(false);
    testFailureLogFormat(false);
  }",No Smells
"@Test  
  public void testNMAuditLoggerWithoutIP() throws Exception {
    // test without ip
    testSuccessLogFormat(false);
    testFailureLogFormat(false);
  }",Eager Test
"@Test
  public void testCreationOfNodeLabelsProviderService()
      throws InterruptedException {
    try {
      NodeManager nodeManager = new NodeManager();
      Configuration conf = new Configuration();
      NodeLabelsProvider labelsProviderService =
          nodeManager.createNodeLabelsProvider(conf);
      Assert
          .assertNull(
              ""LabelsProviderService should not be initialized in default configuration"",
              labelsProviderService);

      // With valid className
      conf.set(
          YarnConfiguration.NM_NODE_LABELS_PROVIDER_CONFIG,
          ""org.apache.hadoop.yarn.server.nodemanager.nodelabels.ConfigurationNodeLabelsProvider"");
      labelsProviderService = nodeManager.createNodeLabelsProvider(conf);
      Assert.assertNotNull(""LabelsProviderService should be initialized When ""
          + ""node labels provider class is configured"", labelsProviderService);

      // With invalid className
      conf.set(YarnConfiguration.NM_NODE_LABELS_PROVIDER_CONFIG,
          ""org.apache.hadoop.yarn.server.nodemanager.NodeManager"");
      try {
        labelsProviderService = nodeManager.createNodeLabelsProvider(conf);
        Assert.fail(""Expected to throw IOException on Invalid configuration"");
      }",Eager Test + Mystery Guest
"@Test
  public void testNMRegistration() throws Exception {
    nm = new NodeManager() {
      @Override
      protected NodeStatusUpdater createNodeStatusUpdater(Context context,
          Dispatcher dispatcher, NodeHealthCheckerService healthChecker) {
        return new MyNodeStatusUpdater(context, dispatcher, healthChecker,
                                       metrics);
      }",No Smells
"@Test public void testContainerResourceUsage() {
    ApplicationId appId = ApplicationId.newInstance(0, 1);
    publisher.createTimelineClient(appId);
    Container aContainer = mock(Container.class);
    when(aContainer.getContainerId()).thenReturn(ContainerId
        .newContainerId(ApplicationAttemptId.newInstance(appId, 1), 0L));
    long idPrefix = TimelineServiceHelper.invertLong(
        aContainer.getContainerId().getContainerId());
    publisher.reportContainerResourceUsage(aContainer, 1024L, 8F);
    verifyPublishedResourceUsageMetrics(timelineClient, 1024L, 8, idPrefix);
    timelineClient.reset();

    publisher.reportContainerResourceUsage(aContainer, 1024L, 0.8F);
    verifyPublishedResourceUsageMetrics(timelineClient, 1024L, 1, idPrefix);
    timelineClient.reset();

    publisher.reportContainerResourceUsage(aContainer, 1024L, 0.49F);
    verifyPublishedResourceUsageMetrics(timelineClient, 1024L, 0, idPrefix);
    timelineClient.reset();

    publisher.reportContainerResourceUsage(aContainer, 1024L,
        (float) ResourceCalculatorProcessTree.UNAVAILABLE);
    verifyPublishedResourceUsageMetrics(timelineClient, 1024L,
        ResourceCalculatorProcessTree.UNAVAILABLE, idPrefix);
  }",Eager Test
"@Test
  public void testSelectCgroup() {
    File cpu = new File(cgroupDir, ""cpu"");
    File cpuNoExist = new File(cgroupDir, ""cpuNoExist"");
    File memory = new File(cgroupDir, ""memory"");
    try {
      CgroupsLCEResourcesHandler handler = new CgroupsLCEResourcesHandler();
      Map<String, Set<String>> cgroups = new LinkedHashMap<>();

      Assert.assertTrue(""temp dir should be created"", cpu.mkdirs());
      Assert.assertTrue(""temp dir should be created"", memory.mkdirs());
      Assert.assertFalse(""temp dir should not be created"", cpuNoExist.exists());

      cgroups.put(
          memory.getAbsolutePath(), Collections.singleton(""memory""));
      cgroups.put(
          cpuNoExist.getAbsolutePath(), Collections.singleton(""cpu""));
      cgroups.put(cpu.getAbsolutePath(), Collections.singleton(""cpu""));
      String selectedCPU = handler.findControllerInMtab(""cpu"", cgroups);
      Assert.assertEquals(""Wrong CPU mount point selected"",
          cpu.getAbsolutePath(), selectedCPU);
    }",Eager Test + Mystery Guest
"@Test
  public void testGetContainerMemoryMB() throws Exception {

    ResourceCalculatorPlugin plugin = new TestResourceCalculatorPlugin();
    long physicalMemMB = plugin.getPhysicalMemorySize() / (1024 * 1024);
    YarnConfiguration conf = new YarnConfiguration();
    conf.setBoolean(YarnConfiguration.NM_ENABLE_HARDWARE_CAPABILITY_DETECTION,
        true);
    long mem = NodeManagerHardwareUtils.getContainerMemoryMB(null, conf);
    Assert.assertEquals(YarnConfiguration.DEFAULT_NM_PMEM_MB, mem);

    mem = NodeManagerHardwareUtils.getContainerMemoryMB(plugin, conf);
    int hadoopHeapSizeMB =
        (int) (Runtime.getRuntime().maxMemory() / (1024 * 1024));
    int calculatedMemMB =
        (int) (0.8 * (physicalMemMB - (2 * hadoopHeapSizeMB)));
    Assert.assertEquals(calculatedMemMB, mem);

    conf.setInt(YarnConfiguration.NM_PMEM_MB, 1024);
    mem = NodeManagerHardwareUtils.getContainerMemoryMB(conf);
    Assert.assertEquals(1024, mem);

    conf = new YarnConfiguration();
    conf.setBoolean(YarnConfiguration.NM_ENABLE_HARDWARE_CAPABILITY_DETECTION,
        false);
    mem = NodeManagerHardwareUtils.getContainerMemoryMB(conf);
    Assert.assertEquals(YarnConfiguration.DEFAULT_NM_PMEM_MB, mem);
    conf.setInt(YarnConfiguration.NM_PMEM_MB, 10 * 1024);
    mem = NodeManagerHardwareUtils.getContainerMemoryMB(conf);
    Assert.assertEquals(10 * 1024, mem);
  }",Eager Test
"@Test
  public void testLogFileWithDriveLetter() throws Exception {
    
    ContainerImpl container = mock(ContainerImpl.class);
    
    ApplicationIdPBImpl appId = mock(ApplicationIdPBImpl.class);
    when(appId.toString()).thenReturn(""appId"");
    
    Application app = mock(Application.class);
    when(app.getAppId()).thenReturn(appId);
    
    ApplicationAttemptIdPBImpl appAttemptId =
               mock(ApplicationAttemptIdPBImpl.class);
    when(appAttemptId.getApplicationId()).thenReturn(appId); 
    
    ConcurrentMap<ApplicationId, Application> applications = 
      new ConcurrentHashMap<ApplicationId, Application>();
    applications.put(appId, app);
    
    ContainerId containerId = mock(ContainerIdPBImpl.class);
    when(containerId.toString()).thenReturn(""containerId"");
    when(containerId.getApplicationAttemptId()).thenReturn(appAttemptId);
    
    ConcurrentMap<ContainerId, Container> containers = 
      new ConcurrentHashMap<ContainerId, Container>();
    
    containers.put(containerId, container);
    
    LocalDirsHandlerService localDirs = mock(LocalDirsHandlerService.class);
    when(localDirs.getLogPathToRead(""appId"" + Path.SEPARATOR + ""containerId"" +
      Path.SEPARATOR + ""fileName""))
      .thenReturn(new Path(""F:/nmlogs/appId/containerId/fileName""));
    
    NMContext context = mock(NMContext.class);
    when(context.getLocalDirsHandler()).thenReturn(localDirs);
    when(context.getApplications()).thenReturn(applications);
    when(context.getContainers()).thenReturn(containers);
    
    File logFile = ContainerLogsUtils.getContainerLogFile(containerId,
      ""fileName"", null, context);
      
    Assert.assertTrue(""logFile lost drive letter "" +
      logFile,
      logFile.toString().indexOf(""F:"" + File.separator + ""nmlogs"") > -1);
    
  }",Eager Test
"@Test
  public void testRMWritingMassiveHistoryForCapacitySche() throws Exception {
    //test WritingMassiveHistory for Capacity Scheduler.
    testRMWritingMassiveHistory(false);
  }",No Smells
"@Test
  public void testWriteApplication() throws Exception {
    RMApp app = createRMApp(ApplicationId.newInstance(0, 1));

    writer.applicationStarted(app);
    ApplicationHistoryData appHD = null;
    for (int i = 0; i < MAX_RETRIES; ++i) {
      appHD = store.getApplication(ApplicationId.newInstance(0, 1));
      if (appHD != null) {
        break;
      }",Eager Test
"@Test
  public void testWriteApplicationAttempt() throws Exception {
    RMAppAttempt appAttempt =
        createRMAppAttempt(ApplicationAttemptId.newInstance(
          ApplicationId.newInstance(0, 1), 1));
    writer.applicationAttemptStarted(appAttempt);
    ApplicationAttemptHistoryData appAttemptHD = null;
    for (int i = 0; i < MAX_RETRIES; ++i) {
      appAttemptHD =
          store.getApplicationAttempt(ApplicationAttemptId.newInstance(
            ApplicationId.newInstance(0, 1), 1));
      if (appAttemptHD != null) {
        break;
      }",Eager Test
"@Test
  public void testSimpleBlacklistAboveFailureThreshold() {
    // Create a threshold of 0.5 * 3 i.e at 1.5 node failures.
    BlacklistManager manager = new SimpleBlacklistManager(3, 0.5);
    String anyNode = ""foo"";
    String anyNode2 = ""bar"";
    manager.addNode(anyNode);
    ResourceBlacklistRequest blacklist = manager
        .getBlacklistUpdates();

    List<String> blacklistAdditions = blacklist.getBlacklistAdditions();
    Collections.sort(blacklistAdditions);
    List<String> blacklistRemovals = blacklist.getBlacklistRemovals();
    String[] expectedBlacklistAdditions = new String[]{anyNode}",Eager Test
"@Test
  public void testAMResourcePercentForSkippedAMContainers() {
    int[][] qData = new int[][] {
        //  /   A   B
        { 100, 10, 90 }",No Smells
"@Test
  public void testContainerOrdering(){

    List<RMContainer> containers = new ArrayList<RMContainer>();

    ApplicationAttemptId appAttId = ApplicationAttemptId.newInstance(
        ApplicationId.newInstance(TS, 10), 0);

    // create a set of containers
    RMContainer rm1 = mockContainer(appAttId, 5, mock(Resource.class), 3);
    RMContainer rm2 = mockContainer(appAttId, 3, mock(Resource.class), 3);
    RMContainer rm3 = mockContainer(appAttId, 2, mock(Resource.class), 2);
    RMContainer rm4 = mockContainer(appAttId, 1, mock(Resource.class), 2);
    RMContainer rm5 = mockContainer(appAttId, 4, mock(Resource.class), 1);

    // insert them in non-sorted order
    containers.add(rm3);
    containers.add(rm2);
    containers.add(rm1);
    containers.add(rm5);
    containers.add(rm4);

    // sort them
    FifoCandidatesSelector.sortContainers(containers);

    // verify the ""priority""-first, ""reverse container-id""-second
    // ordering is enforced correctly
    assert containers.get(0).equals(rm1);
    assert containers.get(1).equals(rm2);
    assert containers.get(2).equals(rm3);
    assert containers.get(3).equals(rm4);
    assert containers.get(4).equals(rm5);

  }",Eager Test
"@Test
  public void testHierarchical() {
    int[][] qData = new int[][] {
      //  /    A   B   C    D   E   F
      { 200, 100, 50, 50, 100, 10, 90 }",No Smells
"@Test
  public void testHierarchicalLarge() {
    int[][] qData = new int[][] {
      //  /    A              D              G        
      //            B    C         E    F         H    I
      { 400, 200,  60, 140, 100,  70,  30, 100,  10,  90 }",No Smells
"@Test
  public void testHierarchicalWithReserved() {
    int[][] qData = new int[][] {
        //  /    A   B   C    D   E   F
        { 200, 100, 50, 50, 100, 10, 90 }",No Smells
"@Test
  public void testIgnore() {
    ProportionalCapacityPreemptionPolicy policy =
        buildPolicy(Q_DATA_FOR_IGNORE);
    policy.editSchedule();
    // don't correct imbalances without demand
    verify(mDisp, never()).handle(isA(ContainerPreemptEvent.class));
  }",No Smells
"@Test
  public void testOverCapacityImbalance() {
    int[][] qData = new int[][]{
      //  /   A   B   C
      { 100, 40, 40, 20 }",No Smells
"@Test
  public void testPerQueueDisablePreemptionBroadHierarchical() {
    int[][] qData = new int[][] {
        //  /    A              D              G    
        //            B    C         E    F         H    I
        {1000, 350, 150, 200, 400, 200, 200, 250, 100, 150 }",Redundent Print
"@Test
  public void testPreemptCycle() {
    int[][] qData = new int[][]{
      //  /   A   B   C
      { 100, 40, 40, 20 }",Redundent Print
"@Test
  public void testPreemptionNotHappenForSingleReservedQueue() {
    /*
     * Test case to make sure, when reserved > pending, preemption will not
     * happen if there's only one demanding queue.
     */

    int[][] qData = new int[][]{
        //  /   A   B   C
        { 100, 40, 40, 20 }",Redundent Print
"@Test
  public void testBuilderWithSpecifiedNodeResources() throws Exception {
    String labelsConfig =
        ""=200,true;"" + // default partition
            ""red=100,false;"" + // partition=red
            ""blue=200,true""; // partition=blue
    String nodesConfig =
        ""n1=red res=100;"" + // n1 has partition=red
            ""n2=blue;"" + // n2 has partition=blue
            ""n3= res=30""; // n3 doesn't have partition
    String queuesConfig =
        // guaranteed,max,used,pending
        ""root(=[200 200 100 100 100],red=[100 100 100 100 90],blue=[200 200 200 200 80]);"" + //root
            ""-a(=[100 200 100 100 50],red=[0 0 0 0 40],blue=[200 200 200 200 30]);"" + // a
            ""--a1(=[50 100 50 100 40],red=[0 0 0 0 20],blue=[100 200 200 0]);"" + // a1
            ""--a2(=[50 200 50 0 10],red=[0 0 0 0 20],blue=[100 200 0 200]);"" + // a2
            ""-b(=[100 200 0 0],red=[100 100 100 100],blue=[0 0 0 0])"";
    String appsConfig=
        //queueName\t(priority,resource,host,expression,#repeat,reserved)
        // app1 in a1, , 50 in n2 (reserved), 50 in n2 (allocated)
        ""a1\t"" // app1 in a1
            + ""(1,1,n3,red,50,false);"" + // 50 * default in n3

            ""a1\t"" // app2 in a1
            + ""(2,1,n2,,50,true)(2,1,n2,,50,false)"" // 50 * ignore-exclusivity (reserved),
            // 50 * ignore-exclusivity (allocated)
            + ""(2,1,n2,blue,50,true)(2,1,n2,blue,50,true);"" + // 50 in n2 (reserved),
            // 50 in n2 (allocated)
            ""a2\t"" // app3 in a2
            + ""(1,1,n3,red,50,false);"" + // 50 * default in n3

            ""b\t"" // app4 in b
            + ""(1,1,n1,red,100,false);"";

    buildEnv(labelsConfig, nodesConfig, queuesConfig, appsConfig);

    // Check host resources
    Assert.assertEquals(3, this.cs.getAllNodes().size());
    SchedulerNode node1 = cs.getSchedulerNode(NodeId.newInstance(""n1"", 1));
    Assert.assertEquals(100, node1.getTotalResource().getMemorySize());
    Assert.assertEquals(100, node1.getCopiedListOfRunningContainers().size());
    Assert.assertNull(node1.getReservedContainer());

    SchedulerNode node2 = cs.getSchedulerNode(NodeId.newInstance(""n2"", 1));
    Assert.assertEquals(0, node2.getTotalResource().getMemorySize());
    Assert.assertEquals(50, node2.getCopiedListOfRunningContainers().size());
    Assert.assertNotNull(node2.getReservedContainer());

    SchedulerNode node3 = cs.getSchedulerNode(NodeId.newInstance(""n3"", 1));
    Assert.assertEquals(30, node3.getTotalResource().getMemorySize());
    Assert.assertEquals(100, node3.getCopiedListOfRunningContainers().size());
    Assert.assertNull(node3.getReservedContainer());
  }",Eager Test
"@Test
  public void testAddNodeAttributes() throws IOException {
    Map<String, Set<NodeAttribute>> toAddAttributes = new HashMap<>();
    Map<NodeAttribute, AttributeValue> nodeAttributes;

    // Add 3 attributes to host1
    //  yarn.test1.io/A1=host1_v1_1
    //  yarn.test1.io/A2=host1_v1_2
    //  yarn.test1.io/A3=host1_v1_3
    toAddAttributes.put(HOSTNAMES[0],
        createAttributesForTest(PREFIXES[0], 3, ""A"", ""host1_v1""));

    attributesManager.addNodeAttributes(toAddAttributes);
    nodeAttributes = attributesManager.getAttributesForNode(HOSTNAMES[0]);

    Assert.assertEquals(3, nodeAttributes.size());
    Assert.assertTrue(sameAttributeSet(toAddAttributes.get(HOSTNAMES[0]),
        nodeAttributes.keySet()));

    // Add 2 attributes to host2
    //  yarn.test1.io/A1=host2_v1_1
    //  yarn.test1.io/A2=host2_v1_2
    toAddAttributes.clear();
    toAddAttributes.put(HOSTNAMES[1],
        createAttributesForTest(PREFIXES[0], 2, ""A"", ""host2_v1""));
    attributesManager.addNodeAttributes(toAddAttributes);

    // Verify host1 attributes are still valid.
    nodeAttributes = attributesManager.getAttributesForNode(HOSTNAMES[0]);
    Assert.assertEquals(3, nodeAttributes.size());

    // Verify new added host2 attributes are correctly updated.
    nodeAttributes = attributesManager.getAttributesForNode(HOSTNAMES[1]);
    Assert.assertEquals(2, nodeAttributes.size());
    Assert.assertTrue(sameAttributeSet(toAddAttributes.get(HOSTNAMES[1]),
        nodeAttributes.keySet()));

    // Cluster wide, it only has 3 attributes.
    //  yarn.test1.io/A1
    //  yarn.test1.io/A2
    //  yarn.test1.io/A3
    Set<NodeAttribute> clusterAttributes = attributesManager
        .getClusterNodeAttributes(Sets.newHashSet(PREFIXES[0]));
    Assert.assertEquals(3, clusterAttributes.size());

    // Query for attributes under a non-exist prefix,
    // ensure it returns an empty set.
    clusterAttributes = attributesManager
        .getClusterNodeAttributes(Sets.newHashSet(""non_exist_prefix""));
    Assert.assertEquals(0, clusterAttributes.size());

    // Not provide any prefix, ensure it returns all attributes.
    clusterAttributes = attributesManager.getClusterNodeAttributes(null);
    Assert.assertEquals(3, clusterAttributes.size());

    // Add some other attributes with different prefixes on host1 and host2.
    toAddAttributes.clear();

    // Host1
    //  yarn.test2.io/A_1=host1_v2_1
    //  ...
    //  yarn.test2.io/A_10=host1_v2_10
    toAddAttributes.put(HOSTNAMES[0],
        createAttributesForTest(PREFIXES[1], 10, ""C"", ""host1_v2""));
    // Host2
    //  yarn.test2.io/C_1=host1_v2_1
    //  ...
    //  yarn.test2.io/C_20=host1_v2_20
    toAddAttributes.put(HOSTNAMES[1],
        createAttributesForTest(PREFIXES[1], 20, ""C"", ""host1_v2""));
    attributesManager.addNodeAttributes(toAddAttributes);

    nodeAttributes = attributesManager.getAttributesForNode(HOSTNAMES[0]);
    Assert.assertEquals(13, nodeAttributes.size());

    nodeAttributes = attributesManager.getAttributesForNode(HOSTNAMES[1]);
    Assert.assertEquals(22, nodeAttributes.size());
  }",Eager Test
"@Test
  public void testRMNodeLabelsMappingProviderConfiguration() {
    conf.unset(YarnConfiguration.RM_NODE_LABELS_PROVIDER_CONFIG);
    try {
      MockRM rm = new MockRM(conf);
      rm.init(conf);
      rm.start();
      Assert.fail(""Expected an exception"");
    }",No Smells
"@Test
  public void testBadKeyIteration() throws Exception {
    stateStore = new LeveldbRMStateStore();
    stateStore.init(conf);
    stateStore.start();
    DB db = stateStore.getDatabase();
    // add an entry that appears at the end of the database when iterating
    db.put(JniDBFactory.bytes(""zzz""), JniDBFactory.bytes(""z""));
    stateStore.loadState();
  }",No Smells
"@Test
  public void testNotifyStoreOperationFailed() throws Exception {
    RMStateStore store = new MemoryRMStateStore() {
      @Override
      public synchronized void removeRMDelegationTokenState(
          RMDelegationTokenIdentifier rmDTIdentifier) throws Exception {
        throw new Exception(""testNotifyStoreOperationFailed"");
      }",No Smells
"@Test
  public void testReadRMDelegationTokenIdentifierDataOldFormat()
      throws Exception {
    testReadRMDelegationTokenIdentifierData(true);
  }",No Smells
"@Test
  public void testAppNodeSplit() throws Exception {
    TestZKRMStateStoreTester zkTester = new TestZKRMStateStoreTester();
    long submitTime = System.currentTimeMillis();
    long startTime = submitTime + 1234;
    Configuration conf = new YarnConfiguration();

    // Get store with app node split config set as 1.
    RMStateStore store = zkTester.getRMStateStore(createConfForAppNodeSplit(1));
    TestDispatcher dispatcher = new TestDispatcher();
    store.setRMDispatcher(dispatcher);

    // Create RM Context and app token manager.
    RMContext rmContext = mock(RMContext.class);
    when(rmContext.getStateStore()).thenReturn(store);
    AMRMTokenSecretManager appTokenMgr =
        spy(new AMRMTokenSecretManager(conf, rmContext));
    MasterKeyData masterKeyData = appTokenMgr.createNewMasterKey();
    when(appTokenMgr.getMasterKey()).thenReturn(masterKeyData);
    ClientToAMTokenSecretManagerInRM clientToAMTokenMgr =
        new ClientToAMTokenSecretManagerInRM();

    // Store app1.
    ApplicationId appId1 = ApplicationId.newInstance(1352994193343L, 1);
    ApplicationAttemptId attemptId1 =
        ApplicationAttemptId.newInstance(appId1, 1);
    ApplicationAttemptId attemptId2 =
        ApplicationAttemptId.newInstance(appId1, 2);
    storeAppWithAttempts(store, dispatcher, submitTime, startTime,
        appTokenMgr, clientToAMTokenMgr, attemptId1, attemptId2);

    // Store app2 with app id application_1352994193343_120213.
    ApplicationId appId21 = ApplicationId.newInstance(1352994193343L, 120213);
    storeApp(store, appId21, submitTime, startTime);
    waitNotify(dispatcher);

    // Store another app which will be removed.
    ApplicationId appIdRemoved = ApplicationId.newInstance(1352994193343L, 2);
    ApplicationAttemptId attemptIdRemoved =
        ApplicationAttemptId.newInstance(appIdRemoved, 1);
    storeAppWithAttempts(store, dispatcher, submitTime, startTime,
        null, null, attemptIdRemoved);
    // Remove the app.
    RMApp mockRemovedApp =
        createMockAppForRemove(appIdRemoved, attemptIdRemoved);
    store.removeApplication(mockRemovedApp);
    // Close state store
    store.close();

    // Load state store
    store = zkTester.getRMStateStore(createConfForAppNodeSplit(1));
    store.setRMDispatcher(dispatcher);
    RMState state = store.loadState();
    // Check if application_1352994193343_120213 (i.e. app2) exists in state
    // store as per split index.
    verifyAppPathPath(store, appId21, 1);

    // Verify loaded apps and attempts based on the operations we did before
    // reloading the state store.
    verifyLoadedApp(state, appId1, submitTime, startTime, 0, false,
        Lists.newArrayList(attemptId1, attemptId2), Lists.newArrayList(-1000,
        -1000), Lists.newArrayList((FinalApplicationStatus) null, null));

    // Update app state for app1.
    finishAppWithAttempts(state, store, dispatcher, attemptId2, submitTime,
        startTime, 100, 1234, false);

    // Test updating app/attempt for app whose initial state is not saved
    ApplicationId dummyAppId = ApplicationId.newInstance(1234, 10);
    ApplicationAttemptId dummyAttemptId =
        ApplicationAttemptId.newInstance(dummyAppId, 6);
    finishAppWithAttempts(state, store, dispatcher, dummyAttemptId, submitTime,
        startTime, 111, 1234, true);
    // Close the store
    store.close();

    // Check updated application state.
    store = zkTester.getRMStateStore(createConfForAppNodeSplit(1));
    store.setRMDispatcher(dispatcher);
    RMState newRMState = store.loadState();
    verifyLoadedApp(newRMState, dummyAppId, submitTime, startTime, 1234, true,
        Lists.newArrayList(dummyAttemptId), Lists.newArrayList(111),
        Lists.newArrayList(FinalApplicationStatus.SUCCEEDED));
    verifyLoadedApp(newRMState, appId1, submitTime, startTime, 1234, true,
        Lists.newArrayList(attemptId1, attemptId2),
        Lists.newArrayList(-1000, 100), Lists.newArrayList(null,
        FinalApplicationStatus.SUCCEEDED));

    // assert store is in expected state after everything is cleaned
    assertTrue(""Store is not in expected state"", zkTester.isFinalStateValid());
    store.close();
  }",Eager Test
"@Test
  public void testDelegationTokenNodeNoSplit() throws Exception {
    testDelegationTokenNode(0);
  }",No Smells
"@Test
  public void testDelegationTokenNodeWithSplitOne() throws Exception {
    testDelegationTokenNode(1);
  }",No Smells
"@Test
  public void testDelegationTokenNodeWithSplitThree() throws Exception {
    testDelegationTokenNode(3);
  }",No Smells
"@Test
  public void testDuplicateRMAppDeletion() throws Exception {
    TestZKRMStateStoreTester zkTester = new TestZKRMStateStoreTester();
    long submitTime = System.currentTimeMillis();
    long startTime = System.currentTimeMillis() + 1234;
    RMStateStore store = zkTester.getRMStateStore();
    TestDispatcher dispatcher = new TestDispatcher();
    store.setRMDispatcher(dispatcher);

    ApplicationAttemptId attemptIdRemoved = ApplicationAttemptId.fromString(
        ""appattempt_1352994193343_0002_000001"");
    ApplicationId appIdRemoved = attemptIdRemoved.getApplicationId();
    storeApp(store, appIdRemoved, submitTime, startTime);
    storeAttempt(store, attemptIdRemoved,
        ""container_1352994193343_0002_01_000001"", null, null, dispatcher);

    ApplicationSubmissionContext context =
        new ApplicationSubmissionContextPBImpl();
    context.setApplicationId(appIdRemoved);

    ApplicationStateData appStateRemoved =
        ApplicationStateData.newInstance(
            submitTime, startTime, context, ""user1"");
    appStateRemoved.attempts.put(attemptIdRemoved, null);
    store.removeApplicationStateInternal(appStateRemoved);
    try {
      store.removeApplicationStateInternal(appStateRemoved);
    }",Eager Test
"@Test
  public void testAll() throws PlanningException {
    prepareBasicPlan();
    // create an ALL request
    ReservationDefinition rr = new ReservationDefinitionPBImpl();
    rr.setArrival(100 * step);
    rr.setDeadline(120 * step);
    rr.setRecurrenceExpression(recurrenceExpression);
    ReservationRequests reqs = new ReservationRequestsPBImpl();
    reqs.setInterpreter(ReservationRequestInterpreter.R_ALL);
    ReservationRequest r = ReservationRequest.newInstance(
        Resource.newInstance(1024, 1), 5, 5, 10 * step);
    ReservationRequest r2 = ReservationRequest.newInstance(
        Resource.newInstance(2048, 2), 10, 10, 20 * step);

    List<ReservationRequest> list = new ArrayList<ReservationRequest>();
    list.add(r);
    list.add(r2);
    reqs.setReservationResources(list);
    rr.setReservationRequests(reqs);

    // submit to agent
    ReservationId reservationID = ReservationSystemTestUtil
        .getNewReservationId();
    agent.createReservation(reservationID, ""u1"", plan, rr);

    // validate results, we expect the second one to be accepted
    assertTrue(""Agent-based allocation failed"", reservationID != null);
    assertTrue(""Agent-based allocation failed"", plan.getAllReservations()
        .size() == 3);

    ReservationAllocation cs = plan.getReservationById(reservationID);

    if (allocateLeft) {
      assertTrue(cs.toString(), check(cs, 100 * step, 110 * step, 25, 1024, 1));
      assertTrue(cs.toString(), check(cs, 110 * step, 120 * step, 20, 1024, 1));
    }",Eager Test
"@Test
  public void testAnyImpossible() throws PlanningException {
    prepareBasicPlan();
    // create an ANY request, with all impossible alternatives
    ReservationDefinition rr = new ReservationDefinitionPBImpl();
    rr.setArrival(100L);
    rr.setDeadline(120L);
    rr.setRecurrenceExpression(recurrenceExpression);
    ReservationRequests reqs = new ReservationRequestsPBImpl();
    reqs.setInterpreter(ReservationRequestInterpreter.R_ANY);

    // longer than arrival-deadline
    ReservationRequest r1 = ReservationRequest.newInstance(
        Resource.newInstance(1024, 1), 35, 5, 30);
    // above max cluster size
    ReservationRequest r2 = ReservationRequest.newInstance(
        Resource.newInstance(1024, 1), 110, 110, 10);

    List<ReservationRequest> list = new ArrayList<ReservationRequest>();
    list.add(r1);
    list.add(r2);
    reqs.setReservationResources(list);
    rr.setReservationRequests(reqs);

    ReservationId reservationID = ReservationSystemTestUtil
        .getNewReservationId();
    boolean result = false;
    try {
      // submit to agent
      result = agent.createReservation(reservationID, ""u1"", plan, rr);
      fail();
    }",Eager Test
"@Test
  public void testOrderNoGapImpossible() throws PlanningException {
    prepareBasicPlan();
    // create a completely utilized segment at time 30
    int[] f = { 100, 100 }",Eager Test
"@Test
  public void testSimple() throws PlanningException {

    prepareBasicPlan();

    // create a request with a single atomic ask
    ReservationDefinition rr = new ReservationDefinitionPBImpl();
    rr.setArrival(5 * step);
    rr.setDeadline(20 * step);
    rr.setRecurrenceExpression(recurrenceExpression);
    ReservationRequest r = ReservationRequest.newInstance(
        Resource.newInstance(2048, 2), 10, 5, 10 * step);
    ReservationRequests reqs = new ReservationRequestsPBImpl();
    reqs.setReservationResources(Collections.singletonList(r));
    rr.setReservationRequests(reqs);

    ReservationId reservationID = ReservationSystemTestUtil
        .getNewReservationId();
    agent.createReservation(reservationID, ""u1"", plan, rr);

    assertTrue(""Agent-based allocation failed"", reservationID != null);
    assertTrue(""Agent-based allocation failed"", plan.getAllReservations()
        .size() == 3);

    ReservationAllocation cs = plan.getReservationById(reservationID);

    System.out.println(""--------AFTER SIMPLE ALLOCATION (queue: ""
        + reservationID + "")----------"");
    System.out.println(plan.toString());
    System.out.println(plan.toCumulativeString());

    if(allocateLeft){
      for (long i = 5 * step; i < 15 * step; i++) {
        assertTrue(
            ""Agent-based allocation unexpected"",
            Resources.equals(cs.getResourcesAtTime(i),
                Resource.newInstance(2048 * 10, 2 * 10)));
      }",Eager Test
"@Test
  public void testSingleSliding() throws PlanningException {
    prepareBasicPlan();

    // create a single request for which we need subsequent (tight) packing.
    ReservationDefinition rr = new ReservationDefinitionPBImpl();
    rr.setArrival(100 * step);
    rr.setDeadline(120 * step);
    rr.setRecurrenceExpression(recurrenceExpression);
    ReservationRequests reqs = new ReservationRequestsPBImpl();
    reqs.setInterpreter(ReservationRequestInterpreter.R_ALL);
    ReservationRequest r = ReservationRequest.newInstance(
        Resource.newInstance(1024, 1), 200, 10, 10 * step);

    List<ReservationRequest> list = new ArrayList<ReservationRequest>();
    list.add(r);
    reqs.setReservationResources(list);
    rr.setReservationRequests(reqs);

    // submit to agent
    ReservationId reservationID = ReservationSystemTestUtil
        .getNewReservationId();
    agent.createReservation(reservationID, ""u1"", plan, rr);

    // validate results, we expect the second one to be accepted
    assertTrue(""Agent-based allocation failed"", reservationID != null);
    assertTrue(""Agent-based allocation failed"", plan.getAllReservations()
        .size() == 3);

    ReservationAllocation cs = plan.getReservationById(reservationID);

    assertTrue(cs.toString(), check(cs, 100 * step, 120 * step, 100, 1024, 1));

    System.out.println(""--------AFTER packed ALLOCATION (queue: ""
        + reservationID + "")----------"");
    System.out.println(plan.toString());
    System.out.println(plan.toCumulativeString());

  }",Eager Test
"@Test
  public void testReplanningPlanCapacityLoss() throws PlanningException {

    Resource clusterCapacity = Resource.newInstance(100 * 1024, 100);
    Resource minAlloc = Resource.newInstance(1024, 1);
    Resource maxAlloc = Resource.newInstance(1024 * 8, 8);

    ResourceCalculator res = new DefaultResourceCalculator();
    long step = 1L;
    Clock clock = mock(Clock.class);
    ReservationAgent agent = mock(ReservationAgent.class);

    SharingPolicy policy = new NoOverCommitPolicy();
    policy.init(""root.dedicated"", null);

    QueueMetrics queueMetrics = mock(QueueMetrics.class);

    when(clock.getTime()).thenReturn(0L);
    SimpleCapacityReplanner enf = new SimpleCapacityReplanner(clock);

    RMContext context = ReservationSystemTestUtil.createMockRMContext();
    ReservationSchedulerConfiguration conf =
        mock(ReservationSchedulerConfiguration.class);
    when(conf.getEnforcementWindow(any(QueuePath.class))).thenReturn(6L);

    enf.init(""blah"", conf);

    // Initialize the plan with more resources
    InMemoryPlan plan = new InMemoryPlan(queueMetrics, policy, agent,
        clusterCapacity, step, res, minAlloc, maxAlloc, ""dedicated"", enf, true,
        YarnConfiguration.DEFAULT_RM_RESERVATION_SYSTEM_MAX_PERIODICITY,
        context, clock);

    // add reservation filling the plan (separating them 1ms, so we are sure
    // s2 follows s1 on acceptance
    long ts = System.currentTimeMillis();
    ReservationId r1 = ReservationId.newInstance(ts, 1);
    int[] f5 = { 20, 20, 20, 20, 20 }",Eager Test
"@Test
  public void testNegativeGetReservationSearchIntervalCloseToEndTime() {
    // Reservation duration is 10 minutes
    long reservationStart = Timestamp.valueOf(""2050-12-03 10:37:37"").getTime();
    long reservationEnd = Timestamp.valueOf(""2050-12-03 10:47:37"").getTime();

    // Reservation does not fit within search interval, but is close to the end
    // time.
    long searchStart = Timestamp.valueOf(""2050-12-03 10:48:37"").getTime();
    long searchEnd = Timestamp.valueOf(""2050-12-03 10:50:37"").getTime();

    // 60 minute period in milliseconds.
    long period = 60 * 60 * 1000;

    testNegativeGetRecurringReservationsHelper(reservationStart,
        reservationEnd, searchStart, searchEnd, 100, period, 10);
  }",Eager Test
"@Test
  public void testZeroAlloaction() {
    ReservationId reservationID =
        ReservationId.newInstance(rand.nextLong(), rand.nextLong());
    int[] alloc = {}",Eager Test
"@Test
  public void testMaxPeriodicCapacity() {
    int[] alloc = { 2, 5, 7, 10, 3, 4, 6, 8 }",No Smells
"@Test
  public void testMixPeriodicAndNonPeriodic() throws PlanningException {
    int[] alloc = { 2, 5, 0 }",No Smells
"@Test
  public void testPeriodicCapacity() {
    int[] alloc = { 10, 7, 5, 2, 0 }",No Smells
"@Test
  public void testSetCapacityInInterval() {
    int[] alloc = { 2, 5, 0 }",No Smells
"@Test
  public void testDeleteReservationInvalidPlan() {
    ReservationDeleteRequest request = new ReservationDeleteRequestPBImpl();
    ReservationId reservationID =
        ReservationSystemTestUtil.getNewReservationId();
    request.setReservationId(reservationID);
    when(rSystem.getPlan(PLAN_NAME)).thenReturn(null);
    Plan plan = null;
    try {
      plan = rrValidator.validateReservationDeleteRequest(rSystem, request);
      Assert.fail();
    }",No Smells
"@Test
  public void testListReservationsNullPlan() {
    ReservationListRequest request = new ReservationListRequestPBImpl();
    request.setQueue(ReservationSystemTestUtil.reservationQ);
    when(rSystem.getPlan(ReservationSystemTestUtil.reservationQ)).thenReturn
            (null);
    Plan plan = null;
    try {
      plan = rrValidator.validateReservationListRequest(rSystem, request);
      Assert.fail();
    }",No Smells
"@Test
  public void testSubmitReservationExceedsGangSize() {
    ReservationSubmissionRequest request =
        createSimpleReservationSubmissionRequest(1, 1, 1, 5, 4);
    Resource resource = Resource.newInstance(512, 1);
    when(plan.getTotalCapacity()).thenReturn(resource);
    Plan plan = null;
    try {
      plan =
          rrValidator.validateReservationSubmissionRequest(rSystem, request,
              ReservationSystemTestUtil.getNewReservationId());
      Assert.fail();
    }",No Smells
"@Test
  public void testSubmitReservationInvalidDeadline() {
    ReservationSubmissionRequest request =
        createSimpleReservationSubmissionRequest(1, 1, 1, 0, 3);
    Plan plan = null;
    try {
      plan =
          rrValidator.validateReservationSubmissionRequest(rSystem, request,
              ReservationSystemTestUtil.getNewReservationId());
      Assert.fail();
    }",No Smells
"@Test
  public void testSubmitReservationInvalidRR() {
    ReservationSubmissionRequest request =
        createSimpleReservationSubmissionRequest(0, 0, 1, 5, 3);
    Plan plan = null;
    try {
      plan =
          rrValidator.validateReservationSubmissionRequest(rSystem, request,
              ReservationSystemTestUtil.getNewReservationId());
      Assert.fail();
    }",No Smells
"@Test
  public void testSubmitReservationNegativeRecurrenceExpression() {
    ReservationSubmissionRequest request =
        createSimpleReservationSubmissionRequest(1, 1, 1, 5, 3, ""-1234"");
    plan = null;
    try {
      plan =
          rrValidator.validateReservationSubmissionRequest(rSystem, request,
              ReservationSystemTestUtil.getNewReservationId());
      Assert.fail();
    }",No Smells
"@Test
  public void testUpdateReservationExceedsGangSize() {
    ReservationUpdateRequest request =
        createSimpleReservationUpdateRequest(1, 1, 1, 5, 4);
    Resource resource = Resource.newInstance(512, 1);
    when(plan.getTotalCapacity()).thenReturn(resource);
    Plan plan = null;
    try {
      plan = rrValidator.validateReservationUpdateRequest(rSystem, request);
      Assert.fail();
    }",No Smells
"@Test
  public void testUpdateReservationInvalidRecurrenceExpression() {
    // first check recurrence expression
    ReservationUpdateRequest request =
        createSimpleReservationUpdateRequest(1, 1, 1, 5, 3, ""123abc"");
    plan = null;
    try {
      plan =
          rrValidator.validateReservationUpdateRequest(rSystem, request);
      Assert.fail();
    }",No Smells
"@Test
  public void testUpdateReservationNormal() {
    ReservationUpdateRequest request =
        createSimpleReservationUpdateRequest(1, 1, 1, 5, 3);
    Plan plan = null;
    try {
      plan = rrValidator.validateReservationUpdateRequest(rSystem, request);
    }",No Smells
"@Test
  public void testUpdateReservationValidRecurrenceExpression() {
    ReservationUpdateRequest request =
        createSimpleReservationUpdateRequest(1, 1, 1, 5, 3, ""600000"");
    plan = null;
    try {
      plan =
          rrValidator.validateReservationUpdateRequest(rSystem, request);
    }",No Smells
"@Test
  public void testInitialize() throws IOException {
    try {
      reservationSystem.reinitialize(scheduler.getConfig(), rmContext);
    }",Eager Test
"@Test
  public void testConvertAllocationsToReservationInfoEmptyAllocations() {
    long startTime = new Date().getTime();
    long step = 10000;
    int[] alloc = {}",Eager Test + Redundent Print
"@Test
  public void testMaxPeriodicCapacity() {
    long[] timeSteps = { 0L, 1L, 2L, 3L, 4L, 5L, 6L, 7L }",No Smells
"@Test
  public void testMergeMin() throws PlanningException {

    TreeMap<Long, Resource> a = new TreeMap<>();
    TreeMap<Long, Resource> b = new TreeMap<>();

    setupArrays(a, b);

    RLESparseResourceAllocation rleA =
        new RLESparseResourceAllocation(a, new DefaultResourceCalculator());
    RLESparseResourceAllocation rleB =
        new RLESparseResourceAllocation(b, new DefaultResourceCalculator());

    RLESparseResourceAllocation out =
        RLESparseResourceAllocation.merge(new DefaultResourceCalculator(),
            Resource.newInstance(100 * 128 * 1024, 100 * 32), rleA, rleB,
            RLEOperator.min, 0, 60);

    System.out.println(out);

    long[] time = { 10, 22, 33, 40, 43, 50, 60 }",Eager Test
"@Test
  public void testCachedResolverWithEvent() throws Exception {
    GenericTestUtils.setRootLogLevel(Level.DEBUG);

    YarnConfiguration conf = new YarnConfiguration();
    conf.setInt(YarnConfiguration.RM_NODE_IP_CACHE_EXPIRY_INTERVAL_SECS, 30);

    MockRM rm = new MockRM(conf);
    rm.init(conf);
    NodesListManager nodesListManager = rm.getNodesListManager();
    nodesListManager.init(conf);
    nodesListManager.start();

    NodesListManager.CachedResolver resolver =
        (NodesListManager.CachedResolver)nodesListManager.getResolver();

    resolver.addToCache(""testCachedResolverHost1"", ""1.1.1.1"");
    resolver.addToCache(""testCachedResolverHost2"", ""1.1.1.2"");
    Assert.assertEquals(""1.1.1.1"",
        resolver.resolve(""testCachedResolverHost1""));
    Assert.assertEquals(""1.1.1.2"",
        resolver.resolve(""testCachedResolverHost2""));

    RMNode rmnode1 = MockNodes.newNodeInfo(1, Resource.newInstance(28000, 8),
        1, ""testCachedResolverHost1"", 1234);
    RMNode rmnode2 = MockNodes.newNodeInfo(1, Resource.newInstance(28000, 8),
        1, ""testCachedResolverHost2"", 1234);

    nodesListManager.handle(
        new NodesListManagerEvent(NodesListManagerEventType.NODE_USABLE,
            rmnode1));
    Assert.assertNotEquals(""1.1.1.1"",
        resolver.resolve(""testCachedResolverHost1""));
    Assert.assertEquals(""1.1.1.2"",
        resolver.resolve(""testCachedResolverHost2""));

    nodesListManager.handle(
        new NodesListManagerEvent(NodesListManagerEventType.NODE_USABLE,
            rmnode2));
    Assert.assertNotEquals(""1.1.1.1"",
        resolver.resolve(""testCachedResolverHost1""));
    Assert.assertNotEquals(""1.1.1.2"",
        resolver.resolve(""testCachedResolverHost2""));

  }",Eager Test
"@Test
  public void testExistenceOfResourceRequestInRMContainer() throws Exception {
    Configuration conf = new Configuration();
    MockRM rm1 = new MockRM(conf);
    rm1.start();
    MockNM nm1 = rm1.registerNode(""unknownhost:1234"", 8000);
    RMApp app1 = MockRMAppSubmitter.submitWithMemory(1024, rm1);
    MockAM am1 = MockRM.launchAndRegisterAM(app1, rm1, nm1);
    ResourceScheduler scheduler = rm1.getResourceScheduler();

    // request a container.
    am1.allocate(""127.0.0.1"", 1024, 1, new ArrayList<ContainerId>());
    ContainerId containerId2 = ContainerId.newContainerId(
        am1.getApplicationAttemptId(), 2);
    rm1.waitForState(nm1, containerId2, RMContainerState.ALLOCATED);

    // Verify whether list of ResourceRequest is present in RMContainer
    // while moving to ALLOCATED state
    Assert.assertNotNull(
        scheduler.getRMContainer(containerId2).getContainerRequest());

    // Allocate container
    am1.allocate(new ArrayList<ResourceRequest>(), new ArrayList<ContainerId>())
        .getAllocatedContainers();
    rm1.waitForState(nm1, containerId2, RMContainerState.ACQUIRED);

    // After RMContainer moving to ACQUIRED state, list of ResourceRequest will
    // be empty
    Assert.assertNull(
        scheduler.getRMContainer(containerId2).getContainerRequest());
  }",Eager Test
"@Test
  public void testHDFSBackedProvider() throws Exception {
    File testSchedulerConfigurationDir = new File(
        TestMutableCSConfigurationProvider.class.getResource("""").getPath()
            + TestMutableCSConfigurationProvider.class.getSimpleName());
    FileUtils.deleteDirectory(testSchedulerConfigurationDir);
    testSchedulerConfigurationDir.mkdirs();

    Configuration conf = new Configuration(false);
    conf.set(YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,
        YarnConfiguration.FS_CONFIGURATION_STORE);
    conf.set(YarnConfiguration.SCHEDULER_CONFIGURATION_FS_PATH,
        testSchedulerConfigurationDir.getAbsolutePath());
    writeConf(conf, testSchedulerConfigurationDir.getAbsolutePath());

    confProvider.init(conf);
    assertNull(confProvider.loadConfiguration(conf)
        .get(""yarn.scheduler.capacity.root.a.goodKey""));

    LogMutation log = confProvider.logAndApplyMutation(TEST_USER, goodUpdate);
    confProvider.confirmPendingMutation(log, true);
    assertEquals(""goodVal"", confProvider.loadConfiguration(conf)
        .get(""yarn.scheduler.capacity.root.a.goodKey""));

    assertNull(confProvider.loadConfiguration(conf).get(
        ""yarn.scheduler.capacity.root.a.badKey""));
    log = confProvider.logAndApplyMutation(TEST_USER, badUpdate);
    confProvider.confirmPendingMutation(log, false);
    assertNull(confProvider.loadConfiguration(conf).get(
        ""yarn.scheduler.capacity.root.a.badKey""));

    confProvider.formatConfigurationInStore(conf);
    assertNull(confProvider.loadConfiguration(conf)
        .get(""yarn.scheduler.capacity.root.a.goodKey""));

  }",Eager Test + Mystery Guest
"@Test
  public void testPriorityUtilizationOrdering() {
    PriorityUtilizationQueueOrderingPolicy policy =
        new PriorityUtilizationQueueOrderingPolicy(true);

    // Case 1, one queue
    policy.setQueues(mockCSQueues(new String[] { ""a"" }",Eager Test
"@Test
  public void testUtilizationOrdering() {
    PriorityUtilizationQueueOrderingPolicy policy =
        new PriorityUtilizationQueueOrderingPolicy(false);

    // Case 1, one queue
    policy.setQueues(mockCSQueues(new String[] { ""a"" }",Eager Test
"@Test
  public void testAllocateReorder() throws Exception {

    //Confirm that allocation (resource request) alone will trigger a change in
    //application ordering where appropriate

    Configuration conf = new Configuration();
    conf.setClass(YarnConfiguration.RM_SCHEDULER, CapacityScheduler.class,
        ResourceScheduler.class);
    MockRM rm = new MockRM(conf);
    rm.start();
    CapacityScheduler cs = (CapacityScheduler) rm.getResourceScheduler();

    LeafQueue q = (LeafQueue) cs.getQueue(""default"");
    Assert.assertNotNull(q);

    FairOrderingPolicy fop = new FairOrderingPolicy();
    fop.setSizeBasedWeight(true);
    q.setOrderingPolicy(fop);

    String host = ""127.0.0.1"";
    RMNode node =
        MockNodes.newNodeInfo(0, MockNodes.newResource(4 * GB), 1, host);
    cs.handle(new NodeAddedSchedulerEvent(node));

    ApplicationAttemptId appAttemptId1 = appHelper(rm, cs, 100, 1, ""default"", ""user"");
    ApplicationAttemptId appAttemptId2 = appHelper(rm, cs, 100, 2, ""default"", ""user"");

    RecordFactory recordFactory =
      RecordFactoryProvider.getRecordFactory(null);

    Priority priority = TestUtils.createMockPriority(1);
    ResourceRequest r1 = TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 1, true, priority, recordFactory);

    //This will allocate for app1
    cs.allocate(appAttemptId1,
        Collections.<ResourceRequest>singletonList(r1), null, Collections.<ContainerId>emptyList(),
        null, null, NULL_UPDATE_REQUESTS);

    //And this will result in container assignment for app1
    CapacityScheduler.schedule(cs);

    //Verify that app1 is still first in assignment order
    //This happens because app2 has no demand/a magnitude of NaN, which
    //results in app1 and app2 being equal in the fairness comparison and
    //failling back to fifo (start) ordering
    assertEquals(q.getOrderingPolicy().getAssignmentIterator(
        IteratorSelector.EMPTY_ITERATOR_SELECTOR).next().getId(),
        appAttemptId1.getApplicationId().toString());

    //Now, allocate for app2 (this would be the first/AM allocation)
    ResourceRequest r2 = TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 1, true, priority, recordFactory);
    cs.allocate(appAttemptId2,
        Collections.<ResourceRequest>singletonList(r2), null, Collections.<ContainerId>emptyList(),
        null, null, NULL_UPDATE_REQUESTS);

    //In this case we do not perform container assignment because we want to
    //verify re-ordering based on the allocation alone

    //Now, the first app for assignment is app2
    assertEquals(q.getOrderingPolicy().getAssignmentIterator(
        IteratorSelector.EMPTY_ITERATOR_SELECTOR).next().getId(),
        appAttemptId2.getApplicationId().toString());

    rm.stop();
  }",Eager Test
"@Test
  public void testApplicationHeadRoom() throws Exception {
    Configuration conf = new Configuration();
    conf.setClass(YarnConfiguration.RM_SCHEDULER, CapacityScheduler.class,
        ResourceScheduler.class);
    MockRM rm = new MockRM(conf);
    rm.start();
    CapacityScheduler cs = (CapacityScheduler) rm.getResourceScheduler();

    ApplicationId appId = BuilderUtils.newApplicationId(100, 1);
    ApplicationAttemptId appAttemptId =
        BuilderUtils.newApplicationAttemptId(appId, 1);

    RMAppAttemptMetrics attemptMetric =
        new RMAppAttemptMetrics(appAttemptId, rm.getRMContext());
    RMAppImpl app = mock(RMAppImpl.class);
    when(app.getApplicationId()).thenReturn(appId);
    RMAppAttemptImpl attempt = mock(RMAppAttemptImpl.class);
    Container container = mock(Container.class);
    when(attempt.getMasterContainer()).thenReturn(container);
    ApplicationSubmissionContext submissionContext = mock(
        ApplicationSubmissionContext.class);
    when(attempt.getSubmissionContext()).thenReturn(submissionContext);
    when(attempt.getAppAttemptId()).thenReturn(appAttemptId);
    when(attempt.getRMAppAttemptMetrics()).thenReturn(attemptMetric);
    when(app.getCurrentAppAttempt()).thenReturn(attempt);

    rm.getRMContext().getRMApps().put(appId, app);

    SchedulerEvent addAppEvent =
        new AppAddedSchedulerEvent(appId, ""default"", ""user"");
    cs.handle(addAppEvent);
    SchedulerEvent addAttemptEvent =
        new AppAttemptAddedSchedulerEvent(appAttemptId, false);
    cs.handle(addAttemptEvent);

    Allocation allocate =
        cs.allocate(appAttemptId, Collections.<ResourceRequest> emptyList(),
            null, Collections.<ContainerId> emptyList(), null, null,
            NULL_UPDATE_REQUESTS);

    Assert.assertNotNull(attempt);

    Assert
        .assertEquals(Resource.newInstance(0, 0), allocate.getResourceLimit());
    Assert.assertEquals(Resource.newInstance(0, 0),
        attemptMetric.getApplicationAttemptHeadroom());

    // Add a node to cluster
    Resource newResource = Resource.newInstance(4 * GB, 1);
    RMNode node = MockNodes.newNodeInfo(0, newResource, 1, ""127.0.0.1"");
    cs.handle(new NodeAddedSchedulerEvent(node));

    allocate =
        cs.allocate(appAttemptId, Collections.<ResourceRequest> emptyList(),
            null, Collections.<ContainerId> emptyList(), null, null,
            NULL_UPDATE_REQUESTS);

    // All resources should be sent as headroom
    Assert.assertEquals(newResource, allocate.getResourceLimit());
    Assert.assertEquals(newResource,
        attemptMetric.getApplicationAttemptHeadroom());

    rm.stop();
  }",Eager Test
"@Test
  public void testCapacityScheduler() throws Exception {

    LOG.info(""--- START: testCapacityScheduler ---"");

    NodeStatus mockNodeStatus = createMockNodeStatus();

    // Register node1
    String host_0 = ""host_0"";
    NodeManager nm_0 =
        registerNode(resourceManager, host_0, 1234, 2345, NetworkTopology.DEFAULT_RACK,
            Resources.createResource(4 * GB, 1), mockNodeStatus);

    // Register node2
    String host_1 = ""host_1"";
    NodeManager nm_1 =
        registerNode(resourceManager, host_1, 1234, 2345, NetworkTopology.DEFAULT_RACK,
            Resources.createResource(2 * GB, 1), mockNodeStatus);

    // ResourceRequest priorities
    Priority priority_0 = Priority.newInstance(0);
    Priority priority_1 = Priority.newInstance(1);

    // Submit an application
    Application application_0 = new Application(""user_0"", ""a1"", resourceManager);
    application_0.submit();

    application_0.addNodeManager(host_0, 1234, nm_0);
    application_0.addNodeManager(host_1, 1234, nm_1);

    Resource capability_0_0 = Resources.createResource(1 * GB, 1);
    application_0.addResourceRequestSpec(priority_1, capability_0_0);

    Resource capability_0_1 = Resources.createResource(2 * GB, 1);
    application_0.addResourceRequestSpec(priority_0, capability_0_1);

    Task task_0_0 = new Task(application_0, priority_1,
        new String[] {host_0, host_1}",Eager Test
"@Test
  public void testCapacitySchedulerInfo() throws Exception {
    QueueInfo queueInfo = resourceManager.getResourceScheduler().getQueueInfo(""a"", true, true);
    Assert.assertEquals(""Queue Name should be a"", ""a"",
        queueInfo.getQueueName());
    Assert.assertEquals(""Queue Path should be root.a"", ""root.a"",
        queueInfo.getQueuePath());
    Assert.assertEquals(""Child Queues size should be 2"", 2,
        queueInfo.getChildQueues().size());

    List<QueueUserACLInfo> userACLInfo = resourceManager.getResourceScheduler().getQueueUserAclInfo();
    Assert.assertNotNull(userACLInfo);
    for (QueueUserACLInfo queueUserACLInfo : userACLInfo) {
      Assert.assertEquals(1, getQueueCount(userACLInfo,
          queueUserACLInfo.getQueueName()));
    }",Eager Test
"@Test
  public void testCSQueueBlocked() throws Exception {
    CapacitySchedulerConfiguration conf = new CapacitySchedulerConfiguration();
    setupBlockedQueueConfiguration(conf);
    conf.setClass(YarnConfiguration.RM_SCHEDULER, CapacityScheduler.class,
        ResourceScheduler.class);
    MockRM rm = new MockRM(conf);
    rm.start();
    CapacityScheduler cs = (CapacityScheduler) rm.getResourceScheduler();
    LeafQueue q = (LeafQueue) cs.getQueue(""a"");

    Assert.assertNotNull(q);
    String host = ""127.0.0.1"";
    String host1 = ""test"";
    RMNode node =
        MockNodes.newNodeInfo(0, Resource.newInstance(8 * GB, 8), 1, host);
    RMNode node1 =
        MockNodes.newNodeInfo(0, Resource.newInstance(8 * GB, 8), 2, host1);
    cs.handle(new NodeAddedSchedulerEvent(node));
    cs.handle(new NodeAddedSchedulerEvent(node1));
    //add app begin
    ApplicationAttemptId appAttemptId1 =
        appHelper(rm, cs, 100, 1, ""a"", ""user1"");
    ApplicationAttemptId appAttemptId2 =
        appHelper(rm, cs, 100, 2, ""b"", ""user2"");
    //add app end

    RecordFactory recordFactory =
        RecordFactoryProvider.getRecordFactory(null);

    Priority priority = TestUtils.createMockPriority(1);
    ResourceRequest r1 = TestUtils.createResourceRequest(
        ResourceRequest.ANY, 2 * GB, 1, true, priority, recordFactory);
    //This will allocate for app1
    cs.allocate(appAttemptId1, Collections.<ResourceRequest>singletonList(r1),
        null, Collections.<ContainerId>emptyList(),
        null, null, NULL_UPDATE_REQUESTS).getContainers().size();
    CapacityScheduler.schedule(cs);
    ResourceRequest r2 = null;
    for (int i =0; i < 13; i++) {
      r2 = TestUtils.createResourceRequest(
          ResourceRequest.ANY, 1 * GB, 1, true, priority, recordFactory);
      cs.allocate(appAttemptId2,
          Collections.<ResourceRequest>singletonList(r2), null, Collections.<ContainerId>emptyList(),
          null, null, NULL_UPDATE_REQUESTS);
      CapacityScheduler.schedule(cs);
    }",Eager Test
"@Test
  public void testContainerTokenGeneratedOnPullRequest() throws Exception {
    MockRM rm1 = new MockRM(conf);
    rm1.start();
    MockNM nm1 = rm1.registerNode(""127.0.0.1:1234"", 8000);
    RMApp app1 = MockRMAppSubmitter.submitWithMemory(200, rm1);
    MockAM am1 = MockRM.launchAndRegisterAM(app1, rm1, nm1);
    // request a container.
    am1.allocate(""127.0.0.1"", 1024, 1, new ArrayList<ContainerId>());
    ContainerId containerId2 =
        ContainerId.newContainerId(am1.getApplicationAttemptId(), 2);
    rm1.waitForState(nm1, containerId2, RMContainerState.ALLOCATED);

    RMContainer container =
        rm1.getResourceScheduler().getRMContainer(containerId2);
    // no container token is generated.
    Assert.assertEquals(containerId2, container.getContainerId());
    Assert.assertNull(container.getContainer().getContainerToken());

    // acquire the container.
    List<Container> containers =
        am1.allocate(new ArrayList<ResourceRequest>(),
          new ArrayList<ContainerId>()).getAllocatedContainers();
    Assert.assertEquals(containerId2, containers.get(0).getId());
    // container token is generated.
    Assert.assertNotNull(containers.get(0).getContainerToken());
    rm1.stop();
  }",No Smells
"@Test
  public void testNormalContainerAllocationWhenDNSUnavailable() throws Exception{
    MockRM rm1 = new MockRM(conf);
    rm1.start();
    MockNM nm1 = rm1.registerNode(""unknownhost:1234"", 8000);
    RMApp app1 = MockRMAppSubmitter.submitWithMemory(200, rm1);
    MockAM am1 = MockRM.launchAndRegisterAM(app1, rm1, nm1);

    // request a container.
    am1.allocate(""127.0.0.1"", 1024, 1, new ArrayList<ContainerId>());
    ContainerId containerId2 =
        ContainerId.newContainerId(am1.getApplicationAttemptId(), 2);
    rm1.waitForState(nm1, containerId2, RMContainerState.ALLOCATED);

    // acquire the container.
    SecurityUtilTestHelper.setTokenServiceUseIp(true);
    List<Container> containers;
    try {
      containers =
          am1.allocate(new ArrayList<ResourceRequest>(),
              new ArrayList<ContainerId>()).getAllocatedContainers();
      // not able to fetch the container;
      Assert.assertEquals(0, containers.size());
    }",Eager Test
"@Test
  public void testAppAttemptMetrics() throws Exception {
    CSMaxRunningAppsEnforcer enforcer = mock(CSMaxRunningAppsEnforcer.class);
    cs.setMaxRunningAppsEnforcer(enforcer);
    ApplicationSubmissionContext applicationSubmissionContext =
        mock(ApplicationSubmissionContext.class);
    when(applicationSubmissionContext.getUnmanagedAM()).thenReturn(false);
    when(rmApp.getApplicationSubmissionContext())
        .thenReturn(applicationSubmissionContext);
    when(rmApp.getCurrentAppAttempt()).thenReturn(mock(RMAppAttempt.class));
    // Manipulate queue 'a'
    LeafQueue a = stubLeafQueue((LeafQueue) queues.get(B));

    // Users
    final String user_0 = ""user_0"";

    // Submit applications
    final ApplicationAttemptId appAttemptId_0 = TestUtils
        .getMockApplicationAttemptId(0, 1);

    AppAddedSchedulerEvent addAppEvent =
        new AppAddedSchedulerEvent(appAttemptId_0.getApplicationId(),
          a.getQueuePath(), user_0);
    cs.handle(addAppEvent);
    AppAttemptAddedSchedulerEvent addAttemptEvent = 
        new AppAttemptAddedSchedulerEvent(appAttemptId_0, false);
    cs.handle(addAttemptEvent);

    AppAttemptRemovedSchedulerEvent event = new AppAttemptRemovedSchedulerEvent(
        appAttemptId_0, RMAppAttemptState.FAILED, false);
    cs.handle(event);
    
    assertEquals(0, a.getMetrics().getAppsPending());
    assertEquals(0, a.getMetrics().getAppsFailed());

    // Attempt the same application again
    final ApplicationAttemptId appAttemptId_1 = TestUtils
        .getMockApplicationAttemptId(0, 2);
    FiCaSchedulerApp app1 = new FiCaSchedulerApp(appAttemptId_1, user_0, a,
        null, spyRMContext);
    app1.getAppSchedulingInfo().setUnmanagedAM(false);
    app1.setAMResource(Resource.newInstance(100, 1));
    a.submitApplicationAttempt(app1, user_0); // same user

    assertEquals(1, a.getMetrics().getAppsSubmitted());
    assertEquals(1, a.getMetrics().getAppsPending());
    assertEquals(1, a.getUser(user_0).getActiveApplications());
    assertEquals(app1.getAMResource().getMemorySize(), a.getMetrics()
        .getUsedAMResourceMB());
    assertEquals(app1.getAMResource().getVirtualCores(), a.getMetrics()
        .getUsedAMResourceVCores());
    
    event = new AppAttemptRemovedSchedulerEvent(appAttemptId_0,
        RMAppAttemptState.FINISHED, false);
    cs.handle(event);
    AppRemovedSchedulerEvent rEvent = new AppRemovedSchedulerEvent(
        appAttemptId_0.getApplicationId(), RMAppState.FINISHED);
    cs.handle(rEvent);
    
    assertEquals(1, a.getMetrics().getAppsSubmitted());
    assertEquals(0, a.getMetrics().getAppsPending());
    assertEquals(0, a.getMetrics().getAppsFailed());
    assertEquals(1, a.getMetrics().getAppsCompleted());

    QueueMetrics userMetrics = a.getMetrics().getUserMetrics(user_0);
    assertEquals(1, userMetrics.getAppsSubmitted());
  }",Eager Test
"@Test
  public void testDRFUserLimits() throws Exception {
    setUpWithDominantResourceCalculator();

    // Mock the queue
    LeafQueue b = stubLeafQueue((LeafQueue) queues.get(B));
    // unset maxCapacity
    b.setMaxCapacity(1.0f);

    // Users
    final String user0 = ""user_0"";
    final String user1 = ""user_1"";

    // Submit applications
    final ApplicationAttemptId appAttemptId0 =
        TestUtils.getMockApplicationAttemptId(0, 0);
    FiCaSchedulerApp app0 =
        new FiCaSchedulerApp(appAttemptId0, user0, b,
            b.getAbstractUsersManager(), spyRMContext);
    b.submitApplicationAttempt(app0, user0);

    final ApplicationAttemptId appAttemptId2 =
        TestUtils.getMockApplicationAttemptId(2, 0);
    FiCaSchedulerApp app2 =
        new FiCaSchedulerApp(appAttemptId2, user1, b,
            b.getAbstractUsersManager(), spyRMContext);
    b.submitApplicationAttempt(app2, user1);

    // Setup some nodes
    String host0 = ""127.0.0.1"";
    FiCaSchedulerNode node0 =
        TestUtils.getMockNode(host0, DEFAULT_RACK, 0, 8 * GB, 100);
    String host1 = ""127.0.0.2"";
    FiCaSchedulerNode node1 =
        TestUtils.getMockNode(host1, DEFAULT_RACK, 0, 8 * GB, 100);

    Map<NodeId, FiCaSchedulerNode> nodes = ImmutableMap.of(node0.getNodeID(),
        node0, node1.getNodeID(), node1);
    Map<ApplicationAttemptId, FiCaSchedulerApp> apps = ImmutableMap.of(
        app0.getApplicationAttemptId(), app0, app2.getApplicationAttemptId(),
        app2);

    int numNodes = 2;
    Resource clusterResource =
        Resources.createResource(numNodes * (8 * GB), numNodes * 100);
    when(csContext.getNumClusterNodes()).thenReturn(numNodes);
    when(csContext.getClusterResource()).thenReturn(clusterResource);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));

    // Setup resource-requests so that one application is memory dominant
    // and other application is vcores dominant
    Priority priority = TestUtils.createMockPriority(1);
    app0.updateResourceRequests(Collections.singletonList(TestUtils
        .createResourceRequest(ResourceRequest.ANY, 1 * GB, 40, 10, true,
            priority, recordFactory, NO_LABEL)));

    app2.updateResourceRequests(Collections.singletonList(TestUtils
        .createResourceRequest(ResourceRequest.ANY, 2 * GB, 10, 10, true,
            priority, recordFactory, NO_LABEL)));

    /**
     * Start testing...
     */

    // Set user-limit
    b.setUserLimit(50);
    b.setUserLimitFactor(2);
    User queueUser0 = b.getUser(user0);
    User queueUser1 = b.getUser(user1);

    assertEquals(""There should 2 active users!"", 2, b
        .getAbstractUsersManager().getNumActiveUsers());
    // Fill both Nodes as far as we can
    CSAssignment assign;
    do {
      assign =
          b.assignContainers(clusterResource, node0, new ResourceLimits(
              clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
      LOG.info(assign.toString());
      applyCSAssignment(clusterResource, assign, b, nodes, apps);
    }",Eager Test
"@Test
  public void testGetTotalPendingResourcesConsideringUserLimitOneUser()
      throws Exception {
    // Manipulate queue 'e'
    LeafQueue e = stubLeafQueue((LeafQueue)queues.get(E));
    // Allow queue 'e' to use 100% of cluster resources (max capacity).
    e.setMaxCapacity(1.0f);
    // When used queue resources goes above capacity (in this case, 1%), user
    // resource limit (used in calculating headroom) is calculated in small
    // increments to ensure that user-limit-percent can be met for all users in
    // a queue. Take user-limit-percent out of the equation so that user
    // resource limit will always be calculated to its max possible value.
    e.setUserLimit(1000);

    final String user_0 = ""user_0"";

    // Submit 2 applications for user_0
    final ApplicationAttemptId appAttemptId_0 =
        TestUtils.getMockApplicationAttemptId(0, 0);
    FiCaSchedulerApp app_0 =
        new FiCaSchedulerApp(appAttemptId_0, user_0, e,
            mock(ActiveUsersManager.class), spyRMContext);
    e.submitApplicationAttempt(app_0, user_0);

    final ApplicationAttemptId appAttemptId_1 =
        TestUtils.getMockApplicationAttemptId(1, 0);
    FiCaSchedulerApp app_1 =
        new FiCaSchedulerApp(appAttemptId_1, user_0, e,
            mock(ActiveUsersManager.class), spyRMContext);
    e.submitApplicationAttempt(app_1, user_0);  // same user

    // Setup 1 node with 100GB of memory resources.
    String host_0 = ""127.0.0.1"";
    FiCaSchedulerNode node_0 = TestUtils.getMockNode(host_0, DEFAULT_RACK, 0,
        100*GB);

    Map<ApplicationAttemptId, FiCaSchedulerApp> apps = ImmutableMap.of(
        app_0.getApplicationAttemptId(), app_0, app_1.getApplicationAttemptId(),
        app_1);
    Map<NodeId, FiCaSchedulerNode> nodes = ImmutableMap.of(node_0.getNodeID(),
        node_0);

    final int numNodes = 1;
    Resource clusterResource =
        Resources.createResource(numNodes * (100*GB), numNodes * 128);
    when(csContext.getNumClusterNodes()).thenReturn(numNodes);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));

    // Pending resource requests for app_0 and app_1 total 5GB.
    Priority priority = TestUtils.createMockPriority(1);
    app_0.updateResourceRequests(Collections.singletonList(
            TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 3, true,
                priority, recordFactory)));

    app_1.updateResourceRequests(Collections.singletonList(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 2, true,
            priority, recordFactory)));

    // Start testing...

    // Assign 1st Container of 1GB
    applyCSAssignment(clusterResource,
        e.assignContainers(clusterResource, node_0,
            new ResourceLimits(clusterResource),
            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), e, nodes, apps);
    // With queue capacity set at 1% of 100GB and user-limit-factor set to 1.0,
    // all users (only user_0) queue 'e' should be able to consume 1GB.
    // The first container should be assigned to app_0 with no headroom left
    // even though user_0's apps are still asking for a total of 4GB.
    assertEquals(1*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0 * GB,
        e.getTotalPendingResourcesConsideringUserLimit(clusterResource,
            NO_LABEL, false).getMemorySize());

    // Assign 2nd container of 1GB
    applyCSAssignment(clusterResource,
        e.assignContainers(clusterResource, node_0,
            new ResourceLimits(clusterResource),
            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), e, nodes, apps);
    // user_0 has no headroom due to user-limit-factor of 1.0. However capacity
    // scheduler will assign one container more than user-limit-factor.
    // This container also went to app_0. Still with no neadroom even though
    // app_0 and app_1 are asking for a cumulative 3GB.
    assertEquals(2*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, e.getTotalPendingResourcesConsideringUserLimit(
        clusterResource, NO_LABEL, false).getMemorySize());

    // Can't allocate 3rd container due to user-limit. Headroom still 0.
    applyCSAssignment(clusterResource,
        e.assignContainers(clusterResource, node_0,
            new ResourceLimits(clusterResource),
            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), e, nodes, apps);
    assertEquals(2*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, e.getTotalPendingResourcesConsideringUserLimit(
        clusterResource, NO_LABEL, false).getMemorySize());

    // Increase user-limit-factor from 1GB to 10GB (1% * 10 * 100GB = 10GB).
    // Pending for both app_0 and app_1 are still 3GB, so user-limit-factor
    // is no longer limiting the return value of
    // getTotalPendingResourcesConsideringUserLimit()
    e.setUserLimitFactor(10.0f);
    assertEquals(3*GB, e.getTotalPendingResourcesConsideringUserLimit(
        clusterResource, NO_LABEL, false).getMemorySize());

    applyCSAssignment(clusterResource,
        e.assignContainers(clusterResource, node_0,
            new ResourceLimits(clusterResource),
            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), e, nodes, apps);
    // app_0 is now satisified, app_1 is still asking for 2GB.
    assertEquals(3*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(2*GB, e.getTotalPendingResourcesConsideringUserLimit(
        clusterResource, NO_LABEL, false).getMemorySize());

    // Get the last 2 containers for app_1, no more pending requests.
    applyCSAssignment(clusterResource,
        e.assignContainers(clusterResource, node_0,
            new ResourceLimits(clusterResource),
            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), e, nodes, apps);
    applyCSAssignment(clusterResource,
        e.assignContainers(clusterResource, node_0,
            new ResourceLimits(clusterResource),
            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), e, nodes, apps);
    assertEquals(3*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(2*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, e.getTotalPendingResourcesConsideringUserLimit(
        clusterResource, NO_LABEL, false).getMemorySize());

    // Release each container from app_0
    for (RMContainer rmContainer : app_0.getLiveContainers()) {
      e.completedContainer(clusterResource, app_0, node_0, rmContainer,
          ContainerStatus.newInstance(rmContainer.getContainerId(),
              ContainerState.COMPLETE, """",
              ContainerExitStatus.KILLED_BY_RESOURCEMANAGER),
          RMContainerEventType.KILL, null, true);
    }",Eager Test
"@Test
  public void testInitializeQueue() throws Exception {
    final float epsilon = 1e-5f;
    //can add more sturdy test with 3-layer queues 
    //once MAPREDUCE:3410 is resolved
    LeafQueue a = stubLeafQueue((LeafQueue)queues.get(A));
    assertEquals(0.085, a.getCapacity(), epsilon);
    assertEquals(0.085, a.getAbsoluteCapacity(), epsilon);
    assertEquals(0.2, a.getMaximumCapacity(), epsilon);
    assertEquals(0.2, a.getAbsoluteMaximumCapacity(), epsilon);
    
    LeafQueue b = stubLeafQueue((LeafQueue)queues.get(B));
    assertEquals(0.80, b.getCapacity(), epsilon);
    assertEquals(0.80, b.getAbsoluteCapacity(), epsilon);
    assertEquals(0.99, b.getMaximumCapacity(), epsilon);
    assertEquals(0.99, b.getAbsoluteMaximumCapacity(), epsilon);
    
    ParentQueue c = (ParentQueue)queues.get(C);
    assertEquals(0.015, c.getCapacity(), epsilon);
    assertEquals(0.015, c.getAbsoluteCapacity(), epsilon);
    assertEquals(0.1, c.getMaximumCapacity(), epsilon);
    assertEquals(0.1, c.getAbsoluteMaximumCapacity(), epsilon);

    // Verify the value for getAMResourceLimit for queues with < .1 maxcap
    Resource clusterResource = Resource.newInstance(50 * GB, 50);

    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));
    assertEquals(Resource.newInstance(1 * GB, 1),
        a.calculateAndGetAMResourceLimit());

    assertEquals(Resource.newInstance(5 * GB, 1),
        b.calculateAndGetAMResourceLimit());
  }",No Smells
"@Test
  public void testLocalityConstraints() throws Exception {

    // Manipulate queue 'a'
    LeafQueue a = stubLeafQueue((LeafQueue)queues.get(A));

    // User
    String user_0 = ""user_0"";
    
    // Submit applications
    final ApplicationAttemptId appAttemptId_0 = 
        TestUtils.getMockApplicationAttemptId(0, 0); 
    FiCaSchedulerApp app_0 =
        new FiCaSchedulerApp(appAttemptId_0, user_0, a,
            mock(ActiveUsersManager.class), spyRMContext);
    a.submitApplicationAttempt(app_0, user_0);

    final ApplicationAttemptId appAttemptId_1 = 
        TestUtils.getMockApplicationAttemptId(1, 0); 
    FiCaSchedulerApp app_1 =
        new FiCaSchedulerApp(appAttemptId_1, user_0, a,
            mock(ActiveUsersManager.class), spyRMContext);
    a.submitApplicationAttempt(app_1, user_0);

    Map<ApplicationAttemptId, FiCaSchedulerApp> apps = ImmutableMap.of(
        app_0.getApplicationAttemptId(), app_0, app_1.getApplicationAttemptId(),
        app_1);

    // Setup some nodes and racks
    String host_0_0 = ""127.0.0.1"";
    String rack_0 = ""rack_0"";
    String host_0_1 = ""127.0.0.2"";
    FiCaSchedulerNode node_0_1 = TestUtils.getMockNode(host_0_1, rack_0, 0, 8*GB);

    String host_1_0 = ""127.0.0.3"";
    String rack_1 = ""rack_1"";
    FiCaSchedulerNode node_1_0 = TestUtils.getMockNode(host_1_0, rack_1, 0, 8*GB);
    String host_1_1 = ""127.0.0.4"";
    FiCaSchedulerNode node_1_1 = TestUtils.getMockNode(host_1_1, rack_1, 0, 8*GB);

    Map<NodeId, FiCaSchedulerNode> nodes = ImmutableMap.of(node_0_1.getNodeID(),
        node_0_1, node_1_0.getNodeID(), node_1_0, node_1_1.getNodeID(),
        node_1_1);
    
    final int numNodes = 4;
    Resource clusterResource = Resources.createResource(
        numNodes * (8*GB), numNodes * 1);
    when(csContext.getNumClusterNodes()).thenReturn(numNodes);

    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));

    // Setup resource-requests
    // resourceName: <priority, memory, #containers, relaxLocality>
    // host_0_0: < 1, 1GB, 1, true >
    // host_0_1: < null >
    // rack_0:   < null >                     <----
    // host_1_0: < 1, 1GB, 1, true >
    // host_1_1: < null >
    // rack_1:   < 1, 1GB, 1, false >         <----
    // ANY:      < 1, 1GB, 1, false >         <----
    // Availability:
    // host_0_0: 8G
    // host_0_1: 8G
    // host_1_0: 8G
    // host_1_1: 8G
    // Blacklist: <host_0_0>
    Priority priority = TestUtils.createMockPriority(1);
    SchedulerRequestKey schedulerKey = toSchedulerKey(priority);
    List<ResourceRequest> app_0_requests_0 = new ArrayList<ResourceRequest>();
    app_0_requests_0.add(
        TestUtils.createResourceRequest(host_0_0, 1*GB, 1, 
            true, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(host_1_0, 1*GB, 1, 
            true, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(rack_1, 1*GB, 1, 
            false, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 1, // only one
            false, priority, recordFactory));
    app_0.updateResourceRequests(app_0_requests_0);
    app_0.updateBlacklist(Collections.singletonList(host_0_0), null);
    app_0_requests_0.clear();

    //
    // Start testing...
    //
    
    // node_0_1  
    // Shouldn't allocate since RR(rack_0) = null && RR(ANY) = relax: false
    CSAssignment assignment =
        a.assignContainers(clusterResource, node_0_1, new ResourceLimits(
            clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyCSAssignment(clusterResource, assignment, a, nodes, apps);
    verifyNoContainerAllocated(assignment);
    // should be 0
    assertEquals(0, app_0.getSchedulingOpportunities(schedulerKey));
    
    // resourceName: <priority, memory, #containers, relaxLocality>
    // host_0_0: < 1, 1GB, 1, true >
    // host_0_1: < null >
    // rack_0:   < null >                     <----
    // host_1_0: < 1, 1GB, 1, true >
    // host_1_1: < null >
    // rack_1:   < 1, 1GB, 1, false >         <----
    // ANY:      < 1, 1GB, 1, false >         <----
    // Availability:
    // host_0_0: 8G
    // host_0_1: 8G
    // host_1_0: 8G
    // host_1_1: 8G
    // Blacklist: <host_0_0>

    // node_1_1  
    // Shouldn't allocate since RR(rack_1) = relax: false
    assignment = a.assignContainers(clusterResource, node_1_1, 
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyCSAssignment(clusterResource, assignment, a, nodes, apps);
    verifyNoContainerAllocated(assignment);
    // should be 0
    assertEquals(0, app_0.getSchedulingOpportunities(schedulerKey));
    
    // Allow rack-locality for rack_1, but blacklist node_1_1
    app_0_requests_0.add(
        TestUtils.createResourceRequest(rack_1, 1*GB, 1, 
            true, priority, recordFactory));
    app_0.updateResourceRequests(app_0_requests_0);
    app_0.updateBlacklist(Collections.singletonList(host_1_1), null);
    app_0_requests_0.clear();

    // resourceName: <priority, memory, #containers, relaxLocality>
    // host_0_0: < 1, 1GB, 1, true >
    // host_0_1: < null >
    // rack_0:   < null >                     
    // host_1_0: < 1, 1GB, 1, true >
    // host_1_1: < null >
    // rack_1:   < 1, 1GB, 1, true >         
    // ANY:      < 1, 1GB, 1, false >         
    // Availability:
    // host_0_0: 8G
    // host_0_1: 8G
    // host_1_0: 8G
    // host_1_1: 8G
    // Blacklist: < host_0_0 , host_1_1 >       <----

    // node_1_1  
    // Shouldn't allocate since node_1_1 is blacklisted
    assignment = a.assignContainers(clusterResource, node_1_1, 
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyCSAssignment(clusterResource, assignment, a, nodes, apps);
    verifyNoContainerAllocated(assignment);
    // should be 0
    assertEquals(0, app_0.getSchedulingOpportunities(schedulerKey));

    // Now, remove node_1_1 from blacklist, but add rack_1 to blacklist
    app_0.updateResourceRequests(app_0_requests_0);
    app_0.updateBlacklist(
        Collections.singletonList(rack_1), Collections.singletonList(host_1_1));
    app_0_requests_0.clear();

    // resourceName: <priority, memory, #containers, relaxLocality>
    // host_0_0: < 1, 1GB, 1, true >
    // host_0_1: < null >
    // rack_0:   < null >                     
    // host_1_0: < 1, 1GB, 1, true >
    // host_1_1: < null >
    // rack_1:   < 1, 1GB, 1, true >         
    // ANY:      < 1, 1GB, 1, false >         
    // Availability:
    // host_0_0: 8G
    // host_0_1: 8G
    // host_1_0: 8G
    // host_1_1: 8G
    // Blacklist: < host_0_0 , rack_1 >       <----

    // node_1_1  
    // Shouldn't allocate since rack_1 is blacklisted
    assignment = a.assignContainers(clusterResource, node_1_1,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyCSAssignment(clusterResource, assignment, a, nodes, apps);
    verifyNoContainerAllocated(assignment);
    // should be 0
    assertEquals(0, app_0.getSchedulingOpportunities(schedulerKey));
    
    // Now remove rack_1 from blacklist
    app_0.updateResourceRequests(app_0_requests_0);
    app_0.updateBlacklist(null, Collections.singletonList(rack_1));
    app_0_requests_0.clear();
    
    // resourceName: <priority, memory, #containers, relaxLocality>
    // host_0_0: < 1, 1GB, 1, true >
    // host_0_1: < null >
    // rack_0:   < null >                     
    // host_1_0: < 1, 1GB, 1, true >
    // host_1_1: < null >
    // rack_1:   < 1, 1GB, 1, true >         
    // ANY:      < 1, 1GB, 1, false >         
    // Availability:
    // host_0_0: 8G
    // host_0_1: 8G
    // host_1_0: 8G
    // host_1_1: 8G
    // Blacklist: < host_0_0 >       <----

    // Now, should allocate since RR(rack_1) = relax: true
    assignment = a.assignContainers(clusterResource, node_1_1, 
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyCSAssignment(clusterResource, assignment, a, nodes, apps);
    verifyNoContainerAllocated(assignment);
    assertEquals(0, app_0.getSchedulingOpportunities(schedulerKey));
    assertEquals(1, app_0.getOutstandingAsksCount(schedulerKey));

    // Now sanity-check node_local
    app_0_requests_0.add(
        TestUtils.createResourceRequest(rack_1, 1*GB, 1, 
            false, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 1, // only one
            false, priority, recordFactory));
    app_0.updateResourceRequests(app_0_requests_0);
    app_0_requests_0.clear();
    
    // resourceName: <priority, memory, #containers, relaxLocality>
    // host_0_0: < 1, 1GB, 1, true >
    // host_0_1: < null >
    // rack_0:   < null >                     
    // host_1_0: < 1, 1GB, 1, true >
    // host_1_1: < null >
    // rack_1:   < 1, 1GB, 1, false >          <----
    // ANY:      < 1, 1GB, 1, false >          <----
    // Availability:
    // host_0_0: 8G
    // host_0_1: 8G
    // host_1_0: 8G
    // host_1_1: 7G

    assignment = a.assignContainers(clusterResource, node_1_0, 
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyCSAssignment(clusterResource, assignment, a, nodes, apps);
    verifyContainerAllocated(assignment, NodeType.NODE_LOCAL);
    assertEquals(0, app_0.getSchedulingOpportunities(schedulerKey));
    assertEquals(0, app_0.getOutstandingAsksCount(schedulerKey));

  }",Eager Test
"@Test
  public void testLocalityDelaySkipsApplication() throws Exception {

    // Manipulate queue 'a'
    LeafQueue a = stubLeafQueue((LeafQueue)queues.get(A));

    // User
    String user_0 = ""user_0"";
    
    // Submit applications
    final ApplicationAttemptId appAttemptId_0 = 
        TestUtils.getMockApplicationAttemptId(0, 0); 
    FiCaSchedulerApp app_0 =
        new FiCaSchedulerApp(appAttemptId_0, user_0, a,
            mock(ActiveUsersManager.class), spyRMContext);
    a.submitApplicationAttempt(app_0, user_0);
    final ApplicationAttemptId appAttemptId_1 = 
        TestUtils.getMockApplicationAttemptId(1, 0);
    FiCaSchedulerApp app_1 =
        new FiCaSchedulerApp(appAttemptId_1, user_0, a,
            mock(ActiveUsersManager.class), spyRMContext);
    a.submitApplicationAttempt(app_1, user_0);

    // Setup some nodes and racks
    String host_0 = ""127.0.0.1"";
    String rack_0 = ""rack_0"";
    FiCaSchedulerNode node_0 = TestUtils.getMockNode(host_0, rack_0, 0, 8*GB);
    
    String host_1 = ""127.0.0.2"";
    String rack_1 = ""rack_1"";
    FiCaSchedulerNode node_1 = TestUtils.getMockNode(host_1, rack_1, 0, 8*GB);
    
    String host_2 = ""127.0.0.3"";
    String rack_2 = ""rack_2"";
    FiCaSchedulerNode node_2 = TestUtils.getMockNode(host_2, rack_2, 0, 8*GB);

    Map<ApplicationAttemptId, FiCaSchedulerApp> apps = ImmutableMap.of(
        app_0.getApplicationAttemptId(), app_0, app_1.getApplicationAttemptId(),
        app_1);
    Map<NodeId, FiCaSchedulerNode> nodes = ImmutableMap.of(node_0.getNodeID(),
        node_0, node_1.getNodeID(), node_1, node_2.getNodeID(), node_2);

    final int numNodes = 3;
    Resource clusterResource = 
        Resources.createResource(numNodes * (8*GB), numNodes * 16);
    when(csContext.getNumClusterNodes()).thenReturn(numNodes);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));
    
    // Setup resource-requests and submit
    // App0 has node local request for host_0/host_1, and app1 has node local
    // request for host2.
    Priority priority = TestUtils.createMockPriority(1);
    SchedulerRequestKey schedulerKey = toSchedulerKey(priority);
    List<ResourceRequest> app_0_requests_0 = new ArrayList<ResourceRequest>();
    app_0_requests_0.add(
        TestUtils.createResourceRequest(host_0, 1*GB, 1, 
            true, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(rack_0, 1*GB, 1, 
            true, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(host_1, 1*GB, 1, 
            true, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(rack_1, 1*GB, 1, 
            true, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 3, // one extra
            true, priority, recordFactory));
    app_0.updateResourceRequests(app_0_requests_0);

    List<ResourceRequest> app_1_requests_0 = new ArrayList<ResourceRequest>();
    app_1_requests_0.add(
        TestUtils.createResourceRequest(host_2, 1*GB, 1, 
            true, priority, recordFactory));
    app_1_requests_0.add(
        TestUtils.createResourceRequest(rack_2, 1*GB, 1, 
            true, priority, recordFactory));
    app_1_requests_0.add(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 1, // one extra
            true, priority, recordFactory));
    app_1.updateResourceRequests(app_1_requests_0);

    // Start testing...
    // When doing allocation, even if app_0 submit earlier than app_1, app_1 can
    // still get allocated because app_0 is waiting for node-locality-delay
    CSAssignment assignment = null;
    
    // Check app_0's scheduling opportunities increased and app_1 get allocated
    assignment = a.assignContainers(clusterResource, node_2,
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyCSAssignment(clusterResource, assignment, a, nodes, apps);
    verifyContainerAllocated(assignment, NodeType.NODE_LOCAL);
    assertEquals(1, app_0.getSchedulingOpportunities(schedulerKey));
    assertEquals(3, app_0.getOutstandingAsksCount(schedulerKey));
    assertEquals(0, app_0.getLiveContainers().size());
    assertEquals(1, app_1.getLiveContainers().size());
  }",Eager Test
"@Test
  public void testPolicyConfiguration() throws Exception {
    
    CapacitySchedulerConfiguration testConf = 
        new CapacitySchedulerConfiguration();
    
    String tproot = ROOT + ""."" +
      ""testPolicyRoot"" + System.currentTimeMillis();

    OrderingPolicy<FiCaSchedulerApp> comPol =    
        testConf.<FiCaSchedulerApp>getAppOrderingPolicy(new QueuePath(tproot));
    
    
  }",Eager Test
"@Test
  public void testReservation() throws Exception {

    // Manipulate queue 'a'
    LeafQueue a = stubLeafQueue((LeafQueue)queues.get(A));
    //unset maxCapacity
    a.setMaxCapacity(1.0f);

    // Users
    final String user_0 = ""user_0"";
    final String user_1 = ""user_1"";

    // Submit applications
    final ApplicationAttemptId appAttemptId_0 = 
        TestUtils.getMockApplicationAttemptId(0, 0); 
    FiCaSchedulerApp app_0 = 
        new FiCaSchedulerApp(appAttemptId_0, user_0, a, 
            mock(ActiveUsersManager.class), spyRMContext);
    a.submitApplicationAttempt(app_0, user_0);

    final ApplicationAttemptId appAttemptId_1 = 
        TestUtils.getMockApplicationAttemptId(1, 0); 
    FiCaSchedulerApp app_1 = 
        new FiCaSchedulerApp(appAttemptId_1, user_1, a, 
            mock(ActiveUsersManager.class), spyRMContext);
    a.submitApplicationAttempt(app_1, user_1);  

    // Setup some nodes
    String host_0 = ""127.0.0.1"";
    FiCaSchedulerNode node_0 = TestUtils.getMockNode(host_0, DEFAULT_RACK, 0, 4*GB);

    Map<ApplicationAttemptId, FiCaSchedulerApp> apps = ImmutableMap.of(
        app_0.getApplicationAttemptId(), app_0, app_1.getApplicationAttemptId(),
        app_1);
    Map<NodeId, FiCaSchedulerNode> nodes = ImmutableMap.of(node_0.getNodeID(),
        node_0);
    
    final int numNodes = 2;
    Resource clusterResource = 
        Resources.createResource(numNodes * (4*GB), numNodes * 16);
    when(csContext.getNumClusterNodes()).thenReturn(numNodes);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));
    
    // Setup resource-requests
    Priority priority = TestUtils.createMockPriority(1);
    app_0.updateResourceRequests(Collections.singletonList(
            TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 2, true,
                priority, recordFactory)));

    app_1.updateResourceRequests(Collections.singletonList(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 4*GB, 1, true,
            priority, recordFactory)));

    // Start testing...
    
    // Only 1 container
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
            new ResourceLimits(clusterResource),
            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(1*GB, a.getUsedResources().getMemorySize());
    assertEquals(1*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, a.getMetrics().getReservedMB());
    assertEquals(1*GB, a.getMetrics().getAllocatedMB());
    assertEquals(0*GB, a.getMetrics().getAvailableMB());

    // Also 2nd -> minCapacity = 1024 since (.1 * 8G) < minAlloc, also
    // you can get one container more than user-limit
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
            new ResourceLimits(clusterResource),
            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(2*GB, a.getUsedResources().getMemorySize());
    assertEquals(2*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, a.getMetrics().getReservedMB());
    assertEquals(2*GB, a.getMetrics().getAllocatedMB());
    
    // Now, reservation should kick in for app_1
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
            new ResourceLimits(clusterResource),
            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(6*GB, a.getUsedResources().getMemorySize());
    assertEquals(2*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(4*GB, app_1.getCurrentReservation().getMemorySize());
    assertEquals(2*GB, node_0.getAllocatedResource().getMemorySize());
    assertEquals(4*GB, a.getMetrics().getReservedMB());
    assertEquals(2*GB, a.getMetrics().getAllocatedMB());
    
    // Now free 1 container from app_0 i.e. 1G
    RMContainer rmContainer = app_0.getLiveContainers().iterator().next();
    a.completedContainer(clusterResource, app_0, node_0, rmContainer,
        ContainerStatus.newInstance(rmContainer.getContainerId(),
            ContainerState.COMPLETE, """",
            ContainerExitStatus.KILLED_BY_RESOURCEMANAGER),
        RMContainerEventType.KILL, null, true);
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
            new ResourceLimits(clusterResource),
            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(5*GB, a.getUsedResources().getMemorySize());
    assertEquals(1*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(4*GB, app_1.getCurrentReservation().getMemorySize());
    assertEquals(1*GB, node_0.getAllocatedResource().getMemorySize());
    assertEquals(4*GB, a.getMetrics().getReservedMB());
    assertEquals(1*GB, a.getMetrics().getAllocatedMB());

    // Now finish another container from app_0 and fulfill the reservation
    rmContainer = app_0.getLiveContainers().iterator().next();
    a.completedContainer(clusterResource, app_0, node_0, rmContainer,
        ContainerStatus.newInstance(rmContainer.getContainerId(),
            ContainerState.COMPLETE, """",
            ContainerExitStatus.KILLED_BY_RESOURCEMANAGER),
        RMContainerEventType.KILL, null, true);
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
            new ResourceLimits(clusterResource),
            SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(4*GB, a.getUsedResources().getMemorySize());
    assertEquals(0*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(4*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentReservation().getMemorySize());
    assertEquals(4*GB, node_0.getAllocatedResource().getMemorySize());
    assertEquals(0*GB, a.getMetrics().getReservedMB());
    assertEquals(4*GB, a.getMetrics().getAllocatedMB());
  }",Eager Test
"@Test
  public void testSchedulingConstraints() throws Exception {

    // Manipulate queue 'a'
    LeafQueue a = stubLeafQueue((LeafQueue)queues.get(A));

    // User
    String user_0 = ""user_0"";
    
    // Submit applications
    final ApplicationAttemptId appAttemptId_0 = 
        TestUtils.getMockApplicationAttemptId(0, 0); 
    FiCaSchedulerApp app_0 = 
        new FiCaSchedulerApp(appAttemptId_0, user_0, a, 
            mock(ActiveUsersManager.class), spyRMContext);
    a.submitApplicationAttempt(app_0, user_0);
    
    // Setup some nodes and racks
    String host_0_0 = ""127.0.0.1"";
    String rack_0 = ""rack_0"";
    FiCaSchedulerNode node_0_0 = TestUtils.getMockNode(host_0_0, rack_0, 0, 8*GB);
    String host_0_1 = ""127.0.0.2"";
    FiCaSchedulerNode node_0_1 = TestUtils.getMockNode(host_0_1, rack_0, 0, 8*GB);
    
    
    String host_1_0 = ""127.0.0.3"";
    String rack_1 = ""rack_1"";
    FiCaSchedulerNode node_1_0 = TestUtils.getMockNode(host_1_0, rack_1, 0, 8*GB);

    Map<ApplicationAttemptId, FiCaSchedulerApp> apps = ImmutableMap.of(
        app_0.getApplicationAttemptId(), app_0);
    Map<NodeId, FiCaSchedulerNode> nodes = ImmutableMap.of(node_0_0.getNodeID(),
        node_0_0, node_0_1.getNodeID(), node_0_1, node_1_0.getNodeID(),
        node_1_0);
    
    final int numNodes = 3;
    Resource clusterResource = Resources.createResource(
        numNodes * (8*GB), numNodes * 16);
    when(csContext.getNumClusterNodes()).thenReturn(numNodes);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));

    // Setup resource-requests and submit
    Priority priority = TestUtils.createMockPriority(1);
    SchedulerRequestKey schedulerKey = toSchedulerKey(priority);
    List<ResourceRequest> app_0_requests_0 = new ArrayList<ResourceRequest>();
    app_0_requests_0.add(
        TestUtils.createResourceRequest(host_0_0, 1*GB, 1, 
            true, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(host_0_1, 1*GB, 1, 
            true, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(rack_0, 1*GB, 1, 
            true, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(host_1_0, 1*GB, 1, 
            true, priority, recordFactory));
    app_0_requests_0.add(
        TestUtils.createResourceRequest(rack_1, 1*GB, 1, 
            true, priority, recordFactory));
    app_0.updateResourceRequests(app_0_requests_0);

    // Start testing...
    
    // Add one request
    app_0_requests_0.clear();
    app_0_requests_0.add(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 1, // only 1
            true, priority, recordFactory));
    app_0.updateResourceRequests(app_0_requests_0);
    
    // NODE_LOCAL - node_0_1
    CSAssignment assignment = a.assignContainers(clusterResource, node_0_0,
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyCSAssignment(clusterResource, assignment, a, nodes, apps);
    verifyContainerAllocated(assignment, NodeType.NODE_LOCAL);
    assertEquals(0, app_0.getSchedulingOpportunities(schedulerKey));
    // should reset
    assertEquals(0, app_0.getOutstandingAsksCount(schedulerKey));

    // No allocation on node_1_0 even though it's node/rack local since
    // required(ANY) == 0
    assignment = a.assignContainers(clusterResource, node_1_0,
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyCSAssignment(clusterResource, assignment, a, nodes, apps);
    verifyNoContainerAllocated(assignment);
    // Still zero
    // since #req=0
    assertEquals(0, app_0.getSchedulingOpportunities(schedulerKey));
    assertEquals(0, app_0.getOutstandingAsksCount(schedulerKey));
    
    // Add one request
    app_0_requests_0.clear();
    app_0_requests_0.add(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 1, // only one
            true, priority, recordFactory));
    app_0.updateResourceRequests(app_0_requests_0);

    // No allocation on node_0_1 even though it's node/rack local since
    // required(rack_1) == 0
    assignment = a.assignContainers(clusterResource, node_0_1,
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyCSAssignment(clusterResource, assignment, a, nodes, apps);
    verifyNoContainerAllocated(assignment);
    assertEquals(1, app_0.getSchedulingOpportunities(schedulerKey));
    assertEquals(1, app_0.getOutstandingAsksCount(schedulerKey));
    
    // NODE_LOCAL - node_1
    assignment = a.assignContainers(clusterResource, node_1_0,
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyCSAssignment(clusterResource, assignment, a, nodes, apps);
    verifyContainerAllocated(assignment, NodeType.NODE_LOCAL);
    // should reset
    assertEquals(0, app_0.getSchedulingOpportunities(schedulerKey));
    assertEquals(0, app_0.getOutstandingAsksCount(schedulerKey));
  }",Eager Test
"@Test
  public void testSingleQueueWithMultipleUsers() throws Exception {
    
    // Mock the queue
    LeafQueue a = stubLeafQueue((LeafQueue)queues.get(A));
    //unset maxCapacity
    a.setMaxCapacity(1.0f);
    
    // Users
    final String user_0 = ""user_0"";
    final String user_1 = ""user_1"";
    final String user_2 = ""user_2"";

    // Submit applications
    final ApplicationAttemptId appAttemptId_0 = 
        TestUtils.getMockApplicationAttemptId(0, 0); 
    FiCaSchedulerApp app_0 = 
        new FiCaSchedulerApp(appAttemptId_0, user_0, a, 
            a.getAbstractUsersManager(), spyRMContext);
    a.submitApplicationAttempt(app_0, user_0);

    final ApplicationAttemptId appAttemptId_1 = 
        TestUtils.getMockApplicationAttemptId(1, 0); 
    FiCaSchedulerApp app_1 = 
        new FiCaSchedulerApp(appAttemptId_1, user_0, a, 
            a.getAbstractUsersManager(), spyRMContext);
    a.submitApplicationAttempt(app_1, user_0);  // same user

    final ApplicationAttemptId appAttemptId_2 = 
        TestUtils.getMockApplicationAttemptId(2, 0); 
    FiCaSchedulerApp app_2 = 
        new FiCaSchedulerApp(appAttemptId_2, user_1, a, 
            a.getAbstractUsersManager(), spyRMContext);
    a.submitApplicationAttempt(app_2, user_1);

    final ApplicationAttemptId appAttemptId_3 = 
        TestUtils.getMockApplicationAttemptId(3, 0); 
    FiCaSchedulerApp app_3 = 
        new FiCaSchedulerApp(appAttemptId_3, user_2, a, 
            a.getAbstractUsersManager(), spyRMContext);
    a.submitApplicationAttempt(app_3, user_2);

    Map<ApplicationAttemptId, FiCaSchedulerApp> apps = ImmutableMap.of(
        app_0.getApplicationAttemptId(), app_0, app_1.getApplicationAttemptId(),
        app_1, app_2.getApplicationAttemptId(), app_2,
        app_3.getApplicationAttemptId(), app_3);
    
    // Setup some nodes
    String host_0 = ""127.0.0.1"";
    FiCaSchedulerNode node_0 = TestUtils.getMockNode(host_0, DEFAULT_RACK, 0, 8*GB);
    Map<NodeId, FiCaSchedulerNode> nodes = ImmutableMap.of(node_0.getNodeID(),
        node_0);
    
    final int numNodes = 1;
    Resource clusterResource = 
        Resources.createResource(numNodes * (8*GB), numNodes * 16);
    when(csContext.getNumClusterNodes()).thenReturn(numNodes);
    when(csContext.getClusterResource()).thenReturn(clusterResource);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));

    // Setup resource-requests
    Priority priority = TestUtils.createMockPriority(1);
    app_0.updateResourceRequests(Collections.singletonList(
            TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 10, true,
                priority, recordFactory)));

    app_1.updateResourceRequests(Collections.singletonList(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 10, true,
            priority, recordFactory)));

    /** 
     * Start testing... 
     */
    
    // Only 1 container
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(1*GB, a.getUsedResources().getMemorySize());
    assertEquals(1*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());

    // Also 2nd -> minCapacity = 1024 since (.1 * 8G) < minAlloc, also
    // you can get one container more than user-limit
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(2*GB, a.getUsedResources().getMemorySize());
    assertEquals(2*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    
    // Can't allocate 3rd due to user-limit
    a.setUserLimit(25);
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(2*GB, a.getUsedResources().getMemorySize());
    assertEquals(2*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    
    // Submit resource requests for other apps now to 'activate' them
    
    app_2.updateResourceRequests(Collections.singletonList(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 3*GB, 1, true,
            priority, recordFactory)));

    app_3.updateResourceRequests(Collections.singletonList(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 2, true,
            priority, recordFactory)));

    // Now allocations should goto app_2 since 
    // user_0 is at limit inspite of high user-limit-factor
    a.setUserLimitFactor(10);
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(5*GB, a.getUsedResources().getMemorySize());
    assertEquals(2*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(3*GB, app_2.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_3.getCurrentConsumption().getMemorySize());

    // Now allocations should goto app_0 since 
    // user_0 is at user-limit not above it
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(6*GB, a.getUsedResources().getMemorySize());
    assertEquals(3*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(3*GB, app_2.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_3.getCurrentConsumption().getMemorySize());
    
    // Test max-capacity
    // Now - no more allocs since we are at max-cap
    a.setMaxCapacity(0.5f);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(6*GB, a.getUsedResources().getMemorySize());
    assertEquals(3*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(3*GB, app_2.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_3.getCurrentConsumption().getMemorySize());
    
    // Revert max-capacity and user-limit-factor
    // Now, allocations should goto app_3 since it's under user-limit 
    a.setMaxCapacity(1.0f);
    a.setUserLimitFactor(1);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(7*GB, a.getUsedResources().getMemorySize());
    assertEquals(3*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(3*GB, app_2.getCurrentConsumption().getMemorySize());
    assertEquals(1*GB, app_3.getCurrentConsumption().getMemorySize());

    // Now we should assign to app_3 again since user_2 is under user-limit
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(8*GB, a.getUsedResources().getMemorySize());
    assertEquals(3*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(3*GB, app_2.getCurrentConsumption().getMemorySize());
    assertEquals(2*GB, app_3.getCurrentConsumption().getMemorySize());

    // 8. Release each container from app_0
    for (RMContainer rmContainer : app_0.getLiveContainers()) {
      a.completedContainer(clusterResource, app_0, node_0, rmContainer,
          ContainerStatus.newInstance(rmContainer.getContainerId(),
              ContainerState.COMPLETE, """",
              ContainerExitStatus.KILLED_BY_RESOURCEMANAGER),
          RMContainerEventType.KILL, null, true);
    }",Eager Test
"@Test
  public void testSingleQueueWithOneUser() throws Exception {

    // Manipulate queue 'a'
    LeafQueue a = stubLeafQueue((LeafQueue)queues.get(A));
    //unset maxCapacity
    a.setMaxCapacity(1.0f);

    // Users
    final String user_0 = ""user_0"";

    // Active Users Manager
    AbstractUsersManager activeUserManager = a.getAbstractUsersManager();

    // Submit applications
    final ApplicationAttemptId appAttemptId_0 = 
        TestUtils.getMockApplicationAttemptId(0, 0); 
    FiCaSchedulerApp app_0 = 
        new FiCaSchedulerApp(appAttemptId_0, user_0, a, 
            activeUserManager, spyRMContext);
    a.submitApplicationAttempt(app_0, user_0);

    final ApplicationAttemptId appAttemptId_1 = 
        TestUtils.getMockApplicationAttemptId(1, 0); 
    FiCaSchedulerApp app_1 = 
        new FiCaSchedulerApp(appAttemptId_1, user_0, a, 
            activeUserManager, spyRMContext);
    a.submitApplicationAttempt(app_1, user_0);  // same user

    
    // Setup some nodes
    String host_0 = ""127.0.0.1"";
    FiCaSchedulerNode node_0 = TestUtils.getMockNode(host_0, DEFAULT_RACK, 0,
        8*GB);

    Map<ApplicationAttemptId, FiCaSchedulerApp> apps = ImmutableMap.of(
        app_0.getApplicationAttemptId(), app_0, app_1.getApplicationAttemptId(),
        app_1);
    Map<NodeId, FiCaSchedulerNode> nodes = ImmutableMap.of(node_0.getNodeID(),
        node_0);

    final int numNodes = 1;
    Resource clusterResource = 
        Resources.createResource(numNodes * (8*GB), numNodes * 16);
    when(csContext.getNumClusterNodes()).thenReturn(numNodes);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));

    // Setup resource-requests
    Priority priority = TestUtils.createMockPriority(1);
    app_0.updateResourceRequests(Collections.singletonList(
            TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 3, true,
                priority, recordFactory)));

    app_1.updateResourceRequests(Collections.singletonList(
        TestUtils.createResourceRequest(ResourceRequest.ANY, 1*GB, 2, true,
            priority, recordFactory)));

    // Start testing...
    
    // Only 1 container
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(1*GB, a.getUsedResources().getMemorySize());
    assertEquals(1*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, a.getMetrics().getReservedMB());
    assertEquals(1*GB, a.getMetrics().getAllocatedMB());
    assertEquals(0*GB, a.getMetrics().getAvailableMB());

    // Also 2nd -> minCapacity = 1024 since (.1 * 8G) < minAlloc, also
    // you can get one container more than user-limit
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(2*GB, a.getUsedResources().getMemorySize());
    assertEquals(2*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, a.getMetrics().getReservedMB());
    assertEquals(2*GB, a.getMetrics().getAllocatedMB());
    
    // Can't allocate 3rd due to user-limit
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(2*GB, a.getUsedResources().getMemorySize());
    assertEquals(2*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, a.getMetrics().getReservedMB());
    assertEquals(2*GB, a.getMetrics().getAllocatedMB());
    
    // Bump up user-limit-factor, now allocate should work
    a.setUserLimitFactor(10);
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(3*GB, a.getUsedResources().getMemorySize());
    assertEquals(3*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, a.getMetrics().getReservedMB());
    assertEquals(3*GB, a.getMetrics().getAllocatedMB());

    // One more should work, for app_1, due to user-limit-factor
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(4*GB, a.getUsedResources().getMemorySize());
    assertEquals(3*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(1*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, a.getMetrics().getReservedMB());
    assertEquals(4*GB, a.getMetrics().getAllocatedMB());

    // Test max-capacity
    // Now - no more allocs since we are at max-cap
    a.setMaxCapacity(0.5f);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));
    applyCSAssignment(clusterResource,
        a.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), a, nodes, apps);
    assertEquals(4*GB, a.getUsedResources().getMemorySize());
    assertEquals(3*GB, app_0.getCurrentConsumption().getMemorySize());
    assertEquals(1*GB, app_1.getCurrentConsumption().getMemorySize());
    assertEquals(0*GB, a.getMetrics().getReservedMB());
    assertEquals(4*GB, a.getMetrics().getAllocatedMB());
    
    // Release each container from app_0
    for (RMContainer rmContainer : app_0.getLiveContainers()) {
      a.completedContainer(clusterResource, app_0, node_0, rmContainer,
          ContainerStatus.newInstance(rmContainer.getContainerId(),
              ContainerState.COMPLETE, """",
              ContainerExitStatus.KILLED_BY_RESOURCEMANAGER),
          RMContainerEventType.KILL, null, true);
    }",Eager Test
"@Test
  public void testMultiLevelQueues() throws Exception {
    /*
     * Structure of queue:
     *            Root
     *           ____________
     *          /    |   \   \
     *         A     B    C   D
     *       / |   / | \   \
     *      A1 A2 B1 B2 B3  C1
     *                        \
     *                         C11
     *                           \
     *                           C111
     *                             \
     *                              C1111
     */
    
    // Setup queue configs
    setupMultiLevelQueues(csConf);

    CSQueueStore queues = new CSQueueStore();
    CSQueue root =
        CapacitySchedulerQueueManager.parseQueue(queueContext, csConf, null,
            CapacitySchedulerConfiguration.ROOT, queues, queues,
            TestUtils.spyHook);
    
    // Setup some nodes
    final int memoryPerNode = 10;
    final int coresPerNode = 16;
    final int numNodes = 3;
    
    FiCaSchedulerNode node_0 = 
        TestUtils.getMockNode(""host_0"", DEFAULT_RACK, 0, memoryPerNode*GB);
    FiCaSchedulerNode node_1 = 
        TestUtils.getMockNode(""host_1"", DEFAULT_RACK, 0, memoryPerNode*GB);
    FiCaSchedulerNode node_2 = 
        TestUtils.getMockNode(""host_2"", DEFAULT_RACK, 0, memoryPerNode*GB);
    
    final Resource clusterResource = 
        Resources.createResource(numNodes * (memoryPerNode*GB), 
            numNodes * coresPerNode);
    when(csContext.getNumClusterNodes()).thenReturn(numNodes);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));

    // Start testing
    CSQueue a = queues.get(A);
    a.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));
    CSQueue b = queues.get(B);
    b.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));
    CSQueue c = queues.get(C);
    c.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));
    CSQueue d = queues.get(D);
    d.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));

    CSQueue a1 = queues.get(A1);
    a1.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));
    CSQueue a2 = queues.get(A2);
    a2.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));

    CSQueue b1 = queues.get(B1);
    b1.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));
    CSQueue b2 = queues.get(B2);
    b2.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));
    CSQueue b3 = queues.get(B3);
    b3.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));
    queues.get(CapacitySchedulerConfiguration.ROOT).getQueueResourceUsage()
    .incPending(Resources.createResource(1 * GB));

    // Simulate C returning a container on node_0
    stubQueueAllocation(a, clusterResource, node_0, 0*GB);
    stubQueueAllocation(b, clusterResource, node_0, 0*GB);
    stubQueueAllocation(c, clusterResource, node_0, 1*GB);
    stubQueueAllocation(d, clusterResource, node_0, 0*GB);
    root.assignContainers(clusterResource, node_0, 
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    verifyQueueMetrics(a, 0*GB, clusterResource);
    verifyQueueMetrics(b, 0*GB, clusterResource);
    verifyQueueMetrics(c, 1*GB, clusterResource);
    verifyQueueMetrics(d, 0*GB, clusterResource);
    reset(a); reset(b); reset(c);

    // Now get B2 to allocate
    // A = 0/3, B = 0/15, C = 1/6, D=0/6
    stubQueueAllocation(a, clusterResource, node_1, 0*GB);
    stubQueueAllocation(b2, clusterResource, node_1, 4*GB);
    stubQueueAllocation(c, clusterResource, node_1, 0*GB);
    root.assignContainers(clusterResource, node_1, 
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    applyAllocationToQueue(clusterResource, 4*GB,
        b);
    verifyQueueMetrics(a, 0*GB, clusterResource);
    verifyQueueMetrics(b, 4*GB, clusterResource);
    verifyQueueMetrics(c, 1*GB, clusterResource);
    reset(a); reset(b); reset(c);
    
    // Now get both A1, C & B3 to allocate in right order
    // A = 0/3, B = 4/15, C = 1/6, D=0/6
    stubQueueAllocation(a1, clusterResource, node_0, 1*GB);
    stubQueueAllocation(b3, clusterResource, node_0, 2*GB);
    stubQueueAllocation(c, clusterResource, node_0, 2*GB);

    root.assignContainers(clusterResource, node_0, 
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    InOrder allocationOrder = inOrder(a, c, b);
    allocationOrder.verify(a).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    applyAllocationToQueue(clusterResource, 1 * GB, a);

    root.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    allocationOrder.verify(c).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    applyAllocationToQueue(clusterResource, 2 * GB, root);

    root.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    allocationOrder.verify(b).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    applyAllocationToQueue(clusterResource, 2*GB, b);
    verifyQueueMetrics(a, 1*GB, clusterResource);
    verifyQueueMetrics(b, 6*GB, clusterResource);
    verifyQueueMetrics(c, 3*GB, clusterResource);
    reset(a); reset(b); reset(c);
    
    // Now verify max-capacity
    // A = 1/3, B = 6/15, C = 3/6, D=0/6
    // Ensure a1 won't alloc above max-cap although it should get 
    // scheduling opportunity now, right after a2
    LOG.info(""here"");
    ((ParentQueue)a).setMaxCapacity(.1f);  // a should be capped at 3/30
    stubQueueAllocation(a1, clusterResource, node_2, 1*GB); // shouldn't be 
                                                            // allocated due 
                                                            // to max-cap
    stubQueueAllocation(a2, clusterResource, node_2, 2*GB);
    stubQueueAllocation(b3, clusterResource, node_2, 1*GB);
    stubQueueAllocation(b1, clusterResource, node_2, 1*GB);
    stubQueueAllocation(c, clusterResource, node_2, 1*GB);
    root.assignContainers(clusterResource, node_2,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    allocationOrder = inOrder(a, a2, a1, b, c);
    allocationOrder.verify(a).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    allocationOrder.verify(a2).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    applyAllocationToQueue(clusterResource, 2*GB, a);

    root.assignContainers(clusterResource, node_2,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    allocationOrder.verify(b).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    applyAllocationToQueue(clusterResource, 2*GB, b);

    root.assignContainers(clusterResource, node_2,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    allocationOrder.verify(c).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    verifyQueueMetrics(a, 3*GB, clusterResource);
    verifyQueueMetrics(b, 8*GB, clusterResource);
    verifyQueueMetrics(c, 4*GB, clusterResource);
    reset(a); reset(b); reset(c);
  }",Eager Test
"@Test
  public void testOffSwitchScheduling() throws Exception {
    // Setup queue configs
    setupSingleLevelQueues(csConf);

    CSQueueStore queues = new CSQueueStore();
    CSQueue root =
        CapacitySchedulerQueueManager.parseQueue(queueContext, csConf, null,
            CapacitySchedulerConfiguration.ROOT, queues, queues,
            TestUtils.spyHook);

    // Setup some nodes
    final int memoryPerNode = 10;
    final int coresPerNode = 16;
    final int numNodes = 2;

    FiCaSchedulerNode node_0 =
        TestUtils.getMockNode(""host_0"", DEFAULT_RACK, 0, memoryPerNode*GB);
    FiCaSchedulerNode node_1 =
        TestUtils.getMockNode(""host_1"", DEFAULT_RACK, 0, memoryPerNode*GB);

    final Resource clusterResource =
        Resources.createResource(numNodes * (memoryPerNode*GB),
            numNodes * coresPerNode);
    when(csContext.getNumClusterNodes()).thenReturn(numNodes);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));

    // Start testing
    LeafQueue a = (LeafQueue)queues.get(A);
    LeafQueue b = (LeafQueue)queues.get(B);
    a.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));
    b.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));
    queues.get(CapacitySchedulerConfiguration.ROOT).getQueueResourceUsage()
        .incPending(Resources.createResource(1 * GB));

    // Simulate B returning a container on node_0
    stubQueueAllocation(a, clusterResource, node_0, 0*GB, NodeType.OFF_SWITCH);
    stubQueueAllocation(b, clusterResource, node_0, 1*GB, NodeType.OFF_SWITCH);
    root.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    verifyQueueMetrics(a, 0*GB, clusterResource);
    verifyQueueMetrics(b, 1*GB, clusterResource);

    // Now, A should get the scheduling opportunity since A=0G/6G, B=1G/14G
    // also, B gets a scheduling opportunity since A allocates RACK_LOCAL
    stubQueueAllocation(a, clusterResource, node_1, 2*GB, NodeType.RACK_LOCAL);
    stubQueueAllocation(b, clusterResource, node_1, 1*GB, NodeType.OFF_SWITCH);
    root.assignContainers(clusterResource, node_1,
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    InOrder allocationOrder = inOrder(a);
    allocationOrder.verify(a).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    root.assignContainers(clusterResource, node_1,
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    allocationOrder = inOrder(b);
    allocationOrder.verify(b).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    verifyQueueMetrics(a, 2*GB, clusterResource);
    verifyQueueMetrics(b, 2*GB, clusterResource);

    // Now, B should get the scheduling opportunity
    // since A has 2/6G while B has 2/14G,
    // However, since B returns off-switch, A won't get an opportunity
    stubQueueAllocation(a, clusterResource, node_0, 1*GB, NodeType.NODE_LOCAL);
    stubQueueAllocation(b, clusterResource, node_0, 2*GB, NodeType.OFF_SWITCH);
    root.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    allocationOrder = inOrder(b, a);
    allocationOrder.verify(b).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    allocationOrder.verify(a).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    verifyQueueMetrics(a, 2*GB, clusterResource);
    verifyQueueMetrics(b, 4*GB, clusterResource);

  }",Eager Test
"@Test
  public void testQueueAcl() throws Exception {
 
    setupMultiLevelQueues(csConf);
    csConf.setAcl(ROOT, QueueACL.SUBMIT_APPLICATIONS, "" "");
    csConf.setAcl(ROOT, QueueACL.ADMINISTER_QUEUE, "" "");

    csConf.setAcl(Q_C, QueueACL.ADMINISTER_QUEUE, ""*"");
    csConf.setAcl(Q_C11, QueueACL.SUBMIT_APPLICATIONS, ""*"");
    queueContext.reinitialize();

    CSQueueStore queues = new CSQueueStore();
    CSQueue root = 
        CapacitySchedulerQueueManager.parseQueue(queueContext, csConf, null,
            CapacitySchedulerConfiguration.ROOT, queues, queues,
            TestUtils.spyHook);
    YarnAuthorizationProvider authorizer =
        YarnAuthorizationProvider.getInstance(conf);
    AppPriorityACLsManager appPriorityACLManager = new AppPriorityACLsManager(
        conf);
    CapacitySchedulerQueueManager.setQueueAcls(authorizer,
        appPriorityACLManager, queues);

    UserGroupInformation user = UserGroupInformation.getCurrentUser();
    // Setup queue configs
    ParentQueue c = (ParentQueue)queues.get(C);
    ParentQueue c1 = (ParentQueue)queues.get(C1);
    ParentQueue c11 = (ParentQueue)queues.get(C11);
    ParentQueue c111 = (ParentQueue)queues.get(C111);

    assertFalse(root.hasAccess(QueueACL.ADMINISTER_QUEUE, user));
    List<QueueUserACLInfo> aclInfos = root.getQueueUserAclInfo(user);
    assertFalse(hasQueueACL(aclInfos, QueueACL.ADMINISTER_QUEUE, ""root""));
    
    assertFalse(root.hasAccess(QueueACL.SUBMIT_APPLICATIONS, user));
    assertFalse(hasQueueACL(aclInfos, QueueACL.SUBMIT_APPLICATIONS, ""root""));

    // c has no SA, but QA
    assertTrue(c.hasAccess(QueueACL.ADMINISTER_QUEUE, user));
    assertTrue(hasQueueACL(aclInfos,  QueueACL.ADMINISTER_QUEUE, ""root.c""));
    assertFalse(c.hasAccess(QueueACL.SUBMIT_APPLICATIONS, user));
    assertFalse(hasQueueACL(aclInfos, QueueACL.SUBMIT_APPLICATIONS, ""root.c""));

    //Queue c1 has QA, no SA (gotten perm from parent)
    assertTrue(c1.hasAccess(QueueACL.ADMINISTER_QUEUE, user)); 
    assertTrue(hasQueueACL(aclInfos,  QueueACL.ADMINISTER_QUEUE, ""root.c.c1""));
    assertFalse(c1.hasAccess(QueueACL.SUBMIT_APPLICATIONS, user)); 
    assertFalse(hasQueueACL(
        aclInfos, QueueACL.SUBMIT_APPLICATIONS, ""root.c.c1""));

    //Queue c11 has permissions from parent queue and SA
    assertTrue(c11.hasAccess(QueueACL.ADMINISTER_QUEUE, user));
    assertTrue(hasQueueACL(
        aclInfos,  QueueACL.ADMINISTER_QUEUE, ""root.c.c1.c11""));
    assertTrue(c11.hasAccess(QueueACL.SUBMIT_APPLICATIONS, user));
    assertTrue(
        hasQueueACL(aclInfos, QueueACL.SUBMIT_APPLICATIONS, ""root.c.c1.c11""));

    //Queue c111 has SA and AQ, both from parent
    assertTrue(c111.hasAccess(QueueACL.ADMINISTER_QUEUE, user));
    assertTrue(hasQueueACL(
        aclInfos,  QueueACL.ADMINISTER_QUEUE, ""root.c.c1.c11.c111""));
    assertTrue(c111.hasAccess(QueueACL.SUBMIT_APPLICATIONS, user));
    assertTrue(hasQueueACL(
        aclInfos, QueueACL.SUBMIT_APPLICATIONS, ""root.c.c1.c11.c111""));

    reset(c);
  }",Eager Test
"@Test
  public void testSingleLevelQueues() throws Exception {
    // Setup queue configs
    setupSingleLevelQueues(csConf);

    CSQueueStore queues = new CSQueueStore();
    CSQueue root =
        CapacitySchedulerQueueManager.parseQueue(queueContext, csConf, null,
            CapacitySchedulerConfiguration.ROOT, queues, queues, 
            TestUtils.spyHook);

    // Setup some nodes
    final int memoryPerNode = 10;
    final int coresPerNode = 16;
    final int numNodes = 2;
    
    FiCaSchedulerNode node_0 = 
        TestUtils.getMockNode(""host_0"", DEFAULT_RACK, 0, memoryPerNode*GB);
    FiCaSchedulerNode node_1 = 
        TestUtils.getMockNode(""host_1"", DEFAULT_RACK, 0, memoryPerNode*GB);
    
    final Resource clusterResource = 
        Resources.createResource(numNodes * (memoryPerNode*GB),
            numNodes * coresPerNode);
    when(csContext.getNumClusterNodes()).thenReturn(numNodes);
    root.updateClusterResource(clusterResource,
        new ResourceLimits(clusterResource));

    // Start testing
    LeafQueue a = (LeafQueue)queues.get(A);
    LeafQueue b = (LeafQueue)queues.get(B);
    
    a.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));
    b.getQueueResourceUsage().incPending(Resources.createResource(1 * GB));
    queues.get(CapacitySchedulerConfiguration.ROOT).getQueueResourceUsage()
    .incPending(Resources.createResource(1 * GB));
    
    // Simulate B returning a container on node_0
    stubQueueAllocation(a, clusterResource, node_0, 0*GB);
    stubQueueAllocation(b, clusterResource, node_0, 1*GB);
    root.assignContainers(clusterResource, node_0, 
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    verifyQueueMetrics(a, 0*GB, clusterResource);
    verifyQueueMetrics(b, 1*GB, clusterResource);
    
    // Now, A should get the scheduling opportunity since A=0G/6G, B=1G/14G
    stubQueueAllocation(a, clusterResource, node_1, 2*GB);
    stubQueueAllocation(b, clusterResource, node_1, 1*GB);
    root.assignContainers(clusterResource, node_1,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    InOrder allocationOrder = inOrder(a, b);
    allocationOrder.verify(a).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    root.assignContainers(clusterResource, node_1,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    allocationOrder.verify(b).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    verifyQueueMetrics(a, 2*GB, clusterResource);
    verifyQueueMetrics(b, 2*GB, clusterResource);

    // Now, B should get the scheduling opportunity 
    // since A has 2/6G while B has 2/14G
    stubQueueAllocation(a, clusterResource, node_0, 1*GB);
    stubQueueAllocation(b, clusterResource, node_0, 2*GB);
    root.assignContainers(clusterResource, node_0, 
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    root.assignContainers(clusterResource, node_0,
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    allocationOrder = inOrder(b, a);
    allocationOrder.verify(b).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    allocationOrder.verify(a).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    verifyQueueMetrics(a, 3*GB, clusterResource);
    verifyQueueMetrics(b, 4*GB, clusterResource);

    // Now, B should still get the scheduling opportunity 
    // since A has 3/6G while B has 4/14G
    stubQueueAllocation(a, clusterResource, node_0, 0*GB);
    stubQueueAllocation(b, clusterResource, node_0, 4*GB);
    root.assignContainers(clusterResource, node_0, 
        new ResourceLimits(clusterResource), SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    allocationOrder = inOrder(b, a);
    allocationOrder.verify(b).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    allocationOrder.verify(a).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    verifyQueueMetrics(a, 3*GB, clusterResource);
    verifyQueueMetrics(b, 8*GB, clusterResource);

    // Now, A should get the scheduling opportunity 
    // since A has 3/6G while B has 8/14G
    stubQueueAllocation(a, clusterResource, node_1, 1*GB);
    stubQueueAllocation(b, clusterResource, node_1, 1*GB);
    root.assignContainers(clusterResource, node_1,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    root.assignContainers(clusterResource, node_1,
        new ResourceLimits(clusterResource),
        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);
    allocationOrder = inOrder(a, b);
    allocationOrder.verify(b).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    allocationOrder.verify(a).assignContainers(eq(clusterResource),
        any(CandidateNodeSet.class), anyResourceLimits(),
        any(SchedulingMode.class));
    verifyQueueMetrics(a, 4*GB, clusterResource);
    verifyQueueMetrics(b, 9*GB, clusterResource);
  }",Eager Test
"@Test
  public void testTempContainerAllocations()
      throws InvalidAllocationTagsQueryException {
    /**
     * Construct both TEMP and normal containers: Node1: TEMP container_1_1
     * (mapper/reducer/app_1) container_1_2 (service/app_1)
     *
     * Node2: container_1_3 (reducer/app_1) TEMP container_2_1 (service/app_2)
     */

    AllocationTagsManager atm = new AllocationTagsManager(rmContext);
    LocalAllocationTagsManager ephAtm =
        new LocalAllocationTagsManager(atm);

    // 3 Containers from app1
    ephAtm.addTempTags(NodeId.fromString(""host1:123""),
        TestUtils.getMockApplicationId(1),
        ImmutableSet.of(""mapper"", ""reducer""));

    atm.addContainer(NodeId.fromString(""host1:123""),
        TestUtils.getMockContainerId(1, 2), ImmutableSet.of(""service""));

    atm.addContainer(NodeId.fromString(""host2:123""),
        TestUtils.getMockContainerId(1, 3), ImmutableSet.of(""reducer""));

    // 1 Container from app2
    ephAtm.addTempTags(NodeId.fromString(""host2:123""),
        TestUtils.getMockApplicationId(2), ImmutableSet.of(""service""));

    // Expect tag mappings to be present including temp Tags
    Assert.assertEquals(1,
        atm.getNodeCardinalityByOp(NodeId.fromString(""host1:123""),
            AllocationTags.createSingleAppAllocationTags(
                TestUtils.getMockApplicationId(1),
                ImmutableSet.of(""mapper"")),
            Long::sum));

    Assert.assertEquals(1,
        atm.getNodeCardinalityByOp(NodeId.fromString(""host1:123""),
            AllocationTags.createSingleAppAllocationTags(
                TestUtils.getMockApplicationId(1),
                ImmutableSet.of(""service"")),
            Long::sum));

    Assert.assertEquals(1,
        atm.getNodeCardinalityByOp(NodeId.fromString(""host2:123""),
            AllocationTags.createSingleAppAllocationTags(
                TestUtils.getMockApplicationId(2),
                ImmutableSet.of(""service"")),
            Long::sum));

    // Do a temp Tag cleanup on app2
    ephAtm.cleanTempContainers(TestUtils.getMockApplicationId(2));
    Assert.assertEquals(0,
        atm.getNodeCardinalityByOp(NodeId.fromString(""host2:123""),
            AllocationTags.createSingleAppAllocationTags(
                TestUtils.getMockApplicationId(2),
                ImmutableSet.of(""service"")),
            Long::sum));
    // Expect app1 to be unaffected
    Assert.assertEquals(1,
        atm.getNodeCardinalityByOp(NodeId.fromString(""host1:123""),
            AllocationTags.createSingleAppAllocationTags(
                TestUtils.getMockApplicationId(1),
                ImmutableSet.of(""mapper"")),
            Long::sum));
    // Do a cleanup on app1 as well
    ephAtm.cleanTempContainers(TestUtils.getMockApplicationId(1));
    Assert.assertEquals(0,
        atm.getNodeCardinalityByOp(NodeId.fromString(""host1:123""),
            AllocationTags.createSingleAppAllocationTags(
                TestUtils.getMockApplicationId(1),
                ImmutableSet.of(""mapper"")),
            Long::sum));

    // Non temp-tags should be unaffected
    Assert.assertEquals(1,
        atm.getNodeCardinalityByOp(NodeId.fromString(""host1:123""),
            AllocationTags.createSingleAppAllocationTags(
                TestUtils.getMockApplicationId(1),
                ImmutableSet.of(""service"")),
            Long::sum));

    Assert.assertEquals(0,
        atm.getNodeCardinalityByOp(NodeId.fromString(""host2:123""),
            AllocationTags.createSingleAppAllocationTags(
                TestUtils.getMockApplicationId(2),
                ImmutableSet.of(""service"")),
            Long::sum));

    // Expect app2 with no containers, and app1 with 2 containers across 2 nodes
    Assert.assertEquals(2,
        atm.getPerAppNodeMappings().get(TestUtils.getMockApplicationId(1))
            .getTypeToTagsWithCount().size());

    Assert.assertNull(
        atm.getPerAppNodeMappings().get(TestUtils.getMockApplicationId(2)));
  }",Eager Test
"@Test
  public void testGlobalConstraints() {
    Assert.assertEquals(0, pcm.getNumGlobalConstraints());
    pcm.addGlobalConstraint(sourceTag1, c1, false);
    Assert.assertEquals(1, pcm.getNumGlobalConstraints());
    Assert.assertNotNull(pcm.getGlobalConstraint(sourceTag1));

    // Constraint for sourceTag1 should not be replaced.
    pcm.addGlobalConstraint(sourceTag1, c2, false);
    Assert.assertEquals(1, pcm.getNumGlobalConstraints());
    Assert.assertEquals(c1, pcm.getGlobalConstraint(sourceTag1));
    Assert.assertNotEquals(c2, pcm.getGlobalConstraint(sourceTag1));

    // Now c2 should replace c1 for sourceTag1.
    pcm.addGlobalConstraint(sourceTag1, c2, true);
    Assert.assertEquals(1, pcm.getNumGlobalConstraints());
    Assert.assertEquals(c2, pcm.getGlobalConstraint(sourceTag1));

    pcm.removeGlobalConstraint(sourceTag1);
    Assert.assertEquals(0, pcm.getNumGlobalConstraints());
  }",No Smells
"@Test
  public void testInvalidAllocationTagNamespace() {
    AllocationTagsManager tm = new AllocationTagsManager(rmContext);
    PlacementConstraintManagerService pcm =
        new MemoryPlacementConstraintManager();
    rmContext.setAllocationTagsManager(tm);
    rmContext.setPlacementConstraintManager(pcm);

    long ts = System.currentTimeMillis();
    ApplicationId application1 = BuilderUtils.newApplicationId(ts, 123);
    RMNode n0r1 = rmNodes.get(0);
    SchedulerNode schedulerNode0 = newSchedulerNode(n0r1.getHostName(),
        n0r1.getRackName(), n0r1.getNodeID());

    PlacementConstraint constraint1 = PlacementConstraints
        .targetNotIn(NODE, allocationTagWithNamespace(""unknown_namespace"",
            ""hbase-m""))
        .build();
    Set<String> srcTags1 = new HashSet<>();
    srcTags1.add(""app1"");

    try {
      PlacementConstraintsUtil.canSatisfyConstraints(application1,
          createSchedulingRequest(srcTags1, constraint1), schedulerNode0,
          pcm, tm);
      Assert.fail(""This should fail because we gave an invalid namespace"");
    }",Eager Test
"@Test
  public void testNodeAntiAffinityAssignment()
      throws InvalidAllocationTagsQueryException {
    PlacementConstraintManagerService pcm =
        new MemoryPlacementConstraintManager();
    AllocationTagsManager tm = new AllocationTagsManager(rmContext);
    // Register App1 with anti-affinity constraint map
    pcm.registerApplication(appId1, constraintMap2);
    /**
     * place container:
     * Node0:123 (Rack1):
     *    container_app1_1 (hbase-m)
     */
    RMNode n0_r1 = rmNodes.get(0);
    RMNode n1_r1 = rmNodes.get(1);
    RMNode n2_r2 = rmNodes.get(2);
    RMNode n3_r2 = rmNodes.get(3);

    SchedulerNode schedulerNode0 =newSchedulerNode(n0_r1.getHostName(),
        n0_r1.getRackName(), n0_r1.getNodeID());
    SchedulerNode schedulerNode1 =newSchedulerNode(n1_r1.getHostName(),
        n1_r1.getRackName(), n1_r1.getNodeID());
    SchedulerNode schedulerNode2 =newSchedulerNode(n2_r2.getHostName(),
        n2_r2.getRackName(), n2_r2.getNodeID());
    SchedulerNode schedulerNode3 =newSchedulerNode(n3_r2.getHostName(),
        n3_r2.getRackName(), n3_r2.getNodeID());

    // 1 Containers on node 0 with allocationTag 'hbase-m'
    ContainerId hbase_m = ContainerId
        .newContainerId(ApplicationAttemptId.newInstance(appId1, 0), 0);
    tm.addContainer(n0_r1.getNodeID(), hbase_m, ImmutableSet.of(""hbase-m""));

    // 'spark' placement on Node0 should now FAIL
    Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag1), schedulerNode0, pcm, tm));
    // SUCCEED on the rest of the nodes
    Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag1), schedulerNode1, pcm, tm));
    Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag1), schedulerNode2, pcm, tm));
    Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag1), schedulerNode3, pcm, tm));
  }",Eager Test
"@Test
  public void testORConstraintAssignment()
      throws InvalidAllocationTagsQueryException {
    AllocationTagsManager tm = new AllocationTagsManager(rmContext);
    PlacementConstraintManagerService pcm =
        new MemoryPlacementConstraintManager();
    // Register App1 with anti-affinity constraint map.
    pcm.registerApplication(appId1, constraintMap4);
    RMNode n0r1 = rmNodes.get(0);
    RMNode n1r1 = rmNodes.get(1);
    RMNode n2r2 = rmNodes.get(2);
    RMNode n3r2 = rmNodes.get(3);

    /**
     * Place container:
     *  n0: hbase-m(1)
     *  n1: """"
     *  n2: hbase-rs(1)
     *  n3: """"
     */
    tm.addContainer(n0r1.getNodeID(),
        newContainerId(appId1, 1), ImmutableSet.of(""hbase-m""));
    tm.addContainer(n2r2.getNodeID(),
        newContainerId(appId1, 2), ImmutableSet.of(""hbase-rs""));
    Assert.assertEquals(1L, tm.getAllocationTagsWithCount(n0r1.getNodeID())
        .get(""hbase-m"").longValue());
    Assert.assertEquals(1L, tm.getAllocationTagsWithCount(n2r2.getNodeID())
        .get(""hbase-rs"").longValue());

    SchedulerNode schedulerNode0 =newSchedulerNode(n0r1.getHostName(),
        n0r1.getRackName(), n0r1.getNodeID());
    SchedulerNode schedulerNode1 =newSchedulerNode(n1r1.getHostName(),
        n1r1.getRackName(), n1r1.getNodeID());
    SchedulerNode schedulerNode2 =newSchedulerNode(n2r2.getHostName(),
        n2r2.getRackName(), n2r2.getNodeID());
    SchedulerNode schedulerNode3 =newSchedulerNode(n3r2.getHostName(),
        n3r2.getRackName(), n3r2.getNodeID());

    // n0 and n2 should be qualified for allocation as
    // they either have hbase-m or hbase-rs tag
    Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag1), schedulerNode0, pcm, tm));
    Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag1), schedulerNode1, pcm, tm));
    Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag1), schedulerNode2, pcm, tm));
    Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag1), schedulerNode3, pcm, tm));

    /**
     * Place container:
     *  n0: hbase-m(1)
     *  n1: """"
     *  n2: hbase-rs(1)
     *  n3: hbase-rs(1)
     */
    tm.addContainer(n3r2.getNodeID(),
        newContainerId(appId1, 2), ImmutableSet.of(""hbase-rs""));
    // n3 is qualified now because it is allocated with hbase-rs tag
    Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag1), schedulerNode3, pcm, tm));

    /**
     * Place container:
     *  n0: hbase-m(1)
     *  n1: """"
     *  n2: hbase-rs(1), spark(1)
     *  n3: hbase-rs(1)
     */
    // Place
    tm.addContainer(n2r2.getNodeID(),
        newContainerId(appId1, 3), ImmutableSet.of(""spark""));
    // According to constraint, ""zk"" is allowed to be placed on a node
    // has ""hbase-m"" tag OR a node has both ""hbase-rs"" and ""spark"" tags.
    Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag2), schedulerNode0, pcm, tm));
    Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag2), schedulerNode1, pcm, tm));
    Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag2), schedulerNode2, pcm, tm));
    Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints(appId1,
        createSchedulingRequest(sourceTag2), schedulerNode3, pcm, tm));
  }",Eager Test
"@Test
  public void testCalculateMinShareRatios() {
    Map<String, Integer> index = ResourceUtils.getResourceTypeIndex();
    Resource used = Resources.createResource(10, 5);
    Resource minShares = Resources.createResource(5, 10);
    float[][] ratios = new float[3][3];
    DominantResourceFairnessComparatorN comparator =
        new DominantResourceFairnessComparatorN();

    used.setResourceValue(""test"", 2L);
    minShares.setResourceValue(""test"", 0L);

    comparator.calculateMinShareRatios(used, minShares, ratios);

    assertEquals(""Calculated min share ratio for memory (10MB out of 5MB) is ""
        + ""incorrect"", 2.0,
        ratios[index.get(ResourceInformation.MEMORY_MB.getName())][2], .00001f);
    assertEquals(""Calculated min share ratio for vcores (5 out of 10) is ""
        + ""incorrect"", 0.5,
        ratios[index.get(ResourceInformation.VCORES.getName())][2], .00001f);
    assertEquals(""Calculated min share ratio for test resource (0 out of 5) is ""
        + ""incorrect"", Float.POSITIVE_INFINITY, ratios[index.get(""test"")][2],
        0.00001f);
  }",Eager Test
"@Test
  public void testCompareSchedulablesWithClusterResourceChanges(){
    Schedulable schedulable1 = createSchedulable(2000, 1);
    Schedulable schedulable2 = createSchedulable(1000, 2);

    // schedulable1 has share weights [1/2, 1/5], schedulable2 has share
    // weights [1/4, 2/5], schedulable1 > schedulable2 since 1/2 > 2/5
    assertTrue(createComparator(4000, 5)
        .compare(schedulable1, schedulable2) > 0);

    // share weights have changed because of the cluster resource change.
    // schedulable1 has share weights [1/4, 1/6], schedulable2 has share
    // weights [1/8, 1/3], schedulable1 < schedulable2 since 1/4 < 1/3
    assertTrue(createComparator(8000, 6)
        .compare(schedulable1, schedulable2) < 0);
  }",No Smells
"@Test
  public void testEvenWeightsDifferentDominantResource2() {
    ResourceUtils.resetResourceTypes(new Configuration());
    testEvenWeightsDifferentDominantResource();
  }",No Smells
"@Test
  public void testOneIsNeedy2() {
    ResourceUtils.resetResourceTypes(new Configuration());
    testOneIsNeedy();
  }",No Smells
"@Test
  public void testBackwardsCompatibleAllocationFileParsing() throws Exception {
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, ALLOC_FILE);
    AllocationFileLoaderService allocLoader =
        new AllocationFileLoaderService(scheduler);

    AllocationFileWriter.create()
        .useLegacyTagNameForQueues()
        // Give queue A a minimum of 1024 M
        .addQueue(new AllocationFileQueue.Builder(""queueA"")
            .minResources(""1024mb,0vcores"")
            .build())
        // Give queue B a minimum of 2048 M
        .addQueue(new AllocationFileQueue.Builder(""queueB"")
            .minResources(""2048mb,0vcores"")
            .aclAdministerApps(""alice,bob admins"")
            .build())
        // Give queue C no minimum
        .addQueue(new AllocationFileQueue.Builder(""queueC"")
            .aclAdministerApps(""alice,bob admins"")
            .build())
        // Give queue D a limit of 3 running apps
        .addQueue(new AllocationFileQueue.Builder(""queueD"")
            .maxRunningApps(3)
            .build())
        // Give queue E a preemption timeout of one minute and 0.3f threshold
        .addQueue(new AllocationFileQueue.Builder(""queueE"")
            .minSharePreemptionTimeout(60)
            .fairSharePreemptionThreshold(0.3)
            .build())
        // Set default limit of apps per queue to 15
        .queueMaxAppsDefault(15)
        // Set default limit of apps per user to 5
        .userMaxAppsDefault(5)
        // Set default limit of max resource per queue to 4G and 100 cores
        .queueMaxResourcesDefault(""4096mb,100vcores"")
        // Set default limit of AMResourceShare to 0.5f
        .queueMaxAMShareDefault(0.5)
        // Set default min share preemption timeout to 2 minutes
        .defaultMinSharePreemptionTimeout(120)
        // Set default fair share preemption timeout to 5 minutes
        .defaultFairSharePreemptionTimeout(300)
        // Set default fair share preemption threshold to 0.6
        .defaultFairSharePreemptionThreshold(0.6)
        // Set default scheduling policy to DRF
        .drfDefaultQueueSchedulingPolicy()
        // Give user1 a limit of 10 jobs
        .userSettings(new UserSettings.Builder(""user1"")
            .maxRunningApps(10)
            .build())
        .writeToFile(ALLOC_FILE);

    allocLoader.init(conf);
    ReloadListener confHolder = new ReloadListener();
    allocLoader.setReloadListener(confHolder);
    allocLoader.reloadAllocations();
    AllocationConfiguration queueConf = confHolder.allocConf;

    assertEquals(5, queueConf.getConfiguredQueues().get(FSQueueType.LEAF).size());
    assertEquals(Resources.createResource(0),
        queueConf.getMinResources(""root."" + YarnConfiguration.DEFAULT_QUEUE_NAME));
    assertEquals(Resources.createResource(0),
        queueConf.getMinResources(""root."" + YarnConfiguration.DEFAULT_QUEUE_NAME));

    assertEquals(Resources.createResource(1024, 0),
        queueConf.getMinResources(""root.queueA""));
    assertEquals(Resources.createResource(2048, 0),
        queueConf.getMinResources(""root.queueB""));
    assertEquals(Resources.createResource(0),
        queueConf.getMinResources(""root.queueC""));
    assertEquals(Resources.createResource(0),
        queueConf.getMinResources(""root.queueD""));
    assertEquals(Resources.createResource(0),
        queueConf.getMinResources(""root.queueE""));

    assertEquals(15, queueConf.getQueueMaxApps(""root."" + YarnConfiguration.DEFAULT_QUEUE_NAME));
    assertEquals(15, queueConf.getQueueMaxApps(""root.queueA""));
    assertEquals(15, queueConf.getQueueMaxApps(""root.queueB""));
    assertEquals(15, queueConf.getQueueMaxApps(""root.queueC""));
    assertEquals(3, queueConf.getQueueMaxApps(""root.queueD""));
    assertEquals(15, queueConf.getQueueMaxApps(""root.queueE""));
    assertEquals(10, queueConf.getUserMaxApps(""user1""));
    assertEquals(5, queueConf.getUserMaxApps(""user2""));

    assertEquals(120000, queueConf.getMinSharePreemptionTimeout(""root""));
    assertEquals(-1, queueConf.getMinSharePreemptionTimeout(""root."" +
        YarnConfiguration.DEFAULT_QUEUE_NAME));
    assertEquals(-1, queueConf.getMinSharePreemptionTimeout(""root.queueA""));
    assertEquals(-1, queueConf.getMinSharePreemptionTimeout(""root.queueB""));
    assertEquals(-1, queueConf.getMinSharePreemptionTimeout(""root.queueC""));
    assertEquals(-1, queueConf.getMinSharePreemptionTimeout(""root.queueD""));
    assertEquals(60000, queueConf.getMinSharePreemptionTimeout(""root.queueE""));

    assertEquals(300000, queueConf.getFairSharePreemptionTimeout(""root""));
    assertEquals(-1, queueConf.getFairSharePreemptionTimeout(""root."" +
        YarnConfiguration.DEFAULT_QUEUE_NAME));
    assertEquals(-1, queueConf.getFairSharePreemptionTimeout(""root.queueA""));
    assertEquals(-1, queueConf.getFairSharePreemptionTimeout(""root.queueB""));
    assertEquals(-1, queueConf.getFairSharePreemptionTimeout(""root.queueC""));
    assertEquals(-1, queueConf.getFairSharePreemptionTimeout(""root.queueD""));
    assertEquals(-1, queueConf.getFairSharePreemptionTimeout(""root.queueE""));

    assertEquals(.6f, queueConf.getFairSharePreemptionThreshold(""root""), 0.01);
    assertEquals(-1, queueConf.getFairSharePreemptionThreshold(""root.""
        + YarnConfiguration.DEFAULT_QUEUE_NAME), 0.01);
    assertEquals(-1,
        queueConf.getFairSharePreemptionThreshold(""root.queueA""), 0.01);
    assertEquals(-1,
        queueConf.getFairSharePreemptionThreshold(""root.queueB""), 0.01);
    assertEquals(-1,
        queueConf.getFairSharePreemptionThreshold(""root.queueC""), 0.01);
    assertEquals(-1,
        queueConf.getFairSharePreemptionThreshold(""root.queueD""), 0.01);
    assertEquals(.3f,
        queueConf.getFairSharePreemptionThreshold(""root.queueE""), 0.01);
  }",Eager Test
"@Test
  public void testParentTagWithReservation() throws Exception {
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, ALLOC_FILE);

    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder(""parent"")
            .parent(true)
            .reservation()
            .build())
        .writeToFile(ALLOC_FILE);

    AllocationFileLoaderService allocLoader =
        new AllocationFileLoaderService(scheduler);
    allocLoader.init(conf);
    ReloadListener confHolder = new ReloadListener();
    allocLoader.setReloadListener(confHolder);
    try {
      allocLoader.reloadAllocations();
    }",Eager Test
"@Test
  public void testEmptyList() {
    ComputeFairShares.computeShares(scheds,
        Resources.createResource(40), ResourceInformation.MEMORY_MB.getName());
    verifyMemoryShares();
  }",No Smells
"@Test
  public void testLargeShares() {
    long giga = 1000L * 1000L * 1000L * 4L;
    scheds.add(new FakeSchedulable(0L, giga));
    scheds.add(new FakeSchedulable(0L, giga));
    scheds.add(new FakeSchedulable(0L, giga));
    scheds.add(new FakeSchedulable(0L, giga));
    ComputeFairShares.computeShares(scheds,
        Resources.createResource(4 * giga),
        ResourceInformation.MEMORY_MB.getName());
    verifyMemoryShares(giga, giga, giga, giga);
  }",No Smells
"@Test
  public void testMinShares() {
    scheds.add(new FakeSchedulable(20));
    scheds.add(new FakeSchedulable(18));
    scheds.add(new FakeSchedulable(0));
    scheds.add(new FakeSchedulable(2));
    ComputeFairShares.computeShares(scheds,
        Resources.createResource(40), ResourceInformation.MEMORY_MB.getName());
    verifyMemoryShares(20, 18, 0, 2);
  }",No Smells
"@Test
  public void testWeightedSharingWithMinShares() {
    scheds.add(new FakeSchedulable(20, 2.0f));
    scheds.add(new FakeSchedulable(0, 1.0f));
    scheds.add(new FakeSchedulable(5, 1.0f));
    scheds.add(new FakeSchedulable(15, 0.5f));
    ComputeFairShares.computeShares(scheds,
        Resources.createResource(45), ResourceInformation.MEMORY_MB.getName());
    verifyMemoryShares(20, 5, 5, 15);
  }",No Smells
"@Test
  public void testAclSubmitApplication() throws Exception {
    // Set acl's
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, ALLOC_FILE);

    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder(""root"")
            .aclSubmitApps("" "")
            .aclAdministerApps("" "")
            .subQueue(new AllocationFileQueue.Builder(""queue1"")
                .aclSubmitApps(""norealuserhasthisname"")
                .aclAdministerApps(""norealuserhasthisname"")
                .build())
            .build())
        .writeToFile(ALLOC_FILE);

    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    ApplicationAttemptId attId1 = createSchedulingRequest(1024, ""queue1"",
        ""norealuserhasthisname"", 1);
    ApplicationAttemptId attId2 = createSchedulingRequest(1024, ""queue1"",
        ""norealuserhasthisname2"", 1);

    FSAppAttempt app1 = scheduler.getSchedulerApp(attId1);
    assertNotNull(""The application was not allowed"", app1);
    FSAppAttempt app2 = scheduler.getSchedulerApp(attId2);
    assertNull(""The application was allowed"", app2);
  }",Eager Test
"@Test
  public void testAggregateCapacityTracking() throws Exception {
    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    // Add a node
    RMNode node1 =
        MockNodes
            .newNodeInfo(1, Resources.createResource(1024), 1, ""127.0.0.1"");
    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);
    assertEquals(1024, scheduler.getClusterResource().getMemorySize());

    // Add another node
    RMNode node2 =
        MockNodes.newNodeInfo(1, Resources.createResource(512), 2, ""127.0.0.2"");
    NodeAddedSchedulerEvent nodeEvent2 = new NodeAddedSchedulerEvent(node2);
    scheduler.handle(nodeEvent2);
    assertEquals(1536, scheduler.getClusterResource().getMemorySize());

    // Remove the first node
    NodeRemovedSchedulerEvent nodeEvent3 = new NodeRemovedSchedulerEvent(node1);
    scheduler.handle(nodeEvent3);
    assertEquals(512, scheduler.getClusterResource().getMemorySize());
  }",Eager Test
"@Test
  public void testAMStrictLocalityRackInvalid() throws IOException {
    testAMStrictLocality(false, true);
  }",No Smells
"@Test
  public void testBasicDRFAssignment() throws Exception {
    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    RMNode node = MockNodes.newNodeInfo(1, Resources.createResource(8192, 5));
    NodeAddedSchedulerEvent nodeEvent = new NodeAddedSchedulerEvent(node);
    scheduler.handle(nodeEvent);

    ApplicationAttemptId appAttId1 = createSchedulingRequest(2048, 1, ""queue1"",
        ""user1"", 2);
    FSAppAttempt app1 = scheduler.getSchedulerApp(appAttId1);
    ApplicationAttemptId appAttId2 = createSchedulingRequest(1024, 2, ""queue1"",
        ""user1"", 2);
    FSAppAttempt app2 = scheduler.getSchedulerApp(appAttId2);

    DominantResourceFairnessPolicy drfPolicy = new DominantResourceFairnessPolicy();
    drfPolicy.initialize(scheduler.getContext());
    scheduler.getQueueManager().getQueue(""queue1"").setPolicy(drfPolicy);
    scheduler.update();

    // First both apps get a container
    // Then the first gets another container because its dominant share of
    // 2048/8192 is less than the other's of 2/5
    NodeUpdateSchedulerEvent updateEvent = new NodeUpdateSchedulerEvent(node);
    scheduler.handle(updateEvent);
    Assert.assertEquals(1, app1.getLiveContainers().size());
    Assert.assertEquals(0, app2.getLiveContainers().size());

    scheduler.handle(updateEvent);
    Assert.assertEquals(1, app1.getLiveContainers().size());
    Assert.assertEquals(1, app2.getLiveContainers().size());

    scheduler.handle(updateEvent);
    Assert.assertEquals(2, app1.getLiveContainers().size());
    Assert.assertEquals(1, app2.getLiveContainers().size());
  }",Eager Test
"@Test
  public void testBasicDRFWithQueues() throws Exception {
    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    RMNode node = MockNodes.newNodeInfo(1, Resources.createResource(8192, 7),
        1, ""127.0.0.1"");
    NodeAddedSchedulerEvent nodeEvent = new NodeAddedSchedulerEvent(node);
    scheduler.handle(nodeEvent);

    ApplicationAttemptId appAttId1 = createSchedulingRequest(3072, 1, ""queue1"",
        ""user1"", 2);
    FSAppAttempt app1 = scheduler.getSchedulerApp(appAttId1);
    ApplicationAttemptId appAttId2 = createSchedulingRequest(2048, 2, ""queue1"",
        ""user1"", 2);
    FSAppAttempt app2 = scheduler.getSchedulerApp(appAttId2);
    ApplicationAttemptId appAttId3 = createSchedulingRequest(1024, 2, ""queue2"",
        ""user1"", 2);
    FSAppAttempt app3 = scheduler.getSchedulerApp(appAttId3);
    
    DominantResourceFairnessPolicy drfPolicy = new DominantResourceFairnessPolicy();
    drfPolicy.initialize(scheduler.getContext());
    scheduler.getQueueManager().getQueue(""root"").setPolicy(drfPolicy);
    scheduler.getQueueManager().getQueue(""queue1"").setPolicy(drfPolicy);
    scheduler.update();

    NodeUpdateSchedulerEvent updateEvent = new NodeUpdateSchedulerEvent(node);
    scheduler.handle(updateEvent);
    Assert.assertEquals(1, app1.getLiveContainers().size());
    scheduler.handle(updateEvent);
    Assert.assertEquals(1, app3.getLiveContainers().size());
    scheduler.handle(updateEvent);
    Assert.assertEquals(2, app3.getLiveContainers().size());
    scheduler.handle(updateEvent);
    Assert.assertEquals(1, app2.getLiveContainers().size());
  }",Eager Test
"@Test
  public void testCancelStrictLocality() throws IOException {
    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    RMNode node1 = MockNodes.newNodeInfo(1, Resources.createResource(1024), 1, ""127.0.0.1"");
    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);

    RMNode node2 = MockNodes.newNodeInfo(1, Resources.createResource(1024), 2, ""127.0.0.2"");
    NodeAddedSchedulerEvent nodeEvent2 = new NodeAddedSchedulerEvent(node2);
    scheduler.handle(nodeEvent2);

    ApplicationAttemptId attId1 = createSchedulingRequest(1024, ""queue1"",
        ""user1"", 0);
    
    ResourceRequest nodeRequest = createResourceRequest(1024, node1.getHostName(), 1, 1, true);
    ResourceRequest rackRequest = createResourceRequest(1024, ""rack1"", 1, 1, false);
    ResourceRequest anyRequest = createResourceRequest(1024, ResourceRequest.ANY,
        1, 1, false);
    createSchedulingRequestExistingApplication(nodeRequest, attId1);
    createSchedulingRequestExistingApplication(rackRequest, attId1);
    createSchedulingRequestExistingApplication(anyRequest, attId1);

    scheduler.update();

    NodeUpdateSchedulerEvent node2UpdateEvent = new NodeUpdateSchedulerEvent(node2);

    // no matter how many heartbeats, node2 should never get a container
    FSAppAttempt app = scheduler.getSchedulerApp(attId1);
    for (int i = 0; i < 10; i++) {
      scheduler.handle(node2UpdateEvent);
      assertEquals(0, app.getLiveContainers().size());
    }",Eager Test
"@Test
  public void testChildMaxResources() throws IOException {
    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder(""queueA"")
            .parent(true)
            .maxChildResources(""2048mb,2vcores"")
            .build())
        .writeToFile(ALLOC_FILE);

    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, ALLOC_FILE);
    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    // Add one big node (only care about aggregate capacity)
    RMNode node1 =
        MockNodes.newNodeInfo(1, Resources.createResource(8 * 1024, 8), 1,
            ""127.0.0.1"");

    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);

    ApplicationAttemptId attId1 =
        createSchedulingRequest(1024, 1, ""queueA.queueB"", ""user1"", 8);
    ApplicationAttemptId attId2 =
        createSchedulingRequest(1024, 1, ""queueA.queueC"", ""user1"", 8);

    scheduler.update();

    NodeUpdateSchedulerEvent nodeEvent = new NodeUpdateSchedulerEvent(node1);

    // Send 4 node heartbeats, this should be enough to allocate 4 containers
    // As we have 2 queues with capacity: 2GB,2cores, we could only have
    // 4 containers at most
    scheduler.handle(nodeEvent);
    scheduler.handle(nodeEvent);
    scheduler.handle(nodeEvent);
    scheduler.handle(nodeEvent);
    drainEventsOnRM();

    // Apps should be running with 2 containers
    assertEquals(""App 1 is not running with the correct number of containers"",
        2, scheduler.getSchedulerApp(attId1).getLiveContainers().size());
    assertEquals(""App 2 is not running with the correct number of containers"",
        2, scheduler.getSchedulerApp(attId2).getLiveContainers().size());

    //ensure that a 5th node heartbeat does not allocate more containers
    scheduler.handle(nodeEvent);
    drainEventsOnRM();

    // Apps should be running with 2 containers
    assertEquals(""App 1 is not running with the correct number of containers"",
        2, scheduler.getSchedulerApp(attId1).getLiveContainers().size());
    assertEquals(""App 2 is not running with the correct number of containers"",
        2, scheduler.getSchedulerApp(attId2).getLiveContainers().size());

    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder(""queueA"")
            .parent(true)
            .maxChildResources(""3072mb,3vcores"")
            .build())
        .writeToFile(ALLOC_FILE);

    scheduler.reinitialize(conf, resourceManager.getRMContext());
    scheduler.update();

    // Send 2 node heartbeats, this should be enough to allocate 2
    // more containers.
    // As we have 2 queues with capacity: 3GB,3cores, we could only have
    // 6 containers at most
    scheduler.handle(nodeEvent);
    scheduler.handle(nodeEvent);
    drainEventsOnRM();

    // Apps should be running with 3 containers now
    assertEquals(""App 1 is not running with the correct number of containers"",
        3, scheduler.getSchedulerApp(attId1).getLiveContainers().size());
    assertEquals(""App 2 is not running with the correct number of containers"",
        3, scheduler.getSchedulerApp(attId2).getLiveContainers().size());

    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder(""queueA"")
            .parent(true)
            .maxChildResources(""1024mb,1vcores"")
            .build())
        .writeToFile(ALLOC_FILE);

    //ensure that a 7th node heartbeat does not allocate more containers
    scheduler.handle(nodeEvent);
    drainEventsOnRM();
    assertEquals(6, scheduler.getRootQueueMetrics().getAllocatedContainers());

    scheduler.reinitialize(conf, resourceManager.getRMContext());

    scheduler.update();
    scheduler.handle(nodeEvent);
    drainEventsOnRM();

    // Apps still should be running with 3 containers because we don't preempt
    assertEquals(""App 1 is not running with the correct number of containers"",
        3, scheduler.getSchedulerApp(attId1).getLiveContainers().size());
    assertEquals(""App 2 is not running with the correct number of containers"",
        3, scheduler.getSchedulerApp(attId2).getLiveContainers().size());
  }",Eager Test
"@Test
  public void testEmptyQueueNameInConfigFile() {
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, ALLOC_FILE);
    // set empty queue name
    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder("""").build())
        .writeToFile(ALLOC_FILE);

    try {
      scheduler.init(conf);
      Assert.fail(""scheduler init should fail because"" +
          "" empty queue name."");
    }",Eager Test
"@Test
  public void testFairShareWithLowMaxResources() throws IOException {
    PrintWriter out = new PrintWriter(new FileWriter(ALLOC_FILE));

    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder(""queueA"")
            .maxResources(""1024 mb 1 vcores"")
            .weight(.75f)
            .build())
        .addQueue(new AllocationFileQueue.Builder(""queueB"")
            .maxResources(""3072 mb 3 vcores"")
            .weight(.25f)
            .build())
        .writeToFile(ALLOC_FILE);

    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, ALLOC_FILE);
    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    // Add one big node (only care about aggregate capacity)
    RMNode node1 =
        MockNodes.newNodeInfo(1, Resources.createResource(8 * 1024, 8), 1,
            ""127.0.0.1"");

    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);

    ApplicationAttemptId attId1 =
        createSchedulingRequest(1024, 1, ""queueA"", ""user1"", 2);
    ApplicationAttemptId attId2 =
        createSchedulingRequest(1024, 1, ""queueB"", ""user1"", 4);

    scheduler.update();

    FSLeafQueue queue =
        scheduler.getQueueManager().getLeafQueue(""queueA"", false);
    // queueA's weight is 0.5, so its fair share should be 6GB, but it's
    // capped at 1GB.
    assertEquals(""Queue A did not get its expected fair share"",
        1 * 1024, queue.getFairShare().getMemorySize());
    // queueB's weight is 0.5, so its fair share should be 2GB, but the
    // other queue is capped at 1GB, so queueB's share is 7GB,
    // capped at 3GB.
    queue = scheduler.getQueueManager().getLeafQueue(
        ""queueB"", false);
    assertEquals(""Queue B did not get its expected fair share"",
        3 * 1024, queue.getFairShare().getMemorySize());

    NodeUpdateSchedulerEvent updateEvent = new NodeUpdateSchedulerEvent(node1);
    scheduler.handle(updateEvent);
    scheduler.handle(updateEvent);
    scheduler.handle(updateEvent);
    scheduler.handle(updateEvent);
    scheduler.handle(updateEvent);
    scheduler.handle(updateEvent);

    // App 1 should be running with 1 container
    assertEquals(""App 1 is not running with the correct number of containers"",
        1, scheduler.getSchedulerApp(attId1).getLiveContainers().size());
    // App 2 should be running with 3 containers
    assertEquals(""App 2 is not running with the correct number of containers"",
        3, scheduler.getSchedulerApp(attId2).getLiveContainers().size());
  }",Eager Test
"@Test
  public void testFairShareWithNoneZeroWeightNoneZeroMinRes()
      throws IOException {
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, ALLOC_FILE);
    // set queueA and queueB weight 0.5.
    // set queueA and queueB minResources 1024.
    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder(""queueA"")
            .weight(0.5f)
            .minResources(""1024 mb 1 vcores"")
            .build())
        .addQueue(new AllocationFileQueue.Builder(""queueB"")
            .weight(0.5f)
            .minResources(""1024 mb 1 vcores"")
            .build())
        .writeToFile(ALLOC_FILE);

    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    // Add one big node (only care about aggregate capacity)
    RMNode node1 =
        MockNodes.newNodeInfo(1, Resources.createResource(8 * 1024, 8), 1,
            ""127.0.0.1"");
    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);

    // Queue A wants 4 * 1024.
    createSchedulingRequest(4 * 1024, ""queueA"", ""user1"");
    // Queue B wants 4 * 1024
    createSchedulingRequest(4 * 1024, ""queueB"", ""user1"");

    scheduler.update();

    FSLeafQueue queue = scheduler.getQueueManager().getLeafQueue(
        ""queueA"", false);
    // queueA's weight is 0.5 and minResources is 1024,
    // so its fair share should be 4096.
    assertEquals(4096, queue.getFairShare().getMemorySize());
    // queueB's weight is 0.5 and minResources is 1024,
    // so its fair share should be 4096.
    queue = scheduler.getQueueManager().getLeafQueue(
        ""queueB"", false);
    assertEquals(4096, queue.getFairShare().getMemorySize());
  }",Eager Test
"@Test
  public void testNoMoreCpuOnNode() throws IOException {
    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    RMNode node1 = MockNodes.newNodeInfo(1, Resources.createResource(2048, 1),
        1, ""127.0.0.1"");
    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);
    
    ApplicationAttemptId attId = createSchedulingRequest(1024, 1, ""default"",
        ""user1"", 2);
    FSAppAttempt app = scheduler.getSchedulerApp(attId);
    scheduler.update();

    NodeUpdateSchedulerEvent updateEvent = new NodeUpdateSchedulerEvent(node1);
    scheduler.handle(updateEvent);
    assertEquals(1, app.getLiveContainers().size());
    scheduler.handle(updateEvent);
    assertEquals(1, app.getLiveContainers().size());
  }",No Smells
"@Test  
  public void testNonMinZeroResourcesSettings() throws IOException {
    YarnConfiguration conf = new YarnConfiguration();
    conf.setInt(YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_MB, 256);
    conf.setInt(YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES, 1);
    conf.setInt(
      FairSchedulerConfiguration.RM_SCHEDULER_INCREMENT_ALLOCATION_MB, 512);
    conf.setInt(
      FairSchedulerConfiguration.RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES, 2);
    ResourceUtils.resetResourceTypes(conf);
    scheduler.init(conf);
    scheduler.reinitialize(conf, null);
    Assert.assertEquals(256, scheduler.getMinimumResourceCapability().getMemorySize());
    Assert.assertEquals(1, scheduler.getMinimumResourceCapability().getVirtualCores());
    Assert.assertEquals(512, scheduler.getIncrementResourceCapability().getMemorySize());
    Assert.assertEquals(2, scheduler.getIncrementResourceCapability().getVirtualCores());
  }",No Smells
"@Test
  public void testQueueMaxAMShareDefault() throws Exception {
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, ALLOC_FILE);
    conf.setInt(YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES, 6);

    AllocationFileWriter.create()
        .fairDefaultQueueSchedulingPolicy()
        .addQueue(new AllocationFileQueue.Builder(""queue1"").build())
        .addQueue(new AllocationFileQueue.Builder(""queue2"")
            .maxAMShare(0.4f)
            .build())
        .addQueue(new AllocationFileQueue.Builder(""queue3"")
            .maxResources(""10240 mb 4 vcores"")
            .build())
        .addQueue(new AllocationFileQueue.Builder(""queue4"").build())
        .addQueue(new AllocationFileQueue.Builder(""queue5"").build())
        .writeToFile(ALLOC_FILE);

    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    RMNode node =
        MockNodes.newNodeInfo(1, Resources.createResource(8192, 10),
            0, ""127.0.0.1"");
    NodeAddedSchedulerEvent nodeEvent = new NodeAddedSchedulerEvent(node);
    NodeUpdateSchedulerEvent updateEvent = new NodeUpdateSchedulerEvent(node);
    scheduler.handle(nodeEvent);
    scheduler.update();

    FSLeafQueue queue1 =
        scheduler.getQueueManager().getLeafQueue(""queue1"", true);
    assertEquals(""Queue queue1's fair share should be 0"", 0, queue1
        .getFairShare().getMemorySize());
    FSLeafQueue queue2 =
        scheduler.getQueueManager().getLeafQueue(""queue2"", true);
    assertEquals(""Queue queue2's fair share should be 0"", 0, queue2
        .getFairShare().getMemorySize());
    FSLeafQueue queue3 =
        scheduler.getQueueManager().getLeafQueue(""queue3"", true);
    assertEquals(""Queue queue3's fair share should be 0"", 0, queue3
        .getFairShare().getMemorySize());
    FSLeafQueue queue4 =
        scheduler.getQueueManager().getLeafQueue(""queue4"", true);
    assertEquals(""Queue queue4's fair share should be 0"", 0, queue4
        .getFairShare().getMemorySize());
    FSLeafQueue queue5 =
        scheduler.getQueueManager().getLeafQueue(""queue5"", true);
    assertEquals(""Queue queue5's fair share should be 0"", 0, queue5
        .getFairShare().getMemorySize());

    List<String> queues = Arrays.asList(""root.queue3"", ""root.queue4"",
        ""root.queue5"");
    for (String queue : queues) {
      createSchedulingRequest(1 * 1024, queue, ""user1"");
      scheduler.update();
      scheduler.handle(updateEvent);
    }",Eager Test
"@Test
  public void testQueueMaxAMShareWithContainerReservation() throws Exception {
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, ALLOC_FILE);
    conf.setFloat(FairSchedulerConfiguration.RESERVABLE_NODES, 1f);
    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder(""queue1"")
            .maxAMShare(0.5).build())
        .writeToFile(ALLOC_FILE);

    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    RMNode node1 = MockNodes.newNodeInfo(1,
        Resources.createResource(RM_SCHEDULER_MAXIMUM_ALLOCATION_MB_VALUE, 10),
        1, ""127.0.0.1"");
    RMNode node2 = MockNodes.newNodeInfo(1,
        Resources.createResource(RM_SCHEDULER_MAXIMUM_ALLOCATION_MB_VALUE, 10),
        2, ""127.0.0.2"");
    RMNode node3 =
        MockNodes.newNodeInfo(1, Resources.createResource(5120, 5),
            3, ""127.0.0.3"");
    NodeAddedSchedulerEvent nodeE1 = new NodeAddedSchedulerEvent(node1);
    NodeUpdateSchedulerEvent updateE1 = new NodeUpdateSchedulerEvent(node1);
    NodeAddedSchedulerEvent nodeE2 = new NodeAddedSchedulerEvent(node2);
    NodeUpdateSchedulerEvent updateE2 = new NodeUpdateSchedulerEvent(node2);
    NodeAddedSchedulerEvent nodeE3 = new NodeAddedSchedulerEvent(node3);
    NodeUpdateSchedulerEvent updateE3 = new NodeUpdateSchedulerEvent(node3);
    scheduler.handle(nodeE1);
    scheduler.handle(nodeE2);
    scheduler.handle(nodeE3);
    scheduler.update();
    FSLeafQueue queue1 = scheduler.getQueueManager().getLeafQueue(""queue1"",
        true);
    Resource amResource1 = Resource.newInstance(1024, 1);
    Resource amResource2 = Resource.newInstance(1024, 1);
    Resource amResource3 =
        Resource.newInstance(RM_SCHEDULER_MAXIMUM_ALLOCATION_MB_VALUE, 1);
    Resource amResource4 = Resource.newInstance(5120, 1);
    Resource amResource5 = Resource.newInstance(1024, 1);
    Resource amResource6 =
        Resource.newInstance(RM_SCHEDULER_MAXIMUM_ALLOCATION_MB_VALUE, 1);
    Resource amResource7 = Resource.newInstance(1024, 1);
    Resource amResource8 = Resource.newInstance(1024, 1);
    int amPriority = RMAppAttemptImpl.AM_CONTAINER_PRIORITY.getPriority();
    ApplicationAttemptId attId1 = createAppAttemptId(1, 1);
    createApplicationWithAMResource(attId1, ""queue1"", ""user1"", amResource1);
    createSchedulingRequestExistingApplication(1024, 1, amPriority, attId1);
    FSAppAttempt app1 = scheduler.getSchedulerApp(attId1);
    scheduler.update();
    // Allocate app1's AM container on node1.
    scheduler.handle(updateE1);
    assertEquals(""Application1's AM requests 1024 MB memory"",
        1024, app1.getAMResource().getMemorySize());
    assertEquals(""Application1's AM should be running"",
        1, app1.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 1024 MB memory"",
        1024, queue1.getAmResourceUsage().getMemorySize());

    ApplicationAttemptId attId2 = createAppAttemptId(2, 1);
    createApplicationWithAMResource(attId2, ""queue1"", ""user1"", amResource2);
    createSchedulingRequestExistingApplication(1024, 1, amPriority, attId2);
    FSAppAttempt app2 = scheduler.getSchedulerApp(attId2);
    scheduler.update();
    // Allocate app2's AM container on node2.
    scheduler.handle(updateE2);
    assertEquals(""Application2's AM requests 1024 MB memory"",
        1024, app2.getAMResource().getMemorySize());
    assertEquals(""Application2's AM should be running"",
        1, app2.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 2048 MB memory"",
        2048, queue1.getAmResourceUsage().getMemorySize());

    ApplicationAttemptId attId3 = createAppAttemptId(3, 1);
    createApplicationWithAMResource(attId3, ""queue1"", ""user1"", amResource3);
    createSchedulingRequestExistingApplication(
        RM_SCHEDULER_MAXIMUM_ALLOCATION_MB_VALUE, 1, amPriority, attId3);
    FSAppAttempt app3 = scheduler.getSchedulerApp(attId3);
    scheduler.update();
    // app3 reserves a container on node1 because node1's available resource
    // is less than app3's AM container resource.
    scheduler.handle(updateE1);
    // Similarly app3 reserves a container on node2.
    scheduler.handle(updateE2);
    assertEquals(""Application3's AM resource shouldn't be updated"",
        0, app3.getAMResource().getMemorySize());
    assertEquals(""Application3's AM should not be running"",
        0, app3.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 2048 MB memory"",
        2048, queue1.getAmResourceUsage().getMemorySize());

    ApplicationAttemptId attId4 = createAppAttemptId(4, 1);
    createApplicationWithAMResource(attId4, ""queue1"", ""user1"", amResource4);
    createSchedulingRequestExistingApplication(5120, 1, amPriority, attId4);
    FSAppAttempt app4 = scheduler.getSchedulerApp(attId4);
    scheduler.update();
    // app4 can't allocate its AM container on node1 because
    // app3 already reserved its container on node1.
    scheduler.handle(updateE1);
    assertEquals(""Application4's AM resource shouldn't be updated"",
        0, app4.getAMResource().getMemorySize());
    assertEquals(""Application4's AM should not be running"",
        0, app4.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 2048 MB memory"",
        2048, queue1.getAmResourceUsage().getMemorySize());

    scheduler.update();
    // Allocate app4's AM container on node3.
    scheduler.handle(updateE3);
    assertEquals(""Application4's AM requests 5120 MB memory"",
        5120, app4.getAMResource().getMemorySize());
    assertEquals(""Application4's AM should be running"",
        1, app4.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 7168 MB memory"",
        7168, queue1.getAmResourceUsage().getMemorySize());

    AppAttemptRemovedSchedulerEvent appRemovedEvent1 =
        new AppAttemptRemovedSchedulerEvent(attId1,
            RMAppAttemptState.FINISHED, false);
    // Release app1's AM container on node1.
    scheduler.handle(appRemovedEvent1);
    assertEquals(""Queue1's AM resource usage should be 6144 MB memory"",
        6144, queue1.getAmResourceUsage().getMemorySize());

    ApplicationAttemptId attId5 = createAppAttemptId(5, 1);
    createApplicationWithAMResource(attId5, ""queue1"", ""user1"", amResource5);
    createSchedulingRequestExistingApplication(1024, 1, amPriority, attId5);
    FSAppAttempt app5 = scheduler.getSchedulerApp(attId5);
    scheduler.update();
    // app5 can allocate its AM container on node1 after
    // app3 unreserve its container on node1 due to
    // exceeding queue MaxAMShare limit.
    scheduler.handle(updateE1);
    assertEquals(""Application5's AM requests 1024 MB memory"",
        1024, app5.getAMResource().getMemorySize());
    assertEquals(""Application5's AM should be running"",
        1, app5.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 7168 MB memory"",
        7168, queue1.getAmResourceUsage().getMemorySize());

    AppAttemptRemovedSchedulerEvent appRemovedEvent3 =
        new AppAttemptRemovedSchedulerEvent(attId3,
            RMAppAttemptState.FINISHED, false);
    // Remove app3.
    scheduler.handle(appRemovedEvent3);
    assertEquals(""Queue1's AM resource usage should be 7168 MB memory"",
        7168, queue1.getAmResourceUsage().getMemorySize());

    ApplicationAttemptId attId6 = createAppAttemptId(6, 1);
    createApplicationWithAMResource(attId6, ""queue1"", ""user1"", amResource6);
    createSchedulingRequestExistingApplication(
        RM_SCHEDULER_MAXIMUM_ALLOCATION_MB_VALUE, 1, amPriority, attId6);
    FSAppAttempt app6 = scheduler.getSchedulerApp(attId6);
    scheduler.update();
    // app6 can't reserve a container on node1 because
    // it exceeds queue MaxAMShare limit.
    scheduler.handle(updateE1);
    assertEquals(""Application6's AM resource shouldn't be updated"",
        0, app6.getAMResource().getMemorySize());
    assertEquals(""Application6's AM should not be running"",
        0, app6.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 7168 MB memory"",
        7168, queue1.getAmResourceUsage().getMemorySize());

    ApplicationAttemptId attId7 = createAppAttemptId(7, 1);
    createApplicationWithAMResource(attId7, ""queue1"", ""user1"", amResource7);
    createSchedulingRequestExistingApplication(1024, 1, amPriority, attId7);
    FSAppAttempt app7 = scheduler.getSchedulerApp(attId7);
    scheduler.update();
    // Allocate app7's AM container on node1 to prove
    // app6 didn't reserve a container on node1.
    scheduler.handle(updateE1);
    assertEquals(""Application7's AM requests 1024 MB memory"",
        1024, app7.getAMResource().getMemorySize());
    assertEquals(""Application7's AM should be running"",
        1, app7.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 8192 MB memory"",
        8192, queue1.getAmResourceUsage().getMemorySize());

    AppAttemptRemovedSchedulerEvent appRemovedEvent4 =
        new AppAttemptRemovedSchedulerEvent(attId4,
            RMAppAttemptState.FINISHED, false);
    // Release app4's AM container on node3.
    scheduler.handle(appRemovedEvent4);
    assertEquals(""Queue1's AM resource usage should be 3072 MB memory"",
        3072, queue1.getAmResourceUsage().getMemorySize());

    AppAttemptRemovedSchedulerEvent appRemovedEvent5 =
        new AppAttemptRemovedSchedulerEvent(attId5,
            RMAppAttemptState.FINISHED, false);
    // Release app5's AM container on node1.
    scheduler.handle(appRemovedEvent5);
    assertEquals(""Queue1's AM resource usage should be 2048 MB memory"",
              2048, queue1.getAmResourceUsage().getMemorySize());

    scheduler.update();
    // app6 reserves a container on node1 because node1's available resource
    // is less than app6's AM container resource and
    // app6 is not over AMShare limit.
    scheduler.handle(updateE1);
    // Similarly app6 reserves a container on node2.
    scheduler.handle(updateE2);

    ApplicationAttemptId attId8 = createAppAttemptId(8, 1);
    createApplicationWithAMResource(attId8, ""queue1"", ""user1"", amResource8);
    createSchedulingRequestExistingApplication(1024, 1, amPriority, attId8);
    FSAppAttempt app8 = scheduler.getSchedulerApp(attId8);
    scheduler.update();
    // app8 can't allocate a container on node1 because
    // app6 already reserved a container on node1.
    scheduler.handle(updateE1);
    assertEquals(""Application8's AM resource shouldn't be updated"",
        0, app8.getAMResource().getMemorySize());
    assertEquals(""Application8's AM should not be running"",
        0, app8.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 2048 MB memory"",
        2048, queue1.getAmResourceUsage().getMemorySize());
    scheduler.update();
    // app8 can't allocate a container on node2 because
    // app6 already reserved a container on node2.
    scheduler.handle(updateE2);
    assertEquals(""Application8's AM resource shouldn't be updated"",
        0, app8.getAMResource().getMemorySize());
    assertEquals(""Application8's AM should not be running"",
        0, app8.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 2048 MB memory"",
        2048, queue1.getAmResourceUsage().getMemorySize());

    AppAttemptRemovedSchedulerEvent appRemovedEvent2 =
        new AppAttemptRemovedSchedulerEvent(attId2,
            RMAppAttemptState.FINISHED, false);
    // Release app2's AM container on node2.
    scheduler.handle(appRemovedEvent2);
    assertEquals(""Queue1's AM resource usage should be 1024 MB memory"",
        1024, queue1.getAmResourceUsage().getMemorySize());

    scheduler.update();
    // app6 turns the reservation into an allocation on node2.
    scheduler.handle(updateE2);
    assertEquals(""Application6's AM requests 10240 MB memory"",
        RM_SCHEDULER_MAXIMUM_ALLOCATION_MB_VALUE,
        app6.getAMResource().getMemorySize());
    assertEquals(""Application6's AM should be running"",
        1, app6.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 11264 MB memory"",
        11264, queue1.getAmResourceUsage().getMemorySize());

    scheduler.update();
    // app6 unreserve its container on node1 because
    // it already got a container on node2.
    // Now app8 can allocate its AM container on node1.
    scheduler.handle(updateE1);
    assertEquals(""Application8's AM requests 1024 MB memory"",
        1024, app8.getAMResource().getMemorySize());
    assertEquals(""Application8's AM should be running"",
        1, app8.getLiveContainers().size());
    assertEquals(""Queue1's AM resource usage should be 12288 MB memory"",
        12288, queue1.getAmResourceUsage().getMemorySize());
  }",Eager Test
"@Test
  public void testQueueuNameWithPeriods() throws Exception {
    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    // no queue by default
    assertEquals(0, scheduler.getQueueManager().getLeafQueues().size());

    // Submit app with queue name (.A)
    // Submit fails before we reach the placement check.
    ApplicationAttemptId appAttemptId1 = createAppAttemptId(1, 1);
    AppAddedSchedulerEvent appAddedEvent1 =
        new AppAddedSchedulerEvent(appAttemptId1.getApplicationId(), "".A"",
            ""user1"");
    scheduler.handle(appAddedEvent1);
    // submission rejected
    assertEquals(0, scheduler.getQueueManager().getLeafQueues().size());
    assertNull(scheduler.getSchedulerApp(appAttemptId1));
    assertEquals(0, resourceManager.getRMContext().getRMApps().size());

    // Submit app with queue name (A.)
    // Submit fails before we reach the placement check.
    ApplicationAttemptId appAttemptId2 = createAppAttemptId(2, 1);
    AppAddedSchedulerEvent appAddedEvent2 =
        new AppAddedSchedulerEvent(appAttemptId2.getApplicationId(), ""A."",
            ""user1"");
    scheduler.handle(appAddedEvent2);
    // submission rejected
    assertEquals(0, scheduler.getQueueManager().getLeafQueues().size());
    assertNull(scheduler.getSchedulerApp(appAttemptId2));
    assertEquals(0, resourceManager.getRMContext().getRMApps().size());

    // submit app with queue name (A.B)
    // Submit does not fail we must have a placement context.
    ApplicationAttemptId appAttemptId3 = createAppAttemptId(3, 1);
    AppAddedSchedulerEvent appAddedEvent3 =
        new AppAddedSchedulerEvent(appAttemptId3.getApplicationId(), ""A.B"",
            ""user1"", new ApplicationPlacementContext(""A.B""));
    scheduler.handle(appAddedEvent3);
    // submission accepted
    assertEquals(1, scheduler.getQueueManager().getLeafQueues().size());
    assertNull(scheduler.getSchedulerApp(appAttemptId3));
    assertEquals(0, resourceManager.getRMContext().getRMApps().size());
  }",Eager Test
"@Test
  public void testSchedulerRootQueueMetrics() throws Exception {
    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    // Add a node
    RMNode node1 = MockNodes.newNodeInfo(1, Resources.createResource(1024));
    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);

    // Queue 1 requests full capacity of node
    createSchedulingRequest(1024, ""queue1"", ""user1"", 1);
    scheduler.update();
    NodeUpdateSchedulerEvent updateEvent = new NodeUpdateSchedulerEvent(node1);
    scheduler.handle(updateEvent);

    // Now queue 2 requests likewise
    createSchedulingRequest(1024, ""queue2"", ""user1"", 1);
    scheduler.update();
    scheduler.handle(updateEvent);

    // Make sure reserved memory gets updated correctly
    assertEquals(1024, scheduler.rootMetrics.getReservedMB());
    
    // Now another node checks in with capacity
    RMNode node2 = MockNodes.newNodeInfo(1, Resources.createResource(1024));
    NodeAddedSchedulerEvent nodeEvent2 = new NodeAddedSchedulerEvent(node2);
    NodeUpdateSchedulerEvent updateEvent2 = new NodeUpdateSchedulerEvent(node2);
    scheduler.handle(nodeEvent2);
    scheduler.handle(updateEvent2);


    // The old reservation should still be there...
    assertEquals(1024, scheduler.rootMetrics.getReservedMB());

    // ... but it should disappear when we update the first node.
    scheduler.handle(updateEvent);
    assertEquals(0, scheduler.rootMetrics.getReservedMB());
  }",Eager Test
"@Test
  public void testSimpleHierarchicalFairShareCalculation() throws IOException {
    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    // Add one big node (only care about aggregate capacity)
    int capacity = 10 * 24;
    RMNode node1 =
        MockNodes.newNodeInfo(1, Resources.createResource(capacity), 1,
            ""127.0.0.1"");
    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);

    // Have two queues which want entire cluster capacity
    createSchedulingRequest(10 * 1024, ""parent.queue2"", ""user1"");
    createSchedulingRequest(10 * 1024, ""parent.queue3"", ""user1"");
    createSchedulingRequest(10 * 1024, ""root.default"", ""user1"");

    scheduler.update();
    scheduler.getQueueManager().getRootQueue()
        .setSteadyFairShare(scheduler.getClusterResource());
    scheduler.getQueueManager().getRootQueue().recomputeSteadyShares();

    QueueManager queueManager = scheduler.getQueueManager();
    Collection<FSLeafQueue> queues = queueManager.getLeafQueues();
    assertEquals(3, queues.size());
    
    FSLeafQueue queue1 = queueManager.getLeafQueue(""default"", true);
    FSLeafQueue queue2 = queueManager.getLeafQueue(""parent.queue2"", true);
    FSLeafQueue queue3 = queueManager.getLeafQueue(""parent.queue3"", true);
    assertEquals(capacity / 2, queue1.getFairShare().getMemorySize());
    assertEquals(capacity / 2, queue1.getMetrics().getFairShareMB());
    assertEquals(capacity / 2, queue1.getSteadyFairShare().getMemorySize());
    assertEquals(capacity / 2, queue1.getMetrics().getSteadyFairShareMB());
    assertEquals(capacity / 4, queue2.getFairShare().getMemorySize());
    assertEquals(capacity / 4, queue2.getMetrics().getFairShareMB());
    assertEquals(capacity / 4, queue2.getSteadyFairShare().getMemorySize());
    assertEquals(capacity / 4, queue2.getMetrics().getSteadyFairShareMB());
    assertEquals(capacity / 4, queue3.getFairShare().getMemorySize());
    assertEquals(capacity / 4, queue3.getMetrics().getFairShareMB());
    assertEquals(capacity / 4, queue3.getSteadyFairShare().getMemorySize());
    assertEquals(capacity / 4, queue3.getMetrics().getSteadyFairShareMB());
  }",Eager Test
"@Test
  public void testStrictLocality() throws IOException {
    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    RMNode node1 = MockNodes.newNodeInfo(1, Resources.createResource(1024), 1, ""127.0.0.1"");
    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);

    RMNode node2 = MockNodes.newNodeInfo(1, Resources.createResource(1024), 2, ""127.0.0.2"");
    NodeAddedSchedulerEvent nodeEvent2 = new NodeAddedSchedulerEvent(node2);
    scheduler.handle(nodeEvent2);

    ApplicationAttemptId attId1 = createSchedulingRequest(1024, ""queue1"",
        ""user1"", 0);
    
    ResourceRequest nodeRequest = createResourceRequest(1024, node1.getHostName(), 1, 1, true);
    ResourceRequest rackRequest = createResourceRequest(1024, node1.getRackName(), 1, 1, false);
    ResourceRequest anyRequest = createResourceRequest(1024, ResourceRequest.ANY,
        1, 1, false);
    createSchedulingRequestExistingApplication(nodeRequest, attId1);
    createSchedulingRequestExistingApplication(rackRequest, attId1);
    createSchedulingRequestExistingApplication(anyRequest, attId1);

    scheduler.update();

    NodeUpdateSchedulerEvent node1UpdateEvent = new NodeUpdateSchedulerEvent(node1);
    NodeUpdateSchedulerEvent node2UpdateEvent = new NodeUpdateSchedulerEvent(node2);

    // no matter how many heartbeats, node2 should never get a container
    FSAppAttempt app = scheduler.getSchedulerApp(attId1);
    for (int i = 0; i < 10; i++) {
      scheduler.handle(node2UpdateEvent);
      assertEquals(0, app.getLiveContainers().size());
      assertEquals(0, app.getReservedContainers().size());
    }",Eager Test
"@Test
  public void testUserAndQueueMaxRunningApps() throws Exception {
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, ALLOC_FILE);

    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder(""queue1"")
            .maxRunningApps(2).build())
        .userSettings(new UserSettings.Builder(""user1"")
            .maxRunningApps(1).build())
        .writeToFile(ALLOC_FILE);

    scheduler.init(conf);
    scheduler.start();
    scheduler.reinitialize(conf, resourceManager.getRMContext());

    // exceeds no limits
    ApplicationAttemptId attId1 = createSchedulingRequest(1024, ""queue1"", ""user1"");
    verifyAppRunnable(attId1, true);
    verifyQueueNumRunnable(""queue1"", 1, 0);
    // exceeds user limit
    ApplicationAttemptId attId2 = createSchedulingRequest(1024, ""queue2"", ""user1"");
    verifyAppRunnable(attId2, false);
    verifyQueueNumRunnable(""queue2"", 0, 1);
    // exceeds no limits
    ApplicationAttemptId attId3 = createSchedulingRequest(1024, ""queue1"", ""user2"");
    verifyAppRunnable(attId3, true);
    verifyQueueNumRunnable(""queue1"", 2, 0);
    // exceeds queue limit
    ApplicationAttemptId attId4 = createSchedulingRequest(1024, ""queue1"", ""user2"");
    verifyAppRunnable(attId4, false);
    verifyQueueNumRunnable(""queue1"", 2, 1);
    
    // Remove app 1 and both app 2 and app 4 should becomes runnable in its place
    AppAttemptRemovedSchedulerEvent appRemovedEvent1 =
        new AppAttemptRemovedSchedulerEvent(attId1, RMAppAttemptState.FINISHED, false);
    scheduler.handle(appRemovedEvent1);
    verifyAppRunnable(attId2, true);
    verifyQueueNumRunnable(""queue2"", 1, 0);
    verifyAppRunnable(attId4, true);
    verifyQueueNumRunnable(""queue1"", 2, 0);
    
    // A new app to queue1 should not be runnable
    ApplicationAttemptId attId5 = createSchedulingRequest(1024, ""queue1"", ""user2"");
    verifyAppRunnable(attId5, false);
    verifyQueueNumRunnable(""queue1"", 2, 1);
  }",No Smells
"@Test
  public void testCpuPercentageMemoryAbsolute() throws Exception {
    expectMissingResource(""memory"");
    parseResourceConfigValue(""50% cpu, 1024 mb"");
  }",No Smells
"@Test
  public void testNoUnits() throws Exception {
    String value = ""1024"";
    expectUnparsableResource(value);
    parseResourceConfigValue(value);
  }",No Smells
"@Test
  public void testParseResourceConfigValue() throws Exception {
    Resource expected = Resources.createResource(5 * 1024, 2);
    Resource clusterResource = Resources.createResource(10 * 1024, 4);

    assertEquals(expected,
        parseResourceConfigValue(""5120 mb 2 vcores"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""2 vcores, 5120 mb"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""5120 mb, 2 vcores"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""2vcores,5120mb"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""5120mb,2vcores"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""5120mb   mb, 2    vcores"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""5120 Mb, 2 vCores"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""  5120 mb, 2 vcores  "").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""  5120.3 mb, 2.35 vcores  "").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""  5120. mb, 2. vcores  "").getResource());

    assertEquals(expected,
        parseResourceConfigValue(""50% memory, 50% cpu"").
            getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""50% Memory, 50% CpU"").
            getResource(clusterResource));
    assertEquals(Resources.createResource(5 * 1024, 4),
        parseResourceConfigValue(""50% memory, 100% cpu"").
        getResource(clusterResource));
    assertEquals(Resources.createResource(5 * 1024, 4),
        parseResourceConfigValue("" 100% cpu, 50% memory"").
        getResource(clusterResource));
    assertEquals(Resources.createResource(5 * 1024, 0),
        parseResourceConfigValue(""50% memory, 0% cpu"").
            getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""50 % memory, 50 % cpu"").
            getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""50%memory,50%cpu"").
            getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""  50  %  memory,  50  %  cpu  "").
            getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""50.% memory, 50.% cpu"").
            getResource(clusterResource));
    assertEquals(Resources.createResource((int)(1024 * 10 * 0.109), 2),
        parseResourceConfigValue(""10.9% memory, 50.6% cpu"").
            getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""50%"").getResource(clusterResource));

    Configuration conf = new Configuration();

    conf.set(YarnConfiguration.RESOURCE_TYPES, ""test1"");
    ResourceUtils.resetResourceTypes(conf);

    clusterResource = Resources.createResource(10 * 1024, 4);
    expected = Resources.createResource(5 * 1024, 2);
    expected.setResourceValue(""test1"", Long.MAX_VALUE);

    assertEquals(expected,
        parseResourceConfigValue(""vcores=2, memory-mb=5120"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""memory-mb=5120, vcores=2"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""vcores=2,memory-mb=5120"").getResource());
    assertEquals(expected, parseResourceConfigValue("" vcores = 2 , ""
            + ""memory-mb = 5120 "").getResource());

    expected.setResourceValue(""test1"", 0L);

    assertEquals(expected,
        parseResourceConfigValue(""vcores=2, memory-mb=5120"", 0L).getResource());
    assertEquals(expected,
        parseResourceConfigValue(""memory-mb=5120, vcores=2"", 0L).getResource());
    assertEquals(expected,
        parseResourceConfigValue(""vcores=2,memory-mb=5120"", 0L).getResource());
    assertEquals(expected,
        parseResourceConfigValue("" vcores = 2 , memory-mb = 5120 "",
            0L).getResource());

    clusterResource.setResourceValue(""test1"", 8L);
    expected.setResourceValue(""test1"", 4L);

    assertEquals(expected,
        parseResourceConfigValue(""50%"").getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""vcores=2, memory-mb=5120, ""
            + ""test1=4"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""test1=4, vcores=2, ""
            + ""memory-mb=5120"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""memory-mb=5120, test1=4, ""
            + ""vcores=2"").getResource());
    assertEquals(expected,
        parseResourceConfigValue(""vcores=2,memory-mb=5120,""
            + ""test1=4"").getResource());
    assertEquals(expected,
        parseResourceConfigValue("" vcores = 2 , memory-mb = 5120 , ""
            + ""test1 = 4 "").getResource());

    expected = Resources.createResource(4 * 1024, 3);
    expected.setResourceValue(""test1"", 8L);

    assertEquals(expected,
        parseResourceConfigValue(""vcores=75%, ""
            + ""memory-mb=40%"").getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""memory-mb=40%, ""
            + ""vcores=75%"").getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""vcores=75%,""
            + ""memory-mb=40%"").getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue("" vcores = 75 % , ""
            + ""memory-mb = 40 % "").getResource(clusterResource));

    expected.setResourceValue(""test1"", 4L);

    assertEquals(expected,
        parseResourceConfigValue(""vcores=75%, memory-mb=40%, ""
            + ""test1=50%"").getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""test1=50%, vcores=75%, ""
            + ""memory-mb=40%"").getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""memory-mb=40%, test1=50%, ""
            + ""vcores=75%"").getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue(""vcores=75%,memory-mb=40%,""
            + ""test1=50%"").getResource(clusterResource));
    assertEquals(expected,
        parseResourceConfigValue("" vcores = 75 % , memory-mb = 40 % , ""
            + ""test1 = 50 % "").getResource(clusterResource));
  }",Eager Test
"@Test
  public void testTrimQueueNameEquals() throws Exception {
    final String[] equalsStrings = {
        // no spaces
        ""a"",
        // leading spaces
        "" a"",
        "" \u3000a"",
        ""\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000a"",
        ""\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680a"",
        ""\u0009\u0020\u2006\u2001\u202F\u00A0\u000C\u2009a"",
        ""\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000a"",
        // trailing spaces
        ""a\u200A"",
        ""a  \u0085 "",
        // spaces on both sides
        "" a "",
        ""  a\u00A0"",
        ""\u0009\u0020\u2006\u2001\u202F\u00A0\u000C\u2009a"" +
            ""\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000"",
    }",Eager Test
"@Test
  public void testHeadroom() {
    final FairScheduler mockScheduler = Mockito.mock(FairScheduler.class);
    Mockito.when(mockScheduler.getClock()).thenReturn(scheduler.getClock());

    final FSLeafQueue mockQueue = Mockito.mock(FSLeafQueue.class);

    final Resource queueMaxResources = Resource.newInstance(5 * 1024, 3);
    final Resource queueFairShare = Resources.createResource(4096, 2);
    final Resource queueUsage = Resource.newInstance(2048, 2);

    final Resource queueStarvation =
        Resources.subtract(queueFairShare, queueUsage);
    final Resource queueMaxResourcesAvailable =
        Resources.subtract(queueMaxResources, queueUsage);

    final Resource clusterResource = Resources.createResource(8192, 8);
    final Resource clusterUsage = Resources.createResource(2048, 2);
    final Resource clusterAvailable =
        Resources.subtract(clusterResource, clusterUsage);

    final QueueMetrics fakeRootQueueMetrics = Mockito.mock(QueueMetrics.class);

    Mockito.when(mockQueue.getMaxShare()).thenReturn(queueMaxResources);
    Mockito.when(mockQueue.getFairShare()).thenReturn(queueFairShare);
    Mockito.when(mockQueue.getResourceUsage()).thenReturn(queueUsage);
    Mockito.when(mockScheduler.getClusterResource()).thenReturn
        (clusterResource);
    Mockito.when(fakeRootQueueMetrics.getAllocatedResources()).thenReturn
        (clusterUsage);
    Mockito.when(mockScheduler.getRootQueueMetrics()).thenReturn
        (fakeRootQueueMetrics);
    Mockito.when(mockScheduler.getConf()).thenReturn
        (Mockito.mock(FairSchedulerConfiguration.class));

    ApplicationAttemptId applicationAttemptId = createAppAttemptId(1, 1);
    RMContext rmContext = resourceManager.getRMContext();
    FSAppAttempt schedulerApp =
        new FSAppAttempt(mockScheduler, applicationAttemptId, ""user1"", mockQueue ,
            null, rmContext);

    // Min of Memory and CPU across cluster and queue is used in
    // DominantResourceFairnessPolicy
    Mockito.when(mockQueue.getPolicy()).thenReturn(SchedulingPolicy
        .getInstance(DominantResourceFairnessPolicy.class));
    verifyHeadroom(schedulerApp,
        min(queueStarvation.getMemorySize(),
            clusterAvailable.getMemorySize(),
            queueMaxResourcesAvailable.getMemorySize()),
        min(queueStarvation.getVirtualCores(),
            clusterAvailable.getVirtualCores(),
            queueMaxResourcesAvailable.getVirtualCores())
    );

    // Fair and Fifo ignore CPU of queue, so use cluster available CPU
    Mockito.when(mockQueue.getPolicy()).thenReturn(SchedulingPolicy
        .getInstance(FairSharePolicy.class));
    verifyHeadroom(schedulerApp,
        min(queueStarvation.getMemorySize(),
            clusterAvailable.getMemorySize(),
            queueMaxResourcesAvailable.getMemorySize()),
        Math.min(
            clusterAvailable.getVirtualCores(),
            queueMaxResourcesAvailable.getVirtualCores())
    );

    Mockito.when(mockQueue.getPolicy()).thenReturn(SchedulingPolicy
        .getInstance(FifoPolicy.class));
    verifyHeadroom(schedulerApp,
        min(queueStarvation.getMemorySize(),
            clusterAvailable.getMemorySize(),
            queueMaxResourcesAvailable.getMemorySize()),
        Math.min(
            clusterAvailable.getVirtualCores(),
            queueMaxResourcesAvailable.getVirtualCores())
    );
  }",Eager Test
"@Test
  public void testHeadroomWithBlackListedNodes() {
    // Add two nodes
    RMNode node1 =
        MockNodes.newNodeInfo(1, Resources.createResource(8 * 1024, 8), 1,
            ""127.0.0.1"");
    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);
    RMNode node2 =
        MockNodes.newNodeInfo(1, Resources.createResource(4 * 1024, 4), 2,
            ""127.0.0.2"");
    NodeAddedSchedulerEvent nodeEvent2 = new NodeAddedSchedulerEvent(node2);
    scheduler.handle(nodeEvent2);
    assertEquals(""We should have two alive nodes."",
        2, scheduler.getNumClusterNodes());
    Resource clusterResource = scheduler.getClusterResource();
    Resource clusterUsage = scheduler.getRootQueueMetrics()
        .getAllocatedResources();
    assertEquals(12 * 1024, clusterResource.getMemorySize());
    assertEquals(12, clusterResource.getVirtualCores());
    assertEquals(0, clusterUsage.getMemorySize());
    assertEquals(0, clusterUsage.getVirtualCores());
    ApplicationAttemptId id11 = createAppAttemptId(1, 1);
    createMockRMApp(id11);
    ApplicationPlacementContext placementCtx =
        new ApplicationPlacementContext(""default"");
    scheduler.addApplication(id11.getApplicationId(),
            ""default"", ""user1"", false, placementCtx);
    scheduler.addApplicationAttempt(id11, false, false);
    assertNotNull(scheduler.getSchedulerApplications().get(id11.
            getApplicationId()));
    FSAppAttempt app = scheduler.getSchedulerApp(id11);
    assertNotNull(app);
    Resource queueUsage = app.getQueue().getResourceUsage();
    assertEquals(0, queueUsage.getMemorySize());
    assertEquals(0, queueUsage.getVirtualCores());
    SchedulerNode n1 = scheduler.getSchedulerNode(node1.getNodeID());
    SchedulerNode n2 = scheduler.getSchedulerNode(node2.getNodeID());
    assertNotNull(n1);
    assertNotNull(n2);
    List<String> blacklistAdditions = new ArrayList<String>(1);
    List<String> blacklistRemovals = new ArrayList<String>(1);
    blacklistAdditions.add(n1.getNodeName());
    FSAppAttempt spyApp = spy(app);
    doReturn(false)
        .when(spyApp).isWaitingForAMContainer();
    spyApp.updateBlacklist(blacklistAdditions, blacklistRemovals);
    spyApp.getQueue().setFairShare(clusterResource);
    assertTrue(spyApp.isPlaceBlacklisted(n1.getNodeName()));
    assertFalse(spyApp.isPlaceBlacklisted(n2.getNodeName()));
    assertEquals(n2.getUnallocatedResource(), spyApp.getHeadroom());

    blacklistAdditions.clear();
    blacklistAdditions.add(n2.getNodeName());
    blacklistRemovals.add(n1.getNodeName());
    spyApp.updateBlacklist(blacklistAdditions, blacklistRemovals);
    assertFalse(spyApp.isPlaceBlacklisted(n1.getNodeName()));
    assertTrue(spyApp.isPlaceBlacklisted(n2.getNodeName()));
    assertEquals(n1.getUnallocatedResource(), spyApp.getHeadroom());

    blacklistAdditions.clear();
    blacklistRemovals.clear();
    blacklistRemovals.add(n2.getNodeName());
    spyApp.updateBlacklist(blacklistAdditions, blacklistRemovals);
    assertFalse(spyApp.isPlaceBlacklisted(n1.getNodeName()));
    assertFalse(spyApp.isPlaceBlacklisted(n2.getNodeName()));
    assertEquals(clusterResource, spyApp.getHeadroom());
  }",Eager Test
"@Test
  public void testConcurrentChangeToGetChildQueue() {

    queueManager.getLeafQueue(""parent.child"", true);
    queueManager.getLeafQueue(""parent.child2"", true);
    FSParentQueue test = queueManager.getParentQueue(""parent"", false);
    assertEquals(2, test.getChildQueues().size());

    boolean first = true;
    int childQueuesFound = 0;
    for (FSQueue childQueue:test.getChildQueues()) {
      if (first) {
        first = false;
        queueManager.getLeafQueue(""parent.child3"", true);
      }",Eager Test
"@Test
  public void testSimpleAllocation() {
    RMNode node = createNode();
    FSSchedulerNode schedulerNode = new FSSchedulerNode(node, false);

    createDefaultContainer();
    assertEquals(""Nothing should have been allocated, yet"",
        Resources.none(), schedulerNode.getAllocatedResource());
    schedulerNode.allocateContainer(containers.get(0));
    assertEquals(""Container should be allocated"",
        containers.get(0).getContainer().getResource(),
        schedulerNode.getAllocatedResource());
    schedulerNode.releaseContainer(containers.get(0).getContainerId(), true);
    assertEquals(""Everything should have been released"",
        Resources.none(), schedulerNode.getAllocatedResource());

    // Check that we are error prone
    schedulerNode.releaseContainer(containers.get(0).getContainerId(), true);
    finalValidation(schedulerNode);
  }",No Smells
"@Test
  public void testSimpleAllocation() {
    RMNode node = createNode();
    FSSchedulerNode schedulerNode = new FSSchedulerNode(node, false);

    createDefaultContainer();
    assertEquals(""Nothing should have been allocated, yet"",
        Resources.none(), schedulerNode.getAllocatedResource());
    schedulerNode.allocateContainer(containers.get(0));
    assertEquals(""Container should be allocated"",
        containers.get(0).getContainer().getResource(),
        schedulerNode.getAllocatedResource());
    schedulerNode.releaseContainer(containers.get(0).getContainerId(), true);
    assertEquals(""Everything should have been released"",
        Resources.none(), schedulerNode.getAllocatedResource());

    // Check that we are error prone
    schedulerNode.releaseContainer(containers.get(0).getContainerId(), true);
    finalValidation(schedulerNode);
  }",Eager Test
"@Test
  public void testMultiplePreemptionEvents() {
    RMNode node = createNode();
    FSSchedulerNode schedulerNode = new FSSchedulerNode(node, false);

    // Launch containers and saturate the cluster
    saturateCluster(schedulerNode);
    assertEquals(""Container should be allocated"",
        Resources.multiply(containers.get(0).getContainer().getResource(),
            containers.size()),
        schedulerNode.getAllocatedResource());

    // Preempt a container
    FSAppAttempt starvingApp1 = createStarvingApp(schedulerNode,
        Resource.newInstance(2048, 2));
    FSAppAttempt starvingApp2 = createStarvingApp(schedulerNode,
        Resource.newInstance(1024, 1));

    // Preemption thread kicks in
    schedulerNode.addContainersForPreemption(
        Collections.singletonList(containers.get(0)), starvingApp1);
    schedulerNode.addContainersForPreemption(
        Collections.singletonList(containers.get(1)), starvingApp1);
    schedulerNode.addContainersForPreemption(
        Collections.singletonList(containers.get(2)), starvingApp2);

    // Preemption happens
    schedulerNode.releaseContainer(containers.get(1).getContainerId(), true);
    allocateContainers(schedulerNode);

    schedulerNode.releaseContainer(containers.get(2).getContainerId(), true);
    schedulerNode.releaseContainer(containers.get(0).getContainerId(), true);
    allocateContainers(schedulerNode);

    assertEquals(""Container should be allocated"",
        schedulerNode.getTotalResource(),
        schedulerNode.getAllocatedResource());

    // Release all containers
    for (int i = 3; i < containers.size(); ++i) {
      schedulerNode.releaseContainer(containers.get(i).getContainerId(), true);
    }",Eager Test
"@Test
  public void testPartialReservedPreemption() {
    RMNode node = createNode();
    FSSchedulerNode schedulerNode = new FSSchedulerNode(node, false);

    // Launch containers and saturate the cluster
    saturateCluster(schedulerNode);
    assertEquals(""Container should be allocated"",
        Resources.multiply(containers.get(0).getContainer().getResource(),
            containers.size()),
        schedulerNode.getAllocatedResource());

    // Preempt a container
    Resource originalStarvingAppDemand = Resource.newInstance(512, 1);
    FSAppAttempt starvingApp = createStarvingApp(schedulerNode,
        originalStarvingAppDemand);
    schedulerNode.addContainersForPreemption(
        Collections.singletonList(containers.get(0)), starvingApp);

    // Preemption occurs
    schedulerNode.releaseContainer(containers.get(0).getContainerId(), true);

    // Container partially reassigned
    allocateContainers(schedulerNode);
    assertEquals(""Container should be allocated"",
        Resources.subtract(schedulerNode.getTotalResource(),
            Resource.newInstance(512, 0)),
        schedulerNode.getAllocatedResource());

    // Cleanup simulating node update
    schedulerNode.getPreemptionList();

    // Release all containers
    for (int i = 1; i < containers.size(); ++i) {
      schedulerNode.releaseContainer(containers.get(i).getContainerId(), true);
    }",Eager Test
"@Test
  public void testPreemptionToCompletedApp() {
    RMNode node = createNode();
    FSSchedulerNode schedulerNode = new FSSchedulerNode(node, false);

    // Launch containers and saturate the cluster
    saturateCluster(schedulerNode);
    assertEquals(""Container should be allocated"",
        Resources.multiply(containers.get(0).getContainer().getResource(),
            containers.size()),
        schedulerNode.getAllocatedResource());

    // Preempt a container
    FSAppAttempt starvingApp = createStarvingApp(schedulerNode,
        Resource.newInstance(1024, 1));
    schedulerNode.addContainersForPreemption(
        Collections.singletonList(containers.get(0)), starvingApp);

    schedulerNode.releaseContainer(containers.get(0).getContainerId(), true);

    // Stop the application then try to satisfy the reservation
    // and observe that there are still free resources not allocated to
    // the deleted app
    when(starvingApp.isStopped()).thenReturn(true);
    allocateContainers(schedulerNode);
    assertNotEquals(""Container should be allocated"",
        schedulerNode.getTotalResource(),
        schedulerNode.getAllocatedResource());

    // Release all containers
    for (int i = 1; i < containers.size(); ++i) {
      schedulerNode.releaseContainer(containers.get(i).getContainerId(), true);
    }",Eager Test
"@Test
  public void testSimplePreemption() {
    RMNode node = createNode();
    FSSchedulerNode schedulerNode = new FSSchedulerNode(node, false);

    // Launch containers and saturate the cluster
    saturateCluster(schedulerNode);
    assertEquals(""Container should be allocated"",
        Resources.multiply(containers.get(0).getContainer().getResource(),
            containers.size()),
        schedulerNode.getAllocatedResource());

    // Request preemption
    FSAppAttempt starvingApp = createStarvingApp(schedulerNode,
        Resource.newInstance(1024, 1));
    schedulerNode.addContainersForPreemption(
        Collections.singletonList(containers.get(0)), starvingApp);
    assertEquals(
        ""No resource amount should be reserved for preemptees"",
        containers.get(0).getAllocatedResource(),
        schedulerNode.getTotalReserved());

    // Preemption occurs release one container
    schedulerNode.releaseContainer(containers.get(0).getContainerId(), true);
    allocateContainers(schedulerNode);
    assertEquals(""Container should be allocated"",
        schedulerNode.getTotalResource(),
        schedulerNode.getAllocatedResource());

    // Release all remaining containers
    for (int i = 1; i < containers.size(); ++i) {
      schedulerNode.releaseContainer(containers.get(i).getContainerId(), true);
    }",Eager Test
"@Test
  public void testCheckQueueNodeName() {
    assertFalse(queueManager.isQueueNameValid(""""));
    assertFalse(queueManager.isQueueNameValid(""  ""));
    assertFalse(queueManager.isQueueNameValid("" a""));
    assertFalse(queueManager.isQueueNameValid(""a ""));
    assertFalse(queueManager.isQueueNameValid("" a ""));
    assertFalse(queueManager.isQueueNameValid(""\u00a0""));
    assertFalse(queueManager.isQueueNameValid(""a\u00a0""));
    assertFalse(queueManager.isQueueNameValid(""\u00a0a\u00a0""));
    assertTrue(queueManager.isQueueNameValid(""a b""));
    assertTrue(queueManager.isQueueNameValid(""a""));
  }",No Smells
"@Test
  public void testCreateLeafQueue() {
    FSQueue q1 = queueManager.createQueue(""root.queue1"", FSQueueType.LEAF);

    assertNotNull(""Leaf queue root.queue1 was not created"",
        queueManager.getLeafQueue(""root.queue1"", false));
    assertEquals(""createQueue() returned wrong queue"",
        ""root.queue1"", q1.getName());
  }",No Smells
"@Test
  public void testNonEmptyStaticQueueBecomingDynamicQueue() {
    FSLeafQueue q1 = queueManager.getLeafQueue(""root.test.childA"", false);

    assertNotNull(""Queue root.test.childA does not exist"", q1);
    assertEquals(""createQueue() returned wrong queue"",
        ""root.test.childA"", q1.getName());
    assertFalse(""root.test.childA is not a static queue"", q1.isDynamic());

    // we submitted an app to the queue
    ApplicationId appId = ApplicationId.newInstance(0, 0);
    q1.addAssignedApp(appId);

    // the next removeEmptyDynamicQueues() call should not modify
    // root.test.childA
    queueManager.removePendingIncompatibleQueues();
    queueManager.removeEmptyDynamicQueues();
    q1 = queueManager.getLeafQueue(""root.test.childA"", false);
    assertNotNull(""Queue root.test.childA was deleted"", q1);
    assertFalse(""root.test.childA is not a dynamic queue"", q1.isDynamic());

    // next we remove all queues from the allocation config,
    // this causes all queues to change to dynamic
    AllocationConfiguration allocConf = scheduler.getAllocationConfiguration();
    for (Set<String> queueNames : allocConf.configuredQueues.values()) {
      queueManager.setQueuesToDynamic(queueNames);
      queueNames.clear();
    }",Eager Test
"@Test
  public void testRemovalOfDynamicParentQueue() {
    FSQueue q1 = queueManager.getLeafQueue(""root.parent1.dynamic1"", true);

    assertNotNull(""Queue root.parent1.dynamic1 was not created"", q1);
    assertEquals(""createQueue() returned wrong queue"",
        ""root.parent1.dynamic1"", q1.getName());
    assertTrue(""root.parent1.dynamic1 is not a dynamic queue"", q1.isDynamic());

    FSQueue p1 = queueManager.getParentQueue(""root.parent1"", false);
    assertNotNull(""Queue root.parent1 was not created"", p1);
    assertTrue(""root.parent1 is not a dynamic queue"", p1.isDynamic());

    queueManager.removePendingIncompatibleQueues();
    queueManager.removeEmptyDynamicQueues();
    q1 = queueManager.getLeafQueue(""root.parent1.dynamic1"", false);
    p1 = queueManager.getParentQueue(""root.parent1"", false);

    assertNull(""Queue root.parent1.dynamic1 was not deleted"", q1);
    assertNull(""Queue root.parent1 was not deleted"", p1);
  }",Eager Test
"@Test
  public void testNestedUserQueueDefaultRule() throws Exception {
    // This test covers the use case where we would like user queues to be
    // created under a default parent queue
    StringBuilder sb = new StringBuilder();
    sb.append(""<queuePlacementPolicy>"");
    sb.append(""  <rule name='specified' create='false' />"");
    sb.append(""  <rule name='nestedUserQueue'>"");
    sb.append(""       <rule name='default' queue='root.parent'/>"");
    sb.append(""  </rule>"");
    sb.append(""</queuePlacementPolicy>"");

    createPolicy(sb.toString());
    asc = newAppSubmissionContext(""default"");
    context = placementManager.placeApplication(asc, ""user1"");
    assertEquals(""root.parent.user1"", context.getQueue());

    // Same as above but now with the create flag false for the parent
    createQueue(FSQueueType.PARENT, ""root.parent"");
    sb = new StringBuilder();
    sb.append(""<queuePlacementPolicy>"");
    sb.append(""  <rule name='specified' create='false' />"");
    sb.append(""  <rule name='nestedUserQueue'>"");
    sb.append(""    <rule name='default' queue='root.parent' create='false'/>"");
    sb.append(""  </rule>"");
    sb.append(""  <rule name='default' />"");
    sb.append(""</queuePlacementPolicy>"");

    createPolicy(sb.toString());
    asc = newAppSubmissionContext(""default"");
    context = placementManager.placeApplication(asc, ""user1"");
    assertEquals(""root.parent.user1"", context.getQueue());

    // Parent queue returned is already a configured LEAF, should fail and the
    // context is null.
    createQueue(FSQueueType.LEAF, ""root.parent"");
    sb = new StringBuilder();
    sb.append(""<queuePlacementPolicy>"");
    sb.append(""  <rule name='specified' create='false' />"");
    sb.append(""  <rule name='nestedUserQueue'>"");
    sb.append(""       <rule name='default' queue='root.parent' />"");
    sb.append(""  </rule>"");
    sb.append(""</queuePlacementPolicy>"");

    createPolicy(sb.toString());
    asc = newAppSubmissionContext(""default"");
    context = placementManager.placeApplication(asc, ""user1"");
    assertNull(""Submission should have failed and did not"", context);
  }",No Smells
"@Test
  public void testNestedUserQueuePrimaryGroupNoCreate() throws Exception {
    // Primary group rule has create='false'
    StringBuilder sb = new StringBuilder();
    sb.append(""<queuePlacementPolicy>"");
    sb.append(""  <rule name='nestedUserQueue'>"");
    sb.append(""       <rule name='primaryGroup' create='false'/>"");
    sb.append(""  </rule>"");
    sb.append(""  <rule name='default' />"");
    sb.append(""</queuePlacementPolicy>"");

    createPolicy(sb.toString());

    // Should return root.default since primary group 'root.user1group' is not
    // configured
    asc = newAppSubmissionContext(""default"");
    context = placementManager.placeApplication(asc, ""user1"");
    assertEquals(""root.default"", context.getQueue());

    // Let's configure primary group and check if user queue is created
    createQueue(FSQueueType.PARENT, ""root.user1group"");
    context = placementManager.placeApplication(asc, ""user1"");
    assertEquals(""root.user1group.user1"", context.getQueue());

    // Both Primary group and nestedUserQueue rule has create='false'
    sb = new StringBuilder();
    sb.append(""<queuePlacementPolicy>"");
    sb.append(""  <rule name='nestedUserQueue' create='false'>"");
    sb.append(""       <rule name='primaryGroup' create='false'/>"");
    sb.append(""  </rule>"");
    sb.append(""  <rule name='default' />"");
    sb.append(""</queuePlacementPolicy>"");

    // Should return root.default since primary group and user queue for user 2
    // are not configured.
    asc = newAppSubmissionContext(""default"");
    context = placementManager.placeApplication(asc, ""user2"");
    assertEquals(""root.default"", context.getQueue());

    // Now configure both primary group and the user queue for user2
    createQueue(FSQueueType.LEAF, ""root.user2group.user2"");

    // Try placing the same app again
    context = placementManager.placeApplication(asc, ""user2"");
    assertEquals(""root.user2group.user2"", context.getQueue());
  }",No Smells
"@Test
  public void testNestedUserQueueSpecificRule() throws Exception {
    // This test covers the use case where users can specify different parent
    // queues and want user queues under those.
    StringBuilder sb = new StringBuilder();
    sb.append(""<queuePlacementPolicy>"");
    sb.append(""  <rule name='nestedUserQueue'>"");
    sb.append(""       <rule name='specified' create='false'/>"");
    sb.append(""  </rule>"");
    sb.append(""  <rule name='default' />"");
    sb.append(""</queuePlacementPolicy>"");

    // Let's create couple of parent queues
    createQueue(FSQueueType.PARENT, ""root.parent1"");
    createQueue(FSQueueType.PARENT, ""root.parent2"");

    createPolicy(sb.toString());
    asc = newAppSubmissionContext(""root.parent1"");
    context = placementManager.placeApplication(asc, ""user1"");
    assertEquals(""root.parent1.user1"", context.getQueue());
    asc = newAppSubmissionContext(""root.parent2"");
    context = placementManager.placeApplication(asc, ""user2"");
    assertEquals(""root.parent2.user2"", context.getQueue());
  }",No Smells
"@Test
  public void testOmittedTerminalRule()  {
    StringBuilder sb = new StringBuilder();
    sb.append(""<queuePlacementPolicy>"");
    sb.append(""  <rule name='specified' />"");
    sb.append(""  <rule name='user' create=\""false\"" />"");
    sb.append(""</queuePlacementPolicy>"");
    assertIfExceptionThrown(sb);
  }",No Smells
"@Test
  public void testSpecifiedThenReject() throws Exception {
    StringBuilder sb = new StringBuilder();
    sb.append(""<queuePlacementPolicy>"");
    sb.append(""  <rule name='specified' />"");
    sb.append(""  <rule name='reject' />"");
    sb.append(""</queuePlacementPolicy>"");
    createPolicy(sb.toString());
    asc = newAppSubmissionContext(""specifiedq"");
    context = placementManager.placeApplication(asc, ""someuser"");
    assertEquals(""root.specifiedq"", context.getQueue());
    asc = newAppSubmissionContext(""default"");
    context = placementManager.placeApplication(asc, ""someuser"");
    assertNull(""Assignment should have been rejected and was not"", context);
  }",No Smells
"@Test
  public void testUserContainsPeriod() throws Exception {
    // This test covers the user case where the username contains periods.
    StringBuilder sb = new StringBuilder();
    sb.append(""<queuePlacementPolicy>"");
    sb.append(""  <rule name='user' />"");
    sb.append(""</queuePlacementPolicy>"");
    createPolicy(sb.toString());
    asc = newAppSubmissionContext(""default"");
    context = placementManager.placeApplication(asc, ""first.last"");
    assertEquals(""root.first_dot_last"", context.getQueue());

    sb = new StringBuilder();
    sb.append(""<queuePlacementPolicy>"");
    sb.append(""  <rule name='specified' create='false' />"");
    sb.append(""  <rule name='nestedUserQueue'>"");
    sb.append(""       <rule name='default'/>"");
    sb.append(""  </rule>"");
    sb.append(""</queuePlacementPolicy>"");
    // specified create is false, bypass the rule
    // default rule has create which requires a PARENT queue: remove the LEAF
    queueManager.removeLeafQueue(""root.default"");
    createPolicy(sb.toString());
    asc = newAppSubmissionContext(""default"");
    context = placementManager.placeApplication(asc, ""first_dot_last"");
    assertEquals(""root.default.first_dot_last"", context.getQueue());
  }",No Smells
"@Test
  public void testFIFOPolicyOnlyForLeafQueues()
      throws IOException {
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, ALLOC_FILE);

    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder(""root"")
            .subQueue(new AllocationFileQueue.Builder(""intermediate"")
                .schedulingPolicy(""fifo"")
                .subQueue(new AllocationFileQueue.Builder(""leaf"")
                    .schedulingPolicy(""fair"").build())
                .build())
            .build())
            .writeToFile(ALLOC_FILE);

    scheduler.init(conf);

    FSQueue intermediate = scheduler.getQueueManager().getQueue(""intermediate"");
    assertNull(""Queue 'intermediate' should be null since 'fifo' is only for ""
        + ""leaf queue."", intermediate);

    AllocationFileWriter.create()
        .addQueue(new AllocationFileQueue.Builder(""root"")
            .subQueue(new AllocationFileQueue.Builder(""intermediate"")
                .schedulingPolicy(""fair"")
                .subQueue(new AllocationFileQueue.Builder(""leaf"")
                    .schedulingPolicy(""fifo"").build())
                .build())
            .build())
        .writeToFile(ALLOC_FILE);

    scheduler.reinitialize(conf, null);

    assertNotNull(scheduler.getQueueManager().getQueue(""intermediate""));

    FSQueue leaf = scheduler.getQueueManager().getQueue(""intermediate.leaf"");
    assertNotNull(""Queue 'leaf' should be null since 'fifo' is only for ""
        + ""leaf queue."", leaf);
  }",No Smells
"@Test
  public void testResourceUpdateDecommissioningNode() throws Exception {
    // Mock the RMNodeResourceUpdate event handler to update SchedulerNode
    // to have 0 available resource
    RMContext spyContext = Mockito.spy(resourceManager.getRMContext());
    Dispatcher mockDispatcher = mock(AsyncDispatcher.class);
    when(mockDispatcher.getEventHandler()).thenReturn(new EventHandler<Event>() {
      @Override
      public void handle(Event event) {
        if (event instanceof RMNodeResourceUpdateEvent) {
          RMNodeResourceUpdateEvent resourceEvent =
              (RMNodeResourceUpdateEvent) event;
          resourceManager
              .getResourceScheduler()
              .getSchedulerNode(resourceEvent.getNodeId())
              .updateTotalResource(resourceEvent.getResourceOption().getResource());
        }",Eager Test
"@Test
  public void testNodeAttributesFunctionality() {
    // 1. Simple java=1.8 validation
    SchedulingRequest schedulingRequest =
        SchedulingRequest.newBuilder().executionType(
            ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED))
            .allocationRequestId(10L).priority(Priority.newInstance(1))
            .placementConstraintExpression(PlacementConstraints
                .targetNodeAttribute(PlacementConstraints.NODE,
                    NodeAttributeOpCode.EQ,
                    PlacementConstraints.PlacementTargets
                        .nodeAttribute(""java"", ""1.8""),
                    PlacementConstraints.PlacementTargets.nodePartition(""""))
                .build()).resourceSizing(
            ResourceSizing.newInstance(1, Resource.newInstance(1024, 1)))
            .build();
    allocator.updatePendingAsk(schedulerRequestKey, schedulingRequest, false);
    Set<NodeAttribute> attributes = new HashSet<>();
    attributes.add(
        NodeAttribute.newInstance(""java"", NodeAttributeType.STRING, ""1.8""));
    boolean result = allocator.canAllocate(NodeType.NODE_LOCAL,
        TestUtils.getMockNodeWithAttributes(""host1"", ""/rack1"", 123, 1024,
            attributes));
    Assert.assertTrue(""Allocation should be success for java=1.8"", result);

    // 2. verify python!=3 validation
    SchedulingRequest schedulingRequest2 =
        SchedulingRequest.newBuilder().executionType(
            ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED))
            .allocationRequestId(10L).priority(Priority.newInstance(1))
            .placementConstraintExpression(PlacementConstraints
                .targetNodeAttribute(PlacementConstraints.NODE,
                    NodeAttributeOpCode.NE,
                    PlacementConstraints.PlacementTargets
                        .nodeAttribute(""python"", ""3""),
                    PlacementConstraints.PlacementTargets.nodePartition(""""))
                .build()).resourceSizing(
            ResourceSizing.newInstance(1, Resource.newInstance(1024, 1)))
            .build();
    // Create allocator
    allocator = new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo, schedulerRequestKey, rmContext);
    allocator.updatePendingAsk(schedulerRequestKey, schedulingRequest2, false);
    attributes = new HashSet<>();
    result = allocator.canAllocate(NodeType.NODE_LOCAL,
        TestUtils.getMockNodeWithAttributes(""host1"", ""/rack1"", 123, 1024,
            attributes));
    Assert.assertTrue(""Allocation should be success as python doesn't exist"",
        result);

    // 3. verify python!=3 validation when node has python=2
    allocator = new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo, schedulerRequestKey, rmContext);
    allocator.updatePendingAsk(schedulerRequestKey, schedulingRequest2, false);
    attributes = new HashSet<>();
    attributes.add(
        NodeAttribute.newInstance(""python"", NodeAttributeType.STRING, ""2""));
    result = allocator.canAllocate(NodeType.NODE_LOCAL,
        TestUtils.getMockNodeWithAttributes(""host1"", ""/rack1"", 123, 1024,
            attributes));
    Assert.assertTrue(
        ""Allocation should be success as python=3 doesn't exist in node"",
        result);

    // 4. verify python!=3 validation when node has python=3
    allocator = new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo, schedulerRequestKey, rmContext);
    allocator.updatePendingAsk(schedulerRequestKey, schedulingRequest2, false);
    attributes = new HashSet<>();
    attributes.add(
        NodeAttribute.newInstance(""python"", NodeAttributeType.STRING, ""3""));
    result = allocator.canAllocate(NodeType.NODE_LOCAL,
        TestUtils.getMockNodeWithAttributes(""host1"", ""/rack1"", 123, 1024,
            attributes));
    Assert.assertFalse(""Allocation should fail as python=3 exist in node"",
        result);
  }",Eager Test
"@Test
  public void testSizeBasedWeightNotAffectAppActivation() throws Exception {
    CapacitySchedulerConfiguration csConf =
        new CapacitySchedulerConfiguration();

    // Define top-level queues
    String defaultPath = CapacitySchedulerConfiguration.ROOT + "".default"";
    QueuePath queuePath = new QueuePath(defaultPath);
    csConf.set(YarnConfiguration.RM_SCHEDULER,
        CapacityScheduler.class.getCanonicalName());
    csConf.setOrderingPolicy(queuePath,
        CapacitySchedulerConfiguration.FAIR_APP_ORDERING_POLICY);
    csConf.setOrderingPolicyParameter(queuePath,
        FairOrderingPolicy.ENABLE_SIZE_BASED_WEIGHT, ""true"");
    csConf.setMaximumApplicationMasterResourcePerQueuePercent(queuePath, 0.1f);

    // inject node label manager
    MockRM rm = new MockRM(csConf);
    rm.start();

    CapacityScheduler cs = (CapacityScheduler) rm.getResourceScheduler();

    // Get LeafQueue
    LeafQueue lq = (LeafQueue) cs.getQueue(""default"");
    OrderingPolicy<FiCaSchedulerApp> policy = lq.getOrderingPolicy();
    Assert.assertTrue(policy instanceof FairOrderingPolicy);
    Assert.assertTrue(((FairOrderingPolicy<FiCaSchedulerApp>)policy).getSizeBasedWeight());

    rm.registerNode(""h1:1234"", 10 * GB);

    // Submit 4 apps
    MockRMAppSubmissionData data3 =
        MockRMAppSubmissionData.Builder.createWithMemory(1 * GB, rm)
            .withAppName(""app"")
            .withUser(""user"")
            .withAcls(null)
            .withQueue(""default"")
            .withUnmanagedAM(false)
            .build();
    MockRMAppSubmitter.submit(rm, data3);
    MockRMAppSubmissionData data2 =
        MockRMAppSubmissionData.Builder.createWithMemory(1 * GB, rm)
            .withAppName(""app"")
            .withUser(""user"")
            .withAcls(null)
            .withQueue(""default"")
            .withUnmanagedAM(false)
            .build();
    MockRMAppSubmitter.submit(rm, data2);
    MockRMAppSubmissionData data1 =
        MockRMAppSubmissionData.Builder.createWithMemory(1 * GB, rm)
            .withAppName(""app"")
            .withUser(""user"")
            .withAcls(null)
            .withQueue(""default"")
            .withUnmanagedAM(false)
            .build();
    MockRMAppSubmitter.submit(rm, data1);
    MockRMAppSubmissionData data =
        MockRMAppSubmissionData.Builder.createWithMemory(1 * GB, rm)
            .withAppName(""app"")
            .withUser(""user"")
            .withAcls(null)
            .withQueue(""default"")
            .withUnmanagedAM(false)
            .build();
    MockRMAppSubmitter.submit(rm, data);

    Assert.assertEquals(1, lq.getNumActiveApplications());
    Assert.assertEquals(3, lq.getNumPendingApplications());

    // Try allocate once, #active-apps and #pending-apps should be still correct
    cs.handle(new NodeUpdateSchedulerEvent(
        rm.getRMContext().getRMNodes().get(NodeId.newInstance(""h1"", 1234))));
    Assert.assertEquals(1, lq.getNumActiveApplications());
    Assert.assertEquals(3, lq.getNumPendingApplications());
  }",Eager Test
"@Test
  public void testIterators() {
    OrderingPolicy<MockSchedulableEntity> schedOrder =
     new FifoOrderingPolicy<MockSchedulableEntity>();
    
    MockSchedulableEntity msp1 = new MockSchedulableEntity();
    MockSchedulableEntity msp2 = new MockSchedulableEntity();
    MockSchedulableEntity msp3 = new MockSchedulableEntity();
    
    msp1.setSerial(3);
    msp2.setSerial(2);
    msp3.setSerial(1);
    
    schedOrder.addSchedulableEntity(msp1);
    schedOrder.addSchedulableEntity(msp2);
    schedOrder.addSchedulableEntity(msp3);
    
    //Assignment, oldest to youngest
    checkSerials(Arrays.asList(1L, 2L, 3L), schedOrder.getAssignmentIterator(
        IteratorSelector.EMPTY_ITERATOR_SELECTOR));
    
    //Preemption, youngest to oldest
    checkSerials(Arrays.asList(3L, 2L, 1L), schedOrder.getPreemptionIterator());
  }",Eager Test
"@Test
  public void testGetNodesForResourceName() throws Exception {
    addEight4x4Nodes();
    assertEquals(""Incorrect number of nodes matching ANY"",
        8, nodeTracker.getNodesByResourceName(ResourceRequest.ANY).size());

    assertEquals(""Incorrect number of nodes matching rack"",
        4, nodeTracker.getNodesByResourceName(""rack0"").size());

    assertEquals(""Incorrect number of nodes matching node"",
        1, nodeTracker.getNodesByResourceName(""host0"").size());
  }",No Smells
"@Test
  public void testNodeTypeMetrics() {
    String parentQueueName = ""root"";
    String leafQueueName = ""root.leaf"";

    QueueMetrics parentMetrics =
      QueueMetrics.forQueue(ms, parentQueueName, null, true, conf);
    Queue parentQueue = mock(Queue.class);
    when(parentQueue.getMetrics()).thenReturn(parentMetrics);
    QueueMetrics metrics =
      QueueMetrics.forQueue(ms, leafQueueName, parentQueue, true, conf);
    MetricsSource parentQueueSource = queueSource(ms, parentQueueName);
    MetricsSource queueSource = queueSource(ms, leafQueueName);
    //AppSchedulingInfo app = mockApp(user);

    metrics.submitApp(USER, false);
    MetricsSource userSource = userSource(ms, leafQueueName, USER);
    MetricsSource parentUserSource = userSource(ms, parentQueueName, USER);

    metrics.incrNodeTypeAggregations(USER, NodeType.NODE_LOCAL);
    checkAggregatedNodeTypes(queueSource, 1L, 0L, 0L);
    checkAggregatedNodeTypes(parentQueueSource, 1L, 0L, 0L);
    checkAggregatedNodeTypes(userSource, 1L, 0L, 0L);
    checkAggregatedNodeTypes(parentUserSource, 1L, 0L, 0L);

    metrics.incrNodeTypeAggregations(USER, NodeType.RACK_LOCAL);
    checkAggregatedNodeTypes(queueSource, 1L, 1L, 0L);
    checkAggregatedNodeTypes(parentQueueSource, 1L, 1L, 0L);
    checkAggregatedNodeTypes(userSource, 1L, 1L, 0L);
    checkAggregatedNodeTypes(parentUserSource, 1L, 1L, 0L);

    metrics.incrNodeTypeAggregations(USER, NodeType.OFF_SWITCH);
    checkAggregatedNodeTypes(queueSource, 1L, 1L, 1L);
    checkAggregatedNodeTypes(parentQueueSource, 1L, 1L, 1L);
    checkAggregatedNodeTypes(userSource, 1L, 1L, 1L);
    checkAggregatedNodeTypes(parentUserSource, 1L, 1L, 1L);

    metrics.incrNodeTypeAggregations(USER, NodeType.OFF_SWITCH);
    checkAggregatedNodeTypes(queueSource, 1L, 1L, 2L);
    checkAggregatedNodeTypes(parentQueueSource, 1L, 1L, 2L);
    checkAggregatedNodeTypes(userSource, 1L, 1L, 2L);
    checkAggregatedNodeTypes(parentUserSource, 1L, 1L, 2L);
  }",No Smells
"@Test
  public void testCollectAllMetrics() {
    String queueName = ""single"";
    QueueMetrics.forQueue(ms, queueName, null, false, conf);
    MetricsSource queueSource = queueSource(ms, queueName);

    AppMetricsChecker.create()
        .checkAgainst(queueSource, true);
    try {
      // do not collect all metrics
      AppMetricsChecker.create()
          .checkAgainst(queueSource, false);
      Assert.fail();
    }",No Smells
"@Test
  public void testNodeTypeMetrics() {
    String parentQueueName = ""root"";
    String leafQueueName = ""root.leaf"";

    QueueMetrics parentMetrics =
      QueueMetrics.forQueue(ms, parentQueueName, null, true, conf);
    Queue parentQueue = mock(Queue.class);
    when(parentQueue.getMetrics()).thenReturn(parentMetrics);
    QueueMetrics metrics =
      QueueMetrics.forQueue(ms, leafQueueName, parentQueue, true, conf);
    MetricsSource parentQueueSource = queueSource(ms, parentQueueName);
    MetricsSource queueSource = queueSource(ms, leafQueueName);
    //AppSchedulingInfo app = mockApp(user);

    metrics.submitApp(USER, false);
    MetricsSource userSource = userSource(ms, leafQueueName, USER);
    MetricsSource parentUserSource = userSource(ms, parentQueueName, USER);

    metrics.incrNodeTypeAggregations(USER, NodeType.NODE_LOCAL);
    checkAggregatedNodeTypes(queueSource, 1L, 0L, 0L);
    checkAggregatedNodeTypes(parentQueueSource, 1L, 0L, 0L);
    checkAggregatedNodeTypes(userSource, 1L, 0L, 0L);
    checkAggregatedNodeTypes(parentUserSource, 1L, 0L, 0L);

    metrics.incrNodeTypeAggregations(USER, NodeType.RACK_LOCAL);
    checkAggregatedNodeTypes(queueSource, 1L, 1L, 0L);
    checkAggregatedNodeTypes(parentQueueSource, 1L, 1L, 0L);
    checkAggregatedNodeTypes(userSource, 1L, 1L, 0L);
    checkAggregatedNodeTypes(parentUserSource, 1L, 1L, 0L);

    metrics.incrNodeTypeAggregations(USER, NodeType.OFF_SWITCH);
    checkAggregatedNodeTypes(queueSource, 1L, 1L, 1L);
    checkAggregatedNodeTypes(parentQueueSource, 1L, 1L, 1L);
    checkAggregatedNodeTypes(userSource, 1L, 1L, 1L);
    checkAggregatedNodeTypes(parentUserSource, 1L, 1L, 1L);

    metrics.incrNodeTypeAggregations(USER, NodeType.OFF_SWITCH);
    checkAggregatedNodeTypes(queueSource, 1L, 1L, 2L);
    checkAggregatedNodeTypes(parentQueueSource, 1L, 1L, 2L);
    checkAggregatedNodeTypes(userSource, 1L, 1L, 2L);
    checkAggregatedNodeTypes(parentUserSource, 1L, 1L, 2L);
  }",Eager Test
"@Test
  public void testActiveUsersWhenMove() {
    final String user = ""user1"";
    Queue parentQueue = createQueue(""parent"", null);
    Queue queue1 = createQueue(""queue1"", parentQueue);
    Queue queue2 = createQueue(""queue2"", parentQueue);
    Queue queue3 = createQueue(""queue3"", parentQueue);

    ApplicationAttemptId appAttId = createAppAttemptId(0, 0);
    RMContext rmContext = mock(RMContext.class);
    when(rmContext.getEpoch()).thenReturn(3L);
    when(rmContext.getYarnConfiguration()).thenReturn(conf);
    SchedulerApplicationAttempt app = new SchedulerApplicationAttempt(appAttId,
        user, queue1, queue1.getAbstractUsersManager(), rmContext);

    // Resource request
    Resource requestedResource = Resource.newInstance(1536, 2);
    Priority requestedPriority = Priority.newInstance(2);
    ResourceRequest request = ResourceRequest.newInstance(requestedPriority,
        ResourceRequest.ANY, requestedResource, 1);
    app.updateResourceRequests(Arrays.asList(request));

    assertEquals(1, queue1.getAbstractUsersManager().getNumActiveUsers());
    // move app from queue1 to queue2
    app.move(queue2);
    // Active user count has to decrease from queue1
    assertEquals(0, queue1.getAbstractUsersManager().getNumActiveUsers());
    // Increase the active user count in queue2 if the moved app has pending requests
    assertEquals(1, queue2.getAbstractUsersManager().getNumActiveUsers());

    // Allocated container
    RMContainer container1 = createRMContainer(appAttId, 1, requestedResource);
    app.liveContainers.put(container1.getContainerId(), container1);
    SchedulerNode node = createNode();
    app.appSchedulingInfo.allocate(NodeType.OFF_SWITCH, node,
        toSchedulerKey(requestedPriority), container1);

    // Active user count has to decrease from queue2 due to app has NO pending requests
    assertEquals(0, queue2.getAbstractUsersManager().getNumActiveUsers());
    // move app from queue2 to queue3
    app.move(queue3);
    // Active user count in queue3 stays same if the moved app has NO pending requests
    assertEquals(0, queue3.getAbstractUsersManager().getNumActiveUsers());
  }",Eager Test
"@Test
  public void testAppPercentages() throws Exception {
    FifoScheduler scheduler = mock(FifoScheduler.class);
    when(scheduler.getClusterResource())
        .thenReturn(Resource.newInstance(10 * 1024, 10));
    when(scheduler.getResourceCalculator())
        .thenReturn(new DefaultResourceCalculator());

    ApplicationAttemptId appAttId = createAppAttemptId(0, 0);
    RMContext rmContext = mock(RMContext.class);
    when(rmContext.getEpoch()).thenReturn(3L);
    when(rmContext.getScheduler()).thenReturn(scheduler);
    when(rmContext.getYarnConfiguration()).thenReturn(conf);

    final String user = ""user1"";
    Queue queue = createQueue(""test"", null);
    SchedulerApplicationAttempt app =
        new SchedulerApplicationAttempt(appAttId, user, queue,
            queue.getAbstractUsersManager(), rmContext);

    // Resource request
    Resource requestedResource = Resource.newInstance(1536, 2);
    app.attemptResourceUsage.incUsed(requestedResource);

    assertEquals(15.0f, app.getResourceUsageReport().getQueueUsagePercentage(),
        0.01f);
    assertEquals(15.0f,
        app.getResourceUsageReport().getClusterUsagePercentage(), 0.01f);

    queue = createQueue(""test2"", null, 0.5f);
    app = new SchedulerApplicationAttempt(appAttId, user, queue,
        queue.getAbstractUsersManager(), rmContext);
    app.attemptResourceUsage.incUsed(requestedResource);
    assertEquals(30.0f, app.getResourceUsageReport().getQueueUsagePercentage(),
        0.01f);
    assertEquals(15.0f,
        app.getResourceUsageReport().getClusterUsagePercentage(), 0.01f);

    app.attemptResourceUsage.incUsed(requestedResource);
    app.attemptResourceUsage.incUsed(requestedResource);
    app.attemptResourceUsage.incUsed(requestedResource);

    assertEquals(120.0f, app.getResourceUsageReport().getQueueUsagePercentage(),
        0.01f);
    assertEquals(60.0f,
        app.getResourceUsageReport().getClusterUsagePercentage(), 0.01f);

    queue = createQueue(""test3"", null, Float.MIN_VALUE);
    app = new SchedulerApplicationAttempt(appAttId, user, queue,
        queue.getAbstractUsersManager(), rmContext);

    // Resource request
    app.attemptResourceUsage.incUsed(requestedResource);

    assertEquals(0.0f, app.getResourceUsageReport().getQueueUsagePercentage(),
        0.01f);
    assertEquals(15.0f,
        app.getResourceUsageReport().getClusterUsagePercentage(), 0.01f);
  }",Eager Test
"@Test
  public void testCreateAbnormalContainerStatus() {
    ContainerStatus cd = SchedulerUtils.createAbnormalContainerStatus(
            ContainerId.newContainerId(ApplicationAttemptId.newInstance(
                    ApplicationId.newInstance(System.currentTimeMillis(), 1), 1), 1), ""x"");
    Assert.assertEquals(ContainerExitStatus.ABORTED, cd.getExitStatus());
  }",No Smells
"@Test
  public void testCustomResourceRequestedUnitIsSameAsAvailableUnit() {
    Resource requestedResource = ResourceTypesTestHelper.newResource(1, 1,
            ImmutableMap.of(""custom-resource-1"", ""11M""));

    Resource availableResource = ResourceTypesTestHelper.newResource(1, 1,
            ImmutableMap.of(""custom-resource-1"", ""100M""));

    try {
      SchedulerUtils.checkResourceRequestAgainstAvailableResource(
              requestedResource, availableResource);
    }",No Smells
"@Test
  public void testValidateResourceBlacklistRequest() throws Exception {

    MyContainerManager containerManager = new MyContainerManager();
    final MockRMWithAMS rm =
            new MockRMWithAMS(new YarnConfiguration(), containerManager);
    rm.start();

    MockNM nm1 = rm.registerNode(""localhost:1234"", 5120);

    Map<ApplicationAccessType, String> acls =
            new HashMap<ApplicationAccessType, String>(2);
    acls.put(ApplicationAccessType.VIEW_APP, ""*"");
    MockRMAppSubmissionData data =
        MockRMAppSubmissionData.Builder.createWithMemory(1024, rm)
            .withAppName(""appname"")
            .withUser(""appuser"")
            .withAcls(acls)
            .build();
    RMApp app = MockRMAppSubmitter.submit(rm, data);

    nm1.nodeHeartbeat(true);

    RMAppAttempt attempt = app.getCurrentAppAttempt();
    ApplicationAttemptId applicationAttemptId = attempt.getAppAttemptId();
    waitForLaunchedState(attempt);

    // Create a client to the RM.
    final Configuration yarnConf = rm.getConfig();
    final YarnRPC rpc = YarnRPC.create(yarnConf);

    UserGroupInformation currentUser =
            UserGroupInformation.createRemoteUser(applicationAttemptId.toString());
    Credentials credentials = containerManager.getContainerCredentials();
    final InetSocketAddress rmBindAddress =
            rm.getApplicationMasterService().getBindAddress();
    Token<? extends TokenIdentifier> amRMToken =
            MockRMWithAMS.setupAndReturnAMRMToken(rmBindAddress,
                    credentials.getAllTokens());
    currentUser.addToken(amRMToken);
    ApplicationMasterProtocol client =
            currentUser.doAs(new PrivilegedAction<ApplicationMasterProtocol>() {
              @Override
              public ApplicationMasterProtocol run() {
                return (ApplicationMasterProtocol) rpc.getProxy(
                        ApplicationMasterProtocol.class, rmBindAddress, yarnConf);
              }",Eager Test
"@Test
  public void testForceKillNonExistingApplication() throws YarnException {
    RMContext rmContext = mock(RMContext.class);
    when(rmContext.getRMApps()).thenReturn(
        new ConcurrentHashMap<ApplicationId, RMApp>());
    ClientRMService rmService = new ClientRMService(rmContext, null, null,
        null, null, null);
    ApplicationId applicationId =
        BuilderUtils.newApplicationId(System.currentTimeMillis(), 0);
    KillApplicationRequest request =
        KillApplicationRequest.newInstance(applicationId);
    try {
      rmService.forceKillApplication(request);
      Assert.fail();
    }",Eager Test
"@Test
  public void testGetNodeLabels() throws Exception {
    MockRM rm = new MockRM() {
      protected ClientRMService createClientRMService() {
        return new ClientRMService(this.rmContext, scheduler,
            this.rmAppManager, this.applicationACLsManager,
            this.queueACLsManager, this.getRMContext()
                .getRMDelegationTokenSecretManager());
      }",Mystery Guest
"@Test
  public void testGetQueueInfo() throws Exception {
    ResourceScheduler scheduler = mock(ResourceScheduler.class);
    RMContext rmContext = mock(RMContext.class);
    mockRMContext(scheduler, rmContext);

    ApplicationACLsManager mockAclsManager = mock(ApplicationACLsManager.class);
    QueueACLsManager mockQueueACLsManager = mock(QueueACLsManager.class);
    when(mockQueueACLsManager.checkAccess(any(UserGroupInformation.class),
        any(QueueACL.class), any(RMApp.class), any(String.class),
        any()))
        .thenReturn(true);
    when(mockAclsManager.checkAccess(any(UserGroupInformation.class),
        any(ApplicationAccessType.class), any(),
        any(ApplicationId.class))).thenReturn(true);

    ClientRMService rmService = new ClientRMService(rmContext, scheduler,
        null, mockAclsManager, mockQueueACLsManager, null);
    GetQueueInfoRequest request = recordFactory
        .newRecordInstance(GetQueueInfoRequest.class);
    request.setQueueName(""testqueue"");
    request.setIncludeApplications(true);
    GetQueueInfoResponse queueInfo = rmService.getQueueInfo(request);
    List<ApplicationReport> applications = queueInfo.getQueueInfo()
        .getApplications();
    Assert.assertEquals(2, applications.size());
    Map<String, QueueConfigurations> queueConfigsByPartition =
        queueInfo.getQueueInfo().getQueueConfigurations();
    Assert.assertEquals(1, queueConfigsByPartition.size());
    Assert.assertTrue(queueConfigsByPartition.containsKey(""*""));
    QueueConfigurations queueConfigs = queueConfigsByPartition.get(""*"");
    Assert.assertEquals(0.5f, queueConfigs.getCapacity(), 0.0001f);
    Assert.assertEquals(0.1f, queueConfigs.getAbsoluteCapacity(), 0.0001f);
    Assert.assertEquals(1.0f, queueConfigs.getMaxCapacity(), 0.0001f);
    Assert.assertEquals(1.0f, queueConfigs.getAbsoluteMaxCapacity(), 0.0001f);
    Assert.assertEquals(0.2f, queueConfigs.getMaxAMPercentage(), 0.0001f);

    request.setQueueName(""nonexistentqueue"");
    request.setIncludeApplications(true);
    // should not throw exception on nonexistent queue
    queueInfo = rmService.getQueueInfo(request);

    // Case where user does not have application access
    ApplicationACLsManager mockAclsManager1 =
        mock(ApplicationACLsManager.class);
    QueueACLsManager mockQueueACLsManager1 =
        mock(QueueACLsManager.class);
    when(mockQueueACLsManager1.checkAccess(any(UserGroupInformation.class),
        any(QueueACL.class), any(RMApp.class), any(String.class),
        any()))
        .thenReturn(false);
    when(mockAclsManager1.checkAccess(any(UserGroupInformation.class),
        any(ApplicationAccessType.class), anyString(),
        any(ApplicationId.class))).thenReturn(false);

    ClientRMService rmService1 = new ClientRMService(rmContext, scheduler,
        null, mockAclsManager1, mockQueueACLsManager1, null);
    request.setQueueName(""testqueue"");
    request.setIncludeApplications(true);
    GetQueueInfoResponse queueInfo1 = rmService1.getQueueInfo(request);
    List<ApplicationReport> applications1 = queueInfo1.getQueueInfo()
        .getApplications();
    Assert.assertEquals(0, applications1.size());
  }",Mystery Guest
"@Test
  public void testMoveApplicationAdminTargetQueue() throws Exception {
    ApplicationId applicationId = getApplicationId(1);
    UserGroupInformation aclUGI = UserGroupInformation.getCurrentUser();
    QueueACLsManager queueAclsManager = getQueueAclManager(""allowed_queue"",
        QueueACL.ADMINISTER_QUEUE, aclUGI);
    ApplicationACLsManager appAclsManager = getAppAclManager();
    ClientRMService rmService =
        createClientRMServiceForMoveApplicationRequest(applicationId,
            aclUGI.getShortUserName(), appAclsManager, queueAclsManager);

    // user is admin move to queue in acl
    MoveApplicationAcrossQueuesRequest moveAppRequest =
        MoveApplicationAcrossQueuesRequest.newInstance(applicationId,
            ""allowed_queue"");
    rmService.moveApplicationAcrossQueues(moveAppRequest);

    // user is admin move to queue not in acl
    moveAppRequest = MoveApplicationAcrossQueuesRequest.newInstance(
        applicationId, ""not_allowed"");

    try {
      rmService.moveApplicationAcrossQueues(moveAppRequest);
      Assert.fail(""The request should fail with an AccessControlException"");
    }",Eager Test
"@Test
  public void testRMStartWithDecommissionedNode() throws Exception {
    File testDir = GenericTestUtils.getRandomizedTestDir();
    assertTrue(""Failed to create test directory: "" + testDir.getAbsolutePath(), testDir.mkdirs());
    try {
      File excludeFile = createExcludeFile(testDir);
      conf = new YarnConfiguration();
      conf.set(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH,
          excludeFile.getAbsolutePath());
      MockRM rm = new MockRM(conf) {
        protected ClientRMService createClientRMService() {
          return new ClientRMService(this.rmContext, scheduler,
              this.rmAppManager, this.applicationACLsManager, this.queueACLsManager,
              this.getRMContext().getRMDelegationTokenSecretManager());
        }",Eager Test
"@Test
  public void testNMExpiryAndHeartbeatIntervalsValidation() throws Exception {
    Configuration conf = new YarnConfiguration();
    conf.setLong(YarnConfiguration.RM_NM_EXPIRY_INTERVAL_MS, 1000);
    conf.setLong(YarnConfiguration.RM_NM_HEARTBEAT_INTERVAL_MS, 1001);
    try {
      resourceManager = new MockRM(conf);
    }",Eager Test
"@Test
  public void testIncorrectRecommission() throws Exception {
    //Check decommissioned node not get recommissioned with graceful refresh
    Configuration conf = new Configuration();
    rm = new MockRM(conf);
    rm.start();
    MockNM nm1 = rm.registerNode(""host1:1234"", 5120);
    MockNM nm2 = rm.registerNode(""host2:5678"", 10240);
    nm1.nodeHeartbeat(true);
    nm2.nodeHeartbeat(true);
    writeToHostsFile(excludeHostFile, ""host3"", ""host2"");
    conf.set(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH,
        excludeHostFile.getAbsolutePath());
    writeToHostsFile(hostFile, ""host1"", ""host2"");
    writeToHostsFile(excludeHostFile, ""host1"");
    rm.getNodesListManager().refreshNodesGracefully(conf, null);
    rm.drainEvents();
    nm1.nodeHeartbeat(true);
    rm.drainEvents();
    Assert.assertTrue(""Node "" + nm1.getNodeId().getHost() +
        "" should be Decommissioned"", rm.getRMContext()
        .getInactiveRMNodes().get(nm1.getNodeId()).getState() == NodeState
        .DECOMMISSIONED);
    writeToHostsFile(excludeHostFile, """");
    rm.getNodesListManager().refreshNodesGracefully(conf, null);
    rm.drainEvents();
    Assert.assertTrue(""Node "" + nm1.getNodeId().getHost() +
        "" should be Decommissioned"", rm.getRMContext()
        .getInactiveRMNodes().get(nm1.getNodeId()).getState() == NodeState
        .DECOMMISSIONED);
    rm.stop();
  }",Eager Test
"@Test
  public void testNodeHeartBeatWithInvalidLabels() throws Exception {
    writeToHostsFile(""host2"");
    Configuration conf = new Configuration();
    conf.set(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH,
        hostFile.getAbsolutePath());
    conf.set(YarnConfiguration.NODELABEL_CONFIGURATION_TYPE,
        YarnConfiguration.DISTRIBUTED_NODELABEL_CONFIGURATION_TYPE);

    final RMNodeLabelsManager nodeLabelsMgr = new NullRMNodeLabelsManager();

    rm = new MockRM(conf) {
      @Override
      protected RMNodeLabelsManager createNodeLabelManager() {
        return nodeLabelsMgr;
      }",Eager Test
"@Test
  public void testNodeHeartBeatWithLabels() throws Exception {
    writeToHostsFile(""host2"");
    Configuration conf = new Configuration();
    conf.set(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH,
        hostFile.getAbsolutePath());
    conf.set(YarnConfiguration.NODELABEL_CONFIGURATION_TYPE,
        YarnConfiguration.DISTRIBUTED_NODELABEL_CONFIGURATION_TYPE);

    final RMNodeLabelsManager nodeLabelsMgr = new NullRMNodeLabelsManager();

    rm = new MockRM(conf) {
      @Override
      protected RMNodeLabelsManager createNodeLabelManager() {
        return nodeLabelsMgr;
      }",Eager Test
"@Test
  public void testNodeHeartbeatWithNodeAttributes() throws Exception {
    writeToHostsFile(""host2"");
    Configuration conf = new Configuration();
    conf.set(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH,
        hostFile.getAbsolutePath());
    conf.setClass(YarnConfiguration.FS_NODE_ATTRIBUTE_STORE_IMPL_CLASS,
        FileSystemNodeAttributeStore.class, NodeAttributeStore.class);
    conf.set(YarnConfiguration.FS_NODE_ATTRIBUTE_STORE_ROOT_DIR,
        TEMP_DIR.getAbsolutePath());
    rm = new MockRM(conf);
    rm.start();

    // Register to RM
    ResourceTrackerService resourceTrackerService =
        rm.getResourceTrackerService();
    RegisterNodeManagerRequest registerReq =
        Records.newRecord(RegisterNodeManagerRequest.class);
    NodeId nodeId = NodeId.newInstance(""host2"", 1234);
    Resource capability = Resources.createResource(1024);
    registerReq.setResource(capability);
    registerReq.setNodeId(nodeId);
    registerReq.setHttpPort(1234);
    registerReq.setNMVersion(YarnVersionInfo.getVersion());
    RegisterNodeManagerResponse registerResponse =
        resourceTrackerService.registerNodeManager(registerReq);

    Set<NodeAttribute> nodeAttributes = new HashSet<>();
    nodeAttributes.add(NodeAttribute.newInstance(
        NodeAttribute.PREFIX_DISTRIBUTED, ""host"",
        NodeAttributeType.STRING, ""host2""));

    // Set node attributes in HB.
    NodeHeartbeatRequest heartbeatReq =
        Records.newRecord(NodeHeartbeatRequest.class);
    NodeStatus nodeStatusObject = getNodeStatusObject(nodeId);
    int responseId = nodeStatusObject.getResponseId();
    heartbeatReq.setNodeStatus(nodeStatusObject);
    heartbeatReq.setLastKnownNMTokenMasterKey(registerResponse
        .getNMTokenMasterKey());
    heartbeatReq.setLastKnownContainerTokenMasterKey(registerResponse
        .getContainerTokenMasterKey());
    heartbeatReq.setNodeAttributes(nodeAttributes);
    resourceTrackerService.nodeHeartbeat(heartbeatReq);

    // Ensure RM gets correct node attributes update.
    NodeAttributesManager attributeManager =
        rm.getRMContext().getNodeAttributesManager();
    Map<NodeAttribute, AttributeValue> attrs = attributeManager
        .getAttributesForNode(nodeId.getHost());
    Assert.assertEquals(1, attrs.size());
    NodeAttribute na = attrs.keySet().iterator().next();
    Assert.assertEquals(""host"", na.getAttributeKey().getAttributeName());
    Assert.assertEquals(""host2"", na.getAttributeValue());
    Assert.assertEquals(NodeAttributeType.STRING, na.getAttributeType());


    // Send another HB to RM with updated node atrribute
    nodeAttributes.clear();
    nodeAttributes.add(NodeAttribute.newInstance(
        NodeAttribute.PREFIX_DISTRIBUTED, ""host"",
        NodeAttributeType.STRING, ""host3""));
    nodeStatusObject = getNodeStatusObject(nodeId);
    nodeStatusObject.setResponseId(++responseId);
    heartbeatReq.setNodeStatus(nodeStatusObject);
    heartbeatReq.setNodeAttributes(nodeAttributes);
    resourceTrackerService.nodeHeartbeat(heartbeatReq);

    // Make sure RM gets the updated attribute
    attrs = attributeManager.getAttributesForNode(nodeId.getHost());
    Assert.assertEquals(1, attrs.size());
    na = attrs.keySet().iterator().next();
    Assert.assertEquals(""host"", na.getAttributeKey().getAttributeName());
    Assert.assertEquals(""host3"", na.getAttributeValue());
    Assert.assertEquals(NodeAttributeType.STRING, na.getAttributeType());
  }",Eager Test
"@Test
  public void testNodeRegistrationWithInvalidLabels() throws Exception {
    writeToHostsFile(""host2"");
    Configuration conf = new Configuration();
    conf.set(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH,
        hostFile.getAbsolutePath());
    conf.set(YarnConfiguration.NODELABEL_CONFIGURATION_TYPE,
        YarnConfiguration.DISTRIBUTED_NODELABEL_CONFIGURATION_TYPE);

    final RMNodeLabelsManager nodeLabelsMgr = new NullRMNodeLabelsManager();

    rm = new MockRM(conf) {
      @Override
      protected RMNodeLabelsManager createNodeLabelManager() {
        return nodeLabelsMgr;
      }",Eager Test
"@Test
  public void testNodeRemovalGracefully() throws Exception {
    testNodeRemovalUtil(true);
    testNodeRemovalUtilLost(true);
    testNodeRemovalUtilRebooted(true);
    testNodeRemovalUtilUnhealthy(true);
  }",No Smells
"@Test
  public void testResponseIdOverflow() throws Exception {
    Configuration conf = new Configuration();
    rm = new MockRM(conf);
    rm.start();

    MockNM nm1 = rm.registerNode(""host1:1234"", 5120);

    NodeHeartbeatResponse nodeHeartbeat = nm1.nodeHeartbeat(true);
    Assert.assertEquals(NodeAction.NORMAL, nodeHeartbeat.getNodeAction());

    // prepare the responseId that's about to overflow
    RMNode node = rm.getRMContext().getRMNodes().get(nm1.getNodeId());
    node.getLastNodeHeartBeatResponse().setResponseId(Integer.MAX_VALUE);

    nm1.setResponseId(Integer.MAX_VALUE);

    // heartbeat twice and check responseId
    nodeHeartbeat = nm1.nodeHeartbeat(true);
    Assert.assertEquals(NodeAction.NORMAL, nodeHeartbeat.getNodeAction());
    Assert.assertEquals(0, nodeHeartbeat.getResponseId());

    nodeHeartbeat = nm1.nodeHeartbeat(true);
    Assert.assertEquals(NodeAction.NORMAL, nodeHeartbeat.getNodeAction());
    Assert.assertEquals(1, nodeHeartbeat.getResponseId());
  }",No Smells
"@Test
  public void testSetRMIdentifierInRegistration() throws Exception {

    Configuration conf = new Configuration();
    rm = new MockRM(conf);
    rm.start();

    MockNM nm = new MockNM(""host1:1234"", 5120, rm.getResourceTrackerService());
    RegisterNodeManagerResponse response = nm.registerNode();

    // Verify the RMIdentifier is correctly set in RegisterNodeManagerResponse
    Assert.assertEquals(ResourceManager.getClusterTimeStamp(),
      response.getRMIdentifier());
  }",No Smells
"@Test
  public void testUnhealthyNodeStatus() throws Exception {
    Configuration conf = new Configuration();
    conf.set(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH, hostFile
        .getAbsolutePath());

    rm = new MockRM(conf);
    rm.start();

    MockNM nm1 = rm.registerNode(""host1:1234"", 5120);
    Assert.assertEquals(0, ClusterMetrics.getMetrics().getUnhealthyNMs());
    // node healthy
    nm1.nodeHeartbeat(true);

    // node unhealthy
    nm1.nodeHeartbeat(false);
    checkUnhealthyNMCount(rm, nm1, true, 1);

    // node healthy again
    nm1.nodeHeartbeat(true);
    checkUnhealthyNMCount(rm, nm1, false, 0);
  }",Eager Test
"@Test  
  public void testKeyValLogFormat() throws Exception {
    StringBuilder actLog = new StringBuilder();
    StringBuilder expLog = new StringBuilder();
    // add the first k=v pair and check
    RMAuditLogger.start(Keys.USER, USER, actLog);
    expLog.append(""USER=test"");
    assertEquals(expLog.toString(), actLog.toString());

    // append another k1=v1 pair to already added k=v and test
    RMAuditLogger.add(Keys.OPERATION, OPERATION, actLog);
    expLog.append(""\tOPERATION=oper"");
    assertEquals(expLog.toString(), actLog.toString());

    // append another k1=null pair and test
    RMAuditLogger.add(Keys.APPID, (String)null, actLog);
    expLog.append(""\tAPPID=null"");
    assertEquals(expLog.toString(), actLog.toString());

    // now add the target and check of the final string
    RMAuditLogger.add(Keys.TARGET, TARGET, actLog);
    expLog.append(""\tTARGET=tgt"");
    assertEquals(expLog.toString(), actLog.toString());
  }",Eager Test
"@Test
  public void testValidateAndSplitUpdateResourceRequests() {
    List<UpdateContainerRequest> updateRequests = new ArrayList<>();
    int containerVersion = 10;
    int resource = 10;
    Resource maxAllocation = Resource.newInstance(resource, resource);

    UpdateContainerRequestPBImpl updateContainerRequestPBFail =
        new UpdateContainerRequestPBImpl();
    updateContainerRequestPBFail.setContainerVersion(containerVersion);
    updateContainerRequestPBFail
        .setCapability(Resource.newInstance(resource + 1, resource + 1));
    updateContainerRequestPBFail
        .setContainerId(Mockito.mock(ContainerId.class));

    ContainerId containerIdOk = Mockito.mock(ContainerId.class);
    Resource capabilityOk = Resource.newInstance(resource - 1, resource - 1);
    UpdateContainerRequestPBImpl updateContainerRequestPBOk =
        new UpdateContainerRequestPBImpl();
    updateContainerRequestPBOk.setContainerVersion(containerVersion);
    updateContainerRequestPBOk.setCapability(capabilityOk);
    updateContainerRequestPBOk.setContainerUpdateType(INCREASE_RESOURCE);
    updateContainerRequestPBOk.setContainerId(containerIdOk);

    updateRequests.add(updateContainerRequestPBOk);
    updateRequests.add(updateContainerRequestPBFail);

    Dispatcher dispatcher = Mockito.mock(Dispatcher.class);
    RMContext rmContext = Mockito.mock(RMContext.class);
    ResourceScheduler scheduler = Mockito.mock(ResourceScheduler.class);

    Mockito.when(rmContext.getScheduler()).thenReturn(scheduler);
    Mockito.when(rmContext.getDispatcher()).thenReturn(dispatcher);

    RMContainer rmContainer = Mockito.mock(RMContainer.class);
    Mockito.when(scheduler.getRMContainer(Mockito.any()))
        .thenReturn(rmContainer);
    Container container = Mockito.mock(Container.class);
    Mockito.when(container.getVersion()).thenReturn(containerVersion);
    Mockito.when(rmContainer.getContainer()).thenReturn(container);
    Mockito.when(scheduler.getNormalizedResource(capabilityOk, maxAllocation))
        .thenReturn(capabilityOk);

    AllocateRequest allocateRequest =
        AllocateRequest.newInstance(1, 0.5f, new ArrayList<ResourceRequest>(),
            new ArrayList<ContainerId>(), updateRequests, null);

    List<UpdateContainerError> updateErrors = new ArrayList<>();
    ContainerUpdates containerUpdates =
        RMServerUtils.validateAndSplitUpdateResourceRequests(rmContext,
            allocateRequest, maxAllocation, updateErrors);
    Assert.assertEquals(1, updateErrors.size());
    Assert.assertEquals(resource + 1, updateErrors.get(0)
        .getUpdateContainerRequest().getCapability().getMemorySize());
    Assert.assertEquals(resource + 1, updateErrors.get(0)
        .getUpdateContainerRequest().getCapability().getVirtualCores());
    Assert.assertEquals(RESOURCE_OUTSIDE_ALLOWED_RANGE,
        updateErrors.get(0).getReason());

    Assert.assertEquals(1, containerUpdates.getIncreaseRequests().size());
    UpdateContainerRequest increaseRequest =
        containerUpdates.getIncreaseRequests().get(0);
    Assert.assertEquals(capabilityOk.getVirtualCores(),
        increaseRequest.getCapability().getVirtualCores());
    Assert.assertEquals(capabilityOk.getMemorySize(),
        increaseRequest.getCapability().getMemorySize());
    Assert.assertEquals(containerIdOk, increaseRequest.getContainerId());
  }",Eager Test
"@Test
  public void testRequestWithEmptyStateQueries() {
    GetApplicationsRequest request = ApplicationsRequestBuilder.create()
        .withStatesQuery(Sets.newHashSet()).build();

    GetApplicationsRequest expectedRequest = getDefaultRequest();

    assertEquals(expectedRequest, request);
  }",No Smells
"@Test
  public void testRequestWithEmptyUserQuery() {
    GetApplicationsRequest request =
        ApplicationsRequestBuilder.create().withUserQuery("""").build();

    GetApplicationsRequest expectedRequest = getDefaultRequest();
    assertEquals(expectedRequest, request);
  }",No Smells
"@Test
  public void testRequestWithEmptywithStartedTimeEndQuery() {
    GetApplicationsRequest request =
        ApplicationsRequestBuilder.create().withStartedTimeEnd("""").build();

    GetApplicationsRequest expectedRequest = getDefaultRequest();
    assertEquals(expectedRequest, request);
  }",No Smells
"@Test
  public void testRequestWithNullApplicationTypesQuery() {
    GetApplicationsRequest request = ApplicationsRequestBuilder.create()
        .withApplicationTypes(null).build();
  }",No Smells
"@Test
  public void testRequestWithNullFinishedTimeEndQuery() {
    GetApplicationsRequest request =
        ApplicationsRequestBuilder.create().withFinishTimeEnd(null).build();

    GetApplicationsRequest expectedRequest = getDefaultRequest();
    assertEquals(expectedRequest, request);
  }",No Smells
"@Test
  public void testRequestWithNullLimitQuery() {
    GetApplicationsRequest request =
        ApplicationsRequestBuilder.create().withLimit(null).build();

    GetApplicationsRequest expectedRequest = getDefaultRequest();
    assertEquals(expectedRequest, request);
  }",No Smells
"@Test
  public void testRequestWithQueueQueryExistingQueue() {
    ResourceManager rm = mock(ResourceManager.class);
    GetApplicationsRequest request = ApplicationsRequestBuilder.create()
        .withQueueQuery(rm, ""queue1"").build();

    GetApplicationsRequest expectedRequest = getDefaultRequest();
    expectedRequest.setQueues(Sets.newHashSet(""queue1""));
    assertEquals(expectedRequest, request);
  }",No Smells
"@Test
  public void testRequestWithValidFinishedTimeBeginQuery() {
    GetApplicationsRequest request = ApplicationsRequestBuilder.create()
        .withFinishTimeBegin(""999"").build();

    GetApplicationsRequest expectedRequest = getDefaultRequest();
    expectedRequest.setFinishRange(999L, Long.MAX_VALUE);
    assertEquals(expectedRequest, request);
  }",No Smells
"@Test
  public void testRequestWithValidStateQueries() {
    GetApplicationsRequest request = ApplicationsRequestBuilder.create()
        .withStatesQuery(
            Sets.newHashSet(YarnApplicationState.NEW_SAVING.toString(),
                YarnApplicationState.NEW.toString()))
        .build();

    GetApplicationsRequest expectedRequest = getDefaultRequest();
    Set<String> appStates =
        Sets.newHashSet(YarnApplicationState.NEW_SAVING.toString(),
            YarnApplicationState.NEW.toString());
    Set<String> appStatesLowerCase = parseQueries(appStates, true);
    expectedRequest.setApplicationStates(appStatesLowerCase);

    assertEquals(expectedRequest, request);
  }",No Smells
"@Test
  public void testNodesBlockRenderForLostNodes() {
    NodesBlock nodesBlock = injector.getInstance(NodesBlock.class);
    nodesBlock.set(""node.state"", ""lost"");
    nodesBlock.render();
    PrintWriter writer = injector.getInstance(PrintWriter.class);
    WebAppTests.flushOutput(injector);

    Mockito.verify(writer,
        Mockito.times(numberOfActualTableHeaders + numberOfThInMetricsTable))
        .print(""<th"");
    Mockito.verify(writer, Mockito.times(numberOfThInMetricsTable))
        .print(""<td"");
  }",No Smells
"@Test public void testNodesPage() {
    // 10 nodes. Two of each type.
    final RMContext rmContext = mockRMContext(3, 2, 12, 8*GiB);
    Injector injector = WebAppTests.createMockInjector(RMContext.class,
        rmContext,
        new Module() {
      @Override
      public void configure(Binder binder) {
        try {
          binder.bind(ResourceManager.class).toInstance(mockRm(rmContext));
        }",No Smells
"@Test
  public void testDumpingSchedulerLogs() throws Exception {

    ResourceManager mockRM = mock(ResourceManager.class);
    Configuration conf = new YarnConfiguration();
    HttpServletRequest mockHsr = mockHttpServletRequestByUserName(""non-admin"");
    ApplicationACLsManager aclsManager = new ApplicationACLsManager(conf);
    when(mockRM.getApplicationACLsManager()).thenReturn(aclsManager);
    RMWebServices webSvc =
        new RMWebServices(mockRM, conf, mock(HttpServletResponse.class));

    // nothing should happen
    webSvc.dumpSchedulerLogs(""1"", mockHsr);
    waitforLogDump(50);
    checkSchedulerLogFileAndCleanup();

    conf.setBoolean(YarnConfiguration.YARN_ACL_ENABLE, true);
    conf.setStrings(YarnConfiguration.YARN_ADMIN_ACL, ""admin"");
    aclsManager = new ApplicationACLsManager(conf);
    when(mockRM.getApplicationACLsManager()).thenReturn(aclsManager);
    webSvc = new RMWebServices(mockRM, conf, mock(HttpServletResponse.class));
    boolean exceptionThrown = false;
    try {
      webSvc.dumpSchedulerLogs(""1"", mockHsr);
      fail(""Dumping logs should fail"");
    }",Eager Test + Mystery Guest
"@Test
  public void testRouterClientRMServiceE2E() throws Exception {

    String user = ""test1"";

    LOG.info(""testRouterClientRMServiceE2E - Get New Application"");

    GetNewApplicationResponse responseGetNewApp = getNewApplication(user);
    Assert.assertNotNull(responseGetNewApp);

    LOG.info(""testRouterClientRMServiceE2E - Submit Application"");

    SubmitApplicationResponse responseSubmitApp =
        submitApplication(responseGetNewApp.getApplicationId(), user);
    Assert.assertNotNull(responseSubmitApp);

    LOG.info(""testRouterClientRMServiceE2E - Get Cluster Metrics"");

    GetClusterMetricsResponse responseGetClusterMetrics =
        getClusterMetrics(user);
    Assert.assertNotNull(responseGetClusterMetrics);

    LOG.info(""testRouterClientRMServiceE2E - Get Cluster Nodes"");

    GetClusterNodesResponse responseGetClusterNodes = getClusterNodes(user);
    Assert.assertNotNull(responseGetClusterNodes);

    LOG.info(""testRouterClientRMServiceE2E - Get Queue Info"");

    GetQueueInfoResponse responseGetQueueInfo = getQueueInfo(user);
    Assert.assertNotNull(responseGetQueueInfo);

    LOG.info(""testRouterClientRMServiceE2E - Get Queue User"");

    GetQueueUserAclsInfoResponse responseGetQueueUser = getQueueUserAcls(user);
    Assert.assertNotNull(responseGetQueueUser);

    LOG.info(""testRouterClientRMServiceE2E - Get Cluster Node"");

    GetClusterNodeLabelsResponse responseGetClusterNode =
        getClusterNodeLabels(user);
    Assert.assertNotNull(responseGetClusterNode);

    LOG.info(""testRouterClientRMServiceE2E - Move Application Across Queues"");

    MoveApplicationAcrossQueuesResponse responseMoveApp =
        moveApplicationAcrossQueues(user, responseGetNewApp.getApplicationId());
    Assert.assertNotNull(responseMoveApp);

    LOG.info(""testRouterClientRMServiceE2E - Get New Reservation"");

    GetNewReservationResponse getNewReservationResponse =
        getNewReservation(user);

    LOG.info(""testRouterClientRMServiceE2E - Submit Reservation"");

    ReservationSubmissionResponse responseSubmitReser =
        submitReservation(user, getNewReservationResponse.getReservationId());
    Assert.assertNotNull(responseSubmitReser);

    LOG.info(""testRouterClientRMServiceE2E - Update Reservation"");

    ReservationUpdateResponse responseUpdateReser =
        updateReservation(user, getNewReservationResponse.getReservationId());
    Assert.assertNotNull(responseUpdateReser);

    LOG.info(""testRouterClientRMServiceE2E - Delete Reservation"");

    ReservationDeleteResponse responseDeleteReser =
        deleteReservation(user, getNewReservationResponse.getReservationId());
    Assert.assertNotNull(responseDeleteReser);

    LOG.info(""testRouterClientRMServiceE2E - Kill Application"");

    KillApplicationResponse responseKillApp =
        forceKillApplication(responseGetNewApp.getApplicationId(), user);
    Assert.assertNotNull(responseKillApp);
  }",Eager Test
"@Test
  public void testAppsFailedCreated() {

    long totalBadbefore = metrics.getAppsFailedCreated();

    badSubCluster.getNewApplication();

    Assert.assertEquals(totalBadbefore + 1, metrics.getAppsFailedCreated());
  }",No Smells
"@Test
  public void testAppsFailedSubmitted() {

    long totalBadbefore = metrics.getAppsFailedSubmitted();

    badSubCluster.submitApplication();

    Assert.assertEquals(totalBadbefore + 1, metrics.getAppsFailedSubmitted());
  }",No Smells
"@Test
  public void testAppsReportFailed() {

    long totalBadbefore = metrics.getAppsFailedRetrieved();

    badSubCluster.getApplicationReport();

    Assert.assertEquals(totalBadbefore + 1, metrics.getAppsFailedRetrieved());
  }",No Smells
"@Test
  public void testSucceededAppsKilled() {

    long totalGoodBefore = metrics.getNumSucceededAppsKilled();

    goodSubCluster.forceKillApplication(100);

    Assert.assertEquals(totalGoodBefore + 1,
        metrics.getNumSucceededAppsKilled());
    Assert.assertEquals(100, metrics.getLatencySucceededAppsKilled(), 0);

    goodSubCluster.forceKillApplication(200);

    Assert.assertEquals(totalGoodBefore + 2,
        metrics.getNumSucceededAppsKilled());
    Assert.assertEquals(150, metrics.getLatencySucceededAppsKilled(), 0);
  }",No Smells
"@Test
  public void testSucceededAppsSubmitted() {

    long totalGoodBefore = metrics.getNumSucceededAppsSubmitted();

    goodSubCluster.submitApplication(100);

    Assert.assertEquals(totalGoodBefore + 1,
        metrics.getNumSucceededAppsSubmitted());
    Assert.assertEquals(100, metrics.getLatencySucceededAppsSubmitted(), 0);

    goodSubCluster.submitApplication(200);

    Assert.assertEquals(totalGoodBefore + 2,
        metrics.getNumSucceededAppsSubmitted());
    Assert.assertEquals(150, metrics.getLatencySucceededAppsSubmitted(), 0);
  }",No Smells
"@Test
  public void testGetApplicationWrongFormat() {

    AppInfo response = interceptor.getApp(null, ""Application_wrong_id"", null);

    Assert.assertNull(response);
  }",No Smells
"@Test
  public void testGetClusterMetrics() {

    ClusterMetricsInfo responseGet = interceptor.getClusterMetricsInfo();

    Assert.assertNotNull(responseGet);
    int expectedAppSubmitted = 0;
    for (int i = 0; i < NUM_SUBCLUSTER; i++) {
      expectedAppSubmitted += i;
    }",Eager Test
"@Test
  public void testMerge4DifferentApps() {

    AppsInfo apps = new AppsInfo();
    int value = 1000;

    AppInfo app1 = new AppInfo();
    app1.setAppId(APPID1.toString());
    app1.setAMHostHttpAddress(""http://i_am_the_AM1:1234"");
    app1.setState(YarnApplicationState.FINISHED);
    app1.setNumAMContainerPreempted(value);
    apps.add(app1);

    AppInfo app2 = new AppInfo();
    app2.setAppId(APPID2.toString());
    app2.setAMHostHttpAddress(""http://i_am_the_AM2:1234"");
    app2.setState(YarnApplicationState.ACCEPTED);
    app2.setAllocatedVCores(2 * value);

    apps.add(app2);

    AppInfo app3 = new AppInfo();
    app3.setAppId(APPID3.toString());
    app3.setAMHostHttpAddress(""http://i_am_the_AM3:1234"");
    app3.setState(YarnApplicationState.RUNNING);
    app3.setReservedMB(3 * value);
    apps.add(app3);

    AppInfo app4 = new AppInfo();
    app4.setAppId(APPID4.toString());
    app4.setAMHostHttpAddress(""http://i_am_the_AM4:1234"");
    app4.setState(YarnApplicationState.NEW);
    app4.setAllocatedMB(4 * value);
    apps.add(app4);

    AppsInfo result = RouterWebServiceUtil.mergeAppsInfo(apps.getApps(), false);
    Assert.assertNotNull(result);
    Assert.assertEquals(4, result.getApps().size());

    List<String> appIds = new ArrayList<String>();
    AppInfo appInfo1 = null, appInfo2 = null, appInfo3 = null, appInfo4 = null;
    for (AppInfo app : result.getApps()) {
      appIds.add(app.getAppId());
      if (app.getAppId().equals(APPID1.toString())) {
        appInfo1 = app;
      }",Eager Test
"@Test
  public void testMergeAppsRunning() {

    AppsInfo apps = new AppsInfo();

    String amHost = ""http://i_am_the_AM2:1234"";
    AppInfo am = new AppInfo();
    am.setAppId(APPID2.toString());
    am.setAMHostHttpAddress(amHost);
    am.setState(YarnApplicationState.RUNNING);

    int value = 1000;
    setAppInfoRunning(am, value);

    apps.add(am);

    AppInfo uam1 = new AppInfo();
    uam1.setAppId(APPID2.toString());
    uam1.setState(YarnApplicationState.RUNNING);
    apps.add(uam1);

    setAppInfoRunning(uam1, value);

    AppInfo uam2 = new AppInfo();
    uam2.setAppId(APPID2.toString());
    uam2.setState(YarnApplicationState.RUNNING);
    apps.add(uam2);

    setAppInfoRunning(uam2, value);

    // in this case the result does not change if we enable partial result
    AppsInfo result = RouterWebServiceUtil.mergeAppsInfo(apps.getApps(), false);
    Assert.assertNotNull(result);
    Assert.assertEquals(1, result.getApps().size());

    AppInfo app = result.getApps().get(0);

    Assert.assertEquals(APPID2.toString(), app.getAppId());
    Assert.assertEquals(amHost, app.getAMHostHttpAddress());
    Assert.assertEquals(value * 3, app.getAllocatedMB());
    Assert.assertEquals(value * 3, app.getAllocatedVCores());
    Assert.assertEquals(value * 3, app.getReservedMB());
    Assert.assertEquals(value * 3, app.getReservedVCores());
    Assert.assertEquals(value * 3, app.getRunningContainers());
    Assert.assertEquals(value * 3, app.getMemorySeconds());
    Assert.assertEquals(value * 3, app.getVcoreSeconds());
    Assert.assertEquals(3, app.getResourceRequests().size());
  }",No Smells
"@Test
  public void testMergeMetrics() {
    ClusterMetricsInfo metrics = new ClusterMetricsInfo();
    ClusterMetricsInfo metricsResponse = new ClusterMetricsInfo();

    long seed = System.currentTimeMillis();
    setUpClusterMetrics(metrics, seed);
    // ensure that we don't reuse the same seed when setting up metricsResponse
    // or it might mask bugs
    seed += 1000000000;
    setUpClusterMetrics(metricsResponse, seed);
    ClusterMetricsInfo metricsClone = createClusterMetricsClone(metrics);
    RouterWebServiceUtil.mergeMetrics(metrics, metricsResponse);

    Assert.assertEquals(
        metricsResponse.getAppsSubmitted() + metricsClone.getAppsSubmitted(),
        metrics.getAppsSubmitted());
    Assert.assertEquals(
        metricsResponse.getAppsCompleted() + metricsClone.getAppsCompleted(),
        metrics.getAppsCompleted());
    Assert.assertEquals(
        metricsResponse.getAppsPending() + metricsClone.getAppsPending(),
        metrics.getAppsPending());
    Assert.assertEquals(
        metricsResponse.getAppsRunning() + metricsClone.getAppsRunning(),
        metrics.getAppsRunning());
    Assert.assertEquals(
        metricsResponse.getAppsFailed() + metricsClone.getAppsFailed(),
        metrics.getAppsFailed());
    Assert.assertEquals(
        metricsResponse.getAppsKilled() + metricsClone.getAppsKilled(),
        metrics.getAppsKilled());

    Assert.assertEquals(
        metricsResponse.getReservedMB() + metricsClone.getReservedMB(),
        metrics.getReservedMB());
    Assert.assertEquals(
        metricsResponse.getAvailableMB() + metricsClone.getAvailableMB(),
        metrics.getAvailableMB());
    Assert.assertEquals(
        metricsResponse.getAllocatedMB() + metricsClone.getAllocatedMB(),
        metrics.getAllocatedMB());

    Assert.assertEquals(
        metricsResponse.getReservedVirtualCores()
            + metricsClone.getReservedVirtualCores(),
        metrics.getReservedVirtualCores());
    Assert.assertEquals(
        metricsResponse.getAvailableVirtualCores()
            + metricsClone.getAvailableVirtualCores(),
        metrics.getAvailableVirtualCores());
    Assert.assertEquals(
        metricsResponse.getAllocatedVirtualCores()
            + metricsClone.getAllocatedVirtualCores(),
        metrics.getAllocatedVirtualCores());

    Assert.assertEquals(
        metricsResponse.getContainersAllocated()
            + metricsClone.getContainersAllocated(),
        metrics.getContainersAllocated());
    Assert.assertEquals(
        metricsResponse.getReservedContainers()
            + metricsClone.getReservedContainers(),
        metrics.getReservedContainers());
    Assert.assertEquals(
        metricsResponse.getPendingContainers()
            + metricsClone.getPendingContainers(),
        metrics.getPendingContainers());

    Assert.assertEquals(
        metricsResponse.getTotalMB() + metricsClone.getTotalMB(),
        metrics.getTotalMB());
    Assert.assertEquals(
        metricsResponse.getUtilizedMB() + metricsClone.getUtilizedMB(),
        metrics.getUtilizedMB());
    Assert.assertEquals(
        metricsResponse.getTotalVirtualCores()
            + metricsClone.getTotalVirtualCores(),
        metrics.getTotalVirtualCores());
    Assert.assertEquals(
        metricsResponse.getUtilizedVirtualCores() + metricsClone.getUtilizedVirtualCores(),
        metrics.getUtilizedVirtualCores());
    Assert.assertEquals(
        metricsResponse.getTotalNodes() + metricsClone.getTotalNodes(),
        metrics.getTotalNodes());
    Assert.assertEquals(
        metricsResponse.getLostNodes() + metricsClone.getLostNodes(),
        metrics.getLostNodes());
    Assert.assertEquals(
        metricsResponse.getUnhealthyNodes() + metricsClone.getUnhealthyNodes(),
        metrics.getUnhealthyNodes());
    Assert.assertEquals(
        metricsResponse.getDecommissioningNodes()
            + metricsClone.getDecommissioningNodes(),
        metrics.getDecommissioningNodes());
    Assert.assertEquals(
        metricsResponse.getDecommissionedNodes()
            + metricsClone.getDecommissionedNodes(),
        metrics.getDecommissionedNodes());
    Assert.assertEquals(
        metricsResponse.getRebootedNodes() + metricsClone.getRebootedNodes(),
        metrics.getRebootedNodes());
    Assert.assertEquals(
        metricsResponse.getActiveNodes() + metricsClone.getActiveNodes(),
        metrics.getActiveNodes());
    Assert.assertEquals(
        metricsResponse.getShutdownNodes() + metricsClone.getShutdownNodes(),
        metrics.getShutdownNodes());
  }",No Smells
"@Test
  public void testMergeUAM() {

    AppsInfo apps = new AppsInfo();

    AppInfo app1 = new AppInfo();
    app1.setAppId(APPID1.toString());
    app1.setName(""Test"");
    apps.add(app1);

    // in this case the result does not change if we enable partial result
    AppsInfo result = RouterWebServiceUtil.mergeAppsInfo(apps.getApps(), false);
    Assert.assertNotNull(result);
    Assert.assertEquals(1, result.getApps().size());
  }",No Smells
"@Test
  public void testGetDomain() throws IOException {
    super.testGetDomain();
  }",No Smells
"@Test
  public void testGetEntities() throws IOException {
    super.testGetEntities();
  }",No Smells
"@Test
  public void testGetEntitiesWithPrimaryFilters() throws IOException {
    super.testGetEntitiesWithPrimaryFilters();
  }",No Smells
"@Test
  public void testGetEntitiesWithSecondaryFilters() throws IOException {
    super.testGetEntitiesWithSecondaryFilters();
  }",No Smells
"@Test
  public void testGetEntitiesWithPrimaryFilters() throws IOException {
    super.testGetEntitiesWithPrimaryFilters();
  }",Eager Test
"@Test
  public void testGetSingleEntity() throws IOException {
    super.testGetSingleEntity();
  }",No Smells
"@Test
  public void testGetEntitiesWithFromId() throws IOException {
    super.testGetEntitiesWithFromId();
  }",No Smells
"@Test
  public void testGetEntitiesWithFromTs() throws IOException {
    // feature not supported
  }",No Smells
"@Test
  public void testGetEntitiesWithPrimaryFilters() throws IOException {
    super.testGetEntitiesWithPrimaryFilters();
  }",No Smells
"@Test
  public void testGetEntitiesWithSecondaryFilters() throws IOException {
    super.testGetEntitiesWithSecondaryFilters();
  }",No Smells
"@Test
  public void testActionCompInstanceUpgrade() throws Exception {
    Service service = createService();
    MockServiceClient client = MockServiceClient.create(rule, service, true);

    //upgrade the service
    service.setVersion(""v2"");
    client.initiateUpgrade(service);

    //add containers to the component that needs to be upgraded.
    Component comp = service.getComponents().iterator().next();
    ContainerId containerId = ContainerId.newContainerId(client.attemptId, 1L);
    comp.addContainer(new Container().id(containerId.toString()));

    client.actionUpgrade(service, comp.getContainers());
    CompInstancesUpgradeResponseProto response = client.getLastProxyResponse(
        CompInstancesUpgradeResponseProto.class);
    Assert.assertNotNull(""upgrade did not complete"", response);
    client.stop();
  }",No Smells
"@Test
  public void testActionServiceUpgrade() throws Exception {
    Service service = createService();
    ServiceClient client = MockServiceClient.create(rule, service, true);

    //upgrade the service
    service.setVersion(""v2"");
    client.initiateUpgrade(service);

    Service fromFs = ServiceApiUtil.loadServiceUpgrade(rule.getFs(),
        service.getName(), service.getVersion());
    Assert.assertEquals(service.getName(), fromFs.getName());
    Assert.assertEquals(service.getVersion(), fromFs.getVersion());
    client.stop();
  }",Eager Test
"@Test
  public void testCancelNothingToUpgrade() throws Exception {
    ServiceContext context = TestComponent.createTestContext(rule,
        ""testCancelUpgradeWhenContainerReady"");
    Component component = context.scheduler.getAllComponents().entrySet()
        .iterator().next().getValue();
    cancelCompUpgrade(component);

    ComponentInstance instance = component.getAllComponentInstances().iterator()
        .next();

    ComponentInstanceEvent cancelEvent = new ComponentInstanceEvent(
        instance.getContainer().getId(),
        ComponentInstanceEventType.CANCEL_UPGRADE);
    instance.handle(cancelEvent);

    Assert.assertEquals(""instance not ready"", ContainerState.READY,
        component.getComponentSpec().getContainer(instance.getContainer()
            .getId().toString()).getState());
  }",Eager Test
"@Test
  public void testContainerUpgrade() throws Exception {
    ServiceContext context = TestComponent.createTestContext(rule,
        ""testContainerUpgrade"");
    Component component = context.scheduler.getAllComponents().entrySet()
        .iterator().next().getValue();
    upgradeComponent(component);

    ComponentInstance instance = component.getAllComponentInstances().iterator()
        .next();
    ComponentInstanceEvent instanceEvent = new ComponentInstanceEvent(
        instance.getContainer().getId(), ComponentInstanceEventType.UPGRADE);
    instance.handle(instanceEvent);
    Container containerSpec = component.getComponentSpec().getContainer(
        instance.getContainer().getId().toString());
    Assert.assertEquals(""instance not upgrading"", ContainerState.UPGRADING,
        containerSpec.getState());
  }",Eager Test
"@Test
  public void testComponentDependency() throws Exception{
    ApplicationId applicationId = ApplicationId.newInstance(123456, 1);
    Service exampleApp = new Service();
    exampleApp.setVersion(""v1"");
    exampleApp.setId(applicationId.toString());
    exampleApp.setName(""testComponentDependency"");
    exampleApp.addComponent(createComponent(""compa"", 1, ""sleep 1000""));
    // Let compb depends on compa;
    Component compb = createComponent(""compb"", 1, ""sleep 1000"", Component
        .RestartPolicyEnum.ON_FAILURE, Collections.singletonList(""compa""));
    // Let compb depends on compb;
    Component compc = createComponent(""compc"", 1, ""sleep 1000"", Component
        .RestartPolicyEnum.NEVER, Collections.singletonList(""compb""));

    exampleApp.addComponent(compb);
    exampleApp.addComponent(compc);

    MockServiceAM am = new MockServiceAM(exampleApp);
    am.init(conf);
    am.start();

    // compa ready
    Assert.assertTrue(am.getComponent(""compa"").areDependenciesReady());
    //compb not ready
    Assert.assertFalse(am.getComponent(""compb"").areDependenciesReady());

    // feed 1 container to compa,
    am.feedContainerToComp(exampleApp, 1, ""compa"");
    // waiting for compb's dependencies are satisfied
    am.waitForDependenciesSatisfied(""compb"");

    // feed 1 container to compb,
    am.feedContainerToComp(exampleApp, 2, ""compb"");
    // waiting for compc's dependencies are satisfied
    am.waitForDependenciesSatisfied(""compc"");

    // feed 1 container to compb
    am.feedContainerToComp(exampleApp, 2, ""compb"");
    am.flexComponent(""compa"", 2);
    am.waitForNumDesiredContainers(""compa"", 2);

    // compb dependencies not satisfied again.
    Assert.assertFalse(am.getComponent(""compb"").areDependenciesReady());
    am.stop();
  }",Eager Test + Mystery Guest
"@Test
  public void testBuildContainerLaunchCommand() throws Exception {
    AbstractProviderService providerService = new DockerProviderService();
    Component component = serviceContext.scheduler.getAllComponents().entrySet()
        .iterator().next().getValue();
    ContainerLaunchService.ComponentLaunchContext clc =
        createEntryPointCLCFor(testService, component, ""sleep,9000"");

    ComponentInstance instance = component.getAllComponentInstances().iterator()
        .next();
    Container container = mock(Container.class);
    providerService.buildContainerLaunchCommand(launcher, testService, instance,
        rule.getFs(), serviceContext.scheduler.getConfig(), container, clc,
        null);

    Assert.assertEquals(""commands"", Lists.newArrayList(clc.getLaunchCommand()),
        launcher.getCommands());
  }",Eager Test
"@Test
  public void testDockerFactory() throws Throwable {
    ProviderFactory factory = ProviderFactory
        .createServiceProviderFactory(new Artifact().type(TypeEnum.DOCKER));
    assertTrue(factory instanceof DockerProviderFactory);
    assertTrue(factory.createClientProvider() instanceof DockerClientProvider);
    assertTrue(factory.createServerProvider() instanceof DockerProviderService);
    assertTrue(ProviderFactory.getProviderService(new Artifact()
        .type(TypeEnum.DOCKER)) instanceof DockerProviderService);
  }",No Smells
"@Test
  public void testExternalComponent() throws IOException {
    Service ext = createValidApplication(""comp1"");
    SliderFileSystem sfs = ServiceTestUtils.initMockFs(ext);

    Service app = createValidApplication(""comp2"");
    Artifact artifact = new Artifact();
    artifact.setType(Artifact.TypeEnum.SERVICE);
    artifact.setId(""id"");
    app.setArtifact(artifact);

    try {
      ServiceApiUtil.validateAndResolveService(app, sfs, CONF_DNS_ENABLED);
    }",Eager Test
"@Test
  public void testInvalidComponent() throws IOException {
    SliderFileSystem sfs = ServiceTestUtils.initMockFs();
    testComponent(sfs);
  }",No Smells
"@Test
  public void testResolveCompsCircularDependency() {
    Service service = createExampleApplication();
    List<String> dependencies = new ArrayList<String>();
    List<String> dependencies2 = new ArrayList<String>();
    dependencies.add(""compb"");
    dependencies2.add(""compa"");
    Component compa = createComponent(""compa"");
    compa.setDependencies(dependencies);
    Component compb = createComponent(""compb"");
    compa.setDependencies(dependencies2);
    service.addComponent(compa);
    service.addComponent(compb);
    List<String> order = ServiceApiUtil.resolveCompsDependency(service);
    List<String> expected = new ArrayList<String>();
    expected.add(""compa"");
    expected.add(""compb"");
    for (int i = 0; i < expected.size(); i++) {
      Assert.assertEquals(""Components are not equal."", expected.get(i),
          order.get(i));
    }",Eager Test
"@Test
  public void testServiceDependencies() {
    Thread thread = new Thread() {
      @Override
      public void run() {
        Service service = createExampleApplication();
        Component compa = createComponent(""compa"");
        Component compb = createComponent(""compb"");
        service.addComponent(compa);
        service.addComponent(compb);
        List<String> dependencies = new ArrayList<String>();
        dependencies.add(""abc"");
        service.setDependencies(dependencies);
        Service dependent = createExampleApplication();
        dependent.setState(ServiceState.STOPPED);
        ServiceApiUtil.checkServiceDependencySatisified(service);
      }",Eager Test
"@Test
  public void testAMSimulatorWithNodeLabels() throws Exception {
    if (scheduler.equals(CapacityScheduler.class)) {
      // add label to the cluster
      RMAdminCLI rmAdminCLI = new RMAdminCLI(conf);
      String[] args = {""-addToClusterNodeLabels"", ""label1""}",Eager Test
"@Test
  public void testMultiTask() throws Exception {
    runner.start();
    runner.schedule(new MultiTask(0, 20, 5));
    MultiTask.latch.await(5000, TimeUnit.MILLISECONDS);
    Assert.assertTrue(MultiTask.first);
    Assert.assertEquals((20 - 0) / 5 - 2 + 1, MultiTask.middle);
    Assert.assertTrue(MultiTask.last);
  }",No Smells
"@Test
  public void testSingleTask() throws Exception {
    runner.start();
    runner.schedule(new SingleTask(0));
    SingleTask.latch.await(5000, TimeUnit.MILLISECONDS);
    Assert.assertTrue(SingleTask.first);
  }",No Smells
"@Test
  public void testGetRackHostname() {
    String str = ""/rack1/node1"";
    String[] rackHostname = SLSUtils.getRackHostName(str);
    Assert.assertEquals(""rack1"", rackHostname[0]);
    Assert.assertEquals(""node1"", rackHostname[1]);

    str = ""/rackA/rackB/node1"";
    rackHostname = SLSUtils.getRackHostName(str);
    Assert.assertEquals(""rackA/rackB"", rackHostname[0]);
    Assert.assertEquals(""node1"", rackHostname[1]);
  }",No Smells
"@Test
  public void testTrackPageHtmlTemplate() throws Exception {
    String trackTemplate = FileUtils.readFileToString(
            new File(""src/main/html/track.html.template""), StandardCharsets.UTF_8);
    String trackedQueueInfo = """";
    Set<String> trackedQueues = new HashSet<String>();
    trackedQueues.add(""sls_queue_1"");
    trackedQueues.add(""sls_queue_2"");
    trackedQueues.add(""sls_queue_3"");
    for(String queue : trackedQueues) {
      trackedQueueInfo += ""<option value='Queue "" + queue + ""'>""
              + queue + ""</option>"";
    }",Eager Test + Mystery Guest
"@Test
    public void testLookupURIWithLimitAndTags() throws Exception {
        decoder = new HttpRequestDecoder(authenticationService, requireUserSecurity, httpProperties);
        DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET,
                        ""/api/search/lookup?m=sys.cpu.user{host=*}",No Smells
"@Test
    public void testQueryPostGlobalAnnotations() throws Exception {
    // @formatter:off
        String content = """" +
        ""{""
        + ""\""start\"":1447767369171,""
        + ""\""queries\"":""
        +  ""[""
        +   ""{""
        +      ""\""metric\"":\""sys.cpu.user\"",""
        +      ""\""aggregator\"":\""sum\"",""
        +      ""\""downsample\"":\""30s-avg\""""
        +   ""}",No Smells
"@Test
    public void testSuggestURIWithValidTypeNoSession() throws Exception {
        decoder = new HttpRequestDecoder(authenticationService, requireUserSecurity, httpProperties);
        DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, ""/api/suggest?type=metrics"");
        decoder.decode(null, request, results);
        Assert.assertEquals(1, results.size());
        Object o = results.get(0);
        Assert.assertTrue(o instanceof TimelyException);
    }",No Smells
"@Test
    public void testVersionPost() throws Exception {
        decoder = new HttpRequestDecoder(authenticationService, requireUserSecurity, httpProperties);
        DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, ""/version"");
        decoder.decode(null, request, results);
        Assert.assertEquals(1, results.size());
        Assert.assertEquals(VersionRequest.class, results.iterator().next().getClass());
    }",No Smells
"@Test
    public void testCreateSubscriptionWithInvalidSessionIdAndNonAnonymousAccess() throws Exception {
        ctx.channel().attr(SubscriptionConstants.SESSION_ID_ATTR).set(URLEncoder.encode(UUID.randomUUID().toString(), StandardCharsets.UTF_8.name()));
        decoder = new WebSocketRequestDecoder(authenticationService, requireUserSecurity);
    // @formatter:off
        String request = ""{ ""+
          ""\""operation\"" : \""create\"", "" +
          ""\""subscriptionId\"" : \""1234\"""" +
        "" }",Eager Test
"@Test
    public void testCreateSubscriptionWithValidSessionIdAndNonAnonymousAccess() throws Exception {
        ctx.channel().attr(SubscriptionConstants.SESSION_ID_ATTR).set(cookie);
        decoder = new WebSocketRequestDecoder(authenticationService, requireUserSecurity);
    // @formatter:off
        String request = ""{ "" +
          ""\""operation\"" : \""create\"","" +
          ""\""subscriptionId\"" : \"""" + cookie + ""\"""" +
        ""}",Eager Test
"@Test
    public void testMetrics() throws Exception {
        decoder = new WebSocketRequestDecoder(authenticationService, anonymousSecurity);
        String request = ""{ \""operation\"" : \""metrics\"", \""sessionId\"" : \""1234\"" }",Eager Test
"@Test
    public void testRemoveSubscription() throws Exception {
        decoder = new WebSocketRequestDecoder(authenticationService, anonymousSecurity);
        String request = ""{ \""operation\"" : \""remove\"", \""subscriptionId\"" : \""1234\"" }",Eager Test
