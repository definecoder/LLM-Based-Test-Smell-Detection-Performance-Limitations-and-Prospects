App,TestFilePath,ProductionFilePath,TestFileCode,ProductionFileCode,present_smells,found_smells,false_positive,false_negative,true_positive,true_negative
9727_27.0_querydsl_roojpaentity,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/9727_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/9727_actual.java,"package com.querydsl.apt.domain;

import static org.junit.Assert.assertNotNull;

import org.junit.Test;

public class RooEntitiesTest {

    @Test
    public void rooJpaEntity() {
        assertNotNull(QRooEntities_MyEntity.myEntity);
    }

    @Test
    public void rooJpaActiveRecord() {
        assertNotNull(QRooEntities_MyEntity2.myEntity2);
    }

}
","package com.querydsl.apt.domain;

import javax.persistence.Id;
import javax.persistence.ManyToOne;

import org.springframework.roo.addon.jpa.activerecord.RooJpaActiveRecord;
import org.springframework.roo.addon.jpa.entity.RooJpaEntity;

public class RooEntities {

    @RooJpaEntity
    public static class MyEntity {

        @Id
        Long id;

        String name;

        @ManyToOne
        MyEntity entity;
    }

    @RooJpaActiveRecord
    public static class MyEntity2 {

        @Id
        Long id;

        String name;

        @ManyToOne
        MyEntity entity;
    }

}
",[],[],0,0,0,17
43482_17.0_fastjson_test_for_issue,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/43482_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/43482_actual.java,"package com.alibaba.json.bvt.bug;

import org.junit.Assert;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Issue89 extends TestCase {

    public void test_for_issue() throws Exception {
        Exception error = null;
        try {
            JSON.parse(""{\""a\"":з」∠)_,\""}"");
        } catch (Exception ex) {
            error = ex;
        }
        Assert.assertNotNull(error);
    }
}
","package com.alibaba.json.bvt.bug;

import org.junit.Assert;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;

public class Issue89 extends TestCase {

    public void test_for_issue() throws Exception {
        Exception error = null;
        try {
            JSON.parse(""{\""a\"":з」∠)_,\""}"");
        } catch (Exception ex) {
            error = ex;
        }
        Assert.assertNotNull(error);
    }
}
",['Exception Catching Throwing'],['Exception Handling'],1,1,0,16
1905_47.0_rxjava2-extras_testsettotrue,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/1905_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/1905_actual.java,"package com.github.davidmoten.rx2;

import static org.junit.Assert.assertTrue;

import java.util.concurrent.atomic.AtomicBoolean;

import org.junit.Test;

import com.github.davidmoten.junit.Asserts;

public class ActionsTest {

    @Test
    public void testSetToTrue() throws Exception {
        AtomicBoolean b = new AtomicBoolean();
        Actions.setToTrue(b).run();
        assertTrue(b.get());
    }

    @Test
    public void testIsUtility() {
        Asserts.assertIsUtilityClass(Actions.class);
    }

}
","package com.github.davidmoten.rx2;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import io.reactivex.functions.Action;

public final class Actions {

    private Actions() {
        // prevent instantiation
    }

    public static Action setToTrue(final AtomicBoolean b) {
        return new Action() {

            @Override
            public void run() throws Exception {
                b.set(true);
            }

        };
    }

    public static Action throwing(final Exception e) {
        return new Action() {

            @Override
            public void run() throws Exception {
                throw e;
            }

        };
    }

    public static Action doNothing() {
        return DoNothingHolder.DO_NOTHING;
    }

    private static final class DoNothingHolder {
        static final Action DO_NOTHING = new Action() {
            @Override
            public void run() throws Exception {
                // do nothing!
            }
        };
    }

    public static Action increment(final AtomicInteger x) {
        //TODO make holder
        return new Action() {

            @Override
            public void run() throws Exception {
                x.incrementAndGet();
            }
        };
    }

}
",[],[],0,0,0,17
44330_17.0_fastjson_test_for_issue,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/44330_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/44330_actual.java,"package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.JSONObject;
import junit.framework.TestCase;

/**
 * Created by wenshao on 03/08/2017.
 */
public class Issue1362 extends TestCase {
    public void test_for_issue() throws Exception {
        JSONObject object = new JSONObject();
        object.put(""val"", ""null"");
        assertEquals(0D, object.getDoubleValue(""val""));
        assertEquals(0F, object.getFloatValue(""val""));
        assertEquals(0, object.getIntValue(""val""));
        assertEquals(0L, object.getLongValue(""val""));
        assertEquals((short) 0, object.getShortValue(""val""));
        assertEquals((byte) 0, object.getByteValue(""val""));
        assertEquals(false, object.getBooleanValue(""val""));
    }
}
","package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.JSONObject;
import junit.framework.TestCase;

/**
 * Created by wenshao on 03/08/2017.
 */
public class Issue1362 extends TestCase {
    public void test_for_issue() throws Exception {
        JSONObject object = new JSONObject();
        object.put(""val"", ""null"");
        assertEquals(0D, object.getDoubleValue(""val""));
        assertEquals(0F, object.getFloatValue(""val""));
        assertEquals(0, object.getIntValue(""val""));
        assertEquals(0L, object.getLongValue(""val""));
        assertEquals((short) 0, object.getShortValue(""val""));
        assertEquals((byte) 0, object.getByteValue(""val""));
        assertEquals(false, object.getBooleanValue(""val""));
    }
}
",['Assertion Roulette'],"['Assertion Roulette', 'Eager Test', 'Magic Number Test']",2,0,1,15
5657_49.0_dropwizard_testaccessors,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/5657_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/5657_actual.java,"package io.dropwizard.jersey.validation;

import jakarta.validation.ConstraintViolation;
import jakarta.ws.rs.core.Request;
import org.glassfish.jersey.process.Inflector;
import org.glassfish.jersey.server.model.Invocable;
import org.junit.jupiter.api.Test;

import java.util.Collections;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertSame;
import static org.mockito.Mockito.mock;

class JerseyViolationExceptionTest {

    @Test
    void testAccessors() {
        final Set<? extends ConstraintViolation<?>> violations = Collections.emptySet();

        @SuppressWarnings(""unchecked"")
        final Inflector<Request, ?> inf = mock(Inflector.class);
        final Invocable inv = Invocable.create(inf);
        final JerseyViolationException test = new JerseyViolationException(violations, inv);
        assertSame(inv, test.getInvocable());
    }
}
","package io.dropwizard.jersey.validation;

import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;
import org.glassfish.jersey.server.model.Invocable;

import java.util.Set;

/**
 * A {@link ConstraintViolationException} that occurs while Jersey is
 * validating constraints on a resource endpoint.
 */
public class JerseyViolationException extends ConstraintViolationException {
    private static final long serialVersionUID = -2084629736062306666L;
    private final Invocable invocable;

    public JerseyViolationException(Set<? extends ConstraintViolation<?>> constraintViolations, Invocable invocable) {
        super(constraintViolations);
        this.invocable = invocable;
    }

    public Invocable getInvocable() {
        return invocable;
    }
}
",[],[],0,0,0,17
44472_17.0_fastjson_test_root,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/44472_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/44472_actual.java,"package com.alibaba.json.bvt.path;

import java.math.BigDecimal;
import java.math.BigInteger;

import org.junit.Assert;

import com.alibaba.fastjson.JSONPath;

import junit.framework.TestCase;

public class JSONPath_containsValue_bigdecimal extends TestCase {
    public void test_root() throws Exception {
        Model model = new Model();
        model.value = new BigDecimal(""1001"");
        
        Assert.assertTrue(JSONPath.containsValue(model, ""/value"", 1001));
        Assert.assertTrue(JSONPath.containsValue(model, ""/value"", 1001L));
        Assert.assertTrue(JSONPath.containsValue(model, ""/value"", (short) 1001));
        
        Assert.assertFalse(JSONPath.containsValue(model, ""/value"", 1002));
        Assert.assertFalse(JSONPath.containsValue(model, ""/value"", 1002L));
        Assert.assertFalse(JSONPath.containsValue(model, ""/value"", (short) 1002));
    }
    
    public static class Model {
        public BigDecimal value;
    }
}
","package com.alibaba.json.bvt.path;

import java.math.BigDecimal;
import java.math.BigInteger;

import org.junit.Assert;

import com.alibaba.fastjson.JSONPath;

import junit.framework.TestCase;

public class JSONPath_containsValue_bigdecimal extends TestCase {
    public void test_root() throws Exception {
        Model model = new Model();
        model.value = new BigDecimal(""1001"");
        
        Assert.assertTrue(JSONPath.containsValue(model, ""/value"", 1001));
        Assert.assertTrue(JSONPath.containsValue(model, ""/value"", 1001L));
        Assert.assertTrue(JSONPath.containsValue(model, ""/value"", (short) 1001));
        
        Assert.assertFalse(JSONPath.containsValue(model, ""/value"", 1002));
        Assert.assertFalse(JSONPath.containsValue(model, ""/value"", 1002L));
        Assert.assertFalse(JSONPath.containsValue(model, ""/value"", (short) 1002));
    }
    
    public static class Model {
        public BigDecimal value;
    }
}
",['Assertion Roulette'],"['Assertion Roulette', 'Conditional Test Logic', 'Constructor Initialization', 'Default Test', 'Duplicate Assert', 'Eager Test', 'Empty Test', 'Exception Handling', 'General Fixture', 'Ignored Test', 'Lazy Test', 'Magic Number Test', 'Mystery Guest', 'Redundant Print', 'Redundant Assertion', 'Resource Optimism', 'Sensitive Equality', 'Sleepy Test', 'Unknown Test']",18,0,1,6
8772_27.0_querydsl_findall,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8772_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8772_actual.java,"package com.querydsl.example.dao;

import com.querydsl.example.dto.Supplier;
import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;

import static org.junit.Assert.*;

public class SupplierDaoTest extends AbstractDaoTest {

    @Autowired
    SupplierDao supplierDao;

    @Test
    public void findAll() {
        List<Supplier> suppliers = supplierDao.findAll();
        assertFalse(suppliers.isEmpty());
    }

    @Test
    public void findById() {
        assertNotNull(supplierDao.findById(1));
    }

    @Test
    public void update() {
        Supplier supplier = supplierDao.findById(1);
        supplierDao.save(supplier);
    }

    @Test
    public void delete() {
        Supplier supplier = new Supplier();
        supplierDao.save(supplier);
        assertNotNull(supplier.getId());
        supplierDao.delete(supplier);
        assertNull(supplierDao.findById(supplier.getId()));
    }

}
","package com.querydsl.example.dao;

import com.querydsl.core.types.Predicate;
import com.querydsl.example.dto.Supplier;

import java.util.List;

public interface SupplierDao {

    Supplier findById(long id);

    List<Supplier> findAll(Predicate... where);

    Supplier save(Supplier s);

    long count();

    void delete(Supplier s);

}
","['Assertion Roulette', 'Unknown Test']","['Eager Test', 'Magic Number Test', 'Redundant Assertion', 'Unknown Test']",3,1,1,13
9111_27.0_querydsl_test,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/9111_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/9111_actual.java,"/*
 * Copyright 2015, The Querydsl Team (http://www.querydsl.com/team)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.querydsl.core.util;

import static org.junit.Assert.assertEquals;

import java.util.Arrays;

import org.junit.Test;

public class ArrayUtilsTest {

    @Test
    public void test() {
        Object[] array = ArrayUtils.combine(5, new Object[]{""a"",""b""}, new Object[]{""c"",""d"",""e""});
        assertEquals(Arrays.asList(""a"",""b"",""c"",""d"",""e""), Arrays.asList(array));
    }

}
","/*
 * Copyright 2015, The Querydsl Team (http://www.querydsl.com/team)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.querydsl.core.util;

import java.lang.reflect.Array;

/**
 * ArrayUtils provides array related utility functionality
 *
 * @author tiwe
 *
 */
public final class ArrayUtils {

    @SuppressWarnings(""unchecked"")
    public static <T> T[] combine(Class<T> type, T first, T second, T... rest) {
        T[] array = (T[]) Array.newInstance(type, rest.length + 2);
        array[0] = first;
        array[1] = second;
        System.arraycopy(rest, 0, array, 2, rest.length);
        return array;
    }

    @SuppressWarnings(""unchecked"")
    public static <T> T[] combine(Class<T> type, T first, T... rest) {
        T[] array = (T[]) Array.newInstance(type, rest.length + 1);
        array[0] = first;
        System.arraycopy(rest, 0, array, 1, rest.length);
        return array;
    }

    public static Object[] combine(int size, Object[]... arrays) {
        int offset = 0;
        Object[] target = new Object[size];
        for (Object[] arr : arrays) {
            System.arraycopy(arr, 0, target, offset, arr.length);
            offset += arr.length;
        }
        return target;
    }

    // copied and modified from commons-lang-2.3
    // originally licensed under ASL 2.0
    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        int newSize = endIndexExclusive - startIndexInclusive;
        Class<?> type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }

    public static boolean isEmpty(Object[] array) {
        return array == null || array.length == 0;
    }

    private ArrayUtils() { }

}
",[],"['Unknown Test', 'Magic Number Test', 'Assertion Roulette']",3,0,0,15
6658_49.0_dropwizard_hasausername,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/6658_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/6658_actual.java,"package io.dropwizard.auth.basic;

import com.google.common.testing.EqualsTester;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

class BasicCredentialsTest {
    private final BasicCredentials credentials = new BasicCredentials(""u"", ""p"");

    @Test
    void hasAUsername() {
        assertThat(credentials.getUsername()).isEqualTo(""u"");
    }

    @Test
    void hasAPassword() {
        assertThat(credentials.getPassword()).isEqualTo(""p"");
    }

    @Test
    void hasAWorkingEqualsMethod() {
        new EqualsTester()
            .addEqualityGroup(credentials, new BasicCredentials(""u"", ""p""))
            .addEqualityGroup(new BasicCredentials(""u1"", ""p""))
            .addEqualityGroup(new BasicCredentials(""u"", ""p1""))
            .testEquals();
    }

    @Test
    void hasAWorkingHashCode() {
        assertThat(credentials.hashCode())
            .hasSameHashCodeAs(new BasicCredentials(""u"", ""p""))
            .isNotEqualTo(new BasicCredentials(""u1"", ""p"").hashCode())
            .isNotEqualTo(new BasicCredentials(""u"", ""p1"").hashCode());
    }

    @Test
    void isHumanReadable() {
        assertThat(credentials).hasToString(""BasicCredentials{username=u, password=**********}"");
    }
}
","package io.dropwizard.auth.basic;

import java.util.Objects;

import static java.util.Objects.requireNonNull;

/**
 * A set of user-provided Basic Authentication credentials, consisting of a username and a
 * password.
 */
public class BasicCredentials {
    private final String username;
    private final String password;

    /**
     * Creates a new BasicCredentials with the given username and password.
     *
     * @param username the username
     * @param password the password
     */
    public BasicCredentials(String username, String password) {
        this.username = requireNonNull(username);
        this.password = requireNonNull(password);
    }

    /**
     * Returns the credentials' username.
     *
     * @return the credentials' username
     */
    public String getUsername() {
        return username;
    }

    /**
     * Returns the credentials' password.
     *
     * @return the credentials' password
     */
    public String getPassword() {
        return password;
    }

    @Override
    public int hashCode() {
        return Objects.hash(username, password);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final BasicCredentials other = (BasicCredentials) obj;
        return Objects.equals(this.username, other.username) && Objects.equals(this.password, other.password);
    }


    @Override
    public String toString() {
        return ""BasicCredentials{username="" + username + "", password=**********}"";
    }
}
",['Unknown Test'],[],0,1,0,16
43156_17.0_fastjson_test_for_issue,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/43156_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/43156_actual.java,"package com.alibaba.json.bvt.bug;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;
import junit.framework.TestCase;

import java.sql.Date;
import java.sql.Timestamp;

/**
 * Created by wenshao on 11/03/2017.
 */
public class Issue1063_date extends TestCase {
    public void test_for_issue() throws Exception {
        long currentMillis = System.currentTimeMillis();
        TimestampBean bean = new TimestampBean();
        bean.setTimestamp(new Date(currentMillis));
        String timestampJson = JSON.toJSONString(bean);

        // 这里能转换成功
        TimestampBean beanOfJSON = JSON.parseObject(timestampJson, TimestampBean.class);

        // 这里抛异常 java.lang.NumberFormatException
        JSONObject jsonObject = JSON.parseObject(timestampJson);
        Timestamp timestamp2 = jsonObject.getObject(""timestamp"", Timestamp.class);
        assertEquals(currentMillis/1000, timestamp2.getTime() / 1000);
    }

    public static class TimestampBean {
        private Date timestamp = null;

        public Date getTimestamp() {
            return timestamp;
        }

        public void setTimestamp(Date timestamp) {
            this.timestamp = timestamp;
        }
    }
}
","package com.alibaba.json.bvt.bug;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;
import junit.framework.TestCase;

import java.sql.Date;
import java.sql.Timestamp;

/**
 * Created by wenshao on 11/03/2017.
 */
public class Issue1063_date extends TestCase {
    public void test_for_issue() throws Exception {
        long currentMillis = System.currentTimeMillis();
        TimestampBean bean = new TimestampBean();
        bean.setTimestamp(new Date(currentMillis));
        String timestampJson = JSON.toJSONString(bean);

        // 这里能转换成功
        TimestampBean beanOfJSON = JSON.parseObject(timestampJson, TimestampBean.class);

        // 这里抛异常 java.lang.NumberFormatException
        JSONObject jsonObject = JSON.parseObject(timestampJson);
        Timestamp timestamp2 = jsonObject.getObject(""timestamp"", Timestamp.class);
        assertEquals(currentMillis/1000, timestamp2.getTime() / 1000);
    }

    public static class TimestampBean {
        private Date timestamp = null;

        public Date getTimestamp() {
            return timestamp;
        }

        public void setTimestamp(Date timestamp) {
            this.timestamp = timestamp;
        }
    }
}
",[],"['Magic Number Test', 'Eager Test', 'Sensitive Equality']",3,0,0,15
42785_54.0_activiti_doubleconversionvalidation,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/42785_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/42785_actual.java,"/*
 * Copyright 2010-2020 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.editor.language;

import org.activiti.bpmn.model.BpmnModel;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class SubProcessTest extends AbstractConverterTest {

  @Test
  public void doubleConversionValidation() throws Exception {
    BpmnModel bpmnModel = readXmlFile();
    validateModel(bpmnModel);
    bpmnModel = convertToJsonAndBack(bpmnModel);
    validateModel(bpmnModel);
  }

  private void validateModel(BpmnModel model) {
    assertThat(10).isEqualTo(model.getMainProcess().getFlowElementMap().keySet().size());
  }

  protected String getResource() {
    return ""test.subprocess.xml"";
  }

}
","/*
 * Copyright 2010-2020 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;

public class SubProcess extends Activity implements FlowElementsContainer {

  protected Map<String, FlowElement> flowElementMap = new LinkedHashMap<String, FlowElement>();
  protected List<FlowElement> flowElementList = new ArrayList<FlowElement>();
  protected List<Artifact> artifactList = new ArrayList<Artifact>();
  protected List<ValuedDataObject> dataObjects = new ArrayList<ValuedDataObject>();

  public FlowElement getFlowElement(String id) {
    FlowElement foundElement = null;
    if (StringUtils.isNotEmpty(id)) {
      foundElement = flowElementMap.get(id);
    }
    return foundElement;
  }

  public Collection<FlowElement> getFlowElements() {
    return flowElementList;
  }

  public void addFlowElement(FlowElement element) {
    flowElementList.add(element);
    element.setParentContainer(this);
    if(element instanceof FlowElementsContainer){
      flowElementMap.putAll(((FlowElementsContainer) element).getFlowElementMap());
    }
    if (StringUtils.isNotEmpty(element.getId())) {
      flowElementMap.put(element.getId(), element);
      if (getParentContainer() != null) {
        getParentContainer().addFlowElementToMap(element);
      }
    }
  }

  public void addFlowElementToMap(FlowElement element) {
    if (element != null && StringUtils.isNotEmpty(element.getId())) {
      flowElementMap.put(element.getId(), element);
      if (getParentContainer() != null) {
        getParentContainer().addFlowElementToMap(element);
      }
    }
  }

  public void removeFlowElement(String elementId) {
    FlowElement element = getFlowElement(elementId);
    if (element != null) {
      flowElementList.remove(element);
      flowElementMap.remove(elementId);
      if (element.getParentContainer() != null) {
        element.getParentContainer().removeFlowElementFromMap(elementId);
      }
    }
  }

  public void removeFlowElementFromMap(String elementId) {
    if (StringUtils.isNotEmpty(elementId)) {
      flowElementMap.remove(elementId);
    }
  }

  public Map<String, FlowElement> getFlowElementMap() {
    return flowElementMap;
  }

  public void setFlowElementMap(Map<String, FlowElement> flowElementMap) {
    this.flowElementMap = flowElementMap;
  }

  public boolean containsFlowElementId(String id) {
    return flowElementMap.containsKey(id);
  }

  public Artifact getArtifact(String id) {
    Artifact foundArtifact = null;
    for (Artifact artifact : artifactList) {
      if (id.equals(artifact.getId())) {
        foundArtifact = artifact;
        break;
      }
    }
    return foundArtifact;
  }

  public Collection<Artifact> getArtifacts() {
    return artifactList;
  }

  public void addArtifact(Artifact artifact) {
    artifactList.add(artifact);
  }

  public void removeArtifact(String artifactId) {
    Artifact artifact = getArtifact(artifactId);
    if (artifact != null) {
      artifactList.remove(artifact);
    }
  }

  public SubProcess clone() {
    SubProcess clone = new SubProcess();
    clone.setValues(this);
    return clone;
  }

  public void setValues(SubProcess otherElement) {
    super.setValues(otherElement);

    /*
     * This is required because data objects in Designer have no DI info and are added as properties, not flow elements
     *
     * Determine the differences between the 2 elements' data object
     */
    for (ValuedDataObject thisObject : getDataObjects()) {
      boolean exists = false;
      for (ValuedDataObject otherObject : otherElement.getDataObjects()) {
        if (thisObject.getId().equals(otherObject.getId())) {
          exists = true;
        }
      }
      if (!exists) {
        // missing object
        removeFlowElement(thisObject.getId());
      }
    }

    dataObjects = new ArrayList<ValuedDataObject>();
    if (otherElement.getDataObjects() != null && !otherElement.getDataObjects().isEmpty()) {
      for (ValuedDataObject dataObject : otherElement.getDataObjects()) {
        ValuedDataObject clone = dataObject.clone();
        dataObjects.add(clone);
        // add it to the list of FlowElements
        // if it is already there, remove it first so order is same as
        // data object list
        removeFlowElement(clone.getId());
        addFlowElement(clone);
      }
    }

    flowElementList.clear();
    for (FlowElement flowElement : otherElement.getFlowElements()) {
      addFlowElement(flowElement);
    }

    artifactList.clear();
    for (Artifact artifact : otherElement.getArtifacts()) {
      addArtifact(artifact);
    }
  }

  public List<ValuedDataObject> getDataObjects() {
    return dataObjects;
  }

  public void setDataObjects(List<ValuedDataObject> dataObjects) {
    this.dataObjects = dataObjects;
  }

  @Override
  public void accept(ReferenceOverrider referenceOverrider) {
    getFlowElements().forEach(flowElement -> flowElement.accept(referenceOverrider));
  }

}
",['Unknown Test'],"['Eager Test', 'Magic Number Test', 'Assertion Roulette']",3,1,0,14
12569_15.0_wro4j_shouldreturnemptylistbydefault,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/12569_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/12569_actual.java,"/**
 * Copyright@2011 wro4j
 */
package ro.isdc.wro.http.handler.factory;

import static org.junit.Assert.assertEquals;

import java.util.Collections;
import java.util.Properties;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.mockito.MockitoAnnotations;

import ro.isdc.wro.WroRuntimeException;
import ro.isdc.wro.config.Context;


/**
 * @author Alex Objelean
 */
public class TestConfigurableRequestHandlerFactory {
  private ConfigurableRequestHandlerFactory victim;
  
  @BeforeClass
  public static void onBeforeClass() {
    assertEquals(0, Context.countActive());
  }
  
  @AfterClass
  public static void onAfterClass() {
    assertEquals(0, Context.countActive());
  }
  
  @Before
  public void setUp() {
    MockitoAnnotations.initMocks(this);
    victim = new ConfigurableRequestHandlerFactory();
  }
  
  @Test
  public void shouldReturnEmptyListByDefault() {
    assertEquals(Collections.EMPTY_LIST, victim.getConfiguredStrategies());
  }
  
  @Test(expected = WroRuntimeException.class)
  public void testInvalidRequestHandlerSet() {
    final Properties props = new Properties();
    props.setProperty(ConfigurableRequestHandlerFactory.KEY, ""invalid"");
    victim.setProperties(props);
    victim.getConfiguredStrategies();
  }
}
","/**
 * Copyright@2011 wro4j
 */
package ro.isdc.wro.http.handler.factory;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ro.isdc.wro.http.handler.RequestHandler;
import ro.isdc.wro.http.handler.spi.RequestHandlerProvider;
import ro.isdc.wro.model.resource.support.AbstractConfigurableMultipleStrategy;


/**
 * A {@link RequestHandler} implementation which is easy to configure using a {@link Properties} object.
 * 
 * @author Alex Objelean
 * @since 1.5.0
 */
public class ConfigurableRequestHandlerFactory
    extends AbstractConfigurableMultipleStrategy<RequestHandler, RequestHandlerProvider>
    implements RequestHandlerFactory {
  private static final Logger LOG = LoggerFactory.getLogger(ConfigurableRequestHandlerFactory.class);
  /**
   * Name of the property used to configure requestHandlers.
   */
  public static final String KEY = ""requestHandlers"";
  
  private final RequestHandlerFactory requestHandlerFactory = newRequestHandlerFactory();

  /**
   * {@inheritDoc}
   */
  @Override
  protected String getStrategyKey() {
    return KEY;
  }
  
  /**
   * {@inheritDoc}
   */
  @Override
  protected Map<String, RequestHandler> getStrategies(final RequestHandlerProvider provider) {
    return provider.provideRequestHandlers();
  }

  /**
   * {@inheritDoc}
   */
  public Collection<RequestHandler> create() {
    return requestHandlerFactory.create();
  }
  
  /**
   * {@inheritDoc}
   */
  private RequestHandlerFactory newRequestHandlerFactory() {
    final SimpleRequestHandlerFactory factory = new SimpleRequestHandlerFactory();
    final List<RequestHandler> requestHandlers = getConfiguredStrategies();
    for (final RequestHandler requestHandler : requestHandlers) {
      factory.addHandler(requestHandler);
    }
    // use default when none provided
    if (requestHandlers.isEmpty()) {
      LOG.debug(""No locators configured. Using Default locator factory."");
      return new DefaultRequestHandlerFactory();
    }
    return factory;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  protected Class<RequestHandlerProvider> getProviderClass() {
    return RequestHandlerProvider.class;
  }
}
",['General Fixture'],"['Assertion Roulette', 'Magic Number Test']",2,1,0,15
42940_17.0_fastjson_test_0,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/42940_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/42940_actual.java,"package com.alibaba.json.demo;

import java.util.ArrayList;
import java.util.List;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.annotation.JSONField;

public class Demo2 extends TestCase {

    public void test_0() throws Exception {
        Department dep = new Department();
        dep.setId(123);
        dep.setName(""一级部门"");
        dep.setParent(dep);        

        String text = JSON.toJSONString(dep);
        System.out.println(text);
        
        JSON.parseObject(text, Department.class);
    }

    public static class Department {
    
        private int                  id;
        private String               name;
        private Department parent;
        private transient List<Department> children = new ArrayList<Department>();
    
        public int getId() { return id; }
        public void setId(int id) { this.id = id; }
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        @JSONField(serialize=false)
        public Department getParent() { return parent; }
        public void setParent(Department parent) { this.parent = parent; }
        public List<Department> getChildren() { return children; }
        public void setChildren(List<Department> children) { this.children = children; }
    }
}
","package com.alibaba.json.demo;

import java.util.ArrayList;
import java.util.List;

import junit.framework.TestCase;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.annotation.JSONField;

public class Demo2 extends TestCase {

    public void test_0() throws Exception {
        Department dep = new Department();
        dep.setId(123);
        dep.setName(""一级部门"");
        dep.setParent(dep);        

        String text = JSON.toJSONString(dep);
        System.out.println(text);
        
        JSON.parseObject(text, Department.class);
    }

    public static class Department {
    
        private int                  id;
        private String               name;
        private Department parent;
        private transient List<Department> children = new ArrayList<Department>();
    
        public int getId() { return id; }
        public void setId(int id) { this.id = id; }
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        @JSONField(serialize=false)
        public Department getParent() { return parent; }
        public void setParent(Department parent) { this.parent = parent; }
        public List<Department> getChildren() { return children; }
        public void setChildren(List<Department> children) { this.children = children; }
    }
}
","['Print Statement', 'Eager Test', 'Unknown Test']","['Redundant Print', 'Unknown Test', 'Resource Optimism', 'Mystery Guest', 'Eager Test']",3,1,2,13
8777_27.0_querydsl_findbyid,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8777_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8777_actual.java,"package com.querydsl.example.dao;

import com.querydsl.example.dto.CustomerPaymentMethod;
import com.querydsl.example.dto.Order;
import com.querydsl.example.dto.OrderProduct;
import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Collections;
import java.util.List;

import static org.junit.Assert.*;

public class OrderDaoTest extends AbstractDaoTest {

    @Autowired
    OrderDao orderDao;

    @Test
    public void findAll() {
        List<Order> orders = orderDao.findAll();
        assertFalse(orders.isEmpty());
    }

    @Test
    public void findById() {
        assertNotNull(orderDao.findById(1));
    }

    @Test
    public void update() {
        Order order = orderDao.findById(1);
        orderDao.save(order);
    }

    @Test
    public void delete() {
        OrderProduct orderProduct = new OrderProduct();
        orderProduct.setProductId(1L);
        orderProduct.setQuantity(1);

        // FIXME
        CustomerPaymentMethod paymentMethod = new CustomerPaymentMethod();

        Order order = new Order();
        order.setCustomerPaymentMethod(paymentMethod);
        order.setOrderProducts(Collections.singleton(orderProduct));
        orderDao.save(order);
        assertNotNull(order.getId());
        orderDao.delete(order);
        assertNull(orderDao.findById(order.getId()));
    }
}
","package com.querydsl.example.dao;

import com.querydsl.core.types.Predicate;
import com.querydsl.example.dto.Order;

import java.util.List;

public interface OrderDao {

    Order findById(long id);

    List<Order> findAll(Predicate... where);

    Order save(Order order);

    long count();

    void delete(Order p);

}
","['Assertion Roulette', 'Unknown Test']","['Lazy Test', 'Unknown Test', 'Magic Number Test', 'Redundant Print', 'Resource Optimism']",4,1,1,14
45160_12.0_openpojo_testevaluate,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/45160_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/45160_actual.java,"/*
 * Copyright (c) 2010-2018 Osman Shoukry
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.openpojo.validation.rule.impl;

import com.openpojo.validation.CommonCode;
import com.openpojo.validation.rule.Rule;
import com.openpojo.validation.rule.impl.sampleclasses.NoPrimitivesDoesClass;
import com.openpojo.validation.rule.impl.sampleclasses.NoPrimitivesDoesntClass;
import org.junit.Test;

/**
 * @author oshoukry
 */
public class NoPrimitivesRuleTest {
  private Class<?>[] failClasses = new Class<?>[] { NoPrimitivesDoesntClass.class };
  private Class<?>[] passClasses = new Class<?>[] { NoPrimitivesDoesClass.class };
  private Rule rule = new NoPrimitivesRule();

  @Test
  public void testEvaluate() {
    CommonCode.shouldPassRuleValidation(rule, passClasses);
    CommonCode.shouldFailRuleValidation(rule, failClasses);
  }

}
","/*
 * Copyright (c) 2010-2018 Osman Shoukry
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.openpojo.validation.rule.impl;

import com.openpojo.reflection.PojoClass;
import com.openpojo.reflection.PojoField;
import com.openpojo.validation.affirm.Affirm;
import com.openpojo.validation.rule.Rule;
import com.openpojo.validation.utils.ValidationHelper;

/**
 * This Rule ensures that you aren't using any primitive type fields.
 * This is a best practice, ideally, you want to know the difference between ""set/unset"" and value.
 *
 * @author oshoukry
 */
public class NoPrimitivesRule implements Rule {

  public void evaluate(final PojoClass pojoClass) {
    for (PojoField fieldEntry : pojoClass.getPojoFields()) {
      if (fieldEntry.isPrimitive() && !ValidationHelper.isStaticFinal(fieldEntry)) {
        Affirm.fail(String.format(
            ""Primitive fields (byte, short, int, long, float, double, boolean, char) not allowed [%s]"", fieldEntry));
      }
    }
  }

}
",['Unknown Test'],[],0,1,0,16
14011_11_wikidata-toolkit_testsetuseragent,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/14011_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/14011_actual.java,"package org.wikidata.wdtk.util;

/*
 * #%L
 * Wikidata Toolkit Utilities
 * %%
 * Copyright (C) 2014 - 2015 Wikidata Toolkit Developers
 * %%
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.net.InetSocketAddress;
import java.net.Proxy;

import org.junit.Test;

public class WebResourceFetcherTest {

	@Test
	public void testSetUserAgent() {
		WebResourceFetcherImpl.setUserAgent(""My user agent"");
		assertEquals(""My user agent"", WebResourceFetcherImpl.getUserAgent());
	}

	@Test
	public void testSetProxy() {
		Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(
				""test.adress"", 8080));
		WebResourceFetcherImpl.setProxy(proxy);
		assertTrue(WebResourceFetcherImpl.hasProxy());
		assertEquals(proxy, WebResourceFetcherImpl.getProxy());
	}
}
","package org.wikidata.wdtk.util;

/*
 * #%L
 * Wikidata Toolkit Dump File Handling
 * %%
 * Copyright (C) 2014 Wikidata Toolkit Developers
 * %%
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import java.io.IOException;
import java.io.InputStream;

/**
 * Interface to access files on the Web. Mock implementations can be used for
 * testing without Web access.
 * 
 * @author Markus Kroetzsch
 * 
 */
public interface WebResourceFetcher {

	/**
	 * Returns an InputStream for the document at the given URL. This can be
	 * used for downloading. The stream should be closed after use.
	 * 
	 * @param urlString
	 *            the URL of the document
	 * @return InputStream for the requested document
	 * @throws IOException
	 *             if the document at the URL could not be opened or the URL was
	 *             invalid
	 */
	InputStream getInputStreamForUrl(String urlString) throws IOException;

}",['Assertion Roulette'],[],0,1,0,16
44276_17.0_fastjson_test_for_issue_2,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/44276_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/44276_actual.java,"package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONException;
import junit.framework.TestCase;

/**
 * Created by wenshao on 30/07/2017.
 */
public class Issue1330_short extends TestCase {
    public void test_for_issue() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject(""{\""value\"":\""ABC\""}"", Model.class);
        } catch (JSONException e) {
            error = e;
        }
        assertNotNull(error);
        assertTrue(error.getMessage().indexOf(""parseShort error, field : value"") != -1);
    }

    public void test_for_issue_1() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject(""{\""value\"":[]}"", Model.class);
        } catch (JSONException e) {
            error = e;
        }
        assertNotNull(error);
        assertTrue(error.getMessage().indexOf(""parseShort error, field : value"") != -1);
    }

    public void test_for_issue_2() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject(""{\""value\"":{}}"", Model.class);
        } catch (JSONException e) {
            error = e;
        }
        assertNotNull(error);
        assertTrue(error.getMessage().indexOf(""parseShort error, field : value"") != -1);
    }

    public static class Model {
        public short value;
    }
}
","package com.alibaba.json.bvt.issue_1300;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONException;
import junit.framework.TestCase;

/**
 * Created by wenshao on 30/07/2017.
 */
public class Issue1330_short extends TestCase {
    public void test_for_issue() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject(""{\""value\"":\""ABC\""}"", Model.class);
        } catch (JSONException e) {
            error = e;
        }
        assertNotNull(error);
        assertTrue(error.getMessage().indexOf(""parseShort error, field : value"") != -1);
    }

    public void test_for_issue_1() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject(""{\""value\"":[]}"", Model.class);
        } catch (JSONException e) {
            error = e;
        }
        assertNotNull(error);
        assertTrue(error.getMessage().indexOf(""parseShort error, field : value"") != -1);
    }

    public void test_for_issue_2() throws Exception {
        Exception error = null;
        try {
            JSON.parseObject(""{\""value\"":{}}"", Model.class);
        } catch (JSONException e) {
            error = e;
        }
        assertNotNull(error);
        assertTrue(error.getMessage().indexOf(""parseShort error, field : value"") != -1);
    }

    public static class Model {
        public short value;
    }
}
","['Assertion Roulette', 'Exception Catching Throwing']",[],0,2,0,15
8758_27.0_querydsl_save_and_get_by_id,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8758_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8758_actual.java,"package com.querydsl.example.sql.repository;

import com.querydsl.example.sql.model.Tweet;
import com.querydsl.example.sql.model.User;
import org.junit.Test;

import javax.inject.Inject;
import java.util.List;

import static org.junit.Assert.*;

public class UserRepositoryTest extends AbstractPersistenceTest {
    @Inject
    private UserRepository repository;

    @Inject
    private TweetRepository tweetRepository;

    @Test
    public void save_and_get_by_id() {
        String username = ""jackie"";
        User user = new User();
        user.setUsername(username);
        Long id = repository.save(user);
        assertEquals(username, repository.findById(id).getUsername());
    }

    @Test
    public void get_all() {
        User user = new User();
        user.setUsername(""jimmy"");
        repository.save(user);
        assertTrue(repository.all().size() == 1);
    }

    @Test
    public void get_all_with_tweet_count() {
        User user = new User();
        user.setUsername(""jimmy"");
        Long posterId = repository.save(user);

        Tweet tw3 = new Tweet();
        tw3.setPosterId(posterId);
        tw3.setContent(""#EpicFail"");
        tweetRepository.save(tw3);

        List<UserInfo> infos = repository.allWithTweetCount();
        assertFalse(infos.isEmpty());
        for (UserInfo info : infos) {
            assertNotNull(info.getUsername());
        }
    }
}
","package com.querydsl.example.jpa.repository;

import com.google.inject.persist.Transactional;
import com.querydsl.core.types.Predicate;
import com.querydsl.example.jpa.model.User;

import java.util.List;

import static com.querydsl.example.jpa.model.QUser.user;

@Transactional
public class UserRepository extends AbstractRepository<User> {

    @Override
    public User findById(Long id) {
        return find(User.class, id);
    }

    public User save(User user) {
        return persistOrMerge(user);
    }

    public List<User> findAll(Predicate expr) {
        return selectFrom(user).where(expr).fetch();
    }

    public List<User> all() {
        return selectFrom(user).fetch();
    }
}
","['Assertion Roulette', 'Conditional Test Logic']","['Eager Test', 'Magic Number Test']",2,2,0,14
35853_76.0_achilles_should_delete_by_id,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/35853_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/35853_actual.java,"/*
 * Copyright (C) 2012-2021 DuyHai DOAN
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package info.archinnov.achilles.internals.sample_classes.parser.entity;

import java.util.UUID;

import info.archinnov.achilles.annotations.*;
import info.archinnov.achilles.internals.sample_classes.APUnitTest;

@APUnitTest
@Table
public class TestEntityWithStaticCounterColumn {

    @PartitionKey
    private Long id;

    @ClusteringColumn
    private UUID uuid;

    @Static
    @Column
    @Counter
    private Long count;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public UUID getUuid() {
        return uuid;
    }

    public void setUuid(UUID uuid) {
        this.uuid = uuid;
    }

    public Long getCount() {
        return count;
    }

    public void setCount(Long count) {
        this.count = count;
    }
}
","/*
 * Copyright (C) 2012-2021 DuyHai DOAN
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package info.archinnov.achilles.internals.entities;

import java.util.UUID;

import info.archinnov.achilles.annotations.*;

@Table(table = ""entity_static_counter"")
public class EntityWithStaticCounterColumn {

    @PartitionKey
    private Long id;

    @ClusteringColumn
    private UUID uuid;

    @Static
    @Column(""static_count"")
    @Counter
    private Long staticCount;

    @Column
    @Counter
    private Long count;

    public EntityWithStaticCounterColumn() {
    }

    public EntityWithStaticCounterColumn(Long id, UUID uuid, Long staticCount, Long count) {
        this.id = id;
        this.uuid = uuid;
        this.staticCount = staticCount;
        this.count = count;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public UUID getUuid() {
        return uuid;
    }

    public void setUuid(UUID uuid) {
        this.uuid = uuid;
    }

    public Long getStaticCount() {
        return staticCount;
    }

    public void setStaticCount(Long staticCount) {
        this.staticCount = staticCount;
    }

    public Long getCount() {
        return count;
    }

    public void setCount(Long count) {
        this.count = count;
    }
}
",[],[],0,0,0,17
45068_12.0_openpojo_gettypesshouldthrowexception,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/45068_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/45068_actual.java,"/*
 * Copyright (c) 2010-2018 Osman Shoukry
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.openpojo.random.service.impl;

import com.openpojo.random.exception.RandomGeneratorException;
import org.junit.Test;

/**
 * @author oshoukry
 */
public class RandomGeneratorAdapterTest {

  @Test(expected = RandomGeneratorException.class)
  public void getTypesShouldThrowException() {
    final RandomGeneratorAdapter randomGeneratorAdapter = new RandomGeneratorAdapter(null, null, null);
    randomGeneratorAdapter.getTypes();
  }


  @Test(expected = RandomGeneratorException.class)
  public void doGenerateOnNonRegisteredTypeShouldThrowException() {
    final RandomGeneratorAdapter randomGeneratorAdapter = new RandomGeneratorAdapter(null, null, null);
    randomGeneratorAdapter.doGenerate(anyClass());

  }

  private Class<?> anyClass() {
    return this.getClass();
  }
}
","/*
 * Copyright (c) 2010-2018 Osman Shoukry
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.openpojo.random.service.impl;

import java.util.Collection;

import com.openpojo.log.Logger;
import com.openpojo.log.LoggerFactory;
import com.openpojo.log.utils.MessageFormatter;
import com.openpojo.random.ParameterizableRandomGenerator;
import com.openpojo.random.RandomGenerator;
import com.openpojo.random.exception.RandomGeneratorException;
import com.openpojo.reflection.Parameterizable;

/**
 * @author oshoukry
 */
public final class RandomGeneratorAdapter implements RandomGenerator, ParameterizableRandomGenerator {

  private final Class<?> fromType;
  private final Class<?> toType;
  private final RandomGenerator adaptedRandomGenerator;
  private final static Logger LOGGER = LoggerFactory.getLogger(RandomGeneratorAdapter.class);

  public RandomGeneratorAdapter(final Class<?> fromType, final Class<?> toType, final RandomGenerator adaptedRandomGenerator) {
    this.fromType = fromType;
    this.toType = toType;
    this.adaptedRandomGenerator = adaptedRandomGenerator;
    LOGGER.debug(""Mapping [{0}] to [{1}] for generator [{2}]"", fromType, toType, adaptedRandomGenerator);
  }

  public Collection<Class<?>> getTypes() {
    throw RandomGeneratorException.getInstance(MessageFormatter.format(""Illegal use of RandomGeneratorAdapter([{0}] to [{1}]"",
        fromType, toType));
  }

  public Object doGenerate(final Class<?> type) {
    if (type == fromType) {
      return adaptedRandomGenerator.doGenerate(toType);
    }
    throw RandomGeneratorException.getInstance(MessageFormatter.format(""Unsupported type requested [{0}]"", type));
  }

  public Object doGenerate(Parameterizable parameterizedType) {
    return ((ParameterizableRandomGenerator) adaptedRandomGenerator).doGenerate(parameterizedType);
  }
}
",[],"['Lazy Test', 'Exception Handling']",2,0,0,16
13202_15.0_wro4j_testfromfolder,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/13202_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/13202_actual.java,"/*
 * Copyright (c) 2010. All rights reserved.
 */
package ro.isdc.wro.model.resource.processor;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.net.URL;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import ro.isdc.wro.config.Context;
import ro.isdc.wro.model.resource.ResourceType;
import ro.isdc.wro.model.resource.processor.impl.css.ConformColorsCssProcessor;
import ro.isdc.wro.util.WroTestUtils;


/**
 * TestConformColorsCssProcessor.
 * 
 * @author Alex Objelean
 * @created Created on Aug 15, 2010
 */
public class TestConformColorsCssProcessor {
  private ResourcePreProcessor processor;
  
  @BeforeClass
  public static void onBeforeClass() {
    assertEquals(0, Context.countActive());
  }
  
  @AfterClass
  public static void onAfterClass() {
    assertEquals(0, Context.countActive());
  }
  
  @Before
  public void setUp() {
    processor = new ConformColorsCssProcessor();
  }
  
  @Test
  public void testFromFolder()
      throws Exception {
    final URL url = getClass().getResource(""conformColors"");
    
    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""css"", processor);
  }
  
  @Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(processor, ResourceType.CSS);
  }
}
","/**
 * Copyright Alex Objelean
 */
package ro.isdc.wro.model.resource.processor.impl.css;

import java.io.IOException;
import java.io.Reader;
import java.io.Writer;

import org.apache.commons.io.IOUtils;

import ro.isdc.wro.model.resource.Resource;
import ro.isdc.wro.model.resource.ResourceType;
import ro.isdc.wro.model.resource.SupportedResourceType;
import ro.isdc.wro.model.resource.processor.ResourcePostProcessor;
import ro.isdc.wro.model.resource.processor.ResourcePreProcessor;
import ro.isdc.wro.model.resource.processor.support.Lessify;


/**
 * A processor which transform all colors to #rgb format.
 *
 * @author Alex Objelean
 */
@SupportedResourceType(ResourceType.CSS)
public class ConformColorsCssProcessor
  implements ResourcePreProcessor, ResourcePostProcessor {
  public static final String ALIAS = ""conformColors"";

  /**
   * {@inheritDoc}
   */
  public void process(final Resource resource, final Reader reader, final Writer writer)
    throws IOException {
    try {
      final String result = new Lessify().conformColors(IOUtils.toString(reader));
      writer.write(result);
    } finally {
      reader.close();
      writer.close();
    }
  }

  /**
   * {@inheritDoc}
   */
  public void process(final Reader reader, final Writer writer)
    throws IOException {
    process(null, reader, writer);
  }
}
","['Mystery Guest', 'Unknown Test']","['Magic Number Test', 'Resource Optimism', 'Mystery Guest', 'Eager Test', 'Sensitive Equality', 'Redundant Assertion']",5,1,1,12
11049_35.0_hsac-fitnesse-fixtures_testthrowruntime,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/11049_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/11049_actual.java,"package nl.hsac.fitnesse.fixture.util;

import nl.hsac.fitnesse.fixture.slim.SlimFixtureException;
import org.junit.Test;

import java.io.IOException;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

public class ThrowingFunctionTest {
    @Test
    public void testNoThrow() {
        Object result = callFunction(x -> callThatMightThrow(x), true);
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    public void testThrowChecked() {
        try {
            Object result = callFunction(x -> callThatMightThrow(x), null);
            fail(""expected exception, got: "" + result);
        } catch (SlimFixtureException e) {
            assertEquals(IOException.class, e.getCause().getClass());
        }
    }

    @Test
    public void testThrowRuntime() {
        try {
            Object result = callFunction(x -> callThatMightThrow(x), false);
            fail(""expected exception, got: "" + result);
        } catch (IllegalArgumentException e) {
            assertEquals(""false"", e.getMessage());
        }
    }

    private static Object callFunction(ThrowingFunction<Boolean, Object, IOException> f, Boolean input) {
        return f.applyWrapped(input, SlimFixtureException::new);
    }

    private static Object callThatMightThrow(Boolean val) throws IOException {
        if (val == null) {
            throw new IOException(""Oops"");
        } else if (!val) {
            throw new IllegalArgumentException(""false"");
        } else {
            return val;
        }
    }
}","package nl.hsac.fitnesse.fixture.util;

import java.util.function.Function;

/**
 * Functional interface to allow exceptions thrown by lambdas to be handled, or wrapped to runtime ones.
 */
@FunctionalInterface
public interface ThrowingFunction<T, R, E extends Exception> {
    R apply(T t) throws E;

    /**
     * Applies using t, wrapping converting any checked exception to a runtime one using exceptionWrapper
     * @param t parameter to supply to {@link #apply(Object)}.
     * @param exceptionWrapper function to convert checked exception to runtime one.
     * @param <RE> type of runtime exception which will be thrown
     * @return result of apply(t)
     */
    default <RE extends RuntimeException> R applyWrapped(T t, Function<E, RE> exceptionWrapper) {
        try {
            return apply(t);
        } catch (RuntimeException e) {
            throw e;
        } catch (Exception e) {
            throw exceptionWrapper.apply((E) e);
        }
    }
}
","['Assertion Roulette', 'Exception Catching Throwing']","['Exception Handling', 'Magic Number Test', 'Sensitive Equality', 'Eager Test']",4,2,0,13
13234_15.0_wro4j_shouldhandlewrongcss,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/13234_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/13234_actual.java,"/**
 * Copyright Alex Objelean
 */
package ro.isdc.wro.model.resource.processor;

import java.io.File;
import java.net.URL;

import org.junit.Test;

import ro.isdc.wro.model.resource.ResourceType;
import ro.isdc.wro.model.resource.processor.decorator.ExceptionHandlingProcessorDecorator;
import ro.isdc.wro.model.resource.processor.impl.css.CssMinProcessor;
import ro.isdc.wro.util.WroTestUtils;


/**
 * @author Alex Objelean
 */
public class TestCssMinProcessor {
  @Test
  public void testFromFolder()
    throws Exception {
    final ResourcePostProcessor processor = new CssMinProcessor();

    final URL url = getClass().getResource(""cssmin"");

    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expected"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""css"", processor);
  }

  @Test
  public void shouldHandleWrongCss()
      throws Exception {
    final ResourcePostProcessor processor = new ExceptionHandlingProcessorDecorator(new CssMinProcessor());
    
    final URL url = getClass().getResource(""cssmin"");
    
    final File testFolder = new File(url.getFile(), ""test"");
    final File expectedFolder = new File(url.getFile(), ""expectedInvalid"");
    WroTestUtils.compareFromDifferentFoldersByExtension(testFolder, expectedFolder, ""css"", processor);
  }
  
  @Test
  public void shouldSupportCorrectResourceTypes() {
    WroTestUtils.assertProcessorSupportResourceTypes(new CssMinProcessor(), ResourceType.CSS);
  }
}
","/**
 * Copyright Alex Objelean
 */
package ro.isdc.wro.model.resource.processor.impl.css;

import java.io.IOException;
import java.io.Reader;
import java.io.Writer;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ro.isdc.wro.model.group.processor.Minimize;
import ro.isdc.wro.model.resource.Resource;
import ro.isdc.wro.model.resource.ResourceType;
import ro.isdc.wro.model.resource.SupportedResourceType;
import ro.isdc.wro.model.resource.processor.ResourcePostProcessor;
import ro.isdc.wro.model.resource.processor.ResourcePreProcessor;
import ro.isdc.wro.model.resource.processor.support.CSSMin;


/**
 * A processor implementation using {@link CSSMin} algorithm. This processor can be used as both: PreProcessor and
 * postProcessor.<br/>
 * This processor is annotated with {@link Minimize} because it performs minimization.
 *
 * @author Alex Objelean
 */
@Minimize
@SupportedResourceType(ResourceType.CSS)
public class CssMinProcessor
  implements ResourcePreProcessor, ResourcePostProcessor {
  private static final Logger LOG = LoggerFactory.getLogger(CssMinProcessor.class);
  public static final String ALIAS = ""cssMin"";

  public void process(final Reader reader, final Writer writer)
    throws IOException {
    process(null, reader, writer);
  }

  public void process(final Resource resource, final Reader reader, final Writer writer)
    throws IOException {
    try {
      final String content = IOUtils.toString(reader);
      new CSSMin().formatFile(content, writer);
      writer.flush();
    } catch (final Exception e) {
      final String resourceUri = resource == null ? StringUtils.EMPTY : ""["" + resource.getUri() + ""]"";
      String message = ""Exception while applying "" + getClass().getSimpleName() + "" processor on the ""
          + resourceUri + "" resource"";
      LOG.error(message, e);
      throw new IOException(message);
    } finally {
      reader.close();
      writer.close();
    }
  }
}
","['Mystery Guest', 'Unknown Test']","['Mystery Guest', 'Magic Number Test', 'Redundant Print', 'General Fixture', 'Eager Test', 'Assertion Roulette', 'Constructor Initialization', 'Default Test', 'Duplicate Assert']",8,1,1,10
43915_17.0_fastjson_test_array_2,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/43915_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/43915_actual.java,"package com.alibaba.json.bvt.parser.stream;

import java.io.StringReader;
import java.util.List;

import junit.framework.TestCase;

import org.junit.Assert;

import com.alibaba.fastjson.JSONReader;
import com.alibaba.fastjson.TypeReference;

public class JSONReader_typeRef extends TestCase {
    public void test_array() throws Exception {
        JSONReader reader = new JSONReader(new StringReader(""[{\""id\"":123}]""));
        
        List<VO> list = reader.readObject(new TypeReference<List<VO>>() {}.getType());
        
        Assert.assertEquals(123, list.get(0).getId());
        
        reader.close();
    }
    
    public void test_array_1() throws Exception {
        JSONReader reader = new JSONReader(new StringReader(""[[{\""id\"":123}]]""));
        
        reader.startArray();
        List<VO> list = reader.readObject(new TypeReference<List<VO>>() {}.getType());
        
        Assert.assertEquals(123, list.get(0).getId());
        
        reader.endArray();
        
        reader.close();
    }
    
    public void test_array_2() throws Exception {
        JSONReader reader = new JSONReader(new StringReader(""[[{\""id\"":123}]]""));
        
        reader.startArray();
        List<VO> list = reader.readObject(new TypeReference<List<VO>>() {});
        
        Assert.assertEquals(123, list.get(0).getId());
        
        reader.endArray();
        
        reader.close();
    }
    
    public static class VO {

        private int id;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }
    }
}
","package com.alibaba.json.bvt.parser.stream;

import java.io.StringReader;
import java.util.List;

import junit.framework.TestCase;

import org.junit.Assert;

import com.alibaba.fastjson.JSONReader;
import com.alibaba.fastjson.TypeReference;

public class JSONReader_typeRef extends TestCase {
    public void test_array() throws Exception {
        JSONReader reader = new JSONReader(new StringReader(""[{\""id\"":123}]""));
        
        List<VO> list = reader.readObject(new TypeReference<List<VO>>() {}.getType());
        
        Assert.assertEquals(123, list.get(0).getId());
        
        reader.close();
    }
    
    public void test_array_1() throws Exception {
        JSONReader reader = new JSONReader(new StringReader(""[[{\""id\"":123}]]""));
        
        reader.startArray();
        List<VO> list = reader.readObject(new TypeReference<List<VO>>() {}.getType());
        
        Assert.assertEquals(123, list.get(0).getId());
        
        reader.endArray();
        
        reader.close();
    }
    
    public void test_array_2() throws Exception {
        JSONReader reader = new JSONReader(new StringReader(""[[{\""id\"":123}]]""));
        
        reader.startArray();
        List<VO> list = reader.readObject(new TypeReference<List<VO>>() {});
        
        Assert.assertEquals(123, list.get(0).getId());
        
        reader.endArray();
        
        reader.close();
    }
    
    public static class VO {

        private int id;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }
    }
}
",[],"['Duplicate Assert', 'Eager Test', 'Magic Number Test', 'Resource Optimism']",4,0,0,16
43367_17.0_fastjson_test_for_issue_1,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/43367_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/43367_actual.java,"package com.alibaba.json.bvt.bug;

import org.junit.Assert;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;
import com.alibaba.fastjson.serializer.ValueFilter;

import junit.framework.TestCase;

public class Bug_for_issue_572_private extends TestCase {

    public void test_for_issue() throws Exception {
        Model model = new Model();
        model.id = 1001;
        model.name = ""wenshao"";

        String text = JSON.toJSONString(model, SerializerFeature.WriteNonStringValueAsString);
        Assert.assertEquals(""{\""id\"":\""1001\"",\""name\"":\""wenshao\""}"", text);
    }

    public void test_for_issue_1() throws Exception {
        Model model = new Model();
        model.id = 1001;
        model.name = ""wenshao"";

        ValueFilter valueFilter = new ValueFilter() {

            @Override
            public Object process(Object object, String name, Object value) {
                if (value instanceof Number) {
                    return null;
                }
                return value;
            }
        };

        String text = JSON.toJSONString(model, valueFilter, SerializerFeature.WriteNonStringValueAsString);
        Assert.assertEquals(""{\""id\"":\""1001\"",\""name\"":\""wenshao\""}"", text);
    }

    private static class Model {

        private int    id;
        private String name;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

    }
}
","package com.alibaba.json.bvt.bug;

import org.junit.Assert;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;
import com.alibaba.fastjson.serializer.ValueFilter;

import junit.framework.TestCase;

public class Bug_for_issue_572_private extends TestCase {

    public void test_for_issue() throws Exception {
        Model model = new Model();
        model.id = 1001;
        model.name = ""wenshao"";

        String text = JSON.toJSONString(model, SerializerFeature.WriteNonStringValueAsString);
        Assert.assertEquals(""{\""id\"":\""1001\"",\""name\"":\""wenshao\""}"", text);
    }

    public void test_for_issue_1() throws Exception {
        Model model = new Model();
        model.id = 1001;
        model.name = ""wenshao"";

        ValueFilter valueFilter = new ValueFilter() {

            @Override
            public Object process(Object object, String name, Object value) {
                if (value instanceof Number) {
                    return null;
                }
                return value;
            }
        };

        String text = JSON.toJSONString(model, valueFilter, SerializerFeature.WriteNonStringValueAsString);
        Assert.assertEquals(""{\""id\"":\""1001\"",\""name\"":\""wenshao\""}"", text);
    }

    private static class Model {

        private int    id;
        private String name;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

    }
}
",[],[],0,0,0,17
46127_71_spring-ws_testgetlookupkeyformessage,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/46127_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/46127_actual.java,"/*
 * Copyright 2005-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.ws.server.endpoint.mapping;

import static org.assertj.core.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.ws.MockWebServiceMessage;
import org.springframework.ws.MockWebServiceMessageFactory;
import org.springframework.ws.context.DefaultMessageContext;
import org.springframework.ws.context.MessageContext;

public class XPathPayloadEndpointMappingTest {

	private XPathPayloadEndpointMapping mapping;

	@BeforeEach
	public void setUp() throws Exception {
		mapping = new XPathPayloadEndpointMapping();
	}

	@Test
	public void testGetLookupKeyForMessage() throws Exception {

		mapping.setExpression(""/root/text()"");
		mapping.afterPropertiesSet();

		MockWebServiceMessage request = new MockWebServiceMessage(""<root>value</root>"");
		MessageContext context = new DefaultMessageContext(request, new MockWebServiceMessageFactory());

		String result = mapping.getLookupKeyForMessage(context);

		assertThat(result).isNotNull();
		assertThat(result).isEqualTo(""value"");
	}
}
","/*
 * Copyright 2005-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.ws.server.endpoint.mapping;

import java.util.Map;

import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMResult;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.context.MessageContext;
import org.springframework.xml.transform.TransformerFactoryUtils;
import org.springframework.xml.xpath.XPathExpression;
import org.springframework.xml.xpath.XPathExpressionFactory;
import org.w3c.dom.Element;

/**
 * Implementation of the {@code EndpointMapping} interface that maps to endpoint using an XPath expression. Supports
 * both mapping to bean instances and mapping to bean names: the latter is required for prototype endpoints.
 * <p>
 * The XPath expression can be set using the {@code expression} property. Setting this property is required. There is
 * also an optional {@code namespaces} property, which defines to set namespace bindings that are used in the
 * expression.
 * <p>
 * The {@code endpointMap} property is suitable for populating the endpoint map with bean references, e.g. via the map
 * element in XML bean definitions.
 * <p>
 * Mappings to bean names can be set via the {@code mappings} property, in a form accepted by the
 * {@code java.util.Properties} class, like as follows:
 *
 * <pre>
 * BookFlight=bookFlightEndpoint
 * GetFlights=getFlightsEndpoint
 * </pre>
 *
 * The syntax is XPATH_EVALUATION=ENDPOINT_BEAN_NAME. The key is the evaluation of the XPath expression for the incoming
 * message, the value is the name of the endpoint.
 *
 * @author Arjen Poutsma
 * @see #setExpression(String)
 * @see #setNamespaces(java.util.Map)
 * @since 1.0.0
 */
public class XPathPayloadEndpointMapping extends AbstractMapBasedEndpointMapping implements InitializingBean {

	private String expressionString;

	private XPathExpression expression;

	private Map<String, String> namespaces;

	private TransformerFactory transformerFactory;

	/** Sets the XPath expression to be used. */
	public void setExpression(String expression) {
		expressionString = expression;
	}

	/** Sets the namespaces bindings used in the expression. Keys are prefixes, values are namespaces. */
	public void setNamespaces(Map<String, String> namespaces) {
		this.namespaces = namespaces;
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		Assert.notNull(expressionString, ""expression is required"");
		if (namespaces == null) {
			expression = XPathExpressionFactory.createXPathExpression(expressionString);
		} else {
			expression = XPathExpressionFactory.createXPathExpression(expressionString, namespaces);
		}
		transformerFactory = TransformerFactoryUtils.newInstance();
	}

	@Override
	protected String getLookupKeyForMessage(MessageContext messageContext) throws Exception {
		Element payloadElement = getMessagePayloadElement(messageContext.getRequest());
		return expression.evaluateAsString(payloadElement);
	}

	private Element getMessagePayloadElement(WebServiceMessage message) throws TransformerException {
		Transformer transformer = transformerFactory.newTransformer();
		DOMResult domResult = new DOMResult();
		transformer.transform(message.getPayloadSource(), domResult);
		return (Element) domResult.getNode().getFirstChild();
	}

	@Override
	protected boolean validateLookupKey(String key) {
		return StringUtils.hasLength(key);
	}
}
","['Assertion Roulette', 'General Fixture']","['Assertion Roulette', 'Eager Test']",1,1,1,14
10947_35.0_hsac-fitnesse-fixtures_testparse,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/10947_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/10947_actual.java,"package nl.hsac.fitnesse.fixture.util;

import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

/**
 * Tests XPathCheckResult.
 */
public class XPathCheckResultTest {

    @Test
    public void testHashCodeAndEquals() {
        XPathCheckResult checkResult = new XPathCheckResult();
        XPathCheckResult checkResult2 = new XPathCheckResult();

        resultsMatch(checkResult, checkResult2);
        
        checkResult.setMismatchDetail(""NOK: a"");
        checkResult2.addMisMatch(""name"", ""expected"", ""actual"");
        resultsMatch(checkResult, checkResult2);

        checkResult2 = new XPathCheckResult();
        resultsDontMatch(checkResult, checkResult2);
    }

    @Test
    public void testParse() {
        XPathCheckResult checkResult = new XPathCheckResult();
        XPathCheckResult checkResult2 = XPathCheckResult.parse(""OK"");
        resultsMatch(checkResult, checkResult2);
        
        checkResult.setMismatchDetail(""NOK: a"");
        checkResult2 = XPathCheckResult.parse(""NOK"");
        resultsMatch(checkResult, checkResult2);

        checkResult2 = XPathCheckResult.parse(""OK"");
        resultsDontMatch(checkResult, checkResult2);
    }

    private void resultsDontMatch(XPathCheckResult checkResult, XPathCheckResult checkResult2) {
        assertFalse(checkResult.equals(checkResult2));
        assertTrue(checkResult.hashCode() != checkResult2.hashCode());
    }

    private void resultsMatch(XPathCheckResult checkResult, XPathCheckResult checkResult2) {
        assertEquals(checkResult, checkResult2);
        assertEquals(checkResult.hashCode(), checkResult2.hashCode());
    }

}
","package nl.hsac.fitnesse.fixture.util;

import nl.hsac.fitnesse.fixture.fit.SoapCallMapColumnFixture;

import java.util.ArrayList;
import java.util.List;

/**
 * Results from checking xpaths.
 */
public class XPathCheckResult {
    private String result = ""OK"";
    private List<Mismatch> mismatches = new ArrayList<Mismatch>();
    private String mismatchDetail;

    @Override
    public String toString() {
        String str = result;
        String mismatchDetails = getMismatchDetail();
        if (mismatchDetails != null) {
            str = mismatchDetails;
        }
        return str;
    }

    /**
     * Parse method to allow Fitnesse to determine expected values.
     * @param value expected value from cell.
     * @return object with supplied value as result.
     */
    public static XPathCheckResult parse(String value) {
        XPathCheckResult parsed = new XPathCheckResult();
        parsed.result = value;
        return parsed;
    }

    /**
     * Adds a mismatch to this result.
     * @param name name of value.
     * @param expected expected value.
     * @param actual value of XPath expression.
     */
    public void addMisMatch(String name, String expected, String actual) {
        result = ""NOK"";
        Mismatch mismatch = new Mismatch();
        mismatch.name = name;
        mismatch.expected = expected;
        mismatch.actual = actual;
        mismatches.add(mismatch);
    }

    /**
     * @return the mismatchDetail
     */
    public String getMismatchDetail() {
        String result = mismatchDetail;
        if (hasMismatch()) {
            StringBuilder builder = new StringBuilder(SoapCallMapColumnFixture.NO_ESCAPE_PREFIX + ""NOK:\n<ul>\n"");
            for (Mismatch mismatch : mismatches) {
                builder.append("" <li>"");
                builder.append(mismatch.toString());
                builder.append(""</li>\n"");
            }
            builder.append(""</ul>"");
            result = builder.toString();
        }
        return result;
    }

    /**
     * @return whether result has one or more mismatches.
     */
    public boolean hasMismatch() {
        return !mismatches.isEmpty();
    }

    /**
     * @param aMismatchDetail the mismatchDetail to set
     */
    public void setMismatchDetail(String aMismatchDetail) {
        result = ""NOK"";
        mismatchDetail = aMismatchDetail;
    }
    
    @Override
    public boolean equals(Object anObject) {
        if (anObject == this) {
            return true;
        }
        if (anObject == null) {
            return false;
        }
        if (anObject instanceof XPathCheckResult) {
            return String.valueOf(((XPathCheckResult)anObject).getResult()).equalsIgnoreCase(result);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int ret = 0;
        if (result != null) {
            ret = result.hashCode();
        }
        return ret;
    }

    /**
     * @return the result
     */
    public String getResult() {
        return result;
    }

    private class Mismatch {
        public String name;
        public String expected;
        public String actual;

        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder();
            builder.append(name);
            builder.append("": "");
            builder.append(expected);
            builder.append("" <> "");
            builder.append(actual);
            return builder.toString();
        }
    }
}
",['Unknown Test'],[],0,1,0,16
40467_45.0_hbase_testgetinstance,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/40467_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/40467_actual.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.hadoop.hbase.replication.regionserver;

import static org.junit.Assert.assertTrue;

import org.apache.hadoop.hbase.CompatibilitySingletonFactory;
import org.apache.hadoop.hbase.HBaseClassTestRule;
import org.apache.hadoop.hbase.testclassification.MetricsTests;
import org.apache.hadoop.hbase.testclassification.SmallTests;
import org.junit.ClassRule;
import org.junit.Test;
import org.junit.experimental.categories.Category;

@Category({ MetricsTests.class, SmallTests.class })
public class TestMetricsReplicationSourceFactoryImpl {
  @ClassRule
  public static final HBaseClassTestRule CLASS_RULE =
    HBaseClassTestRule.forClass(TestMetricsReplicationSourceFactoryImpl.class);

  @Test
  public void testGetInstance() {
    MetricsReplicationSourceFactory rms =
      CompatibilitySingletonFactory.getInstance(MetricsReplicationSourceFactory.class);
    assertTrue(rms instanceof MetricsReplicationSourceFactoryImpl);
  }
}
","/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.hadoop.hbase.replication.regionserver;

import org.apache.yetus.audience.InterfaceAudience;

@InterfaceAudience.Private
public class MetricsReplicationSourceFactoryImpl implements MetricsReplicationSourceFactory {

  @SuppressWarnings(""ImmutableEnumChecker"")
  private static enum SourceHolder {
    INSTANCE;

    private final MetricsReplicationSourceImpl source = new MetricsReplicationSourceImpl();
  }

  @Override
  public MetricsReplicationSinkSource getSink() {
    return new MetricsReplicationSinkSourceImpl(SourceHolder.INSTANCE.source);
  }

  @Override
  public MetricsReplicationSourceSource getSource(String id) {
    return new MetricsReplicationSourceSourceImpl(SourceHolder.INSTANCE.source, id);
  }

  @Override
  public MetricsReplicationTableSource getTableSource(String tableName) {
    return new MetricsReplicationTableSourceImpl(SourceHolder.INSTANCE.source, tableName);
  }

  @Override
  public MetricsReplicationGlobalSourceSourceImpl getGlobalSource() {
    return new MetricsReplicationGlobalSourceSourceImpl(SourceHolder.INSTANCE.source);
  }
}
",[],[],0,0,0,17
6702_49.0_dropwizard_testcustomclientconfiguration,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/6702_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/6702_actual.java,"package com.example.helloworld.resources;

import com.example.helloworld.core.Person;
import com.example.helloworld.db.PersonDAO;
import io.dropwizard.testing.junit5.DropwizardExtensionsSupport;
import io.dropwizard.testing.junit5.ResourceExtension;
import jakarta.ws.rs.core.Response;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Unit tests for {@link PersonResource}.
 */
@ExtendWith(DropwizardExtensionsSupport.class)
class PersonResourceTest {
    private static final PersonDAO DAO = mock(PersonDAO.class);
    public static final ResourceExtension RULE = ResourceExtension.builder()
            .addResource(new PersonResource(DAO))
            .build();

    @AfterEach
    void tearDown() {
        reset(DAO);
    }

    @Test
    void getPersonSuccess() {
        final Person person = new Person();
        person.setId(1L);

        when(DAO.findById(1L)).thenReturn(Optional.of(person));

        Person found = RULE.target(""/people/1"").request().get(Person.class);

        assertThat(found.getId()).isEqualTo(person.getId());
        verify(DAO).findById(1L);
    }

    @Test
    void getPersonNotFound() {
        when(DAO.findById(2L)).thenReturn(Optional.empty());
        final Response response = RULE.target(""/people/2"").request().get();

        assertThat(response.getStatusInfo().getStatusCode()).isEqualTo(Response.Status.NOT_FOUND.getStatusCode());
        verify(DAO).findById(2L);
    }
}
","package com.example.helloworld.resources;

import com.example.helloworld.core.Person;
import com.example.helloworld.db.PersonDAO;
import com.example.helloworld.views.PersonView;
import io.dropwizard.hibernate.UnitOfWork;
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.NotFoundException;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

import java.util.OptionalLong;

@Path(""/people/{personId}"")
@Produces(MediaType.APPLICATION_JSON)
public class PersonResource {

    private final PersonDAO peopleDAO;

    public PersonResource(PersonDAO peopleDAO) {
        this.peopleDAO = peopleDAO;
    }

    @GET
    @UnitOfWork
    public Person getPerson(@PathParam(""personId"") OptionalLong personId) {
        return findSafely(personId.orElseThrow(() -> new BadRequestException(""person ID is required"")));
    }

    @GET
    @Path(""/view_freemarker"")
    @UnitOfWork
    @Produces(MediaType.TEXT_HTML)
    public PersonView getPersonViewFreemarker(@PathParam(""personId"") OptionalLong personId) {
        return new PersonView(PersonView.Template.FREEMARKER, findSafely(personId.orElseThrow(() -> new BadRequestException(""person ID is required""))));
    }

    @GET
    @Path(""/view_mustache"")
    @UnitOfWork
    @Produces(MediaType.TEXT_HTML)
    public PersonView getPersonViewMustache(@PathParam(""personId"") OptionalLong personId) {
        return new PersonView(PersonView.Template.MUSTACHE, findSafely(personId.orElseThrow(() -> new BadRequestException(""person ID is required""))));
    }

    private Person findSafely(long personId) {
        return peopleDAO.findById(personId).orElseThrow(() -> new NotFoundException(""No such user.""));
    }
}
",[],[],0,0,0,17
46880_2.0_tyrus_testserver,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/46880_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/46880_actual.java,"/*
 * Copyright (c) 2014, 2017 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 */

package org.glassfish.tyrus.tests.servlet.autobahn;

import java.io.IOException;
import java.util.HashMap;

import javax.websocket.DeploymentException;

import org.glassfish.tyrus.core.TyrusWebSocketEngine;
import org.glassfish.tyrus.server.Server;
import org.glassfish.tyrus.test.tools.TestContainer;

import org.junit.Ignore;
import org.junit.Test;

/**
 * @author Pavel Bucek (pavel.bucek at oracle.com)
 */
public class StandaloneServer extends TestContainer {

    public StandaloneServer() {
        setContextPath(""/autobahn"");
        final HashMap<String, Object> stringObjectHashMap = new HashMap<String, Object>();
        stringObjectHashMap.put(TyrusWebSocketEngine.INCOMING_BUFFER_SIZE, 17000000);
        setServerProperties(stringObjectHashMap);
    }

    @Ignore(""Manual testing."")
    @Test
    public void testServer() throws IOException, DeploymentException {
        final Server server = startServer(AutobahnApplicationConfig.class);

        try {
            System.in.read();
        } finally {
            stopServer(server);
        }
    }
}
","/*
 * Copyright (c) 2014, 2017 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 */

package org.glassfish.tyrus.tests.servlet.autobahn;

import java.io.IOException;
import java.util.HashMap;

import javax.websocket.DeploymentException;

import org.glassfish.tyrus.core.TyrusWebSocketEngine;
import org.glassfish.tyrus.server.Server;
import org.glassfish.tyrus.test.tools.TestContainer;

import org.junit.Ignore;
import org.junit.Test;

/**
 * @author Pavel Bucek (pavel.bucek at oracle.com)
 */
public class StandaloneServer extends TestContainer {

    public StandaloneServer() {
        setContextPath(""/autobahn"");
        final HashMap<String, Object> stringObjectHashMap = new HashMap<String, Object>();
        stringObjectHashMap.put(TyrusWebSocketEngine.INCOMING_BUFFER_SIZE, 17000000);
        setServerProperties(stringObjectHashMap);
    }

    @Ignore(""Manual testing."")
    @Test
    public void testServer() throws IOException, DeploymentException {
        final Server server = startServer(AutobahnApplicationConfig.class);

        try {
            System.in.read();
        } finally {
            stopServer(server);
        }
    }
}
",['Unknown Test'],[],0,1,0,16
1900_47.0_rxjava2-extras_testwithid,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/1900_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/1900_actual.java,"package com.github.davidmoten.rx2;

import static org.junit.Assert.assertEquals;

import org.junit.Assert;
import org.junit.Test;

import com.github.davidmoten.junit.Asserts;

import io.reactivex.Scheduler;
import io.reactivex.Scheduler.Worker;
import io.reactivex.schedulers.Schedulers;

public class SchedulerHelperTest {

    @Test
    public void testIsUtilityClass() {
        Asserts.assertIsUtilityClass(SchedulerHelper.class);
    }

    @Test
    public void testWithId() {
        Scheduler s = SchedulerHelper.withThreadId(Schedulers.trampoline(), ""boo"");
        final StringBuilder b = new StringBuilder();
        String main = Thread.currentThread().getName();
        s.createWorker().schedule(new Runnable() {

            @Override
            public void run() {
                b.append(Thread.currentThread().getName());
            }
        });
        assertEquals(main + ""|schedId=[boo]"", b.toString());
    }

    @Test
    public void testDispose() {
        Scheduler s = SchedulerHelper.withThreadId(Schedulers.trampoline(), ""boo"");
        Worker w = s.createWorker();
        Assert.assertFalse(w.isDisposed());
        w.dispose();
        Assert.assertTrue(w.isDisposed());
    }

    @Test
    public void testWithCallSite() {
        Scheduler s = SchedulerHelper.withThreadIdFromCallSite(Schedulers.trampoline());
        final StringBuilder b = new StringBuilder();
        String main = Thread.currentThread().getName();
        s.createWorker().schedule(new Runnable() {

            @Override
            public void run() {
                b.append(Thread.currentThread().getName());
            }
        });
        System.out.println(b);
        assertEquals(main + ""|schedId=[com.github.davidmoten.rx2.SchedulerHelperTest:testWithCallSite:47]"",
                b.toString());
    }

}
","package com.github.davidmoten.rx2;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import com.github.davidmoten.rx2.internal.SchedulerWithId;

import io.reactivex.Scheduler;
import io.reactivex.Scheduler.Worker;

public final class SchedulerHelper {

    private SchedulerHelper() {
        // prevent instantiation
    }

    public static Scheduler withThreadIdFromCallSite(Scheduler scheduler) {
        return new SchedulerWithId(scheduler, describeCallSite());
    }

    public static Scheduler withThreadId(Scheduler scheduler, String id) {
        return new SchedulerWithId(scheduler, id);
    }

    private static String describeCallSite() {
        StackTraceElement[] elements = Thread.currentThread().getStackTrace();
        StackTraceElement e = elements[3];
        return e.getClassName() + "":"" + e.getMethodName() + "":"" + e.getLineNumber();
    }

    public static void blockUntilWorkFinished(Scheduler scheduler, int numThreads, long timeout, TimeUnit unit) {
        final CountDownLatch latch = new CountDownLatch(numThreads);
        for (int i = 1; i <= numThreads; i++) {
            final Worker worker = scheduler.createWorker();
            worker.schedule(new Runnable() {
                @Override
                public void run() {
                    worker.dispose();
                    latch.countDown();
                }
            });
        }
        try {
            boolean finished = latch.await(timeout, unit);
            if (!finished) {
                throw new RuntimeException(""timeout occured waiting for work to finish"");
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    public static void blockUntilWorkFinished(Scheduler scheduler, int numThreads) {
        blockUntilWorkFinished(scheduler, numThreads, 1, TimeUnit.MINUTES);
    }
}
","['Assertion Roulette', 'Print Statement', 'Sensitive Equality', 'Lazy Test']",['Redundant Assertion'],1,4,0,12
48387_13.0_nexus-repository-helm_filename,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/48387_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/48387_actual.java,"/*
 * Sonatype Nexus (TM) Open Source Version
 * Copyright (c) 2018-present Sonatype, Inc.
 * All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.
 *
 * This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,
 * which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.
 *
 * Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. ""Sonatype"" and ""Sonatype Nexus"" are trademarks
 * of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the
 * Eclipse Foundation. All other trademarks are the property of their respective owners.
 */
package org.sonatype.repository.helm.internal.util;

import java.util.HashMap;
import java.util.Map;

import org.sonatype.goodies.testsupport.TestSupport;
import org.sonatype.nexus.repository.view.matchers.token.TokenMatcher;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.core.Is.is;
import static org.mockito.Mockito.when;
import static org.hamcrest.MatcherAssert.assertThat;

public class HelmPathUtilsTest
    extends TestSupport
{
  private static final String FILENAME = ""mongodb-0.4.9.tgz"";

  private HelmPathUtils underTest;

  @Mock
  private TokenMatcher.State state;

  @Before
  public void setUp() throws Exception {
    underTest = new HelmPathUtils();
  }

  @Test
  public void filename() throws Exception {
    Map<String, String> map = new HashMap<>();
    map.put(""filename"", FILENAME);
    when(state.getTokens()).thenReturn(map);
    String result = underTest.filename(state);
    assertThat(result, is(equalTo(FILENAME)));
  }
}
","/*
 * Sonatype Nexus (TM) Open Source Version
 * Copyright (c) 2018-present Sonatype, Inc.
 * All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.
 *
 * This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,
 * which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.
 *
 * Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. ""Sonatype"" and ""Sonatype Nexus"" are trademarks
 * of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the
 * Eclipse Foundation. All other trademarks are the property of their respective owners.
 */
package org.sonatype.repository.helm.internal.util;

import javax.inject.Named;
import javax.inject.Singleton;

import org.sonatype.nexus.repository.view.Context;
import org.sonatype.nexus.repository.view.matchers.token.TokenMatcher;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * Utility methods for working with Helm routes and paths.
 *
 * @since 0.0.1
 */
@Named
@Singleton
public class HelmPathUtils
{
  /**
   * Returns the filename from a {@link TokenMatcher.State}.
   */
  public String filename(final TokenMatcher.State state) {
    return match(state, ""filename"");
  }

  public String contentFilePath(final TokenMatcher.State state) {
    return String.format(""/%s"",filename(state));
  }

  public String extension(final TokenMatcher.State state) {
    return match(state, ""extension"");
  }

  /**
   * Utility method encapsulating getting a particular token by name from a matcher, including preconditions.
   */
  private String match(final TokenMatcher.State state, final String name) {
    checkNotNull(state);
    String result = state.getTokens().get(name);
    checkNotNull(result);
    return result;
  }

  /**
   * Returns the {@link TokenMatcher.State} for the content.
   */
  public TokenMatcher.State matcherState(final Context context) {
    return context.getAttributes().require(TokenMatcher.State.class);
  }

  public String buildAssetPath(final TokenMatcher.State matcherState) {
    String filename = filename(matcherState);
    String extension = extension(matcherState);
    return filename + ""."" + extension;
  }

  public String buildContentAssetPath(final TokenMatcher.State matcherState) {
    return String.format(""/%s"", buildAssetPath(matcherState));
  }
}
",[],[],0,0,0,17
8186_27.0_querydsl_delete,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8186_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8186_actual.java,"/*
 * Copyright 2015, The Querydsl Team (http://www.querydsl.com/team)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.querydsl.sql.oracle;

import static org.junit.Assert.assertNotNull;

import java.sql.Connection;
import java.util.function.Supplier;

import org.easymock.EasyMock;
import org.junit.Before;
import org.junit.Test;

import com.querydsl.sql.SQLTemplates;
import com.querydsl.sql.domain.QSurvey;

public class OracleQueryFactoryTest {

    private OracleQueryFactory queryFactory;

    @Before
    public void setUp() {
        Supplier<Connection> provider = () -> EasyMock.<Connection> createNiceMock(Connection.class);
        queryFactory = new OracleQueryFactory(SQLTemplates.DEFAULT, provider);
    }

    @Test
    public void query() {
        assertNotNull(queryFactory.query());
    }

    @Test
    public void from() {
        assertNotNull(queryFactory.from(QSurvey.survey));
    }

    @Test
    public void delete() {
        assertNotNull(queryFactory.delete(QSurvey.survey));
    }

    @Test
    public void insert() {
        assertNotNull(queryFactory.insert(QSurvey.survey));
    }

    @Test
    public void update() {
        assertNotNull(queryFactory.update(QSurvey.survey));
    }

    @Test
    public void merge() {
        assertNotNull(queryFactory.merge(QSurvey.survey));
    }

}
","/*
 * Copyright 2015, The Querydsl Team (http://www.querydsl.com/team)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.querydsl.sql.oracle;

import java.sql.Connection;
import java.util.function.Supplier;

import com.querydsl.core.Tuple;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.dsl.Expressions;
import com.querydsl.sql.*;

/**
 * Oracle specific implementation of SQLQueryFactory
 *
 * @author tiwe
 *
 */
public class OracleQueryFactory extends AbstractSQLQueryFactory<OracleQuery<?>> {

    public OracleQueryFactory(Configuration configuration, Supplier<Connection> connection) {
        super(configuration, connection);
    }

    public OracleQueryFactory(Supplier<Connection> connection) {
        this(new Configuration(new OracleTemplates()), connection);
    }

    public OracleQueryFactory(SQLTemplates templates, Supplier<Connection> connection) {
        this(new Configuration(templates), connection);
    }

    @Override
    public OracleQuery<?> query() {
        return new OracleQuery<Void>(connection, configuration);
    }

    @Override
    public <T> OracleQuery<T> select(Expression<T> expr) {
        return query().select(expr);
    }

    @Override
    public OracleQuery<Tuple> select(Expression<?>... exprs) {
        return query().select(exprs);
    }

    @Override
    public <T> OracleQuery<T> selectDistinct(Expression<T> expr) {
        return query().select(expr).distinct();
    }

    @Override
    public OracleQuery<Tuple> selectDistinct(Expression<?>... exprs) {
        return query().select(exprs).distinct();
    }

    @Override
    public OracleQuery<Integer> selectZero() {
        return select(Expressions.ZERO);
    }

    @Override
    public OracleQuery<Integer> selectOne() {
        return select(Expressions.ONE);
    }

    @Override
    public <T> OracleQuery<T> selectFrom(RelationalPath<T> expr) {
        return select(expr).from(expr);
    }

}
",[],[],0,0,0,17
8188_27.0_querydsl_update,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8188_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8188_actual.java,"/*
 * Copyright 2015, The Querydsl Team (http://www.querydsl.com/team)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.querydsl.sql.oracle;

import static org.junit.Assert.assertNotNull;

import java.sql.Connection;
import java.util.function.Supplier;

import org.easymock.EasyMock;
import org.junit.Before;
import org.junit.Test;

import com.querydsl.sql.SQLTemplates;
import com.querydsl.sql.domain.QSurvey;

public class OracleQueryFactoryTest {

    private OracleQueryFactory queryFactory;

    @Before
    public void setUp() {
        Supplier<Connection> provider = () -> EasyMock.<Connection> createNiceMock(Connection.class);
        queryFactory = new OracleQueryFactory(SQLTemplates.DEFAULT, provider);
    }

    @Test
    public void query() {
        assertNotNull(queryFactory.query());
    }

    @Test
    public void from() {
        assertNotNull(queryFactory.from(QSurvey.survey));
    }

    @Test
    public void delete() {
        assertNotNull(queryFactory.delete(QSurvey.survey));
    }

    @Test
    public void insert() {
        assertNotNull(queryFactory.insert(QSurvey.survey));
    }

    @Test
    public void update() {
        assertNotNull(queryFactory.update(QSurvey.survey));
    }

    @Test
    public void merge() {
        assertNotNull(queryFactory.merge(QSurvey.survey));
    }

}
","/*
 * Copyright 2015, The Querydsl Team (http://www.querydsl.com/team)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.querydsl.sql.oracle;

import java.sql.Connection;
import java.util.function.Supplier;

import com.querydsl.core.Tuple;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.dsl.Expressions;
import com.querydsl.sql.*;

/**
 * Oracle specific implementation of SQLQueryFactory
 *
 * @author tiwe
 *
 */
public class OracleQueryFactory extends AbstractSQLQueryFactory<OracleQuery<?>> {

    public OracleQueryFactory(Configuration configuration, Supplier<Connection> connection) {
        super(configuration, connection);
    }

    public OracleQueryFactory(Supplier<Connection> connection) {
        this(new Configuration(new OracleTemplates()), connection);
    }

    public OracleQueryFactory(SQLTemplates templates, Supplier<Connection> connection) {
        this(new Configuration(templates), connection);
    }

    @Override
    public OracleQuery<?> query() {
        return new OracleQuery<Void>(connection, configuration);
    }

    @Override
    public <T> OracleQuery<T> select(Expression<T> expr) {
        return query().select(expr);
    }

    @Override
    public OracleQuery<Tuple> select(Expression<?>... exprs) {
        return query().select(exprs);
    }

    @Override
    public <T> OracleQuery<T> selectDistinct(Expression<T> expr) {
        return query().select(expr).distinct();
    }

    @Override
    public OracleQuery<Tuple> selectDistinct(Expression<?>... exprs) {
        return query().select(exprs).distinct();
    }

    @Override
    public OracleQuery<Integer> selectZero() {
        return select(Expressions.ZERO);
    }

    @Override
    public OracleQuery<Integer> selectOne() {
        return select(Expressions.ONE);
    }

    @Override
    public <T> OracleQuery<T> selectFrom(RelationalPath<T> expr) {
        return select(expr).from(expr);
    }

}
",[],[],0,0,0,17
8674_27.0_querydsl_equals_and_hashcode,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8674_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/8674_actual.java,"/*
 * Copyright 2015, The Querydsl Team (http://www.querydsl.com/team)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.querydsl.codegen;

import static org.junit.Assert.assertEquals;

import java.util.Collections;

import org.junit.Test;

import com.querydsl.codegen.utils.model.SimpleType;
import com.querydsl.codegen.utils.model.Type;
import com.querydsl.codegen.utils.model.TypeCategory;

public class PropertyTest {

    @Test
    public void equals_and_hashCode() {
        Type typeModel = new SimpleType(TypeCategory.ENTITY, ""com.querydsl.DomainClass"", ""com.querydsl"", ""DomainClass"", false,false);
        EntityType type = new EntityType(typeModel);
        Property p1 = new Property(type, ""property"", type, Collections.<String>emptyList());
        Property p2 = new Property(type, ""property"", type, Collections.<String>emptyList());
        assertEquals(p1, p1);
        assertEquals(p1, p2);
        assertEquals(p1.hashCode(), p2.hashCode());
    }

    @Test
    public void escapedName() {
        Type typeModel = new SimpleType(TypeCategory.ENTITY, ""com.querydsl.DomainClass"", ""com.querydsl"", ""DomainClass"", false,false);
        EntityType type = new EntityType(typeModel);
        Property property = new Property(type, ""boolean"", type, Collections.<String>emptyList());
        assertEquals(""boolean$"", property.getEscapedName());
    }

}
","/*
 * Copyright 2015, The Querydsl Team (http://www.querydsl.com/team)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.querydsl.codegen;

import java.lang.annotation.Annotation;
import java.util.*;

import javax.lang.model.SourceVersion;

import com.querydsl.codegen.utils.model.Type;

/**
 * {@code Property} represents a property in a query domain type.
 *
 * @author tiwe
 */
public final class Property implements Comparable<Property> {

    private final EntityType declaringType;

    private final boolean inherited;

    private final List<String> inits;

    private final String name, escapedName;

    private final Map<Class<?>,Annotation> annotations = new HashMap<Class<?>,Annotation>();

    private final Map<Object, Object> data = new HashMap<Object,Object>();

    private final Type type;

    public Property(EntityType declaringType, String name, Type type) {
        this(declaringType, name, type, Collections.<String>emptyList(), false);
    }

    public Property(EntityType declaringType, String name, Type type, List<String> inits) {
        this(declaringType, name, type, inits, false);
    }

    public Property(EntityType declaringType, String name, Type type, List<String> inits,
            boolean inherited) {
        this(declaringType, name, escapeName(name), type, inits, inherited);
    }

    public Property(EntityType declaringType, String name, String escapedName, Type type,
            List<String> inits, boolean inherited) {
        this.declaringType = declaringType;
        this.name = name;
        this.escapedName = escapedName;
        this.type = type;
        this.inits = inits;
        this.inherited = inherited;
    }

    private static String escapeName(String name) {
        if (SourceVersion.isKeyword(name)) {
            name = name + ""$"";
        } else if (!Character.isJavaIdentifierStart(name.charAt(0))) {
            name = ""_"" + name;
        }
        return name;
    }

    public void addAnnotation(Annotation annotation) {
        annotations.put(annotation.annotationType(), annotation);
    }

    @Override
    public int compareTo(Property o) {
        int rv = name.compareToIgnoreCase(o.getName());
        if (rv == 0) {
            return name.compareTo(o.getName());
        } else {
            return rv;
        }
    }

    public Property createCopy(EntityType targetModel) {
        if (!declaringType.getParameters().isEmpty()) {
            Type newType = TypeResolver.resolve(type, declaringType, targetModel);
            if (!newType.equals(type) || !newType.getClass().equals(type.getClass())) {
                return new Property(targetModel, name, newType, inits, false);
            } else {
                return new Property(targetModel, name, type, inits, targetModel.getSuperType() != null);
            }
        } else {
            return new Property(targetModel, name, type, inits, targetModel.getSuperType() != null);
        }
    }

    @SuppressWarnings(""unchecked"")
    public <T extends Annotation> T getAnnotation(Class<T> type) {
        return (T) annotations.get(type);
    }

    public Collection<Annotation> getAnnotations() {
        return Collections.unmodifiableCollection(annotations.values());
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, type);
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        } else if (o instanceof Property) {
            Property p = (Property) o;
            return p.name.equals(name) && p.type.equals(type);
        } else {
            return false;
        }
    }

    public EntityType getDeclaringType() {
        return declaringType;
    }

    public String getEscapedName() {
        return escapedName;
    }

    public List<String> getInits() {
        return inits;
    }

    public String getName() {
        return name;
    }

    public Type getParameter(int i) {
        return type.getParameters().get(i);
    }

    public Map<Object, Object> getData() {
        return data;
    }

    public Type getType() {
        return type;
    }

    public boolean isInherited() {
        return inherited;
    }

    @Override
    public String toString() {
        return declaringType.getFullName() + ""."" + name;
    }

}
","['Assertion Roulette', 'Redundant Assertion']",[],0,2,0,15
32043_4.0_hadoop_testtombstonereconcilingiterator,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/32043_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/32043_actual.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hadoop.fs.s3a;

import java.util.NoSuchElementException;

import org.junit.Assert;
import org.junit.Test;

import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.RemoteIterator;

import static org.apache.hadoop.test.LambdaTestUtils.intercept;

/**
 * Place for the S3A listing classes; keeps all the small classes under control.
 */
public class TestListing extends AbstractS3AMockTest {

  @Test
  public void testProvidedFileStatusIteratorEnd() throws Exception {
    S3AFileStatus s3aStatus = new S3AFileStatus(
        100, 0, new Path(""s3a://blah/blah""),
        8192, null, null, null);

    S3AFileStatus[] statuses = {
        s3aStatus
    };
    RemoteIterator<S3AFileStatus> it = Listing.toProvidedFileStatusIterator(
        statuses);

    Assert.assertTrue(""hasNext() should return true first time"", it.hasNext());
    Assert.assertEquals(""first element from iterator"",
        s3aStatus, it.next());
    Assert.assertFalse(""hasNext() should now be false"", it.hasNext());
    intercept(NoSuchElementException.class, it::next);
  }
}
","/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hadoop.fs.s3a;

import software.amazon.awssdk.services.s3.model.CommonPrefix;
import software.amazon.awssdk.services.s3.model.S3Object;

import org.apache.hadoop.classification.InterfaceAudience;
import org.apache.hadoop.classification.VisibleForTesting;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.LocatedFileStatus;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.PathFilter;
import org.apache.hadoop.fs.RemoteIterator;
import org.apache.hadoop.fs.s3a.impl.AbstractStoreOperation;
import org.apache.hadoop.fs.s3a.impl.ListingOperationCallbacks;
import org.apache.hadoop.fs.s3a.impl.StoreContext;
import org.apache.hadoop.fs.statistics.IOStatistics;
import org.apache.hadoop.fs.statistics.IOStatisticsAggregator;
import org.apache.hadoop.fs.statistics.IOStatisticsSource;
import org.apache.hadoop.fs.statistics.IOStatisticsContext;
import org.apache.hadoop.fs.statistics.impl.IOStatisticsStore;
import org.apache.hadoop.fs.store.audit.AuditSpan;
import org.apache.hadoop.util.functional.RemoteIterators;

import org.slf4j.Logger;

import java.io.Closeable;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import java.util.concurrent.CompletableFuture;
import java.util.StringJoiner;

import static org.apache.hadoop.fs.s3a.Constants.S3N_FOLDER_SUFFIX;
import static org.apache.hadoop.fs.s3a.Invoker.onceInTheFuture;
import static org.apache.hadoop.fs.s3a.S3AUtils.ACCEPT_ALL;
import static org.apache.hadoop.fs.s3a.S3AUtils.createFileStatus;
import static org.apache.hadoop.fs.s3a.S3AUtils.maybeAddTrailingSlash;
import static org.apache.hadoop.fs.s3a.S3AUtils.objectRepresentsDirectory;
import static org.apache.hadoop.fs.s3a.S3AUtils.stringify;
import static org.apache.hadoop.fs.s3a.auth.RoleModel.pathToKey;
import static org.apache.hadoop.fs.statistics.StoreStatisticNames.OBJECT_CONTINUE_LIST_REQUEST;
import static org.apache.hadoop.fs.statistics.StoreStatisticNames.OBJECT_LIST_REQUEST;
import static org.apache.hadoop.fs.statistics.impl.IOStatisticsBinding.iostatisticsStore;
import static org.apache.hadoop.util.functional.RemoteIterators.filteringRemoteIterator;
import static org.apache.hadoop.util.functional.RemoteIterators.remoteIteratorFromArray;
import static org.apache.hadoop.util.functional.RemoteIterators.remoteIteratorFromSingleton;

/**
 * Place for the S3A listing classes; keeps all the small classes under control.
 *
 * Spans passed in are attached to the listing iterators returned, but are not
 * closed at the end of the iteration. This is because the same span
 */
@InterfaceAudience.Private
public class Listing extends AbstractStoreOperation {

  private static final Logger LOG = S3AFileSystem.LOG;
  private final boolean isCSEEnabled;

  static final FileStatusAcceptor ACCEPT_ALL_BUT_S3N =
      new AcceptAllButS3nDirs();

  private final ListingOperationCallbacks listingOperationCallbacks;

  public Listing(ListingOperationCallbacks listingOperationCallbacks,
      StoreContext storeContext) {
    super(storeContext);
    this.listingOperationCallbacks = listingOperationCallbacks;
    this.isCSEEnabled = storeContext.isCSEEnabled();
  }

  /**
   * Create a FileStatus iterator against a provided list of file status, with
   * a given status filter.
   *
   * @param fileStatuses the provided list of file status. NO remote calls.
   * @param filter file path filter on which paths to accept
   * @param acceptor the file status acceptor
   * @return the file status iterator
   */
  RemoteIterator<S3AFileStatus> createProvidedFileStatusIterator(
      S3AFileStatus[] fileStatuses,
      PathFilter filter,
      FileStatusAcceptor acceptor) {
    return filteringRemoteIterator(
        remoteIteratorFromArray(fileStatuses),
        status ->
            filter.accept(status.getPath()) && acceptor.accept(status));
  }

  /**
   * Create a FileStatus iterator against a provided list of file status.
   * @param fileStatuses array of file status.
   * @return the file status iterator.
   */
  @VisibleForTesting
  public static RemoteIterator<S3AFileStatus> toProvidedFileStatusIterator(
          S3AFileStatus[] fileStatuses) {
    return filteringRemoteIterator(
        remoteIteratorFromArray(fileStatuses),
        Listing.ACCEPT_ALL_BUT_S3N::accept);
  }

  /**
   * Create a FileStatus iterator against a path, with a given
   * list object request.
   * @param listPath path of the listing
   * @param request initial request to make
   * @param filter the filter on which paths to accept
   * @param acceptor the class/predicate to decide which entries to accept
   * in the listing based on the full file status.
   * @param span audit span for this iterator
   * @return the iterator
   * @throws IOException IO Problems
   */
  @Retries.RetryRaw
  public FileStatusListingIterator createFileStatusListingIterator(
      Path listPath,
      S3ListRequest request,
      PathFilter filter,
      FileStatusAcceptor acceptor,
      AuditSpan span) throws IOException {
    return new FileStatusListingIterator(
        createObjectListingIterator(listPath, request, span),
        filter,
        acceptor);
  }

  /**
   * Create an object listing iterator against a path, with a given
   * list object request.
   * @param listPath path of the listing
   * @param request initial request to make
   * @param span audit span for this iterator
   * @return the iterator
   * @throws IOException IO Problems
   */
  @Retries.RetryRaw
  private ObjectListingIterator createObjectListingIterator(
      final Path listPath,
      final S3ListRequest request,
      final AuditSpan span) throws IOException {
    return new ObjectListingIterator(listPath, request, span);
  }

  /**
   * Create a located status iterator over a file status iterator.
   * @param statusIterator an iterator over the remote status entries
   * @return a new remote iterator
   */
  @VisibleForTesting
  public RemoteIterator<S3ALocatedFileStatus> createLocatedFileStatusIterator(
      RemoteIterator<S3AFileStatus> statusIterator) {
    return RemoteIterators.mappingRemoteIterator(
        statusIterator,
        listingOperationCallbacks::toLocatedFileStatus);
  }

  /**
   * Create a remote iterator from a single status entry.
   * @param status status
   * @return iterator.
   */
  public RemoteIterator<S3ALocatedFileStatus> createSingleStatusIterator(
      S3ALocatedFileStatus status) {
    return remoteIteratorFromSingleton(status);
  }

  /**
   * List files under a path assuming the path to be a directory.
   * @param path input path.
   * @param recursive recursive listing?
   * @param acceptor file status filter
   * @param span audit span for this iterator
   * @return an iterator over listing.
   * @throws IOException any exception.
   */
  public RemoteIterator<S3ALocatedFileStatus> getListFilesAssumingDir(
      Path path,
      boolean recursive, FileStatusAcceptor acceptor,
      AuditSpan span) throws IOException {

    String key = maybeAddTrailingSlash(pathToKey(path));
    String delimiter = recursive ? null : ""/"";
    if (recursive) {
      LOG.debug(""Recursive list of all entries under {}"", key);
    } else {
      LOG.debug(""Requesting all entries under {} with delimiter '{}'"",
          key, delimiter);
    }
    return createLocatedFileStatusIterator(
        createFileStatusListingIterator(path,
            listingOperationCallbacks
                .createListObjectsRequest(key,
                    delimiter,
                    span),
            ACCEPT_ALL,
            acceptor,
            span));
  }

  /**
   * Generate list located status for a directory.
   * @param dir directory to check.
   * @param filter a path filter.
   * @param span audit span for this iterator
   * @return an iterator that traverses statuses of the given dir.
   * @throws IOException in case of failure.
   */
  public RemoteIterator<S3ALocatedFileStatus> getLocatedFileStatusIteratorForDir(
          Path dir, PathFilter filter, AuditSpan span) throws IOException {
    span.activate();
    final String key = maybeAddTrailingSlash(pathToKey(dir));

    return createLocatedFileStatusIterator(
        createFileStatusListingIterator(dir,
            listingOperationCallbacks
                .createListObjectsRequest(key, ""/"", span),
            filter,
            new AcceptAllButSelfAndS3nDirs(dir),
            span));
  }

  /**
   * Calculate list of file statuses assuming path
   * to be a non-empty directory.
   * @param path input path.
   * @param span audit span for this iterator
   * @return iterator of file statuses.
   * @throws IOException Any IO problems.
   */
  @Retries.RetryRaw
  public RemoteIterator<S3AFileStatus>
        getFileStatusesAssumingNonEmptyDir(Path path, final AuditSpan span)
          throws IOException {
    String key = pathToKey(path);
    if (!key.isEmpty()) {
      key = key + '/';
    }

    S3ListRequest request = createListObjectsRequest(key, ""/"", span);
    LOG.debug(""listStatus: doing listObjects for directory \""{}\"""", key);

    // return the results obtained from s3.
    return createFileStatusListingIterator(
        path,
        request,
        ACCEPT_ALL,
        new AcceptAllButSelfAndS3nDirs(path),
        span);
  }

  public S3ListRequest createListObjectsRequest(String key,
      String delimiter,
      final AuditSpan span) {
    return listingOperationCallbacks.createListObjectsRequest(key, delimiter,
        span);
  }

  /**
   * Interface to implement the logic deciding whether to accept a s3Object
   * entry or path as a valid file or directory.
   */
  interface FileStatusAcceptor {

    /**
     * Predicate to decide whether or not to accept a s3Object entry.
     * @param keyPath qualified path to the entry
     * @param s3Object s3Object entry
     * @return true if the entry is accepted (i.e. that a status entry
     * should be generated.
     */
    boolean accept(Path keyPath, S3Object s3Object);

    /**
     * Predicate to decide whether or not to accept a prefix.
     * @param keyPath qualified path to the entry
     * @param commonPrefix the prefix
     * @return true if the entry is accepted (i.e. that a status entry
     * should be generated.)
     */
    boolean accept(Path keyPath, String commonPrefix);

    /**
     * Predicate to decide whether or not to accept a file status.
     * @param status file status containing file path information
     * @return true if the status is accepted else false
     */
    boolean accept(FileStatus status);
  }

  /**
   * Wraps up object listing into a remote iterator which will ask for more
   * listing data if needed.
   *
   * This is a complex operation, especially the process to determine
   * if there are more entries remaining. If there are no more results
   * remaining in the (filtered) results of the current listing request, then
   * another request is made <i>and those results filtered</i> before the
   * iterator can declare that there is more data available.
   *
   * The need to filter the results precludes the iterator from simply
   * declaring that if the {@link ObjectListingIterator#hasNext()}
   * is true then there are more results. Instead the next batch of results must
   * be retrieved and filtered.
   *
   * What does this mean? It means that remote requests to retrieve new
   * batches of object listings are made in the {@link #hasNext()} call;
   * the {@link #next()} call simply returns the filtered results of the last
   * listing processed. However, do note that {@link #next()} calls
   * {@link #hasNext()} during its operation. This is critical to ensure
   * that a listing obtained through a sequence of {@link #next()} will
   * complete with the same set of results as a classic
   * {@code while(it.hasNext()} loop.
   *
   * Thread safety: None.
   */
  class FileStatusListingIterator
      implements RemoteIterator<S3AFileStatus>, IOStatisticsSource, Closeable {

    /** Source of objects. */
    private final ObjectListingIterator source;
    /** Filter of paths from API call. */
    private final PathFilter filter;
    /** Filter of entries from file status. */
    private final FileStatusAcceptor acceptor;
    /** request batch size. */
    private int batchSize;
    /** Iterator over the current set of results. */
    private ListIterator<S3AFileStatus> statusBatchIterator;


    /**
     * Create an iterator over file status entries.
     * @param source the listing iterator from a listObjects call.
     * @param filter the filter on which paths to accept
     * @param acceptor the class/predicate to decide which entries to accept
     * in the listing based on the full file status.
     * @throws IOException IO Problems
     */
    @Retries.RetryTranslated
    FileStatusListingIterator(ObjectListingIterator source,
        PathFilter filter,
        FileStatusAcceptor acceptor)
        throws IOException {
      this.source = source;
      this.filter = filter;
      this.acceptor = acceptor;

      // build the first set of results. This will not trigger any
      // remote IO, assuming the source iterator is in its initial
      // iteration
      requestNextBatch();
    }

    /**
     * Report whether or not there is new data available.
     * If there is data in the local filtered list, return true.
     * Else: request more data util that condition is met, or there
     * is no more remote listing data.
     * Lastly, return true if the {@code providedStatusIterator}
     * has left items.
     * @return true if a call to {@link #next()} will succeed.
     * @throws IOException IO Problems
     */
    @Override
    @Retries.RetryTranslated
    public boolean hasNext() throws IOException {
      return sourceHasNext();
    }

    @Retries.RetryTranslated
    private boolean sourceHasNext() throws IOException {
      return statusBatchIterator.hasNext() || requestNextBatch();
    }

    @Override
    @Retries.RetryTranslated
    public S3AFileStatus next() throws IOException {
      final S3AFileStatus status;
      if (sourceHasNext()) {
        status = statusBatchIterator.next();
      } else {
        throw new NoSuchElementException();
      }
      return status;
    }

    /**
     * Close, if called, will update
     * the thread statistics context with the value.
     */
    @Override
    public void close() {
      source.close();
    }
    /**
     * Try to retrieve another batch.
     * Note that for the initial batch,
     * {@link ObjectListingIterator} does not generate a request;
     * it simply returns the initial set.
     *
     * @return true if a new batch was created.
     * @throws IOException IO problems
     */
    @Retries.RetryTranslated
    private boolean requestNextBatch() throws IOException {
      // look for more object listing batches being available
      while (source.hasNext()) {
        // if available, retrieve it and build the next status
        if (buildNextStatusBatch(source.next())) {
          // this batch successfully generated entries matching the filters/
          // acceptors; declare that the request was successful
          return true;
        } else {
          LOG.debug(""All entries in batch were filtered...continuing"");
        }
      }
      // if this code is reached, it means that all remaining
      // object lists have been retrieved, and there are no new entries
      // to return.
      return false;
    }

    /**
     * Build the next status batch from a listing.
     * @param objects the next object listing
     * @return true if this added any entries after filtering
     */
    private boolean buildNextStatusBatch(S3ListResult objects) {
      // counters for debug logs
      int added = 0, ignored = 0;
      // list to fill in with results. Initial size will be list maximum.
      List<S3AFileStatus> stats = new ArrayList<>(
          objects.getS3Objects().size() +
              objects.getCommonPrefixes().size());
      // objects
      for (S3Object s3Object : objects.getS3Objects()) {
        String key = s3Object.key();
        Path keyPath = getStoreContext().getContextAccessors().keyToPath(key);
        if (LOG.isDebugEnabled()) {
          LOG.debug(""{}: {}"", keyPath, stringify(s3Object));
        }
        // Skip over keys that are ourselves and old S3N _$folder$ files
        if (acceptor.accept(keyPath, s3Object) && filter.accept(keyPath)) {
          S3AFileStatus status = createFileStatus(keyPath, s3Object,
                  listingOperationCallbacks.getDefaultBlockSize(keyPath),
                  getStoreContext().getUsername(),
                  s3Object.eTag(), null, isCSEEnabled);
          LOG.debug(""Adding: {}"", status);
          stats.add(status);
          added++;
        } else {
          LOG.debug(""Ignoring: {}"", keyPath);
          ignored++;
        }
      }

      // prefixes: always directories
      for (CommonPrefix prefix : objects.getCommonPrefixes()) {
        Path keyPath = getStoreContext()
                .getContextAccessors()
                .keyToPath(prefix.prefix());
        if (acceptor.accept(keyPath, prefix.prefix()) && filter.accept(keyPath)) {
          S3AFileStatus status = new S3AFileStatus(Tristate.FALSE, keyPath,
              getStoreContext().getUsername());
          LOG.debug(""Adding directory: {}"", status);
          added++;
          stats.add(status);
        } else {
          LOG.debug(""Ignoring directory: {}"", keyPath);
          ignored++;
        }
      }

      // finish up
      batchSize = stats.size();
      statusBatchIterator = stats.listIterator();
      boolean hasNext = statusBatchIterator.hasNext();
      LOG.debug(""Added {} entries; ignored {}; hasNext={}; hasMoreObjects={}"",
          added, ignored, hasNext, objects.isTruncated());
      return hasNext;
    }

    /**
     * Get the number of entries in the current batch.
     * @return a number, possibly zero.
     */
    public int getBatchSize() {
      return batchSize;
    }

    /**
     * Return any IOStatistics provided by the underlying stream.
     * @return IO stats from the inner stream.
     */
    @Override
    public IOStatistics getIOStatistics() {
      return source.getIOStatistics();
    }

    @Override
    public String toString() {
      return new StringJoiner("", "",
          FileStatusListingIterator.class.getSimpleName() + ""["", ""]"")
          .add(source.toString())
          .toString();
    }
  }

  /**
   * Wraps up AWS `ListObjects` requests in a remote iterator
   * which will ask for more listing data if needed.
   *
   * That is:
   *
   * 1. The first invocation of the {@link #next()} call will return the results
   * of the first request, the one created during the construction of the
   * instance.
   *
   * 2. Second and later invocations will continue the ongoing listing,
   * calling {@link S3AFileSystem#continueListObjects} to request the next
   * batch of results.
   *
   * 3. The {@link #hasNext()} predicate returns true for the initial call,
   * where {@link #next()} will return the initial results. It declares
   * that it has future results iff the last executed request was truncated.
   *
   * Thread safety: none.
   */
  class ObjectListingIterator implements RemoteIterator<S3ListResult>,
      IOStatisticsSource, Closeable {

    /** The path listed. */
    private final Path listPath;

    private final AuditSpan span;

    /**
     * Context statistics aggregator.
     */
    private final IOStatisticsAggregator aggregator;

    /** The most recent listing results. */
    private S3ListResult objects;

    /** The most recent listing request. */
    private S3ListRequest request;

    /** Indicator that this is the first listing. */
    private boolean firstListing = true;

    /**
     * Count of how many listings have been requested
     * (including initial result).
     */
    private int listingCount = 1;

    /**
     * Maximum keys in a request.
     */
    private int maxKeys;

    private final IOStatisticsStore iostats;

    /**
     * Future to store current batch listing result.
     */
    private CompletableFuture<S3ListResult> s3ListResultFuture;

    /**
     * Result of previous batch.
     */
    private S3ListResult objectsPrev;

    /**
     * Constructor -calls `listObjects()` on the request to populate the
     * initial set of results/fail if there was a problem talking to the bucket.
     * @param listPath path of the listing
     * @param request initial request to make
     * @param span audit span for this iterator.
     * @throws IOException if listObjects raises one.
     */
    @Retries.RetryRaw
    ObjectListingIterator(
        Path listPath,
        S3ListRequest request,
        AuditSpan span) throws IOException {
      this.listPath = listPath;
      this.maxKeys = listingOperationCallbacks.getMaxKeys();
      this.request = request;
      this.objectsPrev = null;
      this.iostats = iostatisticsStore()
          .withDurationTracking(OBJECT_LIST_REQUEST)
          .withDurationTracking(OBJECT_CONTINUE_LIST_REQUEST)
          .build();
      this.span = span;
      this.s3ListResultFuture = listingOperationCallbacks
          .listObjectsAsync(request, iostats, span);
      this.aggregator = IOStatisticsContext.getCurrentIOStatisticsContext()
          .getAggregator();
    }

    /**
     * Declare that the iterator has data if it is either is the initial
     * iteration or it is a later one and the last listing obtained was
     * incomplete.
     * @throws IOException never: there is no IO in this operation.
     */
    @Override
    public boolean hasNext() throws IOException {
      return firstListing ||
              (objectsPrev != null && objectsPrev.isTruncated());
    }

    /**
     * Ask for the next listing.
     * For the first invocation, this returns the initial set, with no
     * remote IO. For later requests, S3 will be queried, hence the calls
     * may block or fail.
     * @return the next object listing.
     * @throws IOException if a query made of S3 fails.
     * @throws NoSuchElementException if there is no more data to list.
     */
    @Override
    @Retries.RetryTranslated
    public S3ListResult next() throws IOException {
      if (firstListing) {
        // clear the firstListing flag for future calls.
        firstListing = false;
        // Calculating the result of last async list call.
        objects = onceInTheFuture(""listObjects()"", listPath.toString(), s3ListResultFuture);
        fetchNextBatchAsyncIfPresent();
      } else {
        if (objectsPrev!= null && !objectsPrev.isTruncated()) {
          // nothing more to request: fail.
          throw new NoSuchElementException(""No more results in listing of ""
              + listPath);
        }
        // Calculating the result of last async list call.
        objects = onceInTheFuture(""listObjects()"", listPath.toString(), s3ListResultFuture);
        // Requesting next batch of results.
        fetchNextBatchAsyncIfPresent();
        listingCount++;
        LOG.debug(""New listing status: {}"", this);
      }
      // Storing the current result to be used by hasNext() call.
      objectsPrev = objects;
      return objectsPrev;
    }

    /**
     * If there are more listings present, call for next batch async.
     */
    private void fetchNextBatchAsyncIfPresent() {
      if (objects.isTruncated()) {
        LOG.debug(""[{}], Requesting next {} objects under {}"",
                listingCount, maxKeys, listPath);
        s3ListResultFuture = listingOperationCallbacks
                .continueListObjectsAsync(request, objects, iostats, span);
      }
    }

    @Override
    public String toString() {
      return ""Object listing iterator against "" + listPath
          + ""; listing count ""+ listingCount
          + ""; isTruncated="" + objects.isTruncated()
          + ""; "" + iostats;
    }

    @Override
    public IOStatistics getIOStatistics() {
      return iostats;
    }

    /**
     * Get the path listed.
     * @return the path used in this listing.
     */
    public Path getListPath() {
      return listPath;
    }

    /**
     * Get the count of listing requests.
     * @return the counter of requests made (including the initial lookup).
     */
    public int getListingCount() {
      return listingCount;
    }

    /**
     * Close, if called, will update
     * the thread statistics context with the value.
     */
    @Override
    public void close() {
      aggregator.aggregate(getIOStatistics());
    }
  }

  /**
   * Accept all entries except the base path and those which map to S3N
   * pseudo directory markers.
   */
  static class AcceptFilesOnly implements FileStatusAcceptor {
    private final Path qualifiedPath;

    public AcceptFilesOnly(Path qualifiedPath) {
      this.qualifiedPath = qualifiedPath;
    }

    /**
     * Reject a s3Object entry if the key path is the qualified Path, or
     * it ends with {@code ""_$folder$""}.
     * @param keyPath key path of the entry
     * @param s3Object s3Object entry
     * @return true if the entry is accepted (i.e. that a status entry
     * should be generated.
     */
    @Override
    public boolean accept(Path keyPath, S3Object s3Object) {
      return !keyPath.equals(qualifiedPath)
          && !s3Object.key().endsWith(S3N_FOLDER_SUFFIX)
          && !objectRepresentsDirectory(s3Object.key());
    }

    /**
     * Accept no directory paths.
     * @param keyPath qualified path to the entry
     * @param prefix common prefix in listing.
     * @return false, always.
     */
    @Override
    public boolean accept(Path keyPath, String prefix) {
      return false;
    }

    @Override
    public boolean accept(FileStatus status) {
      return (status != null) && status.isFile();
    }
  }

  /**
   * Accept all entries except those which map to S3N pseudo directory markers.
   */
  static class AcceptAllButS3nDirs implements FileStatusAcceptor {

    public boolean accept(Path keyPath, S3Object s3Object) {
      return !s3Object.key().endsWith(S3N_FOLDER_SUFFIX);
    }

    public boolean accept(Path keyPath, String prefix) {
      return !keyPath.toString().endsWith(S3N_FOLDER_SUFFIX);
    }

    public boolean accept(FileStatus status) {
      return !status.getPath().toString().endsWith(S3N_FOLDER_SUFFIX);
    }

  }

  /**
   * Accept all entries except the base path and those which map to S3N
   * pseudo directory markers.
   */
  public static class AcceptAllButSelfAndS3nDirs implements FileStatusAcceptor {

    /** Base path. */
    private final Path qualifiedPath;

    /**
     * Constructor.
     * @param qualifiedPath an already-qualified path.
     */
    public AcceptAllButSelfAndS3nDirs(Path qualifiedPath) {
      this.qualifiedPath = qualifiedPath;
    }

    /**
     * Reject a s3Object entry if the key path is the qualified Path, or
     * it ends with {@code ""_$folder$""}.
     * @param keyPath key path of the entry
     * @param s3Object s3Object entry
     * @return true if the entry is accepted (i.e. that a status entry
     * should be generated.)
     */
    @Override
    public boolean accept(Path keyPath, S3Object s3Object) {
      return !keyPath.equals(qualifiedPath) &&
          !s3Object.key().endsWith(S3N_FOLDER_SUFFIX);
    }

    /**
     * Accept all prefixes except the one for the base path, ""self"".
     * @param keyPath qualified path to the entry
     * @param prefix common prefix in listing.
     * @return true if the entry is accepted (i.e. that a status entry
     * should be generated.
     */
    @Override
    public boolean accept(Path keyPath, String prefix) {
      return !keyPath.equals(qualifiedPath);
    }

    @Override
    public boolean accept(FileStatus status) {
      return (status != null) && !status.getPath().equals(qualifiedPath);
    }
  }

  @SuppressWarnings(""unchecked"")
  public static RemoteIterator<LocatedFileStatus> toLocatedFileStatusIterator(
      RemoteIterator<? extends LocatedFileStatus> iterator) {
    return (RemoteIterator < LocatedFileStatus >) iterator;
  }

}
",['Assertion Roulette'],[],0,1,0,16
7672_27.0_querydsl_params,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/7672_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/7672_actual.java,"package com.querydsl.sql;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.Collections;

import org.junit.Test;

import com.querydsl.core.types.dsl.Param;
import com.querydsl.sql.domain.QSurvey;

public class SQLBindingsTest {

    private QSurvey survey = QSurvey.survey;

    private SQLQuery<?> query = new SQLQuery<Void>();

    @Test
    public void empty() {
        SQLBindings bindings = query.getSQL();
        assertEquals(""\nfrom dual"", bindings.getSQL());
        assertTrue(bindings.getNullFriendlyBindings().isEmpty());
    }

    @Test
    public void singleArg() {
        query.from(survey).where(survey.name.eq(""Bob"")).select(survey.id);
        SQLBindings bindings = query.getSQL();
        assertEquals(""select SURVEY.ID\nfrom SURVEY SURVEY\nwhere SURVEY.NAME = ?"", bindings.getSQL());
        assertEquals(Collections.singletonList(""Bob""), bindings.getNullFriendlyBindings());
    }

    @Test
    public void twoArgs() {
        query.from(survey).where(survey.name.eq(""Bob""), survey.name2.eq(""A"")).select(survey.id);
        SQLBindings bindings = query.getSQL();
        assertEquals(""select SURVEY.ID\nfrom SURVEY SURVEY\nwhere SURVEY.NAME = ? and SURVEY.NAME2 = ?"", bindings.getSQL());
        assertEquals(Arrays.asList(""Bob"", ""A""), bindings.getNullFriendlyBindings());
    }

    @Test
    public void params() {
        Param<String> name = new Param<String>(String.class, ""name"");
        query.from(survey).where(survey.name.eq(name), survey.name2.eq(""A"")).select(survey.id);
        query.set(name, ""Bob"");
        SQLBindings bindings = query.getSQL();
        assertEquals(""select SURVEY.ID\nfrom SURVEY SURVEY\nwhere SURVEY.NAME = ? and SURVEY.NAME2 = ?"", bindings.getSQL());
        assertEquals(Arrays.asList(""Bob"", ""A""), bindings.getNullFriendlyBindings());
    }
}
","/*
 * Copyright 2015, The Querydsl Team (http://www.querydsl.com/team)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.querydsl.sql;

import java.util.List;
import java.util.logging.Logger;

import com.querydsl.core.util.CollectionUtils;

/**
 * {@code SQLBindings} provides the SQL query string and bindings
 *
 * @author tiwe
 *
 */
public class SQLBindings {

    private static final Logger log = Logger.getLogger(SQLBindings.class.getName());

    private final String sql;

    private final List<Object> bindings;

    public SQLBindings(String sql, List<Object> bindings) {
        this.sql = sql;
        this.bindings = CollectionUtils.unmodifiableList(bindings);
    }

    public String getSQL() {
        return sql;
    }

    public List<Object> getNullFriendlyBindings() {
        return bindings;
    }

}
","['Assertion Roulette', 'Eager Test', 'Lazy Test']",[],0,3,0,14
43798_17.0_fastjson_test_cast_to_date,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/43798_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/43798_actual.java,"package com.alibaba.json.bvt.util;

import com.alibaba.fastjson.annotation.JSONType;
import com.alibaba.fastjson.serializer.SerializerFeature;
import com.alibaba.fastjson.util.TypeUtils;
import com.alibaba.json.bvt.parser.deser.generic.GenericArrayTest;
import com.jsoniter.spi.GenericArrayTypeImpl;
import junit.framework.TestCase;

import java.lang.reflect.Constructor;
import java.lang.reflect.GenericArrayType;

public class TypeUtilsTest extends TestCase {
    public void test_0() throws Exception {
        assertEquals(0, TypeUtils.getSerializeFeatures(Object.class));
        assertEquals(SerializerFeature.WriteMapNullValue.mask, TypeUtils.getSerializeFeatures(Model.class));
    }

    public void test_1() throws Exception {
        TypeUtils.checkPrimitiveArray((GenericArrayType) A.class.getField(""values"").getGenericType());
    }

    public void test_3() throws Exception {
        assertTrue(TypeUtils.isHibernateInitialized(new Object()));
    }

    public void test_2() throws Exception {
        Constructor<?> constructor = GenericArrayTypeImpl.class.getDeclaredConstructors()[0];
        constructor.setAccessible(true);

        Class[] classes = new Class[] {
            boolean[].class,
            byte[].class,
            short[].class,
            int[].class,
            long[].class,
            float[].class,
            double[].class,
            char[].class,
        };

        for (Class clazz : classes) {
            GenericArrayType type = (GenericArrayType) constructor.newInstance(clazz.getComponentType());
            assertEquals(clazz, TypeUtils.checkPrimitiveArray(type));
        }

    }

    @JSONType(serialzeFeatures = SerializerFeature.WriteMapNullValue)
    public static class Model {

    }

    public static class A<T extends Number> {
        public T[] values;
    }

    public static class VO extends GenericArrayTest.A {

    }
}
","/*
 * Copyright 1999-2017 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.alibaba.fastjson.util;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONException;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.PropertyNamingStrategy;
import com.alibaba.fastjson.annotation.JSONField;
import com.alibaba.fastjson.annotation.JSONType;
import com.alibaba.fastjson.parser.DefaultJSONParser;
import com.alibaba.fastjson.parser.Feature;
import com.alibaba.fastjson.parser.JSONScanner;
import com.alibaba.fastjson.parser.ParserConfig;
import com.alibaba.fastjson.parser.deserializer.EnumDeserializer;
import com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer;
import com.alibaba.fastjson.parser.deserializer.ObjectDeserializer;
import com.alibaba.fastjson.serializer.CalendarCodec;
import com.alibaba.fastjson.serializer.SerializeBeanInfo;
import com.alibaba.fastjson.serializer.SerializerFeature;

import java.io.InputStream;
import java.io.Reader;
import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Clob;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author wenshao[szujobs@hotmail.com]
 */
public class TypeUtils {
    private static final Pattern NUMBER_WITH_TRAILING_ZEROS_PATTERN = Pattern.compile(""\\.0*$"");

    public static boolean compatibleWithJavaBean = false;
    /**
     * 根据field name的大小写输出输入数据
     */
    public static boolean compatibleWithFieldName = false;
    private static boolean setAccessibleEnable = true;
    private static boolean oracleTimestampMethodInited = false;
    private static Method oracleTimestampMethod;
    private static boolean oracleDateMethodInited = false;
    private static Method oracleDateMethod;
    private static boolean optionalClassInited = false;
    private static Class<?> optionalClass;
    private static boolean transientClassInited = false;
    private static Class<? extends Annotation> transientClass;

    private static Class<? extends Annotation> class_OneToMany = null;
    private static boolean class_OneToMany_error = false;
    private static Class<? extends Annotation> class_ManyToMany = null;
    private static boolean class_ManyToMany_error = false;

    private static Method method_HibernateIsInitialized = null;
    private static boolean method_HibernateIsInitialized_error = false;
    private static volatile Class kotlin_metadata;
    private static volatile boolean kotlin_metadata_error;
    private static volatile boolean kotlin_class_klass_error;
    private static volatile Constructor kotlin_kclass_constructor;
    private static volatile Method kotlin_kclass_getConstructors;
    private static volatile Method kotlin_kfunction_getParameters;
    private static volatile Method kotlin_kparameter_getName;
    private static volatile boolean kotlin_error;
    private static volatile Map<Class, String[]> kotlinIgnores;
    private static volatile boolean kotlinIgnores_error;
    private static ConcurrentMap<String, Class<?>> mappings = new ConcurrentHashMap<String, Class<?>>(256, 0.75f, 1);
    private static Class<?> pathClass;
    private static boolean pathClass_error = false;

    private static Class<? extends Annotation> class_JacksonCreator = null;
    private static boolean class_JacksonCreator_error = false;

    private static volatile Class class_XmlAccessType = null;
    private static volatile Class class_XmlAccessorType = null;
    private static volatile boolean classXmlAccessorType_error = false;
    private static volatile Method method_XmlAccessorType_value = null;
    private static volatile Field field_XmlAccessType_FIELD = null;
    private static volatile Object field_XmlAccessType_FIELD_VALUE = null;

    private static Class class_deque = null;

    static {
        try {
            TypeUtils.compatibleWithJavaBean = ""true"".equals(IOUtils.getStringProperty(IOUtils.FASTJSON_COMPATIBLEWITHJAVABEAN));
            TypeUtils.compatibleWithFieldName = ""true"".equals(IOUtils.getStringProperty(IOUtils.FASTJSON_COMPATIBLEWITHFIELDNAME));
        } catch (Throwable e) {
            // skip
        }

        try {
            class_deque = Class.forName(""java.util.Deque"");
        } catch (Throwable e) {
            // skip
        }
    }

    public static boolean isXmlField(Class clazz) {
        if (class_XmlAccessorType == null && !classXmlAccessorType_error) {
            try {
                class_XmlAccessorType = Class.forName(""javax.xml.bind.annotation.XmlAccessorType"");
            } catch (Throwable ex) {
                classXmlAccessorType_error = true;
            }
        }

        if (class_XmlAccessorType == null) {
            return false;
        }

        Annotation annotation = TypeUtils.getAnnotation(clazz, class_XmlAccessorType);
        if (annotation == null) {
            return false;
        }

        if (method_XmlAccessorType_value == null && !classXmlAccessorType_error) {
            try {
                method_XmlAccessorType_value = class_XmlAccessorType.getMethod(""value"");
            } catch (Throwable ex) {
                classXmlAccessorType_error = true;
            }
        }

        if (method_XmlAccessorType_value == null) {
            return false;
        }

        Object value = null;
        if (!classXmlAccessorType_error) {
            try {
                value = method_XmlAccessorType_value.invoke(annotation);
            } catch (Throwable ex) {
                classXmlAccessorType_error = true;
            }
        }
        if (value == null) {
            return false;
        }

        if (class_XmlAccessType == null && !classXmlAccessorType_error) {
            try {
                class_XmlAccessType = Class.forName(""javax.xml.bind.annotation.XmlAccessType"");
                field_XmlAccessType_FIELD = class_XmlAccessType.getField(""FIELD"");
                field_XmlAccessType_FIELD_VALUE = field_XmlAccessType_FIELD.get(null);
            } catch (Throwable ex) {
                classXmlAccessorType_error = true;
            }
        }

        return value == field_XmlAccessType_FIELD_VALUE;
    }

    public static Annotation getXmlAccessorType(Class clazz) {
        if (class_XmlAccessorType == null && !classXmlAccessorType_error) {

            try {
                class_XmlAccessorType = Class.forName(""javax.xml.bind.annotation.XmlAccessorType"");
            } catch (Throwable ex) {
                classXmlAccessorType_error = true;
            }
        }

        if (class_XmlAccessorType == null) {
            return null;
        }

        return TypeUtils.getAnnotation(clazz, class_XmlAccessorType);
    }

//
//    public static boolean isXmlAccessType(Class clazz) {
//        if (class_XmlAccessType == null && !class_XmlAccessType_error) {
//
//            try{
//                class_XmlAccessType = Class.forName(""javax.xml.bind.annotation.XmlAccessType"");
//            } catch(Throwable ex){
//                class_XmlAccessType_error = true;
//            }
//        }
//
//        if (class_XmlAccessType == null) {
//            return false;
//        }
//
//        return  class_XmlAccessType.isAssignableFrom(clazz);
//    }

    private static Function<Class, Boolean> isClobFunction = new Function<Class, Boolean>() {
        public Boolean apply(Class clazz) {
            return Clob.class.isAssignableFrom(clazz);
        }
    };

    public static boolean isClob(final Class clazz) {
        Boolean isClob = ModuleUtil.callWhenHasJavaSql(isClobFunction, clazz);

        return isClob != null ? isClob : false;
    }

    public static String castToString(Object value) {
        if (value == null) {
            return null;
        }
        return value.toString();
    }

    public static Byte castToByte(Object value) {
        if (value == null) {
            return null;
        }

        if (value instanceof BigDecimal) {
            return byteValue((BigDecimal) value);
        }

        if (value instanceof Number) {
            return ((Number) value).byteValue();
        }

        if (value instanceof String) {
            String strVal = (String) value;
            if (strVal.length() == 0 //
                    || ""null"".equals(strVal) //
                    || ""NULL"".equals(strVal)) {
                return null;
            }
            return Byte.parseByte(strVal);
        }

        if (value instanceof Boolean) {
            return (Boolean) value ? (byte) 1 : (byte) 0;
        }

        throw new JSONException(""can not cast to byte, value : "" + value);
    }

    public static Character castToChar(Object value) {
        if (value == null) {
            return null;
        }
        if (value instanceof Character) {
            return (Character) value;
        }
        if (value instanceof String) {
            String strVal = (String) value;
            if (strVal.length() == 0) {
                return null;
            }
            if (strVal.length() != 1) {
                throw new JSONException(""can not cast to char, value : "" + value);
            }
            return strVal.charAt(0);
        }
        throw new JSONException(""can not cast to char, value : "" + value);
    }

    public static Short castToShort(Object value) {
        if (value == null) {
            return null;
        }

        if (value instanceof BigDecimal) {
            return shortValue((BigDecimal) value);
        }

        if (value instanceof Number) {
            return ((Number) value).shortValue();
        }

        if (value instanceof String) {
            String strVal = (String) value;
            if (strVal.length() == 0 //
                    || ""null"".equals(strVal) //
                    || ""NULL"".equals(strVal)) {
                return null;
            }
            return Short.parseShort(strVal);
        }

        if (value instanceof Boolean) {
            return ((Boolean) value).booleanValue() ? (short) 1 : (short) 0;
        }

        throw new JSONException(""can not cast to short, value : "" + value);
    }

    public static BigDecimal castToBigDecimal(Object value) {
        if (value == null) {
            return null;
        }

        if (value instanceof Float) {
            if (Float.isNaN((Float) value) || Float.isInfinite((Float) value)) {
                return null;
            }
        } else if (value instanceof Double) {
            if (Double.isNaN((Double) value) || Double.isInfinite((Double) value)) {
                return null;
            }
        } else if (value instanceof BigDecimal) {
            return (BigDecimal) value;
        } else if (value instanceof BigInteger) {
            return new BigDecimal((BigInteger) value);
        } else if (value instanceof Map && ((Map) value).size() == 0) {
            return null;
        }

        String strVal = value.toString();

        if (strVal.length() == 0
                || strVal.equalsIgnoreCase(""null"")) {
            return null;
        }

        if (strVal.length() > 65535) {
            throw new JSONException(""decimal overflow"");
        }
        return new BigDecimal(strVal);
    }

    public static BigInteger castToBigInteger(Object value) {
        if (value == null) {
            return null;
        }

        if (value instanceof Float) {
            Float floatValue = (Float) value;
            if (Float.isNaN(floatValue) || Float.isInfinite(floatValue)) {
                return null;
            }
            return BigInteger.valueOf(floatValue.longValue());
        } else if (value instanceof Double) {
            Double doubleValue = (Double) value;
            if (Double.isNaN(doubleValue) || Double.isInfinite(doubleValue)) {
                return null;
            }
            return BigInteger.valueOf(doubleValue.longValue());
        } else if (value instanceof BigInteger) {
            return (BigInteger) value;
        } else if (value instanceof BigDecimal) {
            BigDecimal decimal = (BigDecimal) value;
            int scale = decimal.scale();
            if (scale > -1000 && scale < 1000) {
                return ((BigDecimal) value).toBigInteger();
            }
        }

        String strVal = value.toString();

        if (strVal.length() == 0
                || strVal.equalsIgnoreCase(""null"")) {
            return null;
        }

        if (strVal.length() > 65535) {
            throw new JSONException(""decimal overflow"");
        }
        return new BigInteger(strVal);
    }

    public static Float castToFloat(Object value) {
        if (value == null) {
            return null;
        }
        if (value instanceof Number) {
            return ((Number) value).floatValue();
        }
        if (value instanceof String) {
            String strVal = value.toString();
            if (strVal.length() == 0 //
                    || ""null"".equals(strVal) //
                    || ""NULL"".equals(strVal)) {
                return null;
            }
            if (strVal.indexOf(',') != -1) {
                strVal = strVal.replaceAll("","", """");
            }
            return Float.parseFloat(strVal);
        }

        if (value instanceof Boolean) {
            return (Boolean) value ? 1F : 0F;
        }

        throw new JSONException(""can not cast to float, value : "" + value);
    }

    public static Double castToDouble(Object value) {
        if (value == null) {
            return null;
        }
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        }
        if (value instanceof String) {
            String strVal = value.toString();
            if (strVal.length() == 0 //
                    || ""null"".equals(strVal) //
                    || ""NULL"".equals(strVal)) {
                return null;
            }
            if (strVal.indexOf(',') != -1) {
                strVal = strVal.replaceAll("","", """");
            }
            return Double.parseDouble(strVal);
        }

        if (value instanceof Boolean) {
            return (Boolean) value ? 1D : 0D;
        }

        throw new JSONException(""can not cast to double, value : "" + value);
    }

    public static Date castToDate(Object value) {
        return castToDate(value, null);
    }

    public static Date castToDate(Object value, String format) {
        if (value == null) {
            return null;
        }

        if (value instanceof Date) { // 使用频率最高的，应优先处理
            return (Date) value;
        }

        if (value instanceof Calendar) {
            return ((Calendar) value).getTime();
        }

        long longValue = -1;

        if (value instanceof BigDecimal) {
            longValue = longValue((BigDecimal) value);
            return new Date(longValue);
        }

        if (value instanceof Number) {
            longValue = ((Number) value).longValue();
            if (""unixtime"".equals(format)) {
                longValue *= 1000;
            }
            return new Date(longValue);
        }

        if (value instanceof String) {
            String strVal = (String) value;
            JSONScanner dateLexer = new JSONScanner(strVal);
            try {
                if (dateLexer.scanISO8601DateIfMatch(false)) {
                    Calendar calendar = dateLexer.getCalendar();
                    return calendar.getTime();
                }
            } finally {
                dateLexer.close();
            }

            if (strVal.startsWith(""/Date("") && strVal.endsWith("")/"")) {
                strVal = strVal.substring(6, strVal.length() - 2);
            }

            if (strVal.indexOf('-') > 0 || strVal.indexOf('+') > 0 || format != null) {
                if (format == null) {
                    final int len = strVal.length();
                    if (len == JSON.DEFFAULT_DATE_FORMAT.length()
                            || (len == 22 && JSON.DEFFAULT_DATE_FORMAT.equals(""yyyyMMddHHmmssSSSZ""))) {
                        format = JSON.DEFFAULT_DATE_FORMAT;
                    } else if (len == 10) {
                        format = ""yyyy-MM-dd"";
                    } else if (len == ""yyyy-MM-dd HH:mm:ss"".length()) {
                        format = ""yyyy-MM-dd HH:mm:ss"";
                    } else if (len == 29
                            && strVal.charAt(26) == ':'
                            && strVal.charAt(28) == '0') {
                        format = ""yyyy-MM-dd'T'HH:mm:ss.SSSXXX"";
                    } else if (len == 23 && strVal.charAt(19) == ',') {
                        format = ""yyyy-MM-dd HH:mm:ss,SSS"";
                    } else {
                        format = ""yyyy-MM-dd HH:mm:ss.SSS"";
                    }
                }

                SimpleDateFormat dateFormat = new SimpleDateFormat(format, JSON.defaultLocale);
                dateFormat.setTimeZone(JSON.defaultTimeZone);
                try {
                    return dateFormat.parse(strVal);
                } catch (ParseException e) {
                    throw new JSONException(""can not cast to Date, value : "" + strVal);
                }
            }
            if (strVal.length() == 0) {
                return null;
            }
            longValue = Long.parseLong(strVal);
        }

        if (longValue == -1) {
            Class<?> clazz = value.getClass();
            if (""oracle.sql.TIMESTAMP"".equals(clazz.getName())) {
                if (oracleTimestampMethod == null && !oracleTimestampMethodInited) {
                    try {
                        oracleTimestampMethod = clazz.getMethod(""toJdbc"");
                    } catch (NoSuchMethodException e) {
                        // skip
                    } finally {
                        oracleTimestampMethodInited = true;
                    }
                }
                Object result;
                try {
                    result = oracleTimestampMethod.invoke(value);
                } catch (Exception e) {
                    throw new JSONException(""can not cast oracle.sql.TIMESTAMP to Date"", e);
                }
                return (Date) result;
            }
            if (""oracle.sql.DATE"".equals(clazz.getName())) {
                if (oracleDateMethod == null && !oracleDateMethodInited) {
                    try {
                        oracleDateMethod = clazz.getMethod(""toJdbc"");
                    } catch (NoSuchMethodException e) {
                        // skip
                    } finally {
                        oracleDateMethodInited = true;
                    }
                }
                Object result;
                try {
                    result = oracleDateMethod.invoke(value);
                } catch (Exception e) {
                    throw new JSONException(""can not cast oracle.sql.DATE to Date"", e);
                }
                return (Date) result;
            }

            throw new JSONException(""can not cast to Date, value : "" + value);
        }

        return new Date(longValue);
    }

    private static Function<Object, Object> castToSqlDateFunction = new Function<Object, Object>() {
        public Object apply(Object value) {
            if (value == null) {
                return null;
            }
            if (value instanceof java.sql.Date) {
                return (java.sql.Date) value;
            }
            if (value instanceof Date) {
                return new java.sql.Date(((Date) value).getTime());
            }
            if (value instanceof Calendar) {
                return new java.sql.Date(((Calendar) value).getTimeInMillis());
            }

            long longValue = 0;
            if (value instanceof BigDecimal) {
                longValue = longValue((BigDecimal) value);
            } else if (value instanceof Number) {
                longValue = ((Number) value).longValue();
            }

            if (value instanceof String) {
                String strVal = (String) value;
                if (strVal.length() == 0 //
                        || ""null"".equals(strVal) //
                        || ""NULL"".equals(strVal)) {
                    return null;
                }
                if (isNumber(strVal)) {
                    longValue = Long.parseLong(strVal);
                } else {
                    JSONScanner scanner = new JSONScanner(strVal);
                    if (scanner.scanISO8601DateIfMatch(false)) {
                        longValue = scanner.getCalendar().getTime().getTime();
                    } else {
                        throw new JSONException(""can not cast to Timestamp, value : "" + strVal);
                    }
                }
            }
            if (longValue <= 0) {
                throw new JSONException(""can not cast to Date, value : "" + value); // TODO 忽略 1970-01-01 之前的时间处理？
            }
            return new java.sql.Date(longValue);
        }
    };

    public static Object castToSqlDate(final Object value) {
        return ModuleUtil.callWhenHasJavaSql(castToSqlDateFunction, value);
    }

    public static long longExtractValue(Number number) {
        if (number instanceof BigDecimal) {
            return ((BigDecimal) number).longValueExact();
        }

        return number.longValue();
    }

    private static Function<Object, Object> castToSqlTimeFunction = new Function<Object, Object>() {
        public Object apply(Object value) {
            if (value == null) {
                return null;
            }
            if (value instanceof java.sql.Time) {
                return (java.sql.Time) value;
            }
            if (value instanceof java.util.Date) {
                return new java.sql.Time(((java.util.Date) value).getTime());
            }
            if (value instanceof Calendar) {
                return new java.sql.Time(((Calendar) value).getTimeInMillis());
            }

            long longValue = 0;
            if (value instanceof BigDecimal) {
                longValue = longValue((BigDecimal) value);
            } else if (value instanceof Number) {
                longValue = ((Number) value).longValue();
            }

            if (value instanceof String) {
                String strVal = (String) value;
                if (strVal.length() == 0 //
                        || ""null"".equalsIgnoreCase(strVal)) {
                    return null;
                }

                if (isNumber(strVal)) {
                    longValue = Long.parseLong(strVal);
                } else {
                    if (strVal.length() == 8 && strVal.charAt(2) == ':' && strVal.charAt(5) == ':') {
                        return java.sql.Time.valueOf(strVal);
                    }

                    JSONScanner scanner = new JSONScanner(strVal);
                    if (scanner.scanISO8601DateIfMatch(false)) {
                        longValue = scanner.getCalendar().getTime().getTime();
                    } else {
                        throw new JSONException(""can not cast to Timestamp, value : "" + strVal);
                    }

                }
            }
            if (longValue <= 0) {
                throw new JSONException(""can not cast to Date, value : "" + value); // TODO 忽略 1970-01-01 之前的时间处理？
            }
            return new java.sql.Time(longValue);
        }
    };

    public static Object castToSqlTime(final Object value) {
        return ModuleUtil.callWhenHasJavaSql(castToSqlTimeFunction, value);
    }

    public static Function<Object, Object> castToTimestampFunction = new Function<Object, Object>() {
        public Object apply(Object value) {
            if (value == null) {
                return null;
            }
            if (value instanceof Calendar) {
                return new java.sql.Timestamp(((Calendar) value).getTimeInMillis());
            }
            if (value instanceof java.sql.Timestamp) {
                return (java.sql.Timestamp) value;
            }
            if (value instanceof java.util.Date) {
                return new java.sql.Timestamp(((java.util.Date) value).getTime());
            }
            long longValue = 0;
            if (value instanceof BigDecimal) {
                longValue = longValue((BigDecimal) value);
            } else if (value instanceof Number) {
                longValue = ((Number) value).longValue();
            }
            if (value instanceof String) {
                String strVal = (String) value;
                if (strVal.length() == 0 //
                        || ""null"".equals(strVal) //
                        || ""NULL"".equals(strVal)) {
                    return null;
                }
                if (strVal.endsWith("".000000000"")) {
                    strVal = strVal.substring(0, strVal.length() - 10);
                } else if (strVal.endsWith("".000000"")) {
                    strVal = strVal.substring(0, strVal.length() - 7);
                }

                if (strVal.length() == 29
                        && strVal.charAt(4) == '-'
                        && strVal.charAt(7) == '-'
                        && strVal.charAt(10) == ' '
                        && strVal.charAt(13) == ':'
                        && strVal.charAt(16) == ':'
                        && strVal.charAt(19) == '.') {
                    int year = num(
                            strVal.charAt(0),
                            strVal.charAt(1),
                            strVal.charAt(2),
                            strVal.charAt(3));
                    int month = num(
                            strVal.charAt(5),
                            strVal.charAt(6));
                    int day = num(
                            strVal.charAt(8),
                            strVal.charAt(9));
                    int hour = num(
                            strVal.charAt(11),
                            strVal.charAt(12));
                    int minute = num(
                            strVal.charAt(14),
                            strVal.charAt(15));
                    int second = num(
                            strVal.charAt(17),
                            strVal.charAt(18));
                    int nanos = num(
                            strVal.charAt(20),
                            strVal.charAt(21),
                            strVal.charAt(22),
                            strVal.charAt(23),
                            strVal.charAt(24),
                            strVal.charAt(25),
                            strVal.charAt(26),
                            strVal.charAt(27),
                            strVal.charAt(28));
                    return new java.sql.Timestamp(year - 1900, month - 1, day, hour, minute, second, nanos);
                }

                if (isNumber(strVal)) {
                    longValue = Long.parseLong(strVal);
                } else {
                    JSONScanner scanner = new JSONScanner(strVal);
                    if (scanner.scanISO8601DateIfMatch(false)) {
                        longValue = scanner.getCalendar().getTime().getTime();
                    } else {
                        throw new JSONException(""can not cast to Timestamp, value : "" + strVal);
                    }
                }
            }

            return new java.sql.Timestamp(longValue);
        }
    };

    public static Object castToTimestamp(final Object value) {
        return ModuleUtil.callWhenHasJavaSql(castToTimestampFunction, value);
    }

    static int num(char c0, char c1) {
        if (c0 >= '0'
                && c0 <= '9'
                && c1 >= '0'
                && c1 <= '9'
        ) {
            return (c0 - '0') * 10
                    + (c1 - '0');
        }

        return -1;
    }

    static int num(char c0, char c1, char c2, char c3) {
        if (c0 >= '0'
                && c0 <= '9'
                && c1 >= '0'
                && c1 <= '9'
                && c2 >= '0'
                && c2 <= '9'
                && c3 >= '0'
                && c3 <= '9'
        ) {
            return (c0 - '0') * 1000
                    + (c1 - '0') * 100
                    + (c2 - '0') * 10
                    + (c3 - '0');
        }

        return -1;
    }

    static int num(char c0, char c1, char c2, char c3, char c4, char c5, char c6, char c7, char c8) {
        if (c0 >= '0'
                && c0 <= '9'
                && c1 >= '0'
                && c1 <= '9'
                && c2 >= '0'
                && c2 <= '9'
                && c3 >= '0'
                && c3 <= '9'
                && c4 >= '0'
                && c4 <= '9'
                && c5 >= '0'
                && c5 <= '9'
                && c6 >= '0'
                && c6 <= '9'
                && c7 >= '0'
                && c7 <= '9'
                && c8 >= '0'
                && c8 <= '9'
        ) {
            return (c0 - '0') * 100000000
                    + (c1 - '0') * 10000000
                    + (c2 - '0') * 1000000
                    + (c3 - '0') * 100000
                    + (c4 - '0') * 10000
                    + (c5 - '0') * 1000
                    + (c6 - '0') * 100
                    + (c7 - '0') * 10
                    + (c8 - '0');
        }

        return -1;
    }

    public static boolean isNumber(String str) {
        for (int i = 0; i < str.length(); ++i) {
            char ch = str.charAt(i);
            if (ch == '+' || ch == '-') {
                if (i != 0) {
                    return false;
                }
            } else if (ch < '0' || ch > '9') {
                return false;
            }
        }
        return true;
    }

    public static Long castToLong(Object value) {
        if (value == null) {
            return null;
        }

        if (value instanceof BigDecimal) {
            return longValue((BigDecimal) value);
        }

        if (value instanceof Number) {
            return ((Number) value).longValue();
        }

        if (value instanceof String) {
            String strVal = (String) value;
            if (strVal.length() == 0 //
                    || ""null"".equals(strVal) //
                    || ""NULL"".equals(strVal)) {
                return null;
            }
            if (strVal.indexOf(',') != -1) {
                strVal = strVal.replaceAll("","", """");
            }
            try {
                return Long.parseLong(strVal);
            } catch (NumberFormatException ex) {
                //
            }
            JSONScanner dateParser = new JSONScanner(strVal);
            Calendar calendar = null;
            if (dateParser.scanISO8601DateIfMatch(false)) {
                calendar = dateParser.getCalendar();
            }
            dateParser.close();
            if (calendar != null) {
                return calendar.getTimeInMillis();
            }
        }

        if (value instanceof Map) {
            Map map = (Map) value;
            if (map.size() == 2
                    && map.containsKey(""andIncrement"")
                    && map.containsKey(""andDecrement"")) {
                Iterator iter = map.values().iterator();
                iter.next();
                Object value2 = iter.next();
                return castToLong(value2);
            }
        }

        if (value instanceof Boolean) {
            return (Boolean) value ? 1L : 0L;
        }

        throw new JSONException(""can not cast to long, value : "" + value);
    }

    public static byte byteValue(BigDecimal decimal) {
        if (decimal == null) {
            return 0;
        }

        int scale = decimal.scale();
        if (scale >= -100 && scale <= 100) {
            return decimal.byteValue();
        }

        return decimal.byteValueExact();
    }

    public static short shortValue(BigDecimal decimal) {
        if (decimal == null) {
            return 0;
        }

        int scale = decimal.scale();
        if (scale >= -100 && scale <= 100) {
            return decimal.shortValue();
        }

        return decimal.shortValueExact();
    }

    public static int intValue(BigDecimal decimal) {
        if (decimal == null) {
            return 0;
        }

        int scale = decimal.scale();
        if (scale >= -100 && scale <= 100) {
            return decimal.intValue();
        }

        return decimal.intValueExact();
    }

    public static long longValue(BigDecimal decimal) {
        if (decimal == null) {
            return 0;
        }

        int scale = decimal.scale();
        if (scale >= -100 && scale <= 100) {
            return decimal.longValue();
        }

        return decimal.longValueExact();
    }

    public static Integer castToInt(Object value) {
        if (value == null) {
            return null;
        }

        if (value instanceof Integer) {
            return (Integer) value;
        }

        if (value instanceof BigDecimal) {
            return intValue((BigDecimal) value);
        }

        if (value instanceof Number) {
            return ((Number) value).intValue();
        }

        if (value instanceof String) {
            String strVal = (String) value;
            if (strVal.length() == 0 //
                    || ""null"".equals(strVal) //
                    || ""NULL"".equals(strVal)) {
                return null;
            }
            if (strVal.indexOf(',') != -1) {
                strVal = strVal.replaceAll("","", """");
            }

            Matcher matcher = NUMBER_WITH_TRAILING_ZEROS_PATTERN.matcher(strVal);
            if (matcher.find()) {
                strVal = matcher.replaceAll("""");
            }
            return Integer.parseInt(strVal);
        }

        if (value instanceof Boolean) {
            return (Boolean) value ? 1 : 0;
        }
        if (value instanceof Map) {
            Map map = (Map) value;
            if (map.size() == 2
                    && map.containsKey(""andIncrement"")
                    && map.containsKey(""andDecrement"")) {
                Iterator iter = map.values().iterator();
                iter.next();
                Object value2 = iter.next();
                return castToInt(value2);
            }
        }
        throw new JSONException(""can not cast to int, value : "" + value);
    }

    public static byte[] castToBytes(Object value) {
        if (value instanceof byte[]) {
            return (byte[]) value;
        }
        if (value instanceof String) {
            return IOUtils.decodeBase64((String) value);
        }
        throw new JSONException(""can not cast to byte[], value : "" + value);
    }

    public static Boolean castToBoolean(Object value) {
        if (value == null) {
            return null;
        }
        if (value instanceof Boolean) {
            return (Boolean) value;
        }

        if (value instanceof BigDecimal) {
            return intValue((BigDecimal) value) == 1;
        }

        if (value instanceof Number) {
            return ((Number) value).intValue() == 1;
        }

        if (value instanceof String) {
            String strVal = (String) value;
            if (strVal.length() == 0 //
                    || ""null"".equals(strVal) //
                    || ""NULL"".equals(strVal)) {
                return null;
            }
            if (""true"".equalsIgnoreCase(strVal) //
                    || ""1"".equals(strVal)) {
                return Boolean.TRUE;
            }
            if (""false"".equalsIgnoreCase(strVal) //
                    || ""0"".equals(strVal)) {
                return Boolean.FALSE;
            }
            if (""Y"".equalsIgnoreCase(strVal) //
                    || ""T"".equals(strVal)) {
                return Boolean.TRUE;
            }
            if (""F"".equalsIgnoreCase(strVal) //
                    || ""N"".equals(strVal)) {
                return Boolean.FALSE;
            }
        }
        throw new JSONException(""can not cast to boolean, value : "" + value);
    }

    public static <T> T castToJavaBean(Object obj, Class<T> clazz) {
        return cast(obj, clazz, ParserConfig.getGlobalInstance());
    }

    private static BiFunction<Object, Class, Object> castFunction = new BiFunction<Object, Class, Object>() {
        public Object apply(Object obj, Class clazz) {
            if (clazz == java.sql.Date.class) {
                return castToSqlDate(obj);
            }

            if (clazz == java.sql.Time.class) {
                return castToSqlTime(obj);
            }

            if (clazz == java.sql.Timestamp.class) {
                return castToTimestamp(obj);
            }
            return null;
        }
    };

    @SuppressWarnings({""unchecked"", ""rawtypes""})
    public static <T> T cast(final Object obj, final Class<T> clazz, ParserConfig config) {
        if (obj == null) {
            if (clazz == int.class) {
                return (T) Integer.valueOf(0);
            } else if (clazz == long.class) {
                return (T) Long.valueOf(0);
            } else if (clazz == short.class) {
                return (T) Short.valueOf((short) 0);
            } else if (clazz == byte.class) {
                return (T) Byte.valueOf((byte) 0);
            } else if (clazz == float.class) {
                return (T) Float.valueOf(0);
            } else if (clazz == double.class) {
                return (T) Double.valueOf(0);
            } else if (clazz == boolean.class) {
                return (T) Boolean.FALSE;
            }
            return null;
        }

        if (clazz == null) {
            throw new IllegalArgumentException(""clazz is null"");
        }

        if (clazz == obj.getClass()) {
            return (T) obj;
        }

        if (obj instanceof Map) {
            if (clazz == Map.class) {
                return (T) obj;
            }

            Map map = (Map) obj;
            if (clazz == Object.class && !map.containsKey(JSON.DEFAULT_TYPE_KEY)) {
                return (T) obj;
            }
            return castToJavaBean((Map<String, Object>) obj, clazz, config);
        }

        if (clazz.isArray()) {
            if (obj instanceof Collection) {
                Collection collection = (Collection) obj;
                int index = 0;
                Object array = Array.newInstance(clazz.getComponentType(), collection.size());
                for (Object item : collection) {
                    Object value = cast(item, clazz.getComponentType(), config);
                    Array.set(array, index, value);
                    index++;
                }
                return (T) array;
            }
            if (clazz == byte[].class) {
                return (T) castToBytes(obj);
            }
        }

        if (clazz.isAssignableFrom(obj.getClass())) {
            return (T) obj;
        }

        if (clazz == boolean.class || clazz == Boolean.class) {
            return (T) castToBoolean(obj);
        }

        if (clazz == byte.class || clazz == Byte.class) {
            return (T) castToByte(obj);
        }

        if (clazz == char.class || clazz == Character.class) {
            return (T) castToChar(obj);
        }

        if (clazz == short.class || clazz == Short.class) {
            return (T) castToShort(obj);
        }

        if (clazz == int.class || clazz == Integer.class) {
            return (T) castToInt(obj);
        }

        if (clazz == long.class || clazz == Long.class) {
            return (T) castToLong(obj);
        }

        if (clazz == float.class || clazz == Float.class) {
            return (T) castToFloat(obj);
        }

        if (clazz == double.class || clazz == Double.class) {
            return (T) castToDouble(obj);
        }

        if (clazz == String.class) {
            return (T) castToString(obj);
        }

        if (clazz == BigDecimal.class) {
            return (T) castToBigDecimal(obj);
        }

        if (clazz == BigInteger.class) {
            return (T) castToBigInteger(obj);
        }

        if (clazz == Date.class) {
            return (T) castToDate(obj);
        }

        T retObj = (T) ModuleUtil.callWhenHasJavaSql(castFunction, obj, clazz);

        if (retObj != null) {
            return retObj;
        }

        if (clazz.isEnum()) {
            return castToEnum(obj, clazz, config);
        }

        if (Calendar.class.isAssignableFrom(clazz)) {
            Date date = castToDate(obj);
            Calendar calendar;
            if (clazz == Calendar.class) {
                calendar = Calendar.getInstance(JSON.defaultTimeZone, JSON.defaultLocale);
            } else {
                try {
                    calendar = (Calendar) clazz.newInstance();
                } catch (Exception e) {
                    throw new JSONException(""can not cast to : "" + clazz.getName(), e);
                }
            }
            calendar.setTime(date);
            return (T) calendar;
        }

        String className = clazz.getName();
        if (className.equals(""javax.xml.datatype.XMLGregorianCalendar"")) {
            Date date = castToDate(obj);
            Calendar calendar = Calendar.getInstance(JSON.defaultTimeZone, JSON.defaultLocale);
            calendar.setTime(date);
            return (T) CalendarCodec.instance.createXMLGregorianCalendar(calendar);
        }

        if (obj instanceof String) {
            String strVal = (String) obj;
            if (strVal.length() == 0 //
                    || ""null"".equals(strVal) //
                    || ""NULL"".equals(strVal)) {
                return null;
            }

            if (clazz == java.util.Currency.class) {
                return (T) java.util.Currency.getInstance(strVal);
            }

            if (clazz == java.util.Locale.class) {
                return (T) toLocale(strVal);
            }

            if (className.startsWith(""java.time."")) {
                String json = JSON.toJSONString(strVal);
                return JSON.parseObject(json, clazz);
            }
        }

        final ObjectDeserializer objectDeserializer = config.get(clazz);
        if (objectDeserializer != null) {
            String str = JSON.toJSONString(obj);
            return JSON.parseObject(str, clazz);
        }
        throw new JSONException(""can not cast to : "" + clazz.getName());
    }

    public static Locale toLocale(String strVal) {
        String[] items = strVal.split(""_"");
        if (items.length == 1) {
            return new Locale(items[0]);
        }
        if (items.length == 2) {
            return new Locale(items[0], items[1]);
        }
        return new Locale(items[0], items[1], items[2]);
    }

    @SuppressWarnings({""unchecked"", ""rawtypes""})
    public static <T> T castToEnum(Object obj, Class<T> clazz, ParserConfig mapping) {
        try {
            if (obj instanceof String) {
                String name = (String) obj;
                if (name.length() == 0) {
                    return null;
                }

                if (mapping == null) {
                    mapping = ParserConfig.getGlobalInstance();
                }

                ObjectDeserializer deserializer = mapping.getDeserializer(clazz);
                if (deserializer instanceof EnumDeserializer) {
                    EnumDeserializer enumDeserializer = (EnumDeserializer) deserializer;
                    return (T) enumDeserializer.getEnumByHashCode(TypeUtils.fnv1a_64(name));
                }

                return (T) Enum.valueOf((Class<? extends Enum>) clazz, name);
            }

            if (obj instanceof BigDecimal) {
                int ordinal = intValue((BigDecimal) obj);
                Object[] values = clazz.getEnumConstants();
                if (ordinal < values.length) {
                    return (T) values[ordinal];
                }
            }

            if (obj instanceof Number) {
                int ordinal = ((Number) obj).intValue();
                Object[] values = clazz.getEnumConstants();
                if (ordinal < values.length) {
                    return (T) values[ordinal];
                }
            }
        } catch (Exception ex) {
            throw new JSONException(""can not cast to : "" + clazz.getName(), ex);
        }
        throw new JSONException(""can not cast to : "" + clazz.getName());
    }

    @SuppressWarnings(""unchecked"")
    public static <T> T cast(Object obj, Type type, ParserConfig mapping) {
        if (obj == null) {
            return null;
        }
        if (type instanceof Class) {
            return cast(obj, (Class<T>) type, mapping);
        }
        if (type instanceof ParameterizedType) {
            return (T) cast(obj, (ParameterizedType) type, mapping);
        }
        if (obj instanceof String) {
            String strVal = (String) obj;
            if (strVal.length() == 0 //
                    || ""null"".equals(strVal) //
                    || ""NULL"".equals(strVal)) {
                return null;
            }
        }
        if (type instanceof TypeVariable) {
            return (T) obj;
        }
        throw new JSONException(""can not cast to : "" + type);
    }

    @SuppressWarnings({""rawtypes"", ""unchecked""})
    public static <T> T cast(Object obj, ParameterizedType type, ParserConfig mapping) {
        Type rawTye = type.getRawType();

        if (rawTye == List.class || rawTye == ArrayList.class) {
            Type itemType = type.getActualTypeArguments()[0];
            if (obj instanceof List) {
                List listObj = (List) obj;
                List arrayList = new ArrayList(listObj.size());

                for (Object item : listObj) {
                    Object itemValue;
                    if (itemType instanceof Class) {
                        if (item != null && item.getClass() == JSONObject.class) {
                            itemValue = ((JSONObject) item).toJavaObject((Class<T>) itemType, mapping, 0);
                        } else {
                            itemValue = cast(item, (Class<T>) itemType, mapping);
                        }
                    } else {
                        itemValue = cast(item, itemType, mapping);
                    }

                    arrayList.add(itemValue);
                }
                return (T) arrayList;
            }
        }

        if (rawTye == Set.class || rawTye == HashSet.class //
                || rawTye == TreeSet.class //
                || rawTye == Collection.class //
                || rawTye == List.class //
                || rawTye == ArrayList.class) {
            Type itemType = type.getActualTypeArguments()[0];
            if (obj instanceof Iterable) {
                Collection collection;
                if (rawTye == Set.class || rawTye == HashSet.class) {
                    collection = new HashSet();
                } else if (rawTye == TreeSet.class) {
                    collection = new TreeSet();
                } else {
                    collection = new ArrayList();
                }
                for (Object item : (Iterable) obj) {
                    Object itemValue;
                    if (itemType instanceof Class) {
                        if (item != null && item.getClass() == JSONObject.class) {
                            itemValue = ((JSONObject) item).toJavaObject((Class<T>) itemType, mapping, 0);
                        } else {
                            itemValue = cast(item, (Class<T>) itemType, mapping);
                        }
                    } else {
                        itemValue = cast(item, itemType, mapping);
                    }

                    collection.add(itemValue);
                }
                return (T) collection;
            }
        }

        if (rawTye == Map.class || rawTye == HashMap.class) {
            Type keyType = type.getActualTypeArguments()[0];
            Type valueType = type.getActualTypeArguments()[1];
            if (obj instanceof Map) {
                Map map = new HashMap();
                for (Map.Entry entry : ((Map<?, ?>) obj).entrySet()) {
                    Object key = cast(entry.getKey(), keyType, mapping);
                    Object value = cast(entry.getValue(), valueType, mapping);
                    map.put(key, value);
                }
                return (T) map;
            }
        }
        if (obj instanceof String) {
            String strVal = (String) obj;
            if (strVal.length() == 0) {
                return null;
            }
        }

        Type[] actualTypeArguments = type.getActualTypeArguments();
        if (actualTypeArguments.length == 1) {
            Type argType = type.getActualTypeArguments()[0];
            if (argType instanceof WildcardType) {
                return (T) cast(obj, rawTye, mapping);
            }
        }

        if (rawTye == Map.Entry.class && obj instanceof Map && ((Map) obj).size() == 1) {
            Map.Entry entry = (Map.Entry) ((Map) obj).entrySet().iterator().next();
            Object entryValue = entry.getValue();
            if (actualTypeArguments.length == 2 && entryValue instanceof Map) {
                Type valueType = actualTypeArguments[1];
                entry.setValue(
                        cast(entryValue, valueType, mapping)
                );
            }
            return (T) entry;
        }

        if (rawTye instanceof Class) {
            if (mapping == null) {
                mapping = ParserConfig.global;
            }
            ObjectDeserializer deserializer = mapping.getDeserializer(rawTye);
            if (deserializer != null) {
                String str = JSON.toJSONString(obj);
                DefaultJSONParser parser = new DefaultJSONParser(str, mapping);
                return (T) deserializer.deserialze(parser, type, null);
            }
        }

        throw new JSONException(""can not cast to : "" + type);
    }

    @SuppressWarnings({""unchecked""})
    public static <T> T castToJavaBean(Map<String, Object> map, Class<T> clazz, ParserConfig config) {
        try {
            if (clazz == StackTraceElement.class) {
                String declaringClass = (String) map.get(""className"");
                String methodName = (String) map.get(""methodName"");
                String fileName = (String) map.get(""fileName"");
                int lineNumber;
                {
                    Number value = (Number) map.get(""lineNumber"");
                    if (value == null) {
                        lineNumber = 0;
                    } else if (value instanceof BigDecimal) {
                        lineNumber = ((BigDecimal) value).intValueExact();
                    } else {
                        lineNumber = value.intValue();
                    }
                }
                return (T) new StackTraceElement(declaringClass, methodName, fileName, lineNumber);
            }

            {
                Object iClassObject = map.get(JSON.DEFAULT_TYPE_KEY);
                if (iClassObject instanceof String) {
                    String className = (String) iClassObject;
                    Class<?> loadClazz;
                    if (config == null) {
                        config = ParserConfig.global;
                    }
                    loadClazz = config.checkAutoType(className, null);
                    if (loadClazz == null) {
                        throw new ClassNotFoundException(className + "" not found"");
                    }
                    if (!loadClazz.equals(clazz)) {
                        return (T) castToJavaBean(map, loadClazz, config);
                    }
                }
            }

            if (clazz.isInterface()) {
                JSONObject object;
                if (map instanceof JSONObject) {
                    object = (JSONObject) map;
                } else {
                    object = new JSONObject(map);
                }
                if (config == null) {
                    config = ParserConfig.getGlobalInstance();
                }
                ObjectDeserializer deserializer = config.get(clazz);
                if (deserializer != null) {
                    String json = JSON.toJSONString(object);
                    return JSON.parseObject(json, clazz);
                }
                return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
                        new Class<?>[]{clazz}, object);
            }

            if (clazz == Locale.class) {
                Object arg0 = map.get(""language"");
                Object arg1 = map.get(""country"");
                if (arg0 instanceof String) {
                    String language = (String) arg0;
                    if (arg1 instanceof String) {
                        String country = (String) arg1;
                        return (T) new Locale(language, country);
                    } else if (arg1 == null) {
                        return (T) new Locale(language);
                    }
                }
            }

            if (clazz == String.class && map instanceof JSONObject) {
                return (T) map.toString();
            }

            if (clazz == JSON.class && map instanceof JSONObject) {
                return (T) map;
            }

            if (clazz == LinkedHashMap.class && map instanceof JSONObject) {
                JSONObject jsonObject = (JSONObject) map;
                Map<String, Object> innerMap = jsonObject.getInnerMap();
                if (innerMap instanceof LinkedHashMap) {
                    return (T) innerMap;
                }
            }

            if (clazz.isInstance(map)) {
                return (T) map;
            }

            if (clazz == JSONObject.class) {
                return (T) new JSONObject(map);
            }

            if (config == null) {
                config = ParserConfig.getGlobalInstance();
            }

            JavaBeanDeserializer javaBeanDeser = null;
            ObjectDeserializer deserializer = config.getDeserializer(clazz);
            if (deserializer instanceof JavaBeanDeserializer) {
                javaBeanDeser = (JavaBeanDeserializer) deserializer;
            }

            if (javaBeanDeser == null) {
                throw new JSONException(""can not get javaBeanDeserializer. "" + clazz.getName());
            }
            return (T) javaBeanDeser.createInstance(map, config);
        } catch (Exception e) {
            throw new JSONException(e.getMessage(), e);
        }
    }

    private static Function<Map<String, Class<?>>, Void> addBaseClassMappingsFunction =
            new Function<Map<String, Class<?>>, Void>() {
                public Void apply(Map<String, Class<?>> mappings) {
                    Class<?>[] classes = new Class[]{
                            java.sql.Time.class,
                            java.sql.Date.class,
                            java.sql.Timestamp.class
                    };
                    for (Class clazz : classes) {
                        if (clazz == null) {
                            continue;
                        }
                        mappings.put(clazz.getName(), clazz);
                    }
                    return null;
                }
            };

    static {
        addBaseClassMappings();
    }

    private static void addBaseClassMappings() {
        mappings.put(""byte"", byte.class);
        mappings.put(""short"", short.class);
        mappings.put(""int"", int.class);
        mappings.put(""long"", long.class);
        mappings.put(""float"", float.class);
        mappings.put(""double"", double.class);
        mappings.put(""boolean"", boolean.class);
        mappings.put(""char"", char.class);
        mappings.put(""[byte"", byte[].class);
        mappings.put(""[short"", short[].class);
        mappings.put(""[int"", int[].class);
        mappings.put(""[long"", long[].class);
        mappings.put(""[float"", float[].class);
        mappings.put(""[double"", double[].class);
        mappings.put(""[boolean"", boolean[].class);
        mappings.put(""[char"", char[].class);
        mappings.put(""[B"", byte[].class);
        mappings.put(""[S"", short[].class);
        mappings.put(""[I"", int[].class);
        mappings.put(""[J"", long[].class);
        mappings.put(""[F"", float[].class);
        mappings.put(""[D"", double[].class);
        mappings.put(""[C"", char[].class);
        mappings.put(""[Z"", boolean[].class);
        Class<?>[] classes = new Class[]{
                Object.class,
                java.lang.Cloneable.class,
                loadClass(""java.lang.AutoCloseable""),
                java.lang.Exception.class,
                java.lang.RuntimeException.class,
                java.lang.IllegalAccessError.class,
                java.lang.IllegalAccessException.class,
                java.lang.IllegalArgumentException.class,
                java.lang.IllegalMonitorStateException.class,
                java.lang.IllegalStateException.class,
                java.lang.IllegalThreadStateException.class,
                java.lang.IndexOutOfBoundsException.class,
                java.lang.InstantiationError.class,
                java.lang.InstantiationException.class,
                java.lang.InternalError.class,
                java.lang.InterruptedException.class,
                java.lang.LinkageError.class,
                java.lang.NegativeArraySizeException.class,
                java.lang.NoClassDefFoundError.class,
                java.lang.NoSuchFieldError.class,
                java.lang.NoSuchFieldException.class,
                java.lang.NoSuchMethodError.class,
                java.lang.NoSuchMethodException.class,
                java.lang.NullPointerException.class,
                java.lang.NumberFormatException.class,
                java.lang.OutOfMemoryError.class,
                java.lang.SecurityException.class,
                java.lang.StackOverflowError.class,
                java.lang.StringIndexOutOfBoundsException.class,
                java.lang.TypeNotPresentException.class,
                java.lang.VerifyError.class,
                java.lang.StackTraceElement.class,
                java.util.HashMap.class,
                java.util.LinkedHashMap.class,
                java.util.Hashtable.class,
                java.util.TreeMap.class,
                java.util.IdentityHashMap.class,
                java.util.WeakHashMap.class,
                java.util.LinkedHashMap.class,
                java.util.HashSet.class,
                java.util.LinkedHashSet.class,
                java.util.TreeSet.class,
                java.util.ArrayList.class,
                java.util.concurrent.TimeUnit.class,
                java.util.concurrent.ConcurrentHashMap.class,
                java.util.concurrent.atomic.AtomicInteger.class,
                java.util.concurrent.atomic.AtomicLong.class,
                java.util.Collections.EMPTY_MAP.getClass(),
                java.lang.Boolean.class,
                java.lang.Character.class,
                java.lang.Byte.class,
                java.lang.Short.class,
                java.lang.Integer.class,
                java.lang.Long.class,
                java.lang.Float.class,
                java.lang.Double.class,
                java.lang.Number.class,
                java.lang.String.class,
                java.math.BigDecimal.class,
                java.math.BigInteger.class,
                java.util.BitSet.class,
                java.util.Calendar.class,
                java.util.Date.class,
                java.util.Locale.class,
                java.util.UUID.class,
                java.text.SimpleDateFormat.class,
                com.alibaba.fastjson.JSONObject.class,
                com.alibaba.fastjson.JSONPObject.class,
                com.alibaba.fastjson.JSONArray.class,
        };
        for (Class clazz : classes) {
            if (clazz == null) {
                continue;
            }
            mappings.put(clazz.getName(), clazz);
        }
        ModuleUtil.callWhenHasJavaSql(addBaseClassMappingsFunction, mappings);
    }

    public static void clearClassMapping() {
        mappings.clear();
        addBaseClassMappings();
    }

    public static void addMapping(String className, Class<?> clazz) {
        mappings.put(className, clazz);
    }

    public static Class<?> loadClass(String className) {
        return loadClass(className, null);
    }

    public static boolean isPath(Class<?> clazz) {
        if (pathClass == null && !pathClass_error) {
            try {
                pathClass = Class.forName(""java.nio.file.Path"");
            } catch (Throwable ex) {
                pathClass_error = true;
            }
        }
        if (pathClass != null) {
            return pathClass.isAssignableFrom(clazz);
        }
        return false;
    }

    public static Class<?> getClassFromMapping(String className) {
        return mappings.get(className);
    }

    public static Class<?> loadClass(String className, ClassLoader classLoader) {
        return loadClass(className, classLoader, false);
    }

    public static Class<?> loadClass(String className, ClassLoader classLoader, boolean cache) {
        if (className == null || className.length() == 0) {
            return null;
        }

        if (className.length() > 198) {
            throw new JSONException(""illegal className : "" + className);
        }

        Class<?> clazz = mappings.get(className);
        if (clazz != null) {
            return clazz;
        }

        if (className.charAt(0) == '[') {
            Class<?> componentType = loadClass(className.substring(1), classLoader);
            return Array.newInstance(componentType, 0).getClass();
        }

        if (className.startsWith(""L"") && className.endsWith("";"")) {
            String newClassName = className.substring(1, className.length() - 1);
            return loadClass(newClassName, classLoader);
        }

        try {
            if (classLoader != null) {
                clazz = classLoader.loadClass(className);
                if (cache) {
                    mappings.put(className, clazz);
                }
                return clazz;
            }
        } catch (Throwable e) {
            e.printStackTrace();
            // skip
        }
        try {
            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
            if (contextClassLoader != null && contextClassLoader != classLoader) {
                clazz = contextClassLoader.loadClass(className);
                if (cache) {
                    mappings.put(className, clazz);
                }
                return clazz;
            }
        } catch (Throwable e) {
            // skip
        }
        try {
            clazz = Class.forName(className);
            if (cache) {
                mappings.put(className, clazz);
            }
            return clazz;
        } catch (Throwable e) {
            // skip
        }
        return clazz;
    }

    public static SerializeBeanInfo buildBeanInfo(Class<?> beanType //
            , Map<String, String> aliasMap //
            , PropertyNamingStrategy propertyNamingStrategy) {
        return buildBeanInfo(beanType, aliasMap, propertyNamingStrategy, false);
    }

    public static SerializeBeanInfo buildBeanInfo(Class<?> beanType //
            , Map<String, String> aliasMap //
            , PropertyNamingStrategy propertyNamingStrategy //
            , boolean fieldBased //
    ) {
        JSONType jsonType = TypeUtils.getAnnotation(beanType, JSONType.class);
        String[] orders = null;
        final int features;
        String typeName = null, typeKey = null;
        if (jsonType != null) {
            orders = jsonType.orders();

            typeName = jsonType.typeName();
            if (typeName.length() == 0) {
                typeName = null;
            }

            PropertyNamingStrategy jsonTypeNaming = jsonType.naming();
            if (jsonTypeNaming != PropertyNamingStrategy.NeverUseThisValueExceptDefaultValue) {
                propertyNamingStrategy = jsonTypeNaming;
            }

            features = SerializerFeature.of(jsonType.serialzeFeatures());
            for (Class<?> supperClass = beanType.getSuperclass()
                 ; supperClass != null && supperClass != Object.class
                    ; supperClass = supperClass.getSuperclass()) {
                JSONType superJsonType = TypeUtils.getAnnotation(supperClass, JSONType.class);
                if (superJsonType == null) {
                    break;
                }
                typeKey = superJsonType.typeKey();
                if (typeKey.length() != 0) {
                    break;
                }
            }

            for (Class<?> interfaceClass : beanType.getInterfaces()) {
                JSONType superJsonType = TypeUtils.getAnnotation(interfaceClass, JSONType.class);
                if (superJsonType != null) {
                    typeKey = superJsonType.typeKey();
                    if (typeKey.length() != 0) {
                        break;
                    }
                }
            }

            if (typeKey != null && typeKey.length() == 0) {
                typeKey = null;
            }
        } else {
            features = 0;
        }
        // fieldName,field ，先生成fieldName的快照，减少之后的findField的轮询
        Map<String, Field> fieldCacheMap = new HashMap<String, Field>();
        ParserConfig.parserAllFieldToCache(beanType, fieldCacheMap);
        List<FieldInfo> fieldInfoList = fieldBased
                ? computeGettersWithFieldBase(beanType, aliasMap, false, propertyNamingStrategy) //
                : computeGetters(beanType, jsonType, aliasMap, fieldCacheMap, false, propertyNamingStrategy);
        FieldInfo[] fields = new FieldInfo[fieldInfoList.size()];
        fieldInfoList.toArray(fields);
        FieldInfo[] sortedFields;
        List<FieldInfo> sortedFieldList;
        if (orders != null && orders.length != 0) {
            sortedFieldList = fieldBased
                    ? computeGettersWithFieldBase(beanType, aliasMap, true, propertyNamingStrategy) //
                    : computeGetters(beanType, jsonType, aliasMap, fieldCacheMap, true, propertyNamingStrategy);
        } else {
            sortedFieldList = new ArrayList<FieldInfo>(fieldInfoList);
            Collections.sort(sortedFieldList);
        }
        sortedFields = new FieldInfo[sortedFieldList.size()];
        sortedFieldList.toArray(sortedFields);
        if (Arrays.equals(sortedFields, fields)) {
            sortedFields = fields;
        }
        return new SerializeBeanInfo(beanType, jsonType, typeName, typeKey, features, fields, sortedFields);
    }

    public static List<FieldInfo> computeGettersWithFieldBase(
            Class<?> clazz, //
            Map<String, String> aliasMap, //
            boolean sorted, //
            PropertyNamingStrategy propertyNamingStrategy) {
        Map<String, FieldInfo> fieldInfoMap = new LinkedHashMap<String, FieldInfo>();
        for (Class<?> currentClass = clazz; currentClass != null; currentClass = currentClass.getSuperclass()) {
            Field[] fields = currentClass.getDeclaredFields();
            computeFields(currentClass, aliasMap, propertyNamingStrategy, fieldInfoMap, fields);
        }
        return getFieldInfos(clazz, sorted, fieldInfoMap);
    }

    public static List<FieldInfo> computeGetters(Class<?> clazz, Map<String, String> aliasMap) {
        return computeGetters(clazz, aliasMap, true);
    }

    public static List<FieldInfo> computeGetters(Class<?> clazz, Map<String, String> aliasMap, boolean sorted) {
        JSONType jsonType = TypeUtils.getAnnotation(clazz, JSONType.class);
        Map<String, Field> fieldCacheMap = new HashMap<String, Field>();
        ParserConfig.parserAllFieldToCache(clazz, fieldCacheMap);
        return computeGetters(clazz, jsonType, aliasMap, fieldCacheMap, sorted, PropertyNamingStrategy.CamelCase);
    }

    public static List<FieldInfo> computeGetters(Class<?> clazz, //
                                                 JSONType jsonType, //
                                                 Map<String, String> aliasMap, //
                                                 Map<String, Field> fieldCacheMap, //
                                                 boolean sorted, //
                                                 PropertyNamingStrategy propertyNamingStrategy //
    ) {
        Map<String, FieldInfo> fieldInfoMap = new LinkedHashMap<String, FieldInfo>();
        boolean kotlin = TypeUtils.isKotlin(clazz);
        // for kotlin
        Constructor[] constructors = null;
        Annotation[][] paramAnnotationArrays = null;
        String[] paramNames = null;
        short[] paramNameMapping = null;
        Method[] methods = clazz.getMethods();
        try {
            Arrays.sort(methods, new MethodInheritanceComparator());
        } catch (Throwable ignored) {

        }

        for (Method method : methods) {
            String methodName = method.getName();
            int ordinal = 0, serialzeFeatures = 0, parserFeatures = 0;
            String label = null;
            if (Modifier.isStatic(method.getModifiers())) {
                continue;
            }

            Class<?> returnType = method.getReturnType();
            if (returnType.equals(Void.TYPE)) {
                continue;
            }

            if (method.getParameterTypes().length != 0) {
                continue;
            }

            if (returnType == ClassLoader.class
                    || returnType == InputStream.class
                    || returnType == Reader.class) {
                continue;
            }

            if (methodName.equals(""getMetaClass"")
                    && returnType.getName().equals(""groovy.lang.MetaClass"")) {
                continue;
            }
            if (methodName.equals(""getSuppressed"")
                    && method.getDeclaringClass() == Throwable.class) {
                continue;
            }

            if (kotlin && isKotlinIgnore(clazz, methodName)) {
                continue;
            }
            /**
             *  如果在属性或者方法上存在JSONField注解，并且定制了name属性，不以类上的propertyNamingStrategy设置为准，以此字段的JSONField的name定制为准。
             */
            Boolean fieldAnnotationAndNameExists = false;
            JSONField annotation = TypeUtils.getAnnotation(method, JSONField.class);
            if (annotation == null) {
                annotation = getSuperMethodAnnotation(clazz, method);
            }
            if (annotation == null && kotlin) {
                if (constructors == null) {
                    constructors = clazz.getDeclaredConstructors();
                    Constructor creatorConstructor = TypeUtils.getKotlinConstructor(constructors);
                    if (creatorConstructor != null) {
                        paramAnnotationArrays = TypeUtils.getParameterAnnotations(creatorConstructor);
                        paramNames = TypeUtils.getKoltinConstructorParameters(clazz);
                        if (paramNames != null) {
                            String[] paramNames_sorted = new String[paramNames.length];
                            System.arraycopy(paramNames, 0, paramNames_sorted, 0, paramNames.length);

                            Arrays.sort(paramNames_sorted);
                            paramNameMapping = new short[paramNames.length];
                            for (short p = 0; p < paramNames.length; p++) {
                                int index = Arrays.binarySearch(paramNames_sorted, paramNames[p]);
                                paramNameMapping[index] = p;
                            }
                            paramNames = paramNames_sorted;
                        }
                    }
                }
                if (paramNames != null && paramNameMapping != null && methodName.startsWith(""get"")) {
                    String propertyName = decapitalize(methodName.substring(3));
                    int p = Arrays.binarySearch(paramNames, propertyName);
                    if (p < 0) {
                        for (int i = 0; i < paramNames.length; i++) {
                            if (propertyName.equalsIgnoreCase(paramNames[i])) {
                                p = i;
                                break;
                            }
                        }
                    }
                    if (p >= 0) {
                        short index = paramNameMapping[p];
                        Annotation[] paramAnnotations = paramAnnotationArrays[index];
                        if (paramAnnotations != null) {
                            for (Annotation paramAnnotation : paramAnnotations) {
                                if (paramAnnotation instanceof JSONField) {
                                    annotation = (JSONField) paramAnnotation;
                                    break;
                                }
                            }
                        }
                        if (annotation == null) {
                            Field field = ParserConfig.getFieldFromCache(propertyName, fieldCacheMap);
                            if (field != null) {
                                annotation = TypeUtils.getAnnotation(field, JSONField.class);
                            }
                        }
                    }
                }
            }
            if (annotation != null) {
                if (!annotation.serialize()) {
                    continue;
                }
                ordinal = annotation.ordinal();
                serialzeFeatures = SerializerFeature.of(annotation.serialzeFeatures());
                parserFeatures = Feature.of(annotation.parseFeatures());
                if (annotation.name().length() != 0) {
                    String propertyName = annotation.name();
                    if (aliasMap != null) {
                        propertyName = aliasMap.get(propertyName);
                        if (propertyName == null) {
                            continue;
                        }
                    }
                    FieldInfo fieldInfo = new FieldInfo(propertyName, method, null, clazz, null, ordinal,
                            serialzeFeatures, parserFeatures, annotation, null, label);
                    fieldInfoMap.put(propertyName, fieldInfo);
                    continue;
                }
                if (annotation.label().length() != 0) {
                    label = annotation.label();
                }
            }
            if (methodName.startsWith(""get"")) {
                if (methodName.length() < 4) {
                    continue;
                }
                if (methodName.equals(""getClass"")) {
                    continue;
                }
                if (methodName.equals(""getDeclaringClass"") && clazz.isEnum()) {
                    continue;
                }
                char c3 = methodName.charAt(3);
                String propertyName;
                Field field = null;
                if (Character.isUpperCase(c3) //
                        || c3 > 512 // for unicode method name
                ) {
                    if (compatibleWithJavaBean) {
                        propertyName = decapitalize(methodName.substring(3));
                    } else {
                        propertyName = TypeUtils.getPropertyNameByMethodName(methodName);
                    }
                    propertyName = getPropertyNameByCompatibleFieldName(fieldCacheMap, methodName, propertyName, 3);
                } else if (c3 == '_') {
                    propertyName = methodName.substring(3);
                    field = fieldCacheMap.get(propertyName);
                    if (field == null) {
                        String temp = propertyName;
                        propertyName = methodName.substring(4);
                        field = ParserConfig.getFieldFromCache(propertyName, fieldCacheMap);
                        if (field == null) {
                            propertyName = temp; //减少修改代码带来的影响
                        }
                    }
                } else if (c3 == 'f') {
                    propertyName = methodName.substring(3);
                } else if (methodName.length() >= 5 && Character.isUpperCase(methodName.charAt(4))) {
                    propertyName = decapitalize(methodName.substring(3));
                } else {
                    propertyName = methodName.substring(3);
                    field = ParserConfig.getFieldFromCache(propertyName, fieldCacheMap);
                    if (field == null) {
                        continue;
                    }
                }
                boolean ignore = isJSONTypeIgnore(clazz, propertyName);
                if (ignore) {
                    continue;
                }

                if (field == null) {
                    // 假如bean的field很多的情况一下，轮询时将大大降低效率
                    field = ParserConfig.getFieldFromCache(propertyName, fieldCacheMap);
                }

                if (field == null && propertyName.length() > 1) {
                    char ch = propertyName.charAt(1);
                    if (ch >= 'A' && ch <= 'Z') {
                        String javaBeanCompatiblePropertyName = decapitalize(methodName.substring(3));
                        field = ParserConfig.getFieldFromCache(javaBeanCompatiblePropertyName, fieldCacheMap);
                    }
                }
                JSONField fieldAnnotation = null;
                if (field != null) {
                    fieldAnnotation = TypeUtils.getAnnotation(field, JSONField.class);
                    if (fieldAnnotation != null) {
                        if (!fieldAnnotation.serialize()) {
                            continue;
                        }
                        ordinal = fieldAnnotation.ordinal();
                        serialzeFeatures = SerializerFeature.of(fieldAnnotation.serialzeFeatures());
                        parserFeatures = Feature.of(fieldAnnotation.parseFeatures());
                        if (fieldAnnotation.name().length() != 0) {
                            fieldAnnotationAndNameExists = true;
                            propertyName = fieldAnnotation.name();
                            if (aliasMap != null) {
                                propertyName = aliasMap.get(propertyName);
                                if (propertyName == null) {
                                    continue;
                                }
                            }
                        }
                        if (fieldAnnotation.label().length() != 0) {
                            label = fieldAnnotation.label();
                        }
                    }
                }
                if (aliasMap != null) {
                    propertyName = aliasMap.get(propertyName);
                    if (propertyName == null) {
                        continue;
                    }
                }
                if (propertyNamingStrategy != null && !fieldAnnotationAndNameExists) {
                    propertyName = propertyNamingStrategy.translate(propertyName);
                }
                FieldInfo fieldInfo = new FieldInfo(propertyName, method, field, clazz, null, ordinal, serialzeFeatures, parserFeatures,
                        annotation, fieldAnnotation, label);
                fieldInfoMap.put(propertyName, fieldInfo);
            }
            if (methodName.startsWith(""is"")) {
                if (methodName.length() < 3) {
                    continue;
                }
                if (returnType != Boolean.TYPE
                        && returnType != Boolean.class) {
                    continue;
                }
                char c2 = methodName.charAt(2);
                String propertyName;
                Field field = null;
                if (Character.isUpperCase(c2)) {
                    if (compatibleWithJavaBean) {
                        propertyName = decapitalize(methodName.substring(2));
                    } else {
                        propertyName = Character.toLowerCase(methodName.charAt(2)) + methodName.substring(3);
                    }
                    propertyName = getPropertyNameByCompatibleFieldName(fieldCacheMap, methodName, propertyName, 2);
                } else if (c2 == '_') {
                    propertyName = methodName.substring(3);
                    field = fieldCacheMap.get(propertyName);
                    if (field == null) {
                        String temp = propertyName;
                        propertyName = methodName.substring(2);
                        field = ParserConfig.getFieldFromCache(propertyName, fieldCacheMap);
                        if (field == null) {
                            propertyName = temp;
                        }
                    }
                } else if (c2 == 'f') {
                    propertyName = methodName.substring(2);
                } else {
                    propertyName = methodName.substring(2);
                    field = ParserConfig.getFieldFromCache(propertyName, fieldCacheMap);
                    if (field == null) {
                        continue;
                    }
                }
                boolean ignore = isJSONTypeIgnore(clazz, propertyName);
                if (ignore) {
                    continue;
                }

                if (field == null) {
                    field = ParserConfig.getFieldFromCache(propertyName, fieldCacheMap);
                }

                if (field == null) {
                    field = ParserConfig.getFieldFromCache(methodName, fieldCacheMap);
                }
                JSONField fieldAnnotation = null;
                if (field != null) {
                    fieldAnnotation = TypeUtils.getAnnotation(field, JSONField.class);
                    if (fieldAnnotation != null) {
                        if (!fieldAnnotation.serialize()) {
                            continue;
                        }
                        ordinal = fieldAnnotation.ordinal();
                        serialzeFeatures = SerializerFeature.of(fieldAnnotation.serialzeFeatures());
                        parserFeatures = Feature.of(fieldAnnotation.parseFeatures());
                        if (fieldAnnotation.name().length() != 0) {
                            propertyName = fieldAnnotation.name();
                            if (aliasMap != null) {
                                propertyName = aliasMap.get(propertyName);
                                if (propertyName == null) {
                                    continue;
                                }
                            }
                        }
                        if (fieldAnnotation.label().length() != 0) {
                            label = fieldAnnotation.label();
                        }
                    }
                }
                if (aliasMap != null) {
                    propertyName = aliasMap.get(propertyName);
                    if (propertyName == null) {
                        continue;
                    }
                }
                if (propertyNamingStrategy != null) {
                    propertyName = propertyNamingStrategy.translate(propertyName);
                }
                //优先选择get
                if (fieldInfoMap.containsKey(propertyName)) {
                    continue;
                }
                FieldInfo fieldInfo = new FieldInfo(propertyName, method, field, clazz, null, ordinal, serialzeFeatures, parserFeatures,
                        annotation, fieldAnnotation, label);
                fieldInfoMap.put(propertyName, fieldInfo);
            }
        }
        Field[] fields = clazz.getFields();
        computeFields(clazz, aliasMap, propertyNamingStrategy, fieldInfoMap, fields);
        return getFieldInfos(clazz, sorted, fieldInfoMap);
    }

    private static List<FieldInfo> getFieldInfos(Class<?> clazz, boolean sorted, Map<String, FieldInfo> fieldInfoMap) {
        List<FieldInfo> fieldInfoList = new ArrayList<FieldInfo>();
        String[] orders = null;
        JSONType annotation = TypeUtils.getAnnotation(clazz, JSONType.class);
        if (annotation != null) {
            orders = annotation.orders();
        }
        if (orders != null && orders.length > 0) {
            LinkedHashMap<String, FieldInfo> map = new LinkedHashMap<String, FieldInfo>(fieldInfoMap.size());
            for (FieldInfo field : fieldInfoMap.values()) {
                map.put(field.name, field);
            }
            for (String item : orders) {
                FieldInfo field = map.get(item);
                if (field != null) {
                    fieldInfoList.add(field);
                    map.remove(item);
                }
            }
            fieldInfoList.addAll(map.values());
        } else {
            fieldInfoList.addAll(fieldInfoMap.values());
            if (sorted) {
                Collections.sort(fieldInfoList);
            }
        }
        return fieldInfoList;
    }

    private static void computeFields(
            Class<?> clazz, //
            Map<String, String> aliasMap, //
            PropertyNamingStrategy propertyNamingStrategy, //
            Map<String, FieldInfo> fieldInfoMap, //
            Field[] fields) {
        for (Field field : fields) {
            if (Modifier.isStatic(field.getModifiers())) {
                continue;
            }
            JSONField fieldAnnotation = TypeUtils.getAnnotation(field, JSONField.class);
            int ordinal = 0, serialzeFeatures = 0, parserFeatures = 0;
            String propertyName = field.getName();
            String label = null;
            if (fieldAnnotation != null) {
                if (!fieldAnnotation.serialize()) {
                    continue;
                }
                ordinal = fieldAnnotation.ordinal();
                serialzeFeatures = SerializerFeature.of(fieldAnnotation.serialzeFeatures());
                parserFeatures = Feature.of(fieldAnnotation.parseFeatures());
                if (fieldAnnotation.name().length() != 0) {
                    propertyName = fieldAnnotation.name();
                }
                if (fieldAnnotation.label().length() != 0) {
                    label = fieldAnnotation.label();
                }
            }
            if (aliasMap != null) {
                propertyName = aliasMap.get(propertyName);
                if (propertyName == null) {
                    continue;
                }
            }
            if (propertyNamingStrategy != null) {
                propertyName = propertyNamingStrategy.translate(propertyName);
            }
            if (!fieldInfoMap.containsKey(propertyName)) {
                FieldInfo fieldInfo = new FieldInfo(propertyName, null, field, clazz, null, ordinal, serialzeFeatures, parserFeatures,
                        null, fieldAnnotation, label);
                fieldInfoMap.put(propertyName, fieldInfo);
            }
        }
    }

    private static String getPropertyNameByCompatibleFieldName(Map<String, Field> fieldCacheMap, String methodName,
                                                               String propertyName, int fromIdx) {
        if (compatibleWithFieldName) {
            if (!fieldCacheMap.containsKey(propertyName)) {
                String tempPropertyName = methodName.substring(fromIdx);
                return fieldCacheMap.containsKey(tempPropertyName) ? tempPropertyName : propertyName;
            }
        }
        return propertyName;
    }

    public static JSONField getSuperMethodAnnotation(final Class<?> clazz, final Method method) {
        Class<?>[] interfaces = clazz.getInterfaces();
        if (interfaces.length > 0) {
            Class<?>[] types = method.getParameterTypes();
            for (Class<?> interfaceClass : interfaces) {
                for (Method interfaceMethod : interfaceClass.getMethods()) {
                    Class<?>[] interfaceTypes = interfaceMethod.getParameterTypes();
                    if (interfaceTypes.length != types.length) {
                        continue;
                    }
                    if (!interfaceMethod.getName().equals(method.getName())) {
                        continue;
                    }
                    boolean match = true;
                    for (int i = 0; i < types.length; ++i) {
                        if (!interfaceTypes[i].equals(types[i])) {
                            match = false;
                            break;
                        }
                    }
                    if (!match) {
                        continue;
                    }
                    JSONField annotation = TypeUtils.getAnnotation(interfaceMethod, JSONField.class);
                    if (annotation != null) {
                        return annotation;
                    }
                }
            }
        }
        Class<?> superClass = clazz.getSuperclass();
        if (superClass == null) {
            return null;
        }
        if (Modifier.isAbstract(superClass.getModifiers())) {
            Class<?>[] types = method.getParameterTypes();
            for (Method interfaceMethod : superClass.getMethods()) {
                Class<?>[] interfaceTypes = interfaceMethod.getParameterTypes();
                if (interfaceTypes.length != types.length) {
                    continue;
                }
                if (!interfaceMethod.getName().equals(method.getName())) {
                    continue;
                }
                boolean match = true;
                for (int i = 0; i < types.length; ++i) {
                    if (!interfaceTypes[i].equals(types[i])) {
                        match = false;
                        break;
                    }
                }
                if (!match) {
                    continue;
                }
                JSONField annotation = TypeUtils.getAnnotation(interfaceMethod, JSONField.class);
                if (annotation != null) {
                    return annotation;
                }
            }
        }
        return null;
    }

    private static boolean isJSONTypeIgnore(Class<?> clazz, String propertyName) {
        JSONType jsonType = TypeUtils.getAnnotation(clazz, JSONType.class);
        if (jsonType != null) {
            // 1、新增 includes 支持，如果 JSONType 同时设置了includes 和 ignores 属性，则以includes为准。
            // 2、个人认为对于大小写敏感的Java和JS而言，使用 equals() 比 equalsIgnoreCase() 更好，改动的唯一风险就是向后兼容性的问题
            // 不过，相信开发者应该都是严格按照大小写敏感的方式进行属性设置的
            String[] fields = jsonType.includes();
            if (fields.length > 0) {
                for (String field : fields) {
                    if (propertyName.equals(field)) {
                        return false;
                    }
                }
                return true;
            } else {
                fields = jsonType.ignores();
                for (String field : fields) {
                    if (propertyName.equals(field)) {
                        return true;
                    }
                }
            }
        }
        if (clazz.getSuperclass() != Object.class && clazz.getSuperclass() != null) {
            return isJSONTypeIgnore(clazz.getSuperclass(), propertyName);
        }
        return false;
    }

    public static boolean isGenericParamType(Type type) {
        if (type instanceof ParameterizedType) {
            return true;
        }
        if (type instanceof Class) {
            Type superType = ((Class<?>) type).getGenericSuperclass();
            return superType != Object.class && isGenericParamType(superType);
        }
        return false;
    }

    public static Type getGenericParamType(Type type) {
        if (type instanceof ParameterizedType) {
            return type;
        }
        if (type instanceof Class) {
            return getGenericParamType(((Class<?>) type).getGenericSuperclass());
        }
        return type;
    }

    public static Type unwrapOptional(Type type) {
        if (!optionalClassInited) {
            try {
                optionalClass = Class.forName(""java.util.Optional"");
            } catch (Exception e) {
                // skip
            } finally {
                optionalClassInited = true;
            }
        }
        if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            if (parameterizedType.getRawType() == optionalClass) {
                return parameterizedType.getActualTypeArguments()[0];
            }
        }
        return type;
    }

    public static Class<?> getClass(Type type) {
        if (type.getClass() == Class.class) {
            return (Class<?>) type;
        }

        if (type instanceof ParameterizedType) {
            return getClass(((ParameterizedType) type).getRawType());
        }

        if (type instanceof TypeVariable) {
            Type boundType = ((TypeVariable<?>) type).getBounds()[0];
            if (boundType instanceof Class) {
                return (Class) boundType;
            }
            return getClass(boundType);
        }

        if (type instanceof WildcardType) {
            Type[] upperBounds = ((WildcardType) type).getUpperBounds();
            if (upperBounds.length == 1) {
                return getClass(upperBounds[0]);
            }
        }

        return Object.class;
    }

    public static Field getField(Class<?> clazz, String fieldName, Field[] declaredFields) {
        for (Field field : declaredFields) {
            String itemName = field.getName();
            if (fieldName.equals(itemName)) {
                return field;
            }

            char c0, c1;
            if (fieldName.length() > 2
                    && (c0 = fieldName.charAt(0)) >= 'a' && c0 <= 'z'
                    && (c1 = fieldName.charAt(1)) >= 'A' && c1 <= 'Z'
                    && fieldName.equalsIgnoreCase(itemName)) {
                return field;
            }
        }
        Class<?> superClass = clazz.getSuperclass();
        if (superClass != null && superClass != Object.class) {
            return getField(superClass, fieldName, superClass.getDeclaredFields());
        }
        return null;
    }

    /**
     * @deprecated
     */
    public static int getSerializeFeatures(Class<?> clazz) {
        JSONType annotation = TypeUtils.getAnnotation(clazz, JSONType.class);
        if (annotation == null) {
            return 0;
        }
        return SerializerFeature.of(annotation.serialzeFeatures());
    }

    public static int getParserFeatures(Class<?> clazz) {
        JSONType annotation = TypeUtils.getAnnotation(clazz, JSONType.class);
        if (annotation == null) {
            return 0;
        }
        return Feature.of(annotation.parseFeatures());
    }

    public static String decapitalize(String name) {
        if (name == null || name.length() == 0) {
            return name;
        }
        if (name.length() > 1 && Character.isUpperCase(name.charAt(1)) && Character.isUpperCase(name.charAt(0))) {
            return name;
        }
        char[] chars = name.toCharArray();
        chars[0] = Character.toLowerCase(chars[0]);
        return new String(chars);
    }

    /**
     * resolve property name from get/set method name
     *
     * @param methodName get/set method name
     * @return property name
     */
    public static String getPropertyNameByMethodName(String methodName) {
        return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);
    }

    static void setAccessible(AccessibleObject obj) {
        if (!setAccessibleEnable) {
            return;
        }
        if (obj.isAccessible()) {
            return;
        }
        try {
            obj.setAccessible(true);
        } catch (Throwable error) {
            setAccessibleEnable = false;
        }
    }

    public static Type getCollectionItemType(Type fieldType) {
        if (fieldType instanceof ParameterizedType) {
            return getCollectionItemType((ParameterizedType) fieldType);
        }
        if (fieldType instanceof Class<?>) {
            return getCollectionItemType((Class<?>) fieldType);
        }
        return Object.class;
    }

    private static Type getCollectionItemType(Class<?> clazz) {
        return clazz.getName().startsWith(""java."")
                ? Object.class
                : getCollectionItemType(getCollectionSuperType(clazz));
    }

    private static Type getCollectionItemType(ParameterizedType parameterizedType) {
        Type rawType = parameterizedType.getRawType();
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        if (rawType == Collection.class) {
            return getWildcardTypeUpperBounds(actualTypeArguments[0]);
        }
        Class<?> rawClass = (Class<?>) rawType;
        Map<TypeVariable, Type> actualTypeMap = createActualTypeMap(rawClass.getTypeParameters(), actualTypeArguments);
        Type superType = getCollectionSuperType(rawClass);
        if (superType instanceof ParameterizedType) {
            Class<?> superClass = getRawClass(superType);
            Type[] superClassTypeParameters = ((ParameterizedType) superType).getActualTypeArguments();
            return superClassTypeParameters.length > 0
                    ? getCollectionItemType(makeParameterizedType(superClass, superClassTypeParameters, actualTypeMap))
                    : getCollectionItemType(superClass);
        }
        return getCollectionItemType((Class<?>) superType);
    }

    private static Type getCollectionSuperType(Class<?> clazz) {
        Type assignable = null;
        for (Type type : clazz.getGenericInterfaces()) {
            Class<?> rawClass = getRawClass(type);
            if (rawClass == Collection.class) {
                return type;
            }
            if (Collection.class.isAssignableFrom(rawClass)) {
                assignable = type;
            }
        }
        return assignable == null ? clazz.getGenericSuperclass() : assignable;
    }

    private static Map<TypeVariable, Type> createActualTypeMap(TypeVariable[] typeParameters, Type[] actualTypeArguments) {
        int length = typeParameters.length;
        Map<TypeVariable, Type> actualTypeMap = new HashMap<TypeVariable, Type>(length);
        for (int i = 0; i < length; i++) {
            actualTypeMap.put(typeParameters[i], actualTypeArguments[i]);
        }
        return actualTypeMap;
    }

    private static ParameterizedType makeParameterizedType(Class<?> rawClass, Type[] typeParameters, Map<TypeVariable, Type> actualTypeMap) {
        int length = typeParameters.length;
        Type[] actualTypeArguments = new Type[length];
        for (int i = 0; i < length; i++) {
            actualTypeArguments[i] = getActualType(typeParameters[i], actualTypeMap);
        }
        return new ParameterizedTypeImpl(actualTypeArguments, null, rawClass);
    }

    private static Type getActualType(Type typeParameter, Map<TypeVariable, Type> actualTypeMap) {
        if (typeParameter instanceof TypeVariable) {
            return actualTypeMap.get(typeParameter);
        } else if (typeParameter instanceof ParameterizedType) {
            return makeParameterizedType(getRawClass(typeParameter), ((ParameterizedType) typeParameter).getActualTypeArguments(), actualTypeMap);
        } else if (typeParameter instanceof GenericArrayType) {
            return new GenericArrayTypeImpl(getActualType(((GenericArrayType) typeParameter).getGenericComponentType(), actualTypeMap));
        }
        return typeParameter;
    }

    private static Type getWildcardTypeUpperBounds(Type type) {
        if (type instanceof WildcardType) {
            WildcardType wildcardType = (WildcardType) type;
            Type[] upperBounds = wildcardType.getUpperBounds();
            return upperBounds.length > 0 ? upperBounds[0] : Object.class;
        }
        return type;
    }

    public static Class<?> getCollectionItemClass(Type fieldType) {
        if (fieldType instanceof ParameterizedType) {
            Class<?> itemClass;
            Type actualTypeArgument = ((ParameterizedType) fieldType).getActualTypeArguments()[0];
            if (actualTypeArgument instanceof WildcardType) {
                WildcardType wildcardType = (WildcardType) actualTypeArgument;
                Type[] upperBounds = wildcardType.getUpperBounds();
                if (upperBounds.length == 1) {
                    actualTypeArgument = upperBounds[0];
                }
            }
            if (actualTypeArgument instanceof Class) {
                itemClass = (Class<?>) actualTypeArgument;
                if (!Modifier.isPublic(itemClass.getModifiers())) {
                    throw new JSONException(""can not create ASMParser"");
                }
            } else {
                throw new JSONException(""can not create ASMParser"");
            }
            return itemClass;
        }
        return Object.class;
    }

    private static final Map primitiveTypeMap = new HashMap<Class, String>(8) {{
        put(boolean.class, ""Z"");
        put(char.class, ""C"");
        put(byte.class, ""B"");
        put(short.class, ""S"");
        put(int.class, ""I"");
        put(long.class, ""J"");
        put(float.class, ""F"");
        put(double.class, ""D"");
    }};

    public static Type checkPrimitiveArray(GenericArrayType genericArrayType) {
        Type clz = genericArrayType;
        Type genericComponentType = genericArrayType.getGenericComponentType();

        String prefix = ""["";
        while (genericComponentType instanceof GenericArrayType) {
            genericComponentType = ((GenericArrayType) genericComponentType)
                    .getGenericComponentType();
            prefix += prefix;
        }

        if (genericComponentType instanceof Class<?>) {
            Class<?> ck = (Class<?>) genericComponentType;
            if (ck.isPrimitive()) {
                try {
                    String postfix = (String) primitiveTypeMap.get(ck);
                    if (postfix != null) {
                        clz = Class.forName(prefix + postfix);
                    }
                } catch (ClassNotFoundException ignored) {
                }
            }
        }

        return clz;
    }

    public static Set createSet(Type type) {
        Class<?> rawClass = getRawClass(type);
        Set set;
        if (rawClass == AbstractCollection.class //
                || rawClass == Collection.class) {
            set = new HashSet();
        } else if (rawClass.isAssignableFrom(HashSet.class)) {
            set = new HashSet();
        } else if (rawClass.isAssignableFrom(LinkedHashSet.class)) {
            set = new LinkedHashSet();
        } else if (rawClass.isAssignableFrom(TreeSet.class)) {
            set = new TreeSet();
        } else if (rawClass.isAssignableFrom(EnumSet.class)) {
            Type itemType;
            if (type instanceof ParameterizedType) {
                itemType = ((ParameterizedType) type).getActualTypeArguments()[0];
            } else {
                itemType = Object.class;
            }
            set = EnumSet.noneOf((Class<Enum>) itemType);
        } else {
            try {
                set = (Set) rawClass.newInstance();
            } catch (Exception e) {
                throw new JSONException(""create instance error, class "" + rawClass.getName());
            }
        }
        return set;
    }

    @SuppressWarnings({""rawtypes"", ""unchecked""})
    public static Collection createCollection(Type type) {
        Class<?> rawClass = getRawClass(type);
        Collection list;
        if (rawClass == AbstractCollection.class //
                || rawClass == Collection.class) {
            list = new ArrayList();
        } else if (rawClass.isAssignableFrom(HashSet.class)) {
            list = new HashSet();
        } else if (rawClass.isAssignableFrom(LinkedHashSet.class)) {
            list = new LinkedHashSet();
        } else if (rawClass.isAssignableFrom(TreeSet.class)) {
            list = new TreeSet();
        } else if (rawClass.isAssignableFrom(ArrayList.class)) {
            list = new ArrayList();
        } else if (rawClass.isAssignableFrom(EnumSet.class)) {
            Type itemType;
            if (type instanceof ParameterizedType) {
                itemType = ((ParameterizedType) type).getActualTypeArguments()[0];
            } else {
                itemType = Object.class;
            }
            list = EnumSet.noneOf((Class<Enum>) itemType);
        } else if (rawClass.isAssignableFrom(Queue.class)
                || (class_deque != null && rawClass.isAssignableFrom(class_deque))) {
            list = new LinkedList();
        } else {
            try {
                list = (Collection) rawClass.newInstance();
            } catch (Exception e) {
                throw new JSONException(""create instance error, class "" + rawClass.getName());
            }
        }
        return list;
    }

    public static Class<?> getRawClass(Type type) {
        if (type instanceof Class<?>) {
            return (Class<?>) type;
        } else if (type instanceof ParameterizedType) {
            return getRawClass(((ParameterizedType) type).getRawType());
        } else if (type instanceof WildcardType) {
            WildcardType wildcardType = (WildcardType) type;
            Type[] upperBounds = wildcardType.getUpperBounds();
            if (upperBounds.length == 1) {
                return getRawClass(upperBounds[0]);
            } else {
                throw new JSONException(""TODO"");
            }
        } else {
            throw new JSONException(""TODO"");
        }
    }

    private static final Set<String> isProxyClassNames = new HashSet<String>(6) {{
        add(""net.sf.cglib.proxy.Factory"");
        add(""org.springframework.cglib.proxy.Factory"");
        add(""javassist.util.proxy.ProxyObject"");
        add(""org.apache.ibatis.javassist.util.proxy.ProxyObject"");
        add(""org.hibernate.proxy.HibernateProxy"");
        add(""org.springframework.context.annotation.ConfigurationClassEnhancer$EnhancedConfiguration"");
    }};

    public static boolean isProxy(Class<?> clazz) {

        for (Class<?> item : clazz.getInterfaces()) {
            String interfaceName = item.getName();
            if (isProxyClassNames.contains(interfaceName)) {
                return true;
            }
        }
        return false;
    }

    public static boolean isTransient(Method method) {
        if (method == null) {
            return false;
        }
        if (!transientClassInited) {
            try {
                transientClass = (Class<? extends Annotation>) Class.forName(""java.beans.Transient"");
            } catch (Exception e) {
                // skip
            } finally {
                transientClassInited = true;
            }
        }
        if (transientClass != null) {
            Annotation annotation = TypeUtils.getAnnotation(method, transientClass);
            return annotation != null;
        }
        return false;
    }

    public static boolean isAnnotationPresentOneToMany(Method method) {
        if (method == null) {
            return false;
        }

        if (class_OneToMany == null && !class_OneToMany_error) {
            try {
                class_OneToMany = (Class<? extends Annotation>) Class.forName(""javax.persistence.OneToMany"");
            } catch (Throwable e) {
                // skip
                class_OneToMany_error = true;
            }
        }
        return class_OneToMany != null && method.isAnnotationPresent(class_OneToMany);

    }

    public static boolean isAnnotationPresentManyToMany(Method method) {
        if (method == null) {
            return false;
        }

        if (class_ManyToMany == null && !class_ManyToMany_error) {
            try {
                class_ManyToMany = (Class<? extends Annotation>) Class.forName(""javax.persistence.ManyToMany"");
            } catch (Throwable e) {
                // skip
                class_ManyToMany_error = true;
            }
        }
        return class_ManyToMany != null && (method.isAnnotationPresent(class_OneToMany) || method.isAnnotationPresent(class_ManyToMany));

    }

    public static boolean isHibernateInitialized(Object object) {
        if (object == null) {
            return false;
        }
        if (method_HibernateIsInitialized == null && !method_HibernateIsInitialized_error) {
            try {
                Class<?> class_Hibernate = Class.forName(""org.hibernate.Hibernate"");
                method_HibernateIsInitialized = class_Hibernate.getMethod(""isInitialized"", Object.class);
            } catch (Throwable e) {
                // skip
                method_HibernateIsInitialized_error = true;
            }
        }
        if (method_HibernateIsInitialized != null) {
            try {
                Boolean initialized = (Boolean) method_HibernateIsInitialized.invoke(null, object);
                return initialized;
            } catch (Throwable e) {
                // skip
            }
        }
        return true;
    }

    public static double parseDouble(String str) {
        final int len = str.length();
        if (len > 10) {
            return Double.parseDouble(str);
        }

        boolean negative = false;

        long longValue = 0;
        int scale = 0;
        for (int i = 0; i < len; ++i) {
            char ch = str.charAt(i);
            if (ch == '-' && i == 0) {
                negative = true;
                continue;
            }

            if (ch == '.') {
                if (scale != 0) {
                    return Double.parseDouble(str);
                }
                scale = len - i - 1;
                continue;
            }

            if (ch >= '0' && ch <= '9') {
                int digit = ch - '0';
                longValue = longValue * 10 + digit;
            } else {
                return Double.parseDouble(str);
            }
        }

        if (negative) {
            longValue = -longValue;
        }

        switch (scale) {
            case 0:
                return (double) longValue;
            case 1:
                return ((double) longValue) / 10;
            case 2:
                return ((double) longValue) / 100;
            case 3:
                return ((double) longValue) / 1000;
            case 4:
                return ((double) longValue) / 10000;
            case 5:
                return ((double) longValue) / 100000;
            case 6:
                return ((double) longValue) / 1000000;
            case 7:
                return ((double) longValue) / 10000000;
            case 8:
                return ((double) longValue) / 100000000;
            case 9:
                return ((double) longValue) / 1000000000;
        }

        return Double.parseDouble(str);
    }

    public static float parseFloat(String str) {
        final int len = str.length();
        if (len >= 10) {
            return Float.parseFloat(str);
        }

        boolean negative = false;

        long longValue = 0;
        int scale = 0;
        for (int i = 0; i < len; ++i) {
            char ch = str.charAt(i);
            if (ch == '-' && i == 0) {
                negative = true;
                continue;
            }

            if (ch == '.') {
                if (scale != 0) {
                    return Float.parseFloat(str);
                }
                scale = len - i - 1;
                continue;
            }

            if (ch >= '0' && ch <= '9') {
                int digit = ch - '0';
                longValue = longValue * 10 + digit;
            } else {
                return Float.parseFloat(str);
            }
        }

        if (negative) {
            longValue = -longValue;
        }

        switch (scale) {
            case 0:
                return (float) longValue;
            case 1:
                return ((float) longValue) / 10;
            case 2:
                return ((float) longValue) / 100;
            case 3:
                return ((float) longValue) / 1000;
            case 4:
                return ((float) longValue) / 10000;
            case 5:
                return ((float) longValue) / 100000;
            case 6:
                return ((float) longValue) / 1000000;
            case 7:
                return ((float) longValue) / 10000000;
            case 8:
                return ((float) longValue) / 100000000;
            case 9:
                return ((float) longValue) / 1000000000;
        }

        return Float.parseFloat(str);
    }

    public static final long fnv1a_64_magic_hashcode = 0xcbf29ce484222325L;
    public static final long fnv1a_64_magic_prime = 0x100000001b3L;

    public static long fnv1a_64_extract(String key) {
        long hashCode = fnv1a_64_magic_hashcode;
        for (int i = 0; i < key.length(); ++i) {
            char ch = key.charAt(i);
            if (ch == '_' || ch == '-') {
                continue;
            }
            if (ch >= 'A' && ch <= 'Z') {
                ch = (char) (ch + 32);
            }
            hashCode ^= ch;
            hashCode *= fnv1a_64_magic_prime;
        }
        return hashCode;
    }

    public static long fnv1a_64_lower(String key) {
        long hashCode = fnv1a_64_magic_hashcode;
        for (int i = 0; i < key.length(); ++i) {
            char ch = key.charAt(i);
            if (ch >= 'A' && ch <= 'Z') {
                ch = (char) (ch + 32);
            }
            hashCode ^= ch;
            hashCode *= fnv1a_64_magic_prime;
        }
        return hashCode;
    }

    public static long fnv1a_64(String key) {
        long hashCode = fnv1a_64_magic_hashcode;
        for (int i = 0; i < key.length(); ++i) {
            char ch = key.charAt(i);
            hashCode ^= ch;
            hashCode *= fnv1a_64_magic_prime;
        }
        return hashCode;
    }

    public static boolean isKotlin(Class clazz) {
        if (kotlin_metadata == null && !kotlin_metadata_error) {
            try {
                kotlin_metadata = Class.forName(""kotlin.Metadata"");
            } catch (Throwable e) {
                kotlin_metadata_error = true;
            }
        }
        return kotlin_metadata != null && clazz.isAnnotationPresent(kotlin_metadata);
    }

    public static Constructor getKotlinConstructor(Constructor[] constructors) {
        return getKotlinConstructor(constructors, null);
    }

    public static Constructor getKotlinConstructor(Constructor[] constructors, String[] paramNames) {
        Constructor creatorConstructor = null;
        for (Constructor<?> constructor : constructors) {
            Class<?>[] parameterTypes = constructor.getParameterTypes();
            if (paramNames != null && parameterTypes.length != paramNames.length) {
                continue;
            }

            if (parameterTypes.length > 0 && parameterTypes[parameterTypes.length - 1].getName().equals(""kotlin.jvm.internal.DefaultConstructorMarker"")) {
                continue;
            }
            if (creatorConstructor != null && creatorConstructor.getParameterTypes().length >= parameterTypes.length) {
                continue;
            }
            creatorConstructor = constructor;
        }
        return creatorConstructor;
    }

    public static String[] getKoltinConstructorParameters(Class clazz) {
        if (kotlin_kclass_constructor == null && !kotlin_class_klass_error) {
            try {
                Class class_kotlin_kclass = Class.forName(""kotlin.reflect.jvm.internal.KClassImpl"");
                kotlin_kclass_constructor = class_kotlin_kclass.getConstructor(Class.class);
            } catch (Throwable e) {
                kotlin_class_klass_error = true;
            }
        }
        if (kotlin_kclass_constructor == null) {
            return null;
        }

        if (kotlin_kclass_getConstructors == null && !kotlin_class_klass_error) {
            try {
                Class class_kotlin_kclass = Class.forName(""kotlin.reflect.jvm.internal.KClassImpl"");
                kotlin_kclass_getConstructors = class_kotlin_kclass.getMethod(""getConstructors"");
            } catch (Throwable e) {
                kotlin_class_klass_error = true;
            }
        }

        if (kotlin_kfunction_getParameters == null && !kotlin_class_klass_error) {
            try {
                Class class_kotlin_kfunction = Class.forName(""kotlin.reflect.KFunction"");
                kotlin_kfunction_getParameters = class_kotlin_kfunction.getMethod(""getParameters"");
            } catch (Throwable e) {
                kotlin_class_klass_error = true;
            }
        }

        if (kotlin_kparameter_getName == null && !kotlin_class_klass_error) {
            try {
                Class class_kotlinn_kparameter = Class.forName(""kotlin.reflect.KParameter"");
                kotlin_kparameter_getName = class_kotlinn_kparameter.getMethod(""getName"");
            } catch (Throwable e) {
                kotlin_class_klass_error = true;
            }
        }

        if (kotlin_error) {
            return null;
        }

        try {
            Object constructor = null;
            Object kclassImpl = kotlin_kclass_constructor.newInstance(clazz);
            Iterable it = (Iterable) kotlin_kclass_getConstructors.invoke(kclassImpl);
            for (Iterator iterator = it.iterator(); iterator.hasNext(); iterator.hasNext()) {
                Object item = iterator.next();
                List parameters = (List) kotlin_kfunction_getParameters.invoke(item);
                if (constructor != null && parameters.size() == 0) {
                    continue;
                }
                constructor = item;
            }

            if (constructor == null) {
                return null;
            }

            List parameters = (List) kotlin_kfunction_getParameters.invoke(constructor);
            String[] names = new String[parameters.size()];
            for (int i = 0; i < parameters.size(); i++) {
                Object param = parameters.get(i);
                names[i] = (String) kotlin_kparameter_getName.invoke(param);
            }
            return names;
        } catch (Throwable e) {
            e.printStackTrace();
            kotlin_error = true;
        }
        return null;
    }

    private static boolean isKotlinIgnore(Class clazz, String methodName) {
        if (kotlinIgnores == null && !kotlinIgnores_error) {
            try {
                Map<Class, String[]> map = new HashMap<Class, String[]>();
                Class charRangeClass = Class.forName(""kotlin.ranges.CharRange"");
                map.put(charRangeClass, new String[]{""getEndInclusive"", ""isEmpty""});
                Class intRangeClass = Class.forName(""kotlin.ranges.IntRange"");
                map.put(intRangeClass, new String[]{""getEndInclusive"", ""isEmpty""});
                Class longRangeClass = Class.forName(""kotlin.ranges.LongRange"");
                map.put(longRangeClass, new String[]{""getEndInclusive"", ""isEmpty""});
                Class floatRangeClass = Class.forName(""kotlin.ranges.ClosedFloatRange"");
                map.put(floatRangeClass, new String[]{""getEndInclusive"", ""isEmpty""});
                Class doubleRangeClass = Class.forName(""kotlin.ranges.ClosedDoubleRange"");
                map.put(doubleRangeClass, new String[]{""getEndInclusive"", ""isEmpty""});
                kotlinIgnores = map;
            } catch (Throwable error) {
                kotlinIgnores_error = true;
            }
        }
        if (kotlinIgnores == null) {
            return false;
        }
        String[] ignores = kotlinIgnores.get(clazz);
        return ignores != null && Arrays.binarySearch(ignores, methodName) >= 0;
    }

    public static <A extends Annotation> A getAnnotation(Class<?> targetClass, Class<A> annotationClass) {
        A targetAnnotation = targetClass.getAnnotation(annotationClass);

        Class<?> mixInClass = null;
        Type type = JSON.getMixInAnnotations(targetClass);
        if (type instanceof Class<?>) {
            mixInClass = (Class<?>) type;
        }

        if (mixInClass != null) {
            A mixInAnnotation = mixInClass.getAnnotation(annotationClass);
            Annotation[] annotations = mixInClass.getAnnotations();
            if (mixInAnnotation == null && annotations.length > 0) {
                for (Annotation annotation : annotations) {
                    mixInAnnotation = annotation.annotationType().getAnnotation(annotationClass);
                    if (mixInAnnotation != null) {
                        break;
                    }
                }
            }
            if (mixInAnnotation != null) {
                return mixInAnnotation;
            }
        }

        Annotation[] targetClassAnnotations = targetClass.getAnnotations();
        if (targetAnnotation == null && targetClassAnnotations.length > 0) {
            for (Annotation annotation : targetClassAnnotations) {
                targetAnnotation = annotation.annotationType().getAnnotation(annotationClass);
                if (targetAnnotation != null) {
                    break;
                }
            }
        }
        return targetAnnotation;
    }

    public static <A extends Annotation> A getAnnotation(Field field, Class<A> annotationClass) {
        A targetAnnotation = field.getAnnotation(annotationClass);

        Class<?> clazz = field.getDeclaringClass();
        A mixInAnnotation;
        Class<?> mixInClass = null;
        Type type = JSON.getMixInAnnotations(clazz);
        if (type instanceof Class<?>) {
            mixInClass = (Class<?>) type;
        }

        if (mixInClass != null) {
            Field mixInField = null;
            String fieldName = field.getName();
            // 递归从MixIn类的父类中查找注解（如果有父类的话）
            for (Class<?> currClass = mixInClass; currClass != null && currClass != Object.class;
                 currClass = currClass.getSuperclass()) {
                try {
                    mixInField = currClass.getDeclaredField(fieldName);
                    break;
                } catch (NoSuchFieldException e) {
                    // skip
                }
            }
            if (mixInField == null) {
                return targetAnnotation;
            }
            mixInAnnotation = mixInField.getAnnotation(annotationClass);
            if (mixInAnnotation != null) {
                return mixInAnnotation;
            }
        }
        return targetAnnotation;
    }

    public static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationClass) {
        A targetAnnotation = method.getAnnotation(annotationClass);

        Class<?> clazz = method.getDeclaringClass();
        A mixInAnnotation;
        Class<?> mixInClass = null;
        Type type = JSON.getMixInAnnotations(clazz);
        if (type instanceof Class<?>) {
            mixInClass = (Class<?>) type;
        }

        if (mixInClass != null) {
            Method mixInMethod = null;
            String methodName = method.getName();
            Class<?>[] parameterTypes = method.getParameterTypes();
            // 递归从MixIn类的父类中查找注解（如果有父类的话）
            for (Class<?> currClass = mixInClass; currClass != null && currClass != Object.class;
                 currClass = currClass.getSuperclass()) {
                try {
                    mixInMethod = currClass.getDeclaredMethod(methodName, parameterTypes);
                    break;
                } catch (NoSuchMethodException e) {
                    // skip
                }
            }
            if (mixInMethod == null) {
                return targetAnnotation;
            }
            mixInAnnotation = mixInMethod.getAnnotation(annotationClass);
            if (mixInAnnotation != null) {
                return mixInAnnotation;
            }
        }
        return targetAnnotation;
    }

    public static Annotation[][] getParameterAnnotations(Method method) {
        Annotation[][] targetAnnotations = method.getParameterAnnotations();

        Class<?> clazz = method.getDeclaringClass();
        Annotation[][] mixInAnnotations;
        Class<?> mixInClass = null;
        Type type = JSON.getMixInAnnotations(clazz);
        if (type instanceof Class<?>) {
            mixInClass = (Class<?>) type;
        }

        if (mixInClass != null) {
            Method mixInMethod = null;
            String methodName = method.getName();
            Class<?>[] parameterTypes = method.getParameterTypes();
            // 递归从MixIn类的父类中查找注解（如果有父类的话）
            for (Class<?> currClass = mixInClass; currClass != null && currClass != Object.class;
                 currClass = currClass.getSuperclass()) {
                try {
                    mixInMethod = currClass.getDeclaredMethod(methodName, parameterTypes);
                    break;
                } catch (NoSuchMethodException e) {
                    continue;
                }
            }
            if (mixInMethod == null) {
                return targetAnnotations;
            }
            mixInAnnotations = mixInMethod.getParameterAnnotations();
            if (mixInAnnotations != null) {
                return mixInAnnotations;
            }
        }
        return targetAnnotations;
    }

    public static Annotation[][] getParameterAnnotations(Constructor constructor) {
        Annotation[][] targetAnnotations = constructor.getParameterAnnotations();

        Class<?> clazz = constructor.getDeclaringClass();
        Annotation[][] mixInAnnotations;
        Class<?> mixInClass = null;
        Type type = JSON.getMixInAnnotations(clazz);
        if (type instanceof Class<?>) {
            mixInClass = (Class<?>) type;
        }

        if (mixInClass != null) {
            Constructor mixInConstructor = null;
            Class<?>[] parameterTypes = constructor.getParameterTypes();
            // 构建参数列表，因为内部类的构造函数需要传入外部类的引用
            List<Class<?>> enclosingClasses = new ArrayList<Class<?>>(2);
            for (Class<?> enclosingClass = mixInClass.getEnclosingClass(); enclosingClass != null; enclosingClass = enclosingClass.getEnclosingClass()) {
                enclosingClasses.add(enclosingClass);
            }
            int level = enclosingClasses.size();
            // 递归从MixIn类的父类中查找注解（如果有父类的话）
            for (Class<?> currClass = mixInClass; currClass != null && currClass != Object.class;
                 currClass = currClass.getSuperclass()) {
                try {
                    if (level != 0) {
                        Class<?>[] outerClassAndParameterTypes = new Class[level + parameterTypes.length];
                        System.arraycopy(parameterTypes, 0, outerClassAndParameterTypes, level, parameterTypes.length);
                        for (int i = level; i > 0; i--) {
                            outerClassAndParameterTypes[i - 1] = enclosingClasses.get(i - 1);
                        }
                        mixInConstructor = mixInClass.getDeclaredConstructor(outerClassAndParameterTypes);
                    } else {
                        mixInConstructor = mixInClass.getDeclaredConstructor(parameterTypes);
                    }
                    break;
                } catch (NoSuchMethodException e) {
                    level--;
                }
            }
            if (mixInConstructor == null) {
                return targetAnnotations;
            }
            mixInAnnotations = mixInConstructor.getParameterAnnotations();
            if (mixInAnnotations != null) {
                return mixInAnnotations;
            }
        }
        return targetAnnotations;
    }

    public static boolean isJacksonCreator(Method method) {
        if (method == null) {
            return false;
        }

        if (class_JacksonCreator == null && !class_JacksonCreator_error) {
            try {
                class_JacksonCreator = (Class<? extends Annotation>) Class.forName(""com.fasterxml.jackson.annotation.JsonCreator"");
            } catch (Throwable e) {
                // skip
                class_JacksonCreator_error = true;
            }
        }
        return class_JacksonCreator != null && method.isAnnotationPresent(class_JacksonCreator);
    }

    private static Object OPTIONAL_EMPTY;
    private static boolean OPTIONAL_ERROR = false;

    public static Object optionalEmpty(Type type) {
        if (OPTIONAL_ERROR) {
            return null;
        }

        Class clazz = getClass(type);
        if (clazz == null) {
            return null;
        }

        String className = clazz.getName();

        if (""java.util.Optional"".equals(className)) {
            if (OPTIONAL_EMPTY == null) {
                try {
                    Method empty = Class.forName(className).getMethod(""empty"");
                    OPTIONAL_EMPTY = empty.invoke(null);
                } catch (Throwable e) {
                    OPTIONAL_ERROR = true;
                }
            }
            return OPTIONAL_EMPTY;
        }
        return null;
    }

    public static class MethodInheritanceComparator implements Comparator<Method> {
        public int compare(Method m1, Method m2) {
            int cmp = m1.getName().compareTo(m2.getName());
            if (cmp != 0) {
                return cmp;
            }

            Class<?> class1 = m1.getReturnType();
            Class<?> class2 = m2.getReturnType();

            if (class1.equals(class2)) {
                return 0;
            }

            if (class1.isAssignableFrom(class2)) {
                return -1;
            }
            
            if (class2.isAssignableFrom(class1)) {
                return 1;
            }
            return 0;
        }
    }
}
","['Assertion Roulette', 'Conditional Test Logic', 'Unknown Test']","['Assertion Roulette', 'Conditional Test Logic', 'Eager Test', 'Lazy Test']",2,1,2,12
36671_45.0_hbase_testgetvalue,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/36671_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/36671_actual.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.hadoop.hbase.metrics.impl;

import static org.junit.Assert.assertEquals;

import java.util.concurrent.atomic.AtomicLong;
import org.apache.hadoop.hbase.HBaseClassTestRule;
import org.apache.hadoop.hbase.metrics.Gauge;
import org.apache.hadoop.hbase.testclassification.SmallTests;
import org.junit.ClassRule;
import org.junit.Test;
import org.junit.experimental.categories.Category;

/**
 * Test class for {@link Gauge}.
 */
@Category(SmallTests.class)
public class TestGauge {

  @ClassRule
  public static final HBaseClassTestRule CLASS_RULE = HBaseClassTestRule.forClass(TestGauge.class);

  @Test
  public void testGetValue() {
    SimpleGauge gauge = new SimpleGauge();

    assertEquals(0, (long) gauge.getValue());

    gauge.setValue(1000L);

    assertEquals(1000L, (long) gauge.getValue());
  }

  /**
   * Gauge implementation with a setter.
   */
  private static class SimpleGauge implements Gauge<Long> {

    private final AtomicLong value = new AtomicLong(0L);

    @Override
    public Long getValue() {
      return this.value.get();
    }

    public void setValue(long value) {
      this.value.set(value);
    }
  }
}
","/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.hadoop.hbase.metrics;

import org.apache.hadoop.hbase.HBaseInterfaceAudience;
import org.apache.yetus.audience.InterfaceAudience;
import org.apache.yetus.audience.InterfaceStability;

/**
 * A metrics which measures a discrete value.
 * @param <T> The value of the Gauge.
 */
@InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.COPROC)
@InterfaceStability.Evolving
public interface Gauge<T> extends Metric {

  T getValue();

}
",['Assertion Roulette'],[],0,1,0,16
35863_76.0_achilles_should_find_using_static_consistency,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/35863_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/35863_actual.java,"/*
 * Copyright (C) 2012-2021 DuyHai DOAN
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package info.archinnov.achilles.internals.sample_classes.parser.entity;

import com.datastax.driver.core.ConsistencyLevel;

import info.archinnov.achilles.annotations.*;
import info.archinnov.achilles.internals.sample_classes.APUnitTest;
import info.archinnov.achilles.type.strategy.InsertStrategy;
import info.archinnov.achilles.type.strategy.NamingStrategy;

@APUnitTest

@Table(keyspace = ""my_ks"")
@Strategy(naming = NamingStrategy.SNAKE_CASE, insert = InsertStrategy.NOT_NULL_FIELDS)
@Consistency(read = ConsistencyLevel.LOCAL_ONE, write = ConsistencyLevel.LOCAL_ONE, serial = ConsistencyLevel.LOCAL_SERIAL)
@TTL(123456)
public class TestEntityWithStaticAnnotations {

    @PartitionKey
    private Long partitionKey;

    @Column
    private String stringValue;

    @Column(value = ""overriden"")
    private String overridenName;

    public Long getPartitionKey() {
        return partitionKey;
    }

    public void setPartitionKey(Long partitionKey) {
        this.partitionKey = partitionKey;
    }

    public String getStringValue() {
        return stringValue;
    }

    public void setStringValue(String stringValue) {
        this.stringValue = stringValue;
    }

    public String getOverridenName() {
        return overridenName;
    }

    public void setOverridenName(String overridenName) {
        this.overridenName = overridenName;
    }
}
","/*
 * Copyright (C) 2012-2021 DuyHai DOAN
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package info.archinnov.achilles.internals.entities;

import com.datastax.driver.core.ConsistencyLevel;

import info.archinnov.achilles.annotations.*;
import info.archinnov.achilles.type.strategy.InsertStrategy;
import info.archinnov.achilles.type.strategy.NamingStrategy;

@Table(keyspace = ""my_static_keyspace"", table = ""entity_static_annotations"")
@Strategy(naming = NamingStrategy.SNAKE_CASE, insert = InsertStrategy.NOT_NULL_FIELDS)
@Consistency(read = ConsistencyLevel.LOCAL_QUORUM, write = ConsistencyLevel.LOCAL_ONE, serial = ConsistencyLevel.LOCAL_SERIAL)
@TTL(1)
public class EntityWithStaticAnnotations {

    @PartitionKey
    @Column(""partition_key"")
    private Long partitionKey;

    @Column(""value"")
    private String stringValue;

    @Column(value = ""overRiden"")
    private String overridenName;

    public EntityWithStaticAnnotations() {
    }

    public EntityWithStaticAnnotations(Long partitionKey, String stringValue, String overridenName) {
        this.partitionKey = partitionKey;
        this.stringValue = stringValue;
        this.overridenName = overridenName;
    }

    public Long getPartitionKey() {
        return partitionKey;
    }

    public void setPartitionKey(Long partitionKey) {
        this.partitionKey = partitionKey;
    }

    public String getStringValue() {
        return stringValue;
    }

    public void setStringValue(String stringValue) {
        this.stringValue = stringValue;
    }

    public String getOverridenName() {
        return overridenName;
    }

    public void setOverridenName(String overridenName) {
        this.overridenName = overridenName;
    }
}
",[],[],0,0,0,17
46357_6.0_junit-quickcheck_disallowsnullkeyandnullvalue,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/46357_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/46357_actual.java,"/*
 The MIT License

 Copyright (c) 2010-2021 Paul R. Holser, Jr.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 ""Software""), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

package com.pholser.junit.quickcheck.generator.java.util;

import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.*;

public class HashtableGeneratorTest {
    private HashtableGenerator generator;

    @Before public void setUp() {
        generator = new HashtableGenerator();
    }

    @Test public void startsOutWithAnEmptyMap() {
        assertTrue(generator.empty().isEmpty());
    }

    @Test public void disallowsNullKeyAndNullValue() {
        assertFalse(generator.okToAdd(null, null));
    }

    @Test public void disallowsNullKey() {
        assertFalse(generator.okToAdd(null, new Object()));
    }

    @Test public void disallowsNullValue() {
        assertFalse(generator.okToAdd(new Object(), null));
    }

    @Test public void allowsKeyAndValueWhenNeitherIsNull() {
        assertTrue(generator.okToAdd(new Object(), new Object()));
    }
}
","/*
 The MIT License

 Copyright (c) 2010-2021 Paul R. Holser, Jr.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 ""Software""), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

package com.pholser.junit.quickcheck.generator.java.util;

import java.util.Hashtable;

/**
 * Produces values of type {@link Hashtable}.
 */
public class HashtableGenerator extends MapGenerator<Hashtable> {
    public HashtableGenerator() {
        super(Hashtable.class);
    }

    @Override protected boolean okToAdd(Object key, Object value) {
        return key != null && value != null;
    }
}
",[],[],0,0,0,17
10555_1_struts_testsanitizeinputpathshouldreturnnullforleadingwebinf,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/10555_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/10555_actual.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.struts2.showcase.filedownload;

import org.junit.Before;
import org.junit.Test;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertNull;

public class FileDownloadActionTest {

	private FileDownloadAction fileDownloadAction;

	@Before
	public void setUp() {
	    this.fileDownloadAction = new FileDownloadAction();
	}

	@Test
	public void testSanitizeInputPathShouldAllowSimpleParameter() throws Exception {
		assertEquals(""foo"", fileDownloadAction.sanitizeInputPath(""foo""));
	}

	@Test
	public void testSanitizeInputPathShouldReturnNullForNullInput() throws Exception {
		assertNull(fileDownloadAction.sanitizeInputPath(null));
	}

	@Test
	public void testSanitizeInputPathShouldReturnNullForLeadingWebInf() throws Exception {
		assertNull(fileDownloadAction.sanitizeInputPath(""WEB-INF/foo""));
	}

	@Test
	public void testSanitizeInputPathShouldReturnNullForNonLeadingWebInf() throws Exception {
		assertNull(fileDownloadAction.sanitizeInputPath(""./WEB-INF/foo""));
	}

	@Test
	public void testSanitizeInputPathShouldReturnNullForNonUppercaseWebInf() throws Exception {
		assertNull(fileDownloadAction.sanitizeInputPath(""./wEB-Inf/foo""));
	}
}
","/*
 * $Id$
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.struts2.showcase.filedownload;

import com.opensymphony.xwork2.Action;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.interceptor.parameter.StrutsParameter;

import java.io.InputStream;

/**
 * Demonstrates file resource download.
 * Set filePath to the local file resource to download,
 * relative to the application root (""/images/struts.gif"").
 */
public class FileDownloadAction implements Action {

	private String inputPath;

	public String execute() throws Exception {
		return SUCCESS;
	}

	@StrutsParameter
	public void setInputPath(String value) {
		inputPath = sanitizeInputPath(value);
	}

	/**
	 * As the user modifiable parameter inputPath will be used to access server side resources, we want the path to be
	 * sanitized - in this case it is demonstrated to disallow inputPath parameter values containing ""WEB-INF"". Consider to
	 * use even stricter rules in production environments.
	 *
	 * @param value the raw parameter input value to sanitize
	 *
	 * @return the sanitized value; <tt>null</tt> if value contains an invalid path segment like WEB-INF
	 */
	String sanitizeInputPath( String value ) {
		if (value != null && value.toUpperCase().contains(""WEB-INF"")) {
			return null;
		}
		return value;
	}

	public InputStream getInputStream() throws Exception {
		return ServletActionContext.getServletContext().getResourceAsStream(inputPath);
	}
}
",[],[],0,0,0,17
16934_21_dubbo_testprovidervalidation,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/16934_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/16934_actual.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.dubbo.validation.support.jvalidation;

import org.apache.dubbo.common.URL;
import org.apache.dubbo.validation.Validation;
import org.apache.dubbo.validation.Validator;

import javax.validation.ValidationException;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.Is.is;

class JValidationTest {
    @Test
    void testReturnTypeWithInvalidValidationProvider() {
        Assertions.assertThrows(ValidationException.class, () -> {
            Validation jValidation = new JValidation();
            URL url = URL.valueOf(""test://test:11/org.apache.dubbo.validation.support.jvalidation.JValidation?""
                    + ""jvalidation=org.apache.dubbo.validation.Validation"");
            jValidation.getValidator(url);
        });
    }

    @Test
    void testReturnTypeWithDefaultValidatorProvider() {
        Validation jValidation = new JValidation();
        URL url = URL.valueOf(""test://test:11/org.apache.dubbo.validation.support.jvalidation.JValidation"");
        Validator validator = jValidation.getValidator(url);
        assertThat(validator instanceof JValidator, is(true));
    }
}
","/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.alibaba.dubbo.validation;

@Deprecated
public interface Validation extends org.apache.dubbo.validation.Validation {}
",['Lazy Test'],"['Exception Handling', 'Magic Number Test', 'Sensitive Equality', 'Eager Test']",4,1,0,14
5702_49.0_dropwizard_absentoptionalsthrowanotfound,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/5702_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/5702_actual.java,"package io.dropwizard.jersey.guava;

import com.google.common.base.Optional;
import io.dropwizard.jersey.AbstractJerseyTest;
import io.dropwizard.jersey.DropwizardResourceConfig;
import io.dropwizard.jersey.optional.EmptyOptionalExceptionMapper;
import jakarta.ws.rs.FormParam;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.WebApplicationException;
import jakarta.ws.rs.client.Invocation;
import jakarta.ws.rs.core.Application;
import jakarta.ws.rs.core.MediaType;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class OptionalMessageBodyWriterTest extends AbstractJerseyTest {

    @Override
    protected Application configure() {
        return DropwizardResourceConfig.forTesting()
                .register(new EmptyOptionalExceptionMapper())
                .register(OptionalReturnResource.class);
    }

    @Test
    void presentOptionalsReturnTheirValue() {
        assertThat(target(""/optional-return/"")
                .queryParam(""id"", ""woo"").request()
                .get(String.class))
                .isEqualTo(""woo"");
    }

    @Test
    void absentOptionalsThrowANotFound() {
        Invocation.Builder request = target(""/optional-return/"").request();
        assertThatExceptionOfType(WebApplicationException.class)
            .isThrownBy(() -> request.get(String.class))
            .satisfies(e -> assertThat(e.getResponse().getStatus()).isEqualTo(404));
    }

    @Path(""/optional-return/"")
    @Produces(MediaType.TEXT_PLAIN)
    public static class OptionalReturnResource {
        @GET
        public Optional<String> showWithQueryParam(@QueryParam(""id"") String id) {
            return Optional.fromNullable(id);
        }

        @POST
        public Optional<String> showWithFormParam(@FormParam(""id"") String id) {
            return Optional.fromNullable(id);
        }
    }
}
","package io.dropwizard.jersey.guava;

import com.google.common.base.Optional;
import io.dropwizard.jersey.optional.EmptyOptionalException;
import jakarta.inject.Inject;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.MultivaluedMap;
import jakarta.ws.rs.ext.MessageBodyWriter;
import jakarta.ws.rs.ext.Provider;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.glassfish.jersey.message.MessageBodyWorkers;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

import static java.util.Objects.requireNonNull;

@Provider
@Produces(MediaType.WILDCARD)
public class OptionalMessageBodyWriter implements MessageBodyWriter<Optional<?>> {

    @Inject
    private jakarta.inject.@Nullable Provider<MessageBodyWorkers> mbw;

    // Jersey ignores this
    @Override
    public long getSize(Optional<?> entity, Class<?> type, Type genericType,
                        Annotation[] annotations, MediaType mediaType) {
        return 0;
    }

    @Override
    public boolean isWriteable(Class<?> type, Type genericType,
                               Annotation[] annotations, MediaType mediaType) {
        return Optional.class.isAssignableFrom(type);
    }

    @SuppressWarnings({""rawtypes"", ""unchecked""})
    @Override
    public void writeTo(Optional<?> entity,
                        Class<?> type,
                        Type genericType,
                        Annotation[] annotations,
                        MediaType mediaType,
                        MultivaluedMap<String, Object> httpHeaders,
                        OutputStream entityStream)
            throws IOException {
        if (!entity.isPresent()) {
            throw EmptyOptionalException.INSTANCE;
        }

        final ParameterizedType actualGenericType = (ParameterizedType) genericType;
        final Type actualGenericTypeArgument = actualGenericType.getActualTypeArguments()[0];
        final MessageBodyWriter writer = requireNonNull(mbw).get().getMessageBodyWriter(entity.get().getClass(),
                actualGenericTypeArgument, annotations, mediaType);
        writer.writeTo(entity.get(), entity.get().getClass(),
                actualGenericTypeArgument,
                annotations, mediaType, httpHeaders, entityStream);
    }

}
",['Assertion Roulette'],[],0,1,0,16
37822_45.0_hbase_testservicename,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/37822_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/37822_actual.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.hadoop.hbase.ipc;

import static org.junit.Assert.assertEquals;

import org.apache.hadoop.hbase.HBaseClassTestRule;
import org.apache.hadoop.hbase.testclassification.SmallTests;
import org.junit.ClassRule;
import org.junit.Test;
import org.junit.experimental.categories.Category;

import org.apache.hbase.thirdparty.com.google.protobuf.Descriptors.ServiceDescriptor;

import org.apache.hadoop.hbase.shaded.coprocessor.protobuf.generated.DummyRegionServerEndpointProtos;
import org.apache.hadoop.hbase.shaded.protobuf.generated.AuthenticationProtos;

@Category(SmallTests.class)
public class TestCoprocessorRpcUtils {

  @ClassRule
  public static final HBaseClassTestRule CLASS_RULE =
    HBaseClassTestRule.forClass(TestCoprocessorRpcUtils.class);

  @Test
  public void testServiceName() throws Exception {
    // verify that we de-namespace build in HBase rpc services
    ServiceDescriptor authService = AuthenticationProtos.AuthenticationService.getDescriptor();
    assertEquals(authService.getName(), CoprocessorRpcUtils.getServiceName(authService));

    // non-hbase rpc services should remain fully qualified
    ServiceDescriptor dummyService = DummyRegionServerEndpointProtos.DummyService.getDescriptor();
    assertEquals(dummyService.getFullName(), CoprocessorRpcUtils.getServiceName(dummyService));
  }
}
","/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.hadoop.hbase.ipc;

import static org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.RegionSpecifier.RegionSpecifierType.REGION_NAME;

import edu.umd.cs.findbugs.annotations.Nullable;
import java.io.IOException;
import java.io.InterruptedIOException;
import org.apache.hadoop.hbase.DoNotRetryIOException;
import org.apache.hadoop.hbase.HConstants;
import org.apache.hadoop.hbase.exceptions.UnknownProtocolException;
import org.apache.hadoop.util.StringUtils;
import org.apache.yetus.audience.InterfaceAudience;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.hbase.thirdparty.com.google.protobuf.ByteString;
import org.apache.hbase.thirdparty.com.google.protobuf.Descriptors;
import org.apache.hbase.thirdparty.com.google.protobuf.Descriptors.MethodDescriptor;
import org.apache.hbase.thirdparty.com.google.protobuf.Descriptors.ServiceDescriptor;
import org.apache.hbase.thirdparty.com.google.protobuf.Message;
import org.apache.hbase.thirdparty.com.google.protobuf.RpcCallback;
import org.apache.hbase.thirdparty.com.google.protobuf.RpcController;
import org.apache.hbase.thirdparty.com.google.protobuf.Service;

import org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil;
import org.apache.hadoop.hbase.shaded.protobuf.RequestConverter;
import org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos;
import org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos.CoprocessorServiceCall;
import org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos.CoprocessorServiceRequest;
import org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.RegionSpecifier.RegionSpecifierType;

/**
 * Utilities for handling coprocessor rpc service calls.
 */
@InterfaceAudience.Private
public final class CoprocessorRpcUtils {
  private static final Logger LOG = LoggerFactory.getLogger(CoprocessorRpcUtils.class);
  /**
   * We assume that all HBase protobuf services share a common package name (defined in the .proto
   * files).
   */
  private static final String hbaseServicePackage;
  static {
    Descriptors.ServiceDescriptor clientService = ClientProtos.ClientService.getDescriptor();
    hbaseServicePackage = clientService.getFullName().substring(0,
      clientService.getFullName().lastIndexOf(clientService.getName()));
  }

  private CoprocessorRpcUtils() {
    // private for utility class
  }

  /**
   * Returns the name to use for coprocessor service calls. For core HBase services (in the hbase.pb
   * protobuf package), this returns the unqualified name in order to provide backward compatibility
   * across the package name change. For all other services, the fully-qualified service name is
   * used.
   */
  public static String getServiceName(Descriptors.ServiceDescriptor service) {
    if (service.getFullName().startsWith(hbaseServicePackage)) {
      return service.getName();
    }
    return service.getFullName();
  }

  public static CoprocessorServiceRequest
    getCoprocessorServiceRequest(final Descriptors.MethodDescriptor method, final Message request) {
    return getCoprocessorServiceRequest(method, request, HConstants.EMPTY_BYTE_ARRAY,
      HConstants.EMPTY_BYTE_ARRAY);
  }

  public static CoprocessorServiceRequest getCoprocessorServiceRequest(
    final Descriptors.MethodDescriptor method, final Message request, final byte[] row,
    final byte[] regionName) {
    return CoprocessorServiceRequest.newBuilder()
      .setCall(getCoprocessorServiceCall(method, request, row))
      .setRegion(RequestConverter.buildRegionSpecifier(REGION_NAME, regionName)).build();
  }

  private static CoprocessorServiceCall getCoprocessorServiceCall(final MethodDescriptor method,
    final Message request, final byte[] row) {
    return CoprocessorServiceCall.newBuilder()
      .setRow(org.apache.hbase.thirdparty.com.google.protobuf.UnsafeByteOperations.unsafeWrap(row))
      .setServiceName(CoprocessorRpcUtils.getServiceName(method.getService()))
      .setMethodName(method.getName())
      // TODO!!!!! Come back here after!!!!! This is a double copy of the request if I read
      // it right copying from non-shaded to shaded version!!!!!! FIXXXXX!!!!!
      .setRequest(org.apache.hbase.thirdparty.com.google.protobuf.UnsafeByteOperations
        .unsafeWrap(request.toByteArray()))
      .build();
  }

  public static MethodDescriptor getMethodDescriptor(final String methodName,
    final ServiceDescriptor serviceDesc) throws UnknownProtocolException {
    MethodDescriptor methodDesc = serviceDesc.findMethodByName(methodName);
    if (methodDesc == null) {
      throw new UnknownProtocolException(
        ""Unknown method "" + methodName + "" called on service "" + serviceDesc.getFullName());
    }
    return methodDesc;
  }

  public static Message getRequest(Service service, MethodDescriptor methodDesc,
    ByteString shadedRequest) throws IOException {
    Message.Builder builderForType = service.getRequestPrototype(methodDesc).newBuilderForType();
    ProtobufUtil.mergeFrom(builderForType,
      // TODO: COPY FROM SHADED TO NON_SHADED. DO I HAVE TOO?
      shadedRequest.toByteArray());
    return builderForType.build();
  }

  public static Message getResponse(ClientProtos.CoprocessorServiceResponse result,
    Message responsePrototype) throws IOException {
    Message response;
    if (result.getValue().hasValue()) {
      Message.Builder builder = responsePrototype.newBuilderForType();
      builder.mergeFrom(result.getValue().getValue().newInput());
      response = builder.build();
    } else {
      response = responsePrototype.getDefaultInstanceForType();
    }
    if (LOG.isTraceEnabled()) {
      LOG.trace(""Master Result is value="" + response);
    }
    return response;
  }

  public static ClientProtos.CoprocessorServiceResponse getResponse(final Message result,
    final byte[] regionName) {
    ClientProtos.CoprocessorServiceResponse.Builder builder =
      ClientProtos.CoprocessorServiceResponse.newBuilder();
    builder.setRegion(
      RequestConverter.buildRegionSpecifier(RegionSpecifierType.REGION_NAME, regionName));
    // TODO: UGLY COPY IN HERE!!!!
    builder.setValue(builder.getValueBuilder().setName(result.getClass().getName()).setValue(
      org.apache.hbase.thirdparty.com.google.protobuf.ByteString.copyFrom(result.toByteArray())));
    return builder.build();
  }

  /**
   * Simple {@link RpcCallback} implementation providing a {@link java.util.concurrent.Future}-like
   * {@link BlockingRpcCallback#get()} method, which will block util the instance's
   * {@link BlockingRpcCallback#run(Object)} method has been called. {@code R} is the RPC response
   * type that will be passed to the {@link #run(Object)} method.
   */
  @InterfaceAudience.Private
  // Copy of BlockingRpcCallback but deriving from RpcCallback non-shaded.
  public static class BlockingRpcCallback<R> implements RpcCallback<R> {
    private R result;
    private boolean resultSet = false;

    /**
     * Called on completion of the RPC call with the response object, or {@code null} in the case of
     * an error.
     * @param parameter the response object or {@code null} if an error occurred
     */
    @Override
    public void run(R parameter) {
      synchronized (this) {
        result = parameter;
        resultSet = true;
        this.notifyAll();
      }
    }

    /**
     * Returns the parameter passed to {@link #run(Object)} or {@code null} if a null value was
     * passed. When used asynchronously, this method will block until the {@link #run(Object)}
     * method has been called.
     * @return the response object or {@code null} if no response was passed
     */
    public synchronized R get() throws IOException {
      while (!resultSet) {
        try {
          this.wait();
        } catch (InterruptedException ie) {
          InterruptedIOException exception = new InterruptedIOException(ie.getMessage());
          exception.initCause(ie);
          throw exception;
        }
      }
      return result;
    }
  }

  /**
   * Stores an exception encountered during RPC invocation so it can be passed back through to the
   * client.
   * @param controller the controller instance provided by the client when calling the service
   * @param ioe        the exception encountered
   */
  public static void setControllerException(RpcController controller, IOException ioe) {
    if (controller == null) {
      return;
    }
    if (controller instanceof org.apache.hadoop.hbase.ipc.ServerRpcController) {
      ((ServerRpcController) controller).setFailedOn(ioe);
    } else {
      controller.setFailed(StringUtils.stringifyException(ioe));
    }
  }

  /**
   * Retreivies exception stored during RPC invocation.
   * @param controller the controller instance provided by the client when calling the service
   * @return exception if any, or null; Will return DoNotRetryIOException for string represented
   *         failure causes in controller.
   */
  @Nullable
  public static IOException getControllerException(RpcController controller) throws IOException {
    if (controller == null || !controller.failed()) {
      return null;
    }
    if (controller instanceof ServerRpcController) {
      return ((ServerRpcController) controller).getFailedOn();
    }
    return new DoNotRetryIOException(controller.errorText());
  }
}
",['Assertion Roulette'],['Assertion Roulette'],0,0,1,16
15396_7.0_dnsjava_test,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/15396_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/15396_actual.java,"// SPDX-License-Identifier: BSD-3-Clause
// -*- Java -*-
//
// Copyright (c) 2005, Matthew J. Rutherford <rutherfo@cs.colorado.edu>
// Copyright (c) 2005, University of Colorado at Boulder
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the distribution.
//
// * Neither the name of the University of Colorado at Boulder nor the
//   names of its contributors may be used to endorse or promote
//   products derived from this software without specific prior written
//   permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
package org.xbill.DNS;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

class CompressionTest {
  @Test
  void test() throws TextParseException {
    Compression c = new Compression();
    Name n = Name.fromString(""www.amazon.com."");

    c.add(10, n);
    assertEquals(10, c.get(n));

    Name n2 = Name.fromString(""www.cnn.com."");

    c.add(10, n2);
    assertEquals(10, c.get(n2));
  }
}
","// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 1999-2004 Brian Wellington (bwelling@xbill.org)

package org.xbill.DNS;

import lombok.extern.slf4j.Slf4j;

/**
 * DNS Name Compression object.
 *
 * @see Message
 * @see Name
 * @author Brian Wellington
 */
@Slf4j
public class Compression {

  private static class Entry {
    Name name;
    int pos;
    Entry next;
  }

  private static final int TABLE_SIZE = 17;
  private static final int MAX_POINTER = 0x3FFF;
  private final Entry[] table;

  /** Creates a new Compression object. */
  public Compression() {
    table = new Entry[TABLE_SIZE];
  }

  /**
   * Adds a compression entry mapping a name to a position in a message.
   *
   * @param pos The position at which the name is added.
   * @param name The name being added to the message.
   */
  public void add(int pos, Name name) {
    if (pos > MAX_POINTER) {
      return;
    }
    int row = (name.hashCode() & 0x7FFFFFFF) % TABLE_SIZE;
    Entry entry = new Entry();
    entry.name = name;
    entry.pos = pos;
    entry.next = table[row];
    table[row] = entry;
    log.trace(""Adding {} at {}"", name, pos);
  }

  /**
   * Retrieves the position of the given name, if it has been previously included in the message.
   *
   * @param name The name to find in the compression table.
   * @return The position of the name, or -1 if not found.
   */
  public int get(Name name) {
    int row = (name.hashCode() & 0x7FFFFFFF) % TABLE_SIZE;
    int pos = -1;
    for (Entry entry = table[row]; entry != null; entry = entry.next) {
      if (entry.name.equals(name)) {
        pos = entry.pos;
      }
    }
    log.trace(""Looking for {}, found {}"", name, pos);
    return pos;
  }
}
",['Assertion Roulette'],"['Assertion Roulette', 'Conditional Test Logic', 'Constructor Initialization', 'Default Test', 'Duplicate Assert', 'Eager Test', 'Empty Test', 'Exception Handling', 'General Fixture', 'Ignored Test', 'Lazy Test', 'Magic Number Test', 'Mystery Guest', 'Redundant Print', 'Redundant Assertion', 'Resource Optimism', 'Sensitive Equality', 'Sleepy Test', 'Unknown Test', 'Duplicate Assert']",18,0,1,6
14292_11_wikidata-toolkit_testiriforinvalidtype,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/14292_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/14292_actual.java,"package org.wikidata.wdtk.datamodel.implementation;

/*
 * #%L
 * Wikidata Toolkit Data Model
 * %%
 * Copyright (C) 2014 Wikidata Toolkit Developers
 * %%
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import static org.junit.Assert.*;

import org.junit.Test;
import org.wikidata.wdtk.datamodel.interfaces.DatatypeIdValue;

public class DatatypeIdImplTest {

	private final DatatypeIdImpl d1 = new DatatypeIdImpl(DatatypeIdValue.DT_ITEM);
	private final DatatypeIdImpl d2 = new DatatypeIdImpl(""http://wikiba.se/ontology#WikibaseItem"");
	private final DatatypeIdImpl d3 = new DatatypeIdImpl(DatatypeIdValue.DT_TIME);
	private final DatatypeIdImpl d4 = new DatatypeIdImpl(""http://wikiba.se/ontology#SomeUnknownDatatype"", ""some-unknownDatatype"");

	@Test(expected = NullPointerException.class)
	public void datatypeIdNotNull() {
		new DatatypeIdImpl((String) null);
	}

	@Test
	public void equalityBasedOnContent() {
		assertEquals(d1, d1);
		assertEquals(d1, d2);
		assertNotEquals(d1, d3);
		assertNotEquals(d1, null);
		assertNotEquals(d1, new StringValueImpl(""foo""));
	}

	@Test
	public void hashBasedOnContent() {
		assertEquals(d1.hashCode(), d2.hashCode());
	}

	@Test
	public void doNotChokeOnUnknownDatatypes() {
		// for issue https://github.com/Wikidata/Wikidata-Toolkit/issues/716
		assertEquals(""some-unknownDatatype"", d4.getJsonString());
		assertEquals(""http://wikiba.se/ontology#SomeUnknownDatatype"", d4.getIri());
	}

	@Test
	public void testDeserializeUnknownJsonDatatype() {
		// for issue https://github.com/Wikidata/Wikidata-Toolkit/issues/716
		assertEquals(""http://wikiba.se/ontology#LocalMedia"", DatatypeIdImpl.getDatatypeIriFromJsonDatatype(""localMedia""));
	}

}
","package org.wikidata.wdtk.datamodel.implementation;

/*
 * #%L
 * Wikidata Toolkit Data Model
 * %%
 * Copyright (C) 2014 Wikidata Toolkit Developers
 * %%
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;
import org.wikidata.wdtk.datamodel.helpers.Equality;
import org.wikidata.wdtk.datamodel.helpers.Hash;
import org.wikidata.wdtk.datamodel.helpers.ToString;
import org.wikidata.wdtk.datamodel.interfaces.DatatypeIdValue;


import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Jackson implementation of {@link DatatypeIdValue}. This is not actually
 * present in JSON but needed to satisfy the interface.
 *
 * @author Fredo Erxleben
 * @author Antonin Delpeuch
 *
 */
public class DatatypeIdImpl implements DatatypeIdValue {

	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_ITEM} in JSON.
	 */
	public static final String JSON_DT_ITEM = ""wikibase-item"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_PROPERTY} in JSON.
	 */
	public static final String JSON_DT_PROPERTY = ""wikibase-property"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_GLOBE_COORDINATES} in JSON.
	 */
	public static final String JSON_DT_GLOBE_COORDINATES = ""globe-coordinate"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_ITEM} in JSON.
	 */
	public static final String JSON_DT_URL = ""url"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_COMMONS_MEDIA} in JSON.
	 */
	public static final String JSON_DT_COMMONS_MEDIA = ""commonsMedia"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_TIME} in JSON.
	 */
	public static final String JSON_DT_TIME = ""time"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_QUANTITY} in JSON.
	 */
	public static final String JSON_DT_QUANTITY = ""quantity"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_STRING} in JSON.
	 */
	public static final String JSON_DT_STRING = ""string"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_MONOLINGUAL_TEXT} in JSON.
	 */
	public static final String JSON_DT_MONOLINGUAL_TEXT = ""monolingualtext"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_EXTERNAL_ID} in JSON.
	 */
	public static final String JSON_DT_EXTERNAL_ID = ""external-id"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_MATH} in JSON.
	 */
	public static final String JSON_DT_MATH = ""math"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_GEO_SHAPE} in JSON.
	 */
	public static final String JSON_DT_GEO_SHAPE = ""geo-shape"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_EDTF} in JSON.
	 */
	public static final String JSON_DT_EDTF = ""edtf"";

	private static final Pattern JSON_DATATYPE_PATTERN = Pattern.compile(""^[a-zA-Z\\-]+$"");
	private static final Pattern DATATYPE_ID_PATTERN = Pattern.compile(""^http://wikiba\\.se/ontology#([a-zA-Z]+)$"");

	/**
	 * Datatype IRI as used in Wikidata Toolkit.
	 */
	private final String iri;

	/**
	 * JSON representation of the datatype. We store this as well
	 * because the conversion mechanism between JSON datatypes and
	 * datatype URIs is sadly not perfect: see
	 * <a href=""https://github.com/Wikidata/Wikidata-Toolkit/issues/716"">issue #716</a>.
	 */
	private final String jsonString;

	/**
	 * Returns the WDTK datatype IRI for the property datatype as represented by
	 * the given JSON datatype string.
	 *
	 * @param jsonDatatype
	 *            the JSON datatype string; case-sensitive
	 * @throws IllegalArgumentException
	 *             if the given datatype string is not known
	 */
	public static String getDatatypeIriFromJsonDatatype(String jsonDatatype) {
		switch (jsonDatatype) {
		case JSON_DT_ITEM:
			return DT_ITEM;
		case JSON_DT_PROPERTY:
			return DT_PROPERTY;
		case JSON_DT_GLOBE_COORDINATES:
			return DT_GLOBE_COORDINATES;
		case JSON_DT_URL:
			return DT_URL;
		case JSON_DT_COMMONS_MEDIA:
			return DT_COMMONS_MEDIA;
		case JSON_DT_TIME:
			return DT_TIME;
		case JSON_DT_QUANTITY:
			return DT_QUANTITY;
		case JSON_DT_STRING:
			return DT_STRING;
		case JSON_DT_MONOLINGUAL_TEXT:
			return DT_MONOLINGUAL_TEXT;
		case JSON_DT_EDTF:
			return DT_EDTF;
		default:

			String[] parts = jsonDatatype.split(""-"");
			for(int i = 0; i < parts.length; i++) {
				parts[i] = StringUtils.capitalize(parts[i]);
			}
			return ""http://wikiba.se/ontology#"" + StringUtils.join(parts);
		}
	}
	
	/**
	 * Returns the JSON datatype for the property datatype as represented by
	 * the given WDTK datatype IRI string.
	 *
	 * @param datatypeIri
	 *            the WDTK datatype IRI string; case-sensitive
	 * @throws IllegalArgumentException
	 *             if the given datatype string is not known
	 * @deprecated this method is unreliable and will be removed in a future release.
	 */
	public static String getJsonDatatypeFromDatatypeIri(String datatypeIri) {
		switch (datatypeIri) {
			case DatatypeIdValue.DT_ITEM:
				return DatatypeIdImpl.JSON_DT_ITEM;
			case DatatypeIdValue.DT_GLOBE_COORDINATES:
				return DatatypeIdImpl.JSON_DT_GLOBE_COORDINATES;
			case DatatypeIdValue.DT_URL:
				return DatatypeIdImpl.JSON_DT_URL;
			case DatatypeIdValue.DT_COMMONS_MEDIA:
				return DatatypeIdImpl.JSON_DT_COMMONS_MEDIA;
			case DatatypeIdValue.DT_TIME:
				return DatatypeIdImpl.JSON_DT_TIME;
			case DatatypeIdValue.DT_QUANTITY:
				return DatatypeIdImpl.JSON_DT_QUANTITY;
			case DatatypeIdValue.DT_STRING:
				return DatatypeIdImpl.JSON_DT_STRING;
			case DatatypeIdValue.DT_MONOLINGUAL_TEXT:
				return DatatypeIdImpl.JSON_DT_MONOLINGUAL_TEXT;
			case DatatypeIdValue.DT_PROPERTY:
				return DatatypeIdImpl.JSON_DT_PROPERTY;
			case DatatypeIdValue.DT_EDTF:
				return DatatypeIdImpl.JSON_DT_EDTF;
			default:
				//We apply the reverse algorithm of JacksonDatatypeId::getDatatypeIriFromJsonDatatype
				Matcher matcher = DATATYPE_ID_PATTERN.matcher(datatypeIri);
				if(!matcher.matches()) {
					throw new IllegalArgumentException(""Unknown datatype: "" + datatypeIri);
				}
		
				StringBuilder jsonDatatypeBuilder = new StringBuilder();
				for(char ch : StringUtils.uncapitalize(matcher.group(1)).toCharArray()) {
					if(Character.isUpperCase(ch)) {
						jsonDatatypeBuilder
								.append('-')
								.append(Character.toLowerCase(ch));
					} else {
						jsonDatatypeBuilder.append(ch);
					}
				}
				return jsonDatatypeBuilder.toString();
		}
	}
	
	/**
	 * Copy constructor.
	 */
	public DatatypeIdImpl(DatatypeIdValue other) {
		this.iri = other.getIri();
		this.jsonString = other.getJsonString();
	}

	/**
	 * Constructs an object representing the datatype id from a IRI denoting
	 * the datatype. It also tries to determine the JSON datatype based on this
	 * IRI, based on a buggy heuristic. If you also happen to have the JSON datatype
	 * at hand, better use {@link DatatypeIdImpl(String, String)}.
	 *
	 * @param iri
	 *             the WDTK IRI for the datatype
	 * @throws IllegalArgumentException
	 *             if the given datatype string could not be matched to a known
	 *             datatype or was null
	 * @deprecated use {@link #DatatypeIdImpl(String, String)}
	 */
	public DatatypeIdImpl(String iri)
			throws IllegalArgumentException {
		Validate.notNull(iri, ""An IRI must be provided to create a DatatypeIdValue"");
		this.iri = iri;
		// the JSON datatype is not supplied, so we fall back on our buggy heuristic
		// to guess how it should be represented in JSON.
		this.jsonString = getJsonDatatypeFromDatatypeIri(this.iri);
	}

	/**
	 * Constructs an object representing the datatype id from an IRI denoting the datatype,
	 * as well as a string corresponding to its JSON serialization. This constructor
	 * is meant to be used for JSON deserialization.
	 *
	 * @param iri
	 *             the WDTK IRI for the datatype. This can be null.
	 * @param jsonString
	 *             the JSON representation of the datatype. This cannot be null.
	 * @throws IllegalArgumentException
	 *             if the given datatype string could not be matched to a known
	 *             datatype or was null
	 */
	public DatatypeIdImpl(String iri, String jsonString)
			throws IllegalArgumentException {
		Validate.notNull(jsonString, ""A JSON representation of the datatype must be provided to create a DatatypeIdValue"");
		if(!JSON_DATATYPE_PATTERN.matcher(jsonString).matches()) {
			throw new IllegalArgumentException(""Invalid JSON datatype \"""" + jsonString + ""\"""");
		}
		this.jsonString = jsonString;
		this.iri = iri != null ? iri : getDatatypeIriFromJsonDatatype(jsonString);
	}
	
	/**
	 * Returns the string used to represent this datatype in JSON.
	 */
	@Override
	public String getJsonString() {
		return this.jsonString;
	}

	@Override
	public String getIri() {
		return this.iri;
	}

	@Override
	public String toString() {
		return ToString.toString(this);
	}

	@Override
	public boolean equals(Object o) {
		return Equality.equalsDatatypeIdValue(this, o);
	}

	@Override
	public int hashCode() {
		return Hash.hashCode(this);
	}
}
","['Assertion Roulette', 'Redundant Assertion']",[],0,2,0,15
14298_11_wikidata-toolkit_testjsonforquantity,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/14298_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/14298_actual.java,"package org.wikidata.wdtk.datamodel.implementation;

/*
 * #%L
 * Wikidata Toolkit Data Model
 * %%
 * Copyright (C) 2014 Wikidata Toolkit Developers
 * %%
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import static org.junit.Assert.*;

import org.junit.Test;
import org.wikidata.wdtk.datamodel.interfaces.DatatypeIdValue;

public class DatatypeIdImplTest {

	private final DatatypeIdImpl d1 = new DatatypeIdImpl(DatatypeIdValue.DT_ITEM);
	private final DatatypeIdImpl d2 = new DatatypeIdImpl(""http://wikiba.se/ontology#WikibaseItem"");
	private final DatatypeIdImpl d3 = new DatatypeIdImpl(DatatypeIdValue.DT_TIME);
	private final DatatypeIdImpl d4 = new DatatypeIdImpl(""http://wikiba.se/ontology#SomeUnknownDatatype"", ""some-unknownDatatype"");

	@Test(expected = NullPointerException.class)
	public void datatypeIdNotNull() {
		new DatatypeIdImpl((String) null);
	}

	@Test
	public void equalityBasedOnContent() {
		assertEquals(d1, d1);
		assertEquals(d1, d2);
		assertNotEquals(d1, d3);
		assertNotEquals(d1, null);
		assertNotEquals(d1, new StringValueImpl(""foo""));
	}

	@Test
	public void hashBasedOnContent() {
		assertEquals(d1.hashCode(), d2.hashCode());
	}

	@Test
	public void doNotChokeOnUnknownDatatypes() {
		// for issue https://github.com/Wikidata/Wikidata-Toolkit/issues/716
		assertEquals(""some-unknownDatatype"", d4.getJsonString());
		assertEquals(""http://wikiba.se/ontology#SomeUnknownDatatype"", d4.getIri());
	}

	@Test
	public void testDeserializeUnknownJsonDatatype() {
		// for issue https://github.com/Wikidata/Wikidata-Toolkit/issues/716
		assertEquals(""http://wikiba.se/ontology#LocalMedia"", DatatypeIdImpl.getDatatypeIriFromJsonDatatype(""localMedia""));
	}

}
","package org.wikidata.wdtk.datamodel.implementation;

/*
 * #%L
 * Wikidata Toolkit Data Model
 * %%
 * Copyright (C) 2014 Wikidata Toolkit Developers
 * %%
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;
import org.wikidata.wdtk.datamodel.helpers.Equality;
import org.wikidata.wdtk.datamodel.helpers.Hash;
import org.wikidata.wdtk.datamodel.helpers.ToString;
import org.wikidata.wdtk.datamodel.interfaces.DatatypeIdValue;


import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Jackson implementation of {@link DatatypeIdValue}. This is not actually
 * present in JSON but needed to satisfy the interface.
 *
 * @author Fredo Erxleben
 * @author Antonin Delpeuch
 *
 */
public class DatatypeIdImpl implements DatatypeIdValue {

	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_ITEM} in JSON.
	 */
	public static final String JSON_DT_ITEM = ""wikibase-item"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_PROPERTY} in JSON.
	 */
	public static final String JSON_DT_PROPERTY = ""wikibase-property"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_GLOBE_COORDINATES} in JSON.
	 */
	public static final String JSON_DT_GLOBE_COORDINATES = ""globe-coordinate"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_ITEM} in JSON.
	 */
	public static final String JSON_DT_URL = ""url"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_COMMONS_MEDIA} in JSON.
	 */
	public static final String JSON_DT_COMMONS_MEDIA = ""commonsMedia"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_TIME} in JSON.
	 */
	public static final String JSON_DT_TIME = ""time"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_QUANTITY} in JSON.
	 */
	public static final String JSON_DT_QUANTITY = ""quantity"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_STRING} in JSON.
	 */
	public static final String JSON_DT_STRING = ""string"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_MONOLINGUAL_TEXT} in JSON.
	 */
	public static final String JSON_DT_MONOLINGUAL_TEXT = ""monolingualtext"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_EXTERNAL_ID} in JSON.
	 */
	public static final String JSON_DT_EXTERNAL_ID = ""external-id"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_MATH} in JSON.
	 */
	public static final String JSON_DT_MATH = ""math"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_GEO_SHAPE} in JSON.
	 */
	public static final String JSON_DT_GEO_SHAPE = ""geo-shape"";
	/**
	 * String used to refer to the property datatype
	 * {@link DatatypeIdValue#DT_EDTF} in JSON.
	 */
	public static final String JSON_DT_EDTF = ""edtf"";

	private static final Pattern JSON_DATATYPE_PATTERN = Pattern.compile(""^[a-zA-Z\\-]+$"");
	private static final Pattern DATATYPE_ID_PATTERN = Pattern.compile(""^http://wikiba\\.se/ontology#([a-zA-Z]+)$"");

	/**
	 * Datatype IRI as used in Wikidata Toolkit.
	 */
	private final String iri;

	/**
	 * JSON representation of the datatype. We store this as well
	 * because the conversion mechanism between JSON datatypes and
	 * datatype URIs is sadly not perfect: see
	 * <a href=""https://github.com/Wikidata/Wikidata-Toolkit/issues/716"">issue #716</a>.
	 */
	private final String jsonString;

	/**
	 * Returns the WDTK datatype IRI for the property datatype as represented by
	 * the given JSON datatype string.
	 *
	 * @param jsonDatatype
	 *            the JSON datatype string; case-sensitive
	 * @throws IllegalArgumentException
	 *             if the given datatype string is not known
	 */
	public static String getDatatypeIriFromJsonDatatype(String jsonDatatype) {
		switch (jsonDatatype) {
		case JSON_DT_ITEM:
			return DT_ITEM;
		case JSON_DT_PROPERTY:
			return DT_PROPERTY;
		case JSON_DT_GLOBE_COORDINATES:
			return DT_GLOBE_COORDINATES;
		case JSON_DT_URL:
			return DT_URL;
		case JSON_DT_COMMONS_MEDIA:
			return DT_COMMONS_MEDIA;
		case JSON_DT_TIME:
			return DT_TIME;
		case JSON_DT_QUANTITY:
			return DT_QUANTITY;
		case JSON_DT_STRING:
			return DT_STRING;
		case JSON_DT_MONOLINGUAL_TEXT:
			return DT_MONOLINGUAL_TEXT;
		case JSON_DT_EDTF:
			return DT_EDTF;
		default:

			String[] parts = jsonDatatype.split(""-"");
			for(int i = 0; i < parts.length; i++) {
				parts[i] = StringUtils.capitalize(parts[i]);
			}
			return ""http://wikiba.se/ontology#"" + StringUtils.join(parts);
		}
	}
	
	/**
	 * Returns the JSON datatype for the property datatype as represented by
	 * the given WDTK datatype IRI string.
	 *
	 * @param datatypeIri
	 *            the WDTK datatype IRI string; case-sensitive
	 * @throws IllegalArgumentException
	 *             if the given datatype string is not known
	 * @deprecated this method is unreliable and will be removed in a future release.
	 */
	public static String getJsonDatatypeFromDatatypeIri(String datatypeIri) {
		switch (datatypeIri) {
			case DatatypeIdValue.DT_ITEM:
				return DatatypeIdImpl.JSON_DT_ITEM;
			case DatatypeIdValue.DT_GLOBE_COORDINATES:
				return DatatypeIdImpl.JSON_DT_GLOBE_COORDINATES;
			case DatatypeIdValue.DT_URL:
				return DatatypeIdImpl.JSON_DT_URL;
			case DatatypeIdValue.DT_COMMONS_MEDIA:
				return DatatypeIdImpl.JSON_DT_COMMONS_MEDIA;
			case DatatypeIdValue.DT_TIME:
				return DatatypeIdImpl.JSON_DT_TIME;
			case DatatypeIdValue.DT_QUANTITY:
				return DatatypeIdImpl.JSON_DT_QUANTITY;
			case DatatypeIdValue.DT_STRING:
				return DatatypeIdImpl.JSON_DT_STRING;
			case DatatypeIdValue.DT_MONOLINGUAL_TEXT:
				return DatatypeIdImpl.JSON_DT_MONOLINGUAL_TEXT;
			case DatatypeIdValue.DT_PROPERTY:
				return DatatypeIdImpl.JSON_DT_PROPERTY;
			case DatatypeIdValue.DT_EDTF:
				return DatatypeIdImpl.JSON_DT_EDTF;
			default:
				//We apply the reverse algorithm of JacksonDatatypeId::getDatatypeIriFromJsonDatatype
				Matcher matcher = DATATYPE_ID_PATTERN.matcher(datatypeIri);
				if(!matcher.matches()) {
					throw new IllegalArgumentException(""Unknown datatype: "" + datatypeIri);
				}
		
				StringBuilder jsonDatatypeBuilder = new StringBuilder();
				for(char ch : StringUtils.uncapitalize(matcher.group(1)).toCharArray()) {
					if(Character.isUpperCase(ch)) {
						jsonDatatypeBuilder
								.append('-')
								.append(Character.toLowerCase(ch));
					} else {
						jsonDatatypeBuilder.append(ch);
					}
				}
				return jsonDatatypeBuilder.toString();
		}
	}
	
	/**
	 * Copy constructor.
	 */
	public DatatypeIdImpl(DatatypeIdValue other) {
		this.iri = other.getIri();
		this.jsonString = other.getJsonString();
	}

	/**
	 * Constructs an object representing the datatype id from a IRI denoting
	 * the datatype. It also tries to determine the JSON datatype based on this
	 * IRI, based on a buggy heuristic. If you also happen to have the JSON datatype
	 * at hand, better use {@link DatatypeIdImpl(String, String)}.
	 *
	 * @param iri
	 *             the WDTK IRI for the datatype
	 * @throws IllegalArgumentException
	 *             if the given datatype string could not be matched to a known
	 *             datatype or was null
	 * @deprecated use {@link #DatatypeIdImpl(String, String)}
	 */
	public DatatypeIdImpl(String iri)
			throws IllegalArgumentException {
		Validate.notNull(iri, ""An IRI must be provided to create a DatatypeIdValue"");
		this.iri = iri;
		// the JSON datatype is not supplied, so we fall back on our buggy heuristic
		// to guess how it should be represented in JSON.
		this.jsonString = getJsonDatatypeFromDatatypeIri(this.iri);
	}

	/**
	 * Constructs an object representing the datatype id from an IRI denoting the datatype,
	 * as well as a string corresponding to its JSON serialization. This constructor
	 * is meant to be used for JSON deserialization.
	 *
	 * @param iri
	 *             the WDTK IRI for the datatype. This can be null.
	 * @param jsonString
	 *             the JSON representation of the datatype. This cannot be null.
	 * @throws IllegalArgumentException
	 *             if the given datatype string could not be matched to a known
	 *             datatype or was null
	 */
	public DatatypeIdImpl(String iri, String jsonString)
			throws IllegalArgumentException {
		Validate.notNull(jsonString, ""A JSON representation of the datatype must be provided to create a DatatypeIdValue"");
		if(!JSON_DATATYPE_PATTERN.matcher(jsonString).matches()) {
			throw new IllegalArgumentException(""Invalid JSON datatype \"""" + jsonString + ""\"""");
		}
		this.jsonString = jsonString;
		this.iri = iri != null ? iri : getDatatypeIriFromJsonDatatype(jsonString);
	}
	
	/**
	 * Returns the string used to represent this datatype in JSON.
	 */
	@Override
	public String getJsonString() {
		return this.jsonString;
	}

	@Override
	public String getIri() {
		return this.iri;
	}

	@Override
	public String toString() {
		return ToString.toString(this);
	}

	@Override
	public boolean equals(Object o) {
		return Equality.equalsDatatypeIdValue(this, o);
	}

	@Override
	public int hashCode() {
		return Hash.hashCode(this);
	}
}
","['Assertion Roulette', 'Redundant Assertion']","['Assertion Roulette', 'Conditional Test Logic', 'Constructor Initialization', 'Default Test', 'Duplicate Assert', 'Eager Test', 'Empty Test', 'Exception Handling', 'General Fixture', 'Ignored Test', 'Lazy Test', 'Magic Number Test', 'Mystery Guest', 'Redundant Print', 'Redundant Assertion', 'Resource Optimism', 'Sensitive Equality', 'Sleepy Test', 'Unknown Test']",17,0,2,6
46191_71_spring-ws_testloadschema,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/46191_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/46191_actual.java,"/*
 * Copyright 2005-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.xml.validation;

import static org.assertj.core.api.Assertions.*;

import javax.xml.XMLConstants;
import javax.xml.validation.Schema;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

public class SchemaLoaderUtilsTest {

	@Test
	public void testLoadSchema() throws Exception {

		Resource resource = new ClassPathResource(""schema.xsd"", getClass());
		Schema schema = SchemaLoaderUtils.loadSchema(resource, XMLConstants.W3C_XML_SCHEMA_NS_URI);

		assertThat(schema).isNotNull();
		assertThat(resource.isOpen()).isFalse();
	}

	@Test
	public void testLoadNonExistantSchema() throws Exception {

		assertThatIllegalArgumentException().isThrownBy(() -> {
			Resource nonExistent = new ClassPathResource(""bla"");
			SchemaLoaderUtils.loadSchema(nonExistent, XMLConstants.W3C_XML_SCHEMA_NS_URI);
		});
	}

	@Test
	public void testLoadNullSchema() throws Exception {

		assertThatIllegalArgumentException()
				.isThrownBy(() -> SchemaLoaderUtils.loadSchema((Resource) null, XMLConstants.W3C_XML_SCHEMA_NS_URI));
	}

	@Test
	public void testLoadMultipleSchemas() throws Exception {

		Resource envelope = new ClassPathResource(""envelope.xsd"", getClass());
		Resource encoding = new ClassPathResource(""encoding.xsd"", getClass());
		Schema schema = SchemaLoaderUtils.loadSchema(new Resource[] { envelope, encoding },
				XMLConstants.W3C_XML_SCHEMA_NS_URI);

		assertThat(schema).isNotNull();
		assertThat(envelope.isOpen()).isFalse();
		assertThat(encoding.isOpen()).isFalse();
	}
}
","/*
 * Copyright 2005-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.xml.validation;

import java.io.IOException;

import javax.xml.transform.Source;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;

import org.springframework.core.io.Resource;
import org.springframework.util.Assert;
import org.springframework.xml.transform.ResourceSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;

/**
 * Convenient utility methods for loading of {@link Schema} objects, performing standard handling of input streams.
 *
 * @author Arjen Poutsma
 * @since 1.0.0
 */
public abstract class SchemaLoaderUtils {

	/**
	 * Load schema from the given resource.
	 *
	 * @param resource the resource to load from
	 * @param schemaLanguage the language of the schema. Can be {@code XMLConstants.W3C_XML_SCHEMA_NS_URI} or
	 *          {@code XMLConstants.RELAXNG_NS_URI}.
	 * @throws IOException if loading failed
	 * @throws SAXException if loading failed
	 * @see javax.xml.XMLConstants#W3C_XML_SCHEMA_NS_URI
	 * @see javax.xml.XMLConstants#RELAXNG_NS_URI
	 */
	public static Schema loadSchema(Resource resource, String schemaLanguage) throws IOException, SAXException {
		return loadSchema(new Resource[] { resource }, schemaLanguage);
	}

	/**
	 * Load schema from the given resource.
	 *
	 * @param resources the resources to load from
	 * @param schemaLanguage the language of the schema. Can be {@code XMLConstants.W3C_XML_SCHEMA_NS_URI} or
	 *          {@code XMLConstants.RELAXNG_NS_URI}.
	 * @throws IOException if loading failed
	 * @throws SAXException if loading failed
	 * @see javax.xml.XMLConstants#W3C_XML_SCHEMA_NS_URI
	 * @see javax.xml.XMLConstants#RELAXNG_NS_URI
	 */
	public static Schema loadSchema(Resource[] resources, String schemaLanguage) throws IOException, SAXException {
		Assert.notEmpty(resources, ""No resources given"");
		Assert.hasLength(schemaLanguage, ""No schema language provided"");
		Source[] schemaSources = new Source[resources.length];
		XMLReader xmlReader = XMLReaderFactoryUtils.createXMLReader();
		xmlReader.setFeature(""http://xml.org/sax/features/namespace-prefixes"", true);
		for (int i = 0; i < resources.length; i++) {
			Assert.notNull(resources[i], ""Resource is null"");
			Assert.isTrue(resources[i].exists(), ""Resource "" + resources[i] + "" does not exist"");
			schemaSources[i] = new ResourceSource(xmlReader, resources[i]);
		}
		SchemaFactory schemaFactory = SchemaFactoryUtils.newInstance(schemaLanguage);
		return schemaFactory.newSchema(schemaSources);
	}

	/** Retrieves the URL from the given resource as System ID. Returns {@code null} if it cannot be opened. */
	public static String getSystemId(Resource resource) {
		try {
			return resource.getURL().toString();
		} catch (IOException e) {
			return null;
		}
	}

}
","['Assertion Roulette', 'Lazy Test']","['Assertion Roulette', 'Constructor Initialization', 'Conditional Test Logic', 'Default Test', 'Exception Handling']",4,1,1,12
46192_71_spring-ws_testloadnonexistantschema,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/46192_test.java,/Users/codermehraj/Documents/codes/thesis/code-test-pair-for-tsDetect/downloaded_files/46192_actual.java,"/*
 * Copyright 2005-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.xml.validation;

import static org.assertj.core.api.Assertions.*;

import javax.xml.XMLConstants;
import javax.xml.validation.Schema;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

public class SchemaLoaderUtilsTest {

	@Test
	public void testLoadSchema() throws Exception {

		Resource resource = new ClassPathResource(""schema.xsd"", getClass());
		Schema schema = SchemaLoaderUtils.loadSchema(resource, XMLConstants.W3C_XML_SCHEMA_NS_URI);

		assertThat(schema).isNotNull();
		assertThat(resource.isOpen()).isFalse();
	}

	@Test
	public void testLoadNonExistantSchema() throws Exception {

		assertThatIllegalArgumentException().isThrownBy(() -> {
			Resource nonExistent = new ClassPathResource(""bla"");
			SchemaLoaderUtils.loadSchema(nonExistent, XMLConstants.W3C_XML_SCHEMA_NS_URI);
		});
	}

	@Test
	public void testLoadNullSchema() throws Exception {

		assertThatIllegalArgumentException()
				.isThrownBy(() -> SchemaLoaderUtils.loadSchema((Resource) null, XMLConstants.W3C_XML_SCHEMA_NS_URI));
	}

	@Test
	public void testLoadMultipleSchemas() throws Exception {

		Resource envelope = new ClassPathResource(""envelope.xsd"", getClass());
		Resource encoding = new ClassPathResource(""encoding.xsd"", getClass());
		Schema schema = SchemaLoaderUtils.loadSchema(new Resource[] { envelope, encoding },
				XMLConstants.W3C_XML_SCHEMA_NS_URI);

		assertThat(schema).isNotNull();
		assertThat(envelope.isOpen()).isFalse();
		assertThat(encoding.isOpen()).isFalse();
	}
}
","/*
 * Copyright 2005-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.xml.validation;

import java.io.IOException;

import javax.xml.transform.Source;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;

import org.springframework.core.io.Resource;
import org.springframework.util.Assert;
import org.springframework.xml.transform.ResourceSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;

/**
 * Convenient utility methods for loading of {@link Schema} objects, performing standard handling of input streams.
 *
 * @author Arjen Poutsma
 * @since 1.0.0
 */
public abstract class SchemaLoaderUtils {

	/**
	 * Load schema from the given resource.
	 *
	 * @param resource the resource to load from
	 * @param schemaLanguage the language of the schema. Can be {@code XMLConstants.W3C_XML_SCHEMA_NS_URI} or
	 *          {@code XMLConstants.RELAXNG_NS_URI}.
	 * @throws IOException if loading failed
	 * @throws SAXException if loading failed
	 * @see javax.xml.XMLConstants#W3C_XML_SCHEMA_NS_URI
	 * @see javax.xml.XMLConstants#RELAXNG_NS_URI
	 */
	public static Schema loadSchema(Resource resource, String schemaLanguage) throws IOException, SAXException {
		return loadSchema(new Resource[] { resource }, schemaLanguage);
	}

	/**
	 * Load schema from the given resource.
	 *
	 * @param resources the resources to load from
	 * @param schemaLanguage the language of the schema. Can be {@code XMLConstants.W3C_XML_SCHEMA_NS_URI} or
	 *          {@code XMLConstants.RELAXNG_NS_URI}.
	 * @throws IOException if loading failed
	 * @throws SAXException if loading failed
	 * @see javax.xml.XMLConstants#W3C_XML_SCHEMA_NS_URI
	 * @see javax.xml.XMLConstants#RELAXNG_NS_URI
	 */
	public static Schema loadSchema(Resource[] resources, String schemaLanguage) throws IOException, SAXException {
		Assert.notEmpty(resources, ""No resources given"");
		Assert.hasLength(schemaLanguage, ""No schema language provided"");
		Source[] schemaSources = new Source[resources.length];
		XMLReader xmlReader = XMLReaderFactoryUtils.createXMLReader();
		xmlReader.setFeature(""http://xml.org/sax/features/namespace-prefixes"", true);
		for (int i = 0; i < resources.length; i++) {
			Assert.notNull(resources[i], ""Resource is null"");
			Assert.isTrue(resources[i].exists(), ""Resource "" + resources[i] + "" does not exist"");
			schemaSources[i] = new ResourceSource(xmlReader, resources[i]);
		}
		SchemaFactory schemaFactory = SchemaFactoryUtils.newInstance(schemaLanguage);
		return schemaFactory.newSchema(schemaSources);
	}

	/** Retrieves the URL from the given resource as System ID. Returns {@code null} if it cannot be opened. */
	public static String getSystemId(Resource resource) {
		try {
			return resource.getURL().toString();
		} catch (IOException e) {
			return null;
		}
	}

}
","['Assertion Roulette', 'Lazy Test']","['Assertion Roulette', 'Constructor Initialization', 'Conditional Test Logic', 'Default Test', 'Exception Handling']",4,1,1,12
